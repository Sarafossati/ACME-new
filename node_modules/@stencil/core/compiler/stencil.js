/*!
 Stencil Compiler v1.12.2 | MIT Licensed | https://stenciljs.com
 */
var stencil = (function(exports) {
  'use strict';

  if (typeof globalThis === 'undefined') {
  if (typeof self !== 'undefined') {
    self.globalThis = self;
  } else if (typeof window !== 'undefined') {
    window.globalThis = window;
  } else if (typeof global !== 'undefined') {
    global.globalThis = global;
  }
  }

  (gbl => {
  if (!gbl.Buffer) {
    gbl.Buffer = {};
  }

  const process = gbl.process = (gbl.process || {});
  if (!process.argv) {
    process.argv = [''];
  }
  if (!process.binding) {
    process.binding = () => ({});
  }
  let cwd = '/';
  if (!process.cwd) {
    process.cwd = () => cwd;
  }
  if (!process.chdir) {
    process.chdir = (v) => cwd = v;
  }
  if (!process.env) {
    process.env = {};
  }
  if (!process.nextTick) {
    const resolved = Promise.resolve();
    process.nextTick = (cb) => resolved.then(cb);
  }
  if (!process.platform) {
    process.platform = 'stencil';
  }
  if (!process.version) {
    process.version = 'v12.0.0';
  }
  if (!gbl.__dirname) {
    gbl.__dirname = '/';
  }
  if (!gbl.__filename) {
    gbl.__filename = '/index.js';
  }
  })(globalThis);

// MODULE: utils/constants.js
/**
 * Default style mode id
 */
const DEFAULT_STYLE_MODE = '$';
const COLLECTION_MANIFEST_FILE_NAME = 'collection-manifest.json';

// MODULE: utils/environment.js
const IS_NODE_ENV = typeof global !== 'undefined' &&
  typeof require === 'function' &&
  !!global.process &&
  Array.isArray(global.process.argv) &&
  typeof __filename === 'string' &&
  (!global.origin || typeof global.origin !== 'string');
const IS_NODE_WINDOWS_ENV = IS_NODE_ENV && global.process.platform === 'win32';
const IS_LOCATION_ENV = typeof location !== 'undefined';
const IS_GLOBAL_THIS_ENV = typeof globalThis !== 'undefined';
const IS_WEB_WORKER_ENV = typeof self !== 'undefined' && typeof self.importScripts === 'function' && typeof XMLHttpRequest !== 'undefined' && IS_LOCATION_ENV && typeof navigator !== 'undefined';
const IS_FETCH_ENV = typeof fetch === 'function';
const HAS_WEB_WORKER = typeof Worker === 'function' && IS_LOCATION_ENV;
const IS_CASE_SENSITIVE_FILE_NAMES = !IS_NODE_WINDOWS_ENV;
const requireFunc = (path) => (typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require)(path);

// MODULE: utils/format-component-runtime-meta.js
const formatComponentRuntimeMeta = (compilerMeta, includeMethods) => {
  let flags = 0;
  if (compilerMeta.encapsulation === 'shadow') {
    flags |= 1 /* shadowDomEncapsulation */;
    if (compilerMeta.shadowDelegatesFocus) {
      flags |= 16 /* shadowDelegatesFocus */;
    }
  }
  else if (compilerMeta.encapsulation === 'scoped') {
    flags |= 2 /* scopedCssEncapsulation */;
  }
  if (compilerMeta.encapsulation !== 'shadow' && compilerMeta.htmlTagNames.includes('slot')) {
    flags |= 4 /* hasSlotRelocation */;
  }
  const members = formatComponentRuntimeMembers(compilerMeta, includeMethods);
  const hostListeners = formatHostListeners(compilerMeta);
  return trimFalsy([flags, compilerMeta.tagName, Object.keys(members).length > 0 ? members : undefined, hostListeners.length > 0 ? hostListeners : undefined]);
};
const stringifyRuntimeData = (data) => {
  const json = JSON.stringify(data);
  if (json.length > 10000) {
    // JSON metadata is big, JSON.parse() is faster
    // https://twitter.com/mathias/status/1143551692732030979
    return `JSON.parse(${JSON.stringify(json)})`;
  }
  return json;
};
const formatComponentRuntimeMembers = (compilerMeta, includeMethods = true) => {
  return Object.assign(Object.assign(Object.assign({}, formatPropertiesRuntimeMember(compilerMeta.properties)), formatStatesRuntimeMember(compilerMeta.states)), (includeMethods ? formatMethodsRuntimeMember(compilerMeta.methods) : {}));
};
const formatPropertiesRuntimeMember = (properties) => {
  const runtimeMembers = {};
  properties.forEach(member => {
    runtimeMembers[member.name] = trimFalsy([
      /**
       * [0] member type
       */
      formatFlags(member),
      formatAttrName(member),
    ]);
  });
  return runtimeMembers;
};
const formatFlags = (compilerProperty) => {
  let type = formatPropType(compilerProperty.type);
  if (compilerProperty.mutable) {
    type |= 1024 /* Mutable */;
  }
  if (compilerProperty.reflect) {
    type |= 512 /* ReflectAttr */;
  }
  return type;
};
const formatAttrName = (compilerProperty) => {
  if (typeof compilerProperty.attribute === 'string') {
    // string attr name means we should observe this attribute
    if (compilerProperty.name === compilerProperty.attribute) {
      // property name and attribute name are the exact same
      // true value means to use the property name for the attribute name
      return undefined;
    }
    // property name and attribute name are not the same
    // so we need to return the actual string value
    // example: "multiWord" !== "multi-word"
    return compilerProperty.attribute;
  }
  // we shouldn't even observe an attribute for this property
  return undefined;
};
const formatPropType = (type) => {
  if (type === 'string') {
    return 1 /* String */;
  }
  if (type === 'number') {
    return 2 /* Number */;
  }
  if (type === 'boolean') {
    return 4 /* Boolean */;
  }
  if (type === 'any') {
    return 8 /* Any */;
  }
  return 16 /* Unknown */;
};
const formatStatesRuntimeMember = (states) => {
  const runtimeMembers = {};
  states.forEach(member => {
    runtimeMembers[member.name] = [
      32 /* State */,
    ];
  });
  return runtimeMembers;
};
const formatMethodsRuntimeMember = (methods) => {
  const runtimeMembers = {};
  methods.forEach(member => {
    runtimeMembers[member.name] = [
      64 /* Method */,
    ];
  });
  return runtimeMembers;
};
const formatHostListeners = (compilerMeta) => {
  return compilerMeta.listeners.map(compilerListener => {
    const hostListener = [computeListenerFlags(compilerListener), compilerListener.name, compilerListener.method];
    return hostListener;
  });
};
const computeListenerFlags = (listener) => {
  let flags = 0;
  if (listener.capture) {
    flags |= 2 /* Capture */;
  }
  if (listener.passive) {
    flags |= 1 /* Passive */;
  }
  switch (listener.target) {
    case 'document':
      flags |= 4 /* TargetDocument */;
      break;
    case 'window':
      flags |= 8 /* TargetWindow */;
      break;
    case 'parent':
      flags |= 16 /* TargetParent */;
      break;
    case 'body':
      flags |= 32 /* TargetBody */;
      break;
  }
  return flags;
};
const trimFalsy = (data) => {
  const arr = data;
  for (var i = arr.length - 1; i >= 0; i--) {
    if (arr[i]) {
      break;
    }
    // if falsy, safe to pop()
    arr.pop();
  }
  return arr;
};

// MODULE: utils/helpers.js
const toLowerCase = (str) => str.toLowerCase();
const toDashCase = (str) => toLowerCase(str
  .replace(/([A-Z0-9])/g, g => ' ' + g[0])
  .trim()
  .replace(/ /g, '-'));
const dashToPascalCase = (str) => toLowerCase(str)
  .split('-')
  .map(segment => segment.charAt(0).toUpperCase() + segment.slice(1))
  .join('');
const toTitleCase = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const noop = () => {
  /* noop*/
};
const sortBy = (array, prop) => {
  return array.slice().sort((a, b) => {
    const nameA = prop(a);
    const nameB = prop(b);
    if (nameA < nameB)
      return -1;
    if (nameA > nameB)
      return 1;
    return 0;
  });
};
const flatOne = (array) => {
  if (array.flat) {
    return array.flat(1);
  }
  return array.reduce((result, item) => {
    result.push(...item);
    return result;
  }, []);
};
const unique = (array, predicate = i => i) => {
  const set = new Set();
  return array.filter(item => {
    const key = predicate(item);
    if (key == null) {
      return true;
    }
    if (set.has(key)) {
      return false;
    }
    set.add(key);
    return true;
  });
};
const fromEntries = (entries) => {
  const object = {};
  for (const [key, value] of entries) {
    object[key] = value;
  }
  return object;
};
const pluck = (obj, keys) => {
  return keys.reduce((final, key) => {
    if (obj[key]) {
      final[key] = obj[key];
    }
    return final;
  }, {});
};
const isBoolean = (v) => typeof v === 'boolean';
const isDefined = (v) => v !== null && v !== undefined;
const isFunction = (v) => typeof v === 'function';
const isNumber = (v) => typeof v === 'number';
const isObject = (val) => val != null && typeof val === 'object' && Array.isArray(val) === false;
const isString = (v) => typeof v === 'string';
const isIterable = (v) => isDefined(v) && isFunction(v[Symbol.iterator]);

// MODULE: utils/is-glob.js
const isGlobChars = { '{': '}', '(': ')', '[': ']' };
const isGlobStrictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
const isExtglobRegex = /(\\).|([@?!+*]\(.*\))/;
const isExtglob = (str) => {
  let match;
  while ((match = isExtglobRegex.exec(str))) {
    if (match[2]) {
      return true;
    }
    str = str.slice(match.index + match[0].length);
  }
  return false;
};
const isGlob = (str) => {
  if (!isString(str) || str === '') {
    return false;
  }
  if (isExtglob(str)) {
    return true;
  }
  const regex = isGlobStrictRegex;
  let match;
  while ((match = regex.exec(str))) {
    if (match[2]) {
      return true;
    }
    let idx = match.index + match[0].length;
    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    const open = match[1];
    const close = open ? isGlobChars[open] : null;
    if (open && close) {
      const n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }
    str = str.slice(idx);
  }
  return false;
};

// MODULE: utils/logger/logger-utils.js
const normalizeDiagnostics = (compilerCtx, diagnostics) => {
  const normalizedErrors = [];
  const normalizedOthers = [];
  const dups = new Set();
  for (let i = 0; i < diagnostics.length; i++) {
    const d = normalizeDiagnostic(compilerCtx, diagnostics[i]);
    const key = d.absFilePath + d.code + d.messageText + d.type;
    if (dups.has(key)) {
      continue;
    }
    dups.add(key);
    const total = normalizedErrors.length + normalizedOthers.length;
    if (d.level === 'error') {
      normalizedErrors.push(d);
    }
    else if (total < MAX_ERRORS) {
      normalizedOthers.push(d);
    }
  }
  return [...normalizedErrors, ...normalizedOthers];
};
const normalizeDiagnostic = (compilerCtx, diagnostic) => {
  if (diagnostic.messageText) {
    if (typeof diagnostic.messageText.message === 'string') {
      diagnostic.messageText = diagnostic.messageText.message;
    }
    else if (typeof diagnostic.messageText === 'string' && diagnostic.messageText.indexOf('Error: ') === 0) {
      diagnostic.messageText = diagnostic.messageText.substr(7);
    }
  }
  if (diagnostic.messageText) {
    if (diagnostic.messageText.includes(`Cannot find name 'h'`)) {
      diagnostic.header = `Missing "h" import for JSX types`;
      diagnostic.messageText = `In order to load accurate JSX types for components, the "h" function must be imported from "@stencil/core" by each component using JSX. For example: import { Component, h } from '@stencil/core';`;
      try {
        const sourceText = compilerCtx.fs.readFileSync(diagnostic.absFilePath);
        const srcLines = splitLineBreaks(sourceText);
        for (let i = 0; i < srcLines.length; i++) {
          const srcLine = srcLines[i];
          if (srcLine.includes('@stencil/core')) {
            const msgLines = [];
            const beforeLineIndex = i - 1;
            if (beforeLineIndex > -1) {
              const beforeLine = {
                lineIndex: beforeLineIndex,
                lineNumber: beforeLineIndex + 1,
                text: srcLines[beforeLineIndex],
                errorCharStart: -1,
                errorLength: -1,
              };
              msgLines.push(beforeLine);
            }
            const errorLine = {
              lineIndex: i,
              lineNumber: i + 1,
              text: srcLine,
              errorCharStart: 0,
              errorLength: -1,
            };
            msgLines.push(errorLine);
            diagnostic.lineNumber = errorLine.lineNumber;
            diagnostic.columnNumber = srcLine.indexOf('}');
            const afterLineIndex = i + 1;
            if (afterLineIndex < srcLines.length) {
              const afterLine = {
                lineIndex: afterLineIndex,
                lineNumber: afterLineIndex + 1,
                text: srcLines[afterLineIndex],
                errorCharStart: -1,
                errorLength: -1,
              };
              msgLines.push(afterLine);
            }
            diagnostic.lines = msgLines;
            break;
          }
        }
      }
      catch (e) { }
    }
  }
  return diagnostic;
};
const splitLineBreaks = (sourceText) => {
  if (typeof sourceText !== 'string')
    return [];
  sourceText = sourceText.replace(/\\r/g, '\n');
  return sourceText.split('\n');
};
const escapeHtml = (unsafe) => {
  if (unsafe === undefined)
    return 'undefined';
  if (unsafe === null)
    return 'null';
  if (typeof unsafe !== 'string') {
    unsafe = unsafe.toString();
  }
  return unsafe
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
};
const MAX_ERRORS = 25;

// MODULE: utils/message-utils.js
const buildError = (diagnostics) => {
  const diagnostic = {
    level: 'error',
    type: 'build',
    header: 'Build Error',
    messageText: 'build error',
    relFilePath: null,
    absFilePath: null,
    lines: [],
  };
  if (diagnostics) {
    diagnostics.push(diagnostic);
  }
  return diagnostic;
};
const buildWarn = (diagnostics) => {
  const diagnostic = {
    level: 'warn',
    type: 'build',
    header: 'Build Warn',
    messageText: 'build warn',
    relFilePath: null,
    absFilePath: null,
    lines: [],
  };
  diagnostics.push(diagnostic);
  return diagnostic;
};
const buildJsonFileError = (compilerCtx, diagnostics, jsonFilePath, msg, pkgKey) => {
  const err = buildError(diagnostics);
  err.messageText = msg;
  err.absFilePath = jsonFilePath;
  if (typeof pkgKey === 'string') {
    try {
      const jsonStr = compilerCtx.fs.readFileSync(jsonFilePath);
      const lines = jsonStr.replace(/\r/g, '\n').split('\n');
      for (let i = 0; i < lines.length; i++) {
        const txtLine = lines[i];
        const txtIndex = txtLine.indexOf(pkgKey);
        if (txtIndex > -1) {
          const warnLine = {
            lineIndex: i,
            lineNumber: i + 1,
            text: txtLine,
            errorCharStart: txtIndex,
            errorLength: pkgKey.length,
          };
          err.lineNumber = warnLine.lineNumber;
          err.columnNumber = txtIndex + 1;
          err.lines.push(warnLine);
          if (i >= 0) {
            const beforeWarnLine = {
              lineIndex: warnLine.lineIndex - 1,
              lineNumber: warnLine.lineNumber - 1,
              text: lines[i - 1],
              errorCharStart: -1,
              errorLength: -1,
            };
            err.lines.unshift(beforeWarnLine);
          }
          if (i < lines.length) {
            const afterWarnLine = {
              lineIndex: warnLine.lineIndex + 1,
              lineNumber: warnLine.lineNumber + 1,
              text: lines[i + 1],
              errorCharStart: -1,
              errorLength: -1,
            };
            err.lines.push(afterWarnLine);
          }
          break;
        }
      }
    }
    catch (e) { }
  }
  return err;
};
const catchError = (diagnostics, err, msg) => {
  const diagnostic = {
    level: 'error',
    type: 'build',
    header: 'Build Error',
    messageText: 'build error',
    relFilePath: null,
    absFilePath: null,
    lines: [],
  };
  if (isString(msg)) {
    diagnostic.messageText = msg;
  }
  else if (err != null) {
    if (err.stack != null) {
      diagnostic.messageText = err.stack.toString();
    }
    else {
      if (err.message != null) {
        diagnostic.messageText = err.message.toString();
      }
      else {
        diagnostic.messageText = err.toString();
      }
    }
  }
  if (diagnostics != null && !shouldIgnoreError(diagnostic.messageText)) {
    diagnostics.push(diagnostic);
  }
  return diagnostic;
};
const hasError = (diagnostics) => {
  if (diagnostics == null || diagnostics.length === 0) {
    return false;
  }
  return diagnostics.some(d => d.level === 'error' && d.type !== 'runtime');
};
const hasWarning = (diagnostics) => {
  if (diagnostics == null || diagnostics.length === 0) {
    return false;
  }
  return diagnostics.some(d => d.level === 'warn');
};
const shouldIgnoreError = (msg) => {
  return msg === TASK_CANCELED_MSG;
};
const TASK_CANCELED_MSG = `task canceled`;

// MODULE: utils/logger/logger-rollup.js
const loadRollupDiagnostics = (config, compilerCtx, buildCtx, rollupError) => {
  const formattedCode = formatErrorCode(rollupError.code);
  const diagnostic = {
    level: 'error',
    type: 'bundling',
    language: 'javascript',
    code: rollupError.code,
    header: `Rollup${formattedCode.length > 0 ? ': ' + formattedCode : ''}`,
    messageText: formattedCode,
    relFilePath: null,
    absFilePath: null,
    lines: [],
  };
  if (config.logLevel === 'debug' && rollupError.stack) {
    diagnostic.messageText = rollupError.stack;
  }
  else if (rollupError.message) {
    diagnostic.messageText = rollupError.message;
  }
  if (rollupError.plugin) {
    diagnostic.messageText += ` (plugin: ${rollupError.plugin}${rollupError.hook ? `, ${rollupError.hook}` : ''})`;
  }
  const loc = rollupError.loc;
  if (loc != null) {
    const srcFile = loc.file || rollupError.id;
    if (isString(srcFile)) {
      try {
        const sourceText = compilerCtx.fs.readFileSync(srcFile);
        if (sourceText) {
          diagnostic.absFilePath = srcFile;
          try {
            const srcLines = splitLineBreaks(sourceText);
            const errorLine = {
              lineIndex: loc.line - 1,
              lineNumber: loc.line,
              text: srcLines[loc.line - 1],
              errorCharStart: loc.column,
              errorLength: 0,
            };
            diagnostic.lineNumber = errorLine.lineNumber;
            diagnostic.columnNumber = errorLine.errorCharStart;
            const highlightLine = errorLine.text.substr(loc.column);
            for (let i = 0; i < highlightLine.length; i++) {
              if (charBreak.has(highlightLine.charAt(i))) {
                break;
              }
              errorLine.errorLength++;
            }
            diagnostic.lines.push(errorLine);
            if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
              errorLine.errorLength = 1;
              errorLine.errorCharStart--;
            }
            if (errorLine.lineIndex > 0) {
              const previousLine = {
                lineIndex: errorLine.lineIndex - 1,
                lineNumber: errorLine.lineNumber - 1,
                text: srcLines[errorLine.lineIndex - 1],
                errorCharStart: -1,
                errorLength: -1,
              };
              diagnostic.lines.unshift(previousLine);
            }
            if (errorLine.lineIndex + 1 < srcLines.length) {
              const nextLine = {
                lineIndex: errorLine.lineIndex + 1,
                lineNumber: errorLine.lineNumber + 1,
                text: srcLines[errorLine.lineIndex + 1],
                errorCharStart: -1,
                errorLength: -1,
              };
              diagnostic.lines.push(nextLine);
            }
          }
          catch (e) {
            diagnostic.messageText += `\nError parsing: ${diagnostic.absFilePath}, line: ${loc.line}, column: ${loc.column}`;
            diagnostic.debugText = sourceText;
          }
        }
        else if (typeof rollupError.frame === 'string') {
          diagnostic.messageText += '\n' + rollupError.frame;
        }
      }
      catch (e) { }
    }
  }
  buildCtx.diagnostics.push(diagnostic);
};
const createOnWarnFn = (diagnostics, bundleModulesFiles) => {
  const previousWarns = new Set();
  return function onWarningMessage(warning) {
    if (warning == null || ignoreWarnCodes.has(warning.code) || previousWarns.has(warning.message)) {
      return;
    }
    previousWarns.add(warning.message);
    let label = '';
    if (bundleModulesFiles) {
      label = bundleModulesFiles
        .reduce((cmps, m) => {
        cmps.push(...m.cmps);
        return cmps;
      }, [])
        .join(', ')
        .trim();
      if (label.length) {
        label += ': ';
      }
    }
    const diagnostic = buildWarn(diagnostics);
    diagnostic.header = `Bundling Warning ${warning.code}`;
    diagnostic.messageText = label + (warning.message || warning);
  };
};
const ignoreWarnCodes = new Set(['THIS_IS_UNDEFINED', 'NON_EXISTENT_EXPORT', 'CIRCULAR_DEPENDENCY', 'EMPTY_BUNDLE', 'UNUSED_EXTERNAL_IMPORT']);
const charBreak = new Set([' ', '=', '.', ',', '?', ':', ';', '(', ')', '{', '}', '[', ']', '|', `'`, `"`, '`']);
const formatErrorCode = (errorCode) => {
  if (typeof errorCode === 'string') {
    return errorCode
      .split('_')
      .map(c => {
      return toTitleCase(c.toLowerCase());
    })
      .join(' ');
  }
  return (errorCode || '').trim();
};

// MODULE: utils/normalize-path.js
/**
 * Convert Windows backslash paths to slash paths: foo\\bar ➔ foo/bar
 * Forward-slash paths can be used in Windows as long as they're not
 * extended-length paths and don't contain any non-ascii characters.
 * This was created since the path methods in Node.js outputs \\ paths on Windows.
 */
const normalizePath = (path) => {
  if (typeof path !== 'string') {
    throw new Error(`invalid path to normalize`);
  }
  path = normalizeSlashes(path.trim());
  const components = pathComponents(path, getRootLength(path));
  const reducedComponents = reducePathComponents(components);
  const rootPart = reducedComponents[0];
  const secondPart = reducedComponents[1];
  const normalized = rootPart + reducedComponents.slice(1).join('/');
  if (normalized === '') {
    return '.';
  }
  if (rootPart === '' && secondPart && path.includes('/') && !secondPart.startsWith('.') && !secondPart.startsWith('@')) {
    return './' + normalized;
  }
  return normalized;
};
const normalizeSlashes = (path) => path.replace(backslashRegExp, '/');
const altDirectorySeparator = '\\';
const urlSchemeSeparator = '://';
const backslashRegExp = /\\/g;
const reducePathComponents = (components) => {
  if (!Array.isArray(components) || components.length === 0) {
    return [];
  }
  const reduced = [components[0]];
  for (let i = 1; i < components.length; i++) {
    const component = components[i];
    if (!component)
      continue;
    if (component === '.')
      continue;
    if (component === '..') {
      if (reduced.length > 1) {
        if (reduced[reduced.length - 1] !== '..') {
          reduced.pop();
          continue;
        }
      }
      else if (reduced[0])
        continue;
    }
    reduced.push(component);
  }
  return reduced;
};
const getRootLength = (path) => {
  const rootLength = getEncodedRootLength(path);
  return rootLength < 0 ? ~rootLength : rootLength;
};
const getEncodedRootLength = (path) => {
  if (!path)
    return 0;
  const ch0 = path.charCodeAt(0);
  // POSIX or UNC
  if (ch0 === 47 /* slash */ || ch0 === 92 /* backslash */) {
    if (path.charCodeAt(1) !== ch0)
      return 1; // POSIX: "/" (or non-normalized "\")
    const p1 = path.indexOf(ch0 === 47 /* slash */ ? '/' : altDirectorySeparator, 2);
    if (p1 < 0)
      return path.length; // UNC: "//server" or "\\server"
    return p1 + 1; // UNC: "//server/" or "\\server\"
  }
  // DOS
  if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58 /* colon */) {
    const ch2 = path.charCodeAt(2);
    if (ch2 === 47 /* slash */ || ch2 === 92 /* backslash */)
      return 3; // DOS: "c:/" or "c:\"
    if (path.length === 2)
      return 2; // DOS: "c:" (but not "c:d")
  }
  // URL
  const schemeEnd = path.indexOf(urlSchemeSeparator);
  if (schemeEnd !== -1) {
    const authorityStart = schemeEnd + urlSchemeSeparator.length;
    const authorityEnd = path.indexOf('/', authorityStart);
    if (authorityEnd !== -1) {
      // URL: "file:///", "file://server/", "file://server/path"
      // For local "file" URLs, include the leading DOS volume (if present).
      // Per https://www.ietf.org/rfc/rfc1738.txt, a host of "" or "localhost" is a
      // special case interpreted as "the machine from which the URL is being interpreted".
      const scheme = path.slice(0, schemeEnd);
      const authority = path.slice(authorityStart, authorityEnd);
      if (scheme === 'file' && (authority === '' || authority === 'localhost') && isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {
        const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);
        if (volumeSeparatorEnd !== -1) {
          if (path.charCodeAt(volumeSeparatorEnd) === 47 /* slash */) {
            // URL: "file:///c:/", "file://localhost/c:/", "file:///c%3a/", "file://localhost/c%3a/"
            return ~(volumeSeparatorEnd + 1);
          }
          if (volumeSeparatorEnd === path.length) {
            // URL: "file:///c:", "file://localhost/c:", "file:///c$3a", "file://localhost/c%3a"
            // but not "file:///c:d" or "file:///c%3ad"
            return ~volumeSeparatorEnd;
          }
        }
      }
      return ~(authorityEnd + 1); // URL: "file://server/", "http://server/"
    }
    return ~path.length; // URL: "file://server", "http://server"
  }
  // relative
  return 0;
};
const isVolumeCharacter = (charCode) => (charCode >= 97 /* a */ && charCode <= 122 /* z */) || (charCode >= 65 /* A */ && charCode <= 90 /* Z */);
const getFileUrlVolumeSeparatorEnd = (url, start) => {
  const ch0 = url.charCodeAt(start);
  if (ch0 === 58 /* colon */)
    return start + 1;
  if (ch0 === 37 /* percent */ && url.charCodeAt(start + 1) === 51 /* _3 */) {
    const ch2 = url.charCodeAt(start + 2);
    if (ch2 === 97 /* a */ || ch2 === 65 /* A */)
      return start + 3;
  }
  return -1;
};
const pathComponents = (path, rootLength) => {
  const root = path.substring(0, rootLength);
  const rest = path.substring(rootLength).split('/');
  const restLen = rest.length;
  if (restLen > 0 && !rest[restLen - 1]) {
    rest.pop();
  }
  return [root, ...rest];
};
/**
 * Same as normalizePath(), expect it'll also strip any querystrings
 * from the path name. So /dir/file.css?tag=cmp-a becomes /dir/file.css
 */
const normalizeFsPath = (p) => normalizePath(p.split('?')[0]);

// MODULE: utils/logger/logger-typescript.js
const augmentDiagnosticWithNode = (d, node) => {
  if (!node) {
    return d;
  }
  const sourceFile = node.getSourceFile();
  if (!sourceFile) {
    return d;
  }
  d.absFilePath = normalizePath(sourceFile.fileName);
  const sourceText = sourceFile.text;
  const srcLines = splitLineBreaks(sourceText);
  const start = node.getStart();
  const end = node.getEnd();
  const posStart = sourceFile.getLineAndCharacterOfPosition(start);
  const errorLine = {
    lineIndex: posStart.line,
    lineNumber: posStart.line + 1,
    text: srcLines[posStart.line],
    errorCharStart: posStart.character,
    errorLength: Math.max(end - start, 1),
  };
  d.lineNumber = errorLine.lineNumber;
  d.columnNumber = errorLine.errorCharStart + 1;
  d.lines.push(errorLine);
  if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
    errorLine.errorLength = 1;
    errorLine.errorCharStart--;
  }
  if (errorLine.lineIndex > 0) {
    const previousLine = {
      lineIndex: errorLine.lineIndex - 1,
      lineNumber: errorLine.lineNumber - 1,
      text: srcLines[errorLine.lineIndex - 1],
      errorCharStart: -1,
      errorLength: -1,
    };
    d.lines.unshift(previousLine);
  }
  if (errorLine.lineIndex + 1 < srcLines.length) {
    const nextLine = {
      lineIndex: errorLine.lineIndex + 1,
      lineNumber: errorLine.lineNumber + 1,
      text: srcLines[errorLine.lineIndex + 1],
      errorCharStart: -1,
      errorLength: -1,
    };
    d.lines.push(nextLine);
  }
  return d;
};
/**
 * Ok, so formatting overkill, we know. But whatever, it makes for great
 * error reporting within a terminal. So, yeah, let's code it up, shall we?
 */
const loadTypeScriptDiagnostics = (tsDiagnostics) => {
  const diagnostics = [];
  const maxErrors = Math.min(tsDiagnostics.length, 50);
  for (let i = 0; i < maxErrors; i++) {
    diagnostics.push(loadTypeScriptDiagnostic(tsDiagnostics[i]));
  }
  return diagnostics;
};
const loadTypeScriptDiagnostic = (tsDiagnostic) => {
  const d = {
    level: 'warn',
    type: 'typescript',
    language: 'typescript',
    header: 'TypeScript',
    code: tsDiagnostic.code.toString(),
    messageText: flattenDiagnosticMessageText(tsDiagnostic, tsDiagnostic.messageText),
    relFilePath: null,
    absFilePath: null,
    lines: [],
  };
  if (tsDiagnostic.category === 1) {
    d.level = 'error';
  }
  if (tsDiagnostic.file) {
    d.absFilePath = tsDiagnostic.file.fileName;
    const sourceText = tsDiagnostic.file.text;
    const srcLines = splitLineBreaks(sourceText);
    const posData = tsDiagnostic.file.getLineAndCharacterOfPosition(tsDiagnostic.start);
    const errorLine = {
      lineIndex: posData.line,
      lineNumber: posData.line + 1,
      text: srcLines[posData.line],
      errorCharStart: posData.character,
      errorLength: Math.max(tsDiagnostic.length, 1),
    };
    d.lineNumber = errorLine.lineNumber;
    d.columnNumber = errorLine.errorCharStart + 1;
    d.lines.push(errorLine);
    if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
      errorLine.errorLength = 1;
      errorLine.errorCharStart--;
    }
    if (errorLine.lineIndex > 0) {
      const previousLine = {
        lineIndex: errorLine.lineIndex - 1,
        lineNumber: errorLine.lineNumber - 1,
        text: srcLines[errorLine.lineIndex - 1],
        errorCharStart: -1,
        errorLength: -1,
      };
      d.lines.unshift(previousLine);
    }
    if (errorLine.lineIndex + 1 < srcLines.length) {
      const nextLine = {
        lineIndex: errorLine.lineIndex + 1,
        lineNumber: errorLine.lineNumber + 1,
        text: srcLines[errorLine.lineIndex + 1],
        errorCharStart: -1,
        errorLength: -1,
      };
      d.lines.push(nextLine);
    }
  }
  return d;
};
const flattenDiagnosticMessageText = (tsDiagnostic, diag) => {
  if (typeof diag === 'string') {
    return diag;
  }
  else if (diag === undefined) {
    return '';
  }
  const ignoreCodes = [];
  const isStencilConfig = tsDiagnostic.file.fileName.includes('stencil.config');
  if (isStencilConfig) {
    ignoreCodes.push(2322);
  }
  let result = '';
  if (!ignoreCodes.includes(diag.code)) {
    result = diag.messageText;
    if (isIterable(diag.next)) {
      for (const kid of diag.next) {
        result += flattenDiagnosticMessageText(tsDiagnostic, kid);
      }
    }
  }
  if (isStencilConfig) {
    result = result.replace(`type 'StencilConfig'`, `Stencil Config`);
    result = result.replace(`Object literal may only specify known properties, but `, ``);
    result = result.replace(`Object literal may only specify known properties, and `, ``);
  }
  return result.trim();
};

// MODULE: utils/util.js
const createJsVarName = (fileName) => {
  if (isString(fileName)) {
    fileName = fileName.split('?')[0];
    fileName = fileName.split('#')[0];
    fileName = fileName.split('&')[0];
    fileName = fileName.split('=')[0];
    fileName = toDashCase(fileName);
    fileName = fileName.replace(/[|;$%@"<>()+,.{}_\!\/\\]/g, '-');
    fileName = dashToPascalCase(fileName);
    if (fileName.length > 1) {
      fileName = fileName[0].toLowerCase() + fileName.substr(1);
    }
    else {
      fileName = fileName.toLowerCase();
    }
    if (fileName.length > 0 && !isNaN(fileName[0])) {
      fileName = '_' + fileName;
    }
  }
  return fileName;
};
const isDtsFile = (filePath) => {
  const parts = filePath.toLowerCase().split('.');
  if (parts.length > 2) {
    return parts[parts.length - 2] === 'd' && parts[parts.length - 1] === 'ts';
  }
  return false;
};
const isDocsPublic = (jsDocs) => {
  return !(jsDocs && jsDocs.tags.some(s => s.name === 'internal'));
};
const lineBreakRegex = /\r?\n|\r/g;
function getTextDocs(docs) {
  if (docs == null) {
    return '';
  }
  return `${docs.text.replace(lineBreakRegex, ' ')}
${docs.tags
    .filter(tag => tag.name !== 'internal')
    .map(tag => `@${tag.name} ${(tag.text || '').replace(lineBreakRegex, ' ')}`)
    .join('\n')}`.trim();
}
const getDependencies = (buildCtx) => {
  if (buildCtx.packageJson != null && buildCtx.packageJson.dependencies != null) {
    return Object.keys(buildCtx.packageJson.dependencies).filter(pkgName => !SKIP_DEPS.includes(pkgName));
  }
  return [];
};
const hasDependency = (buildCtx, depName) => {
  return getDependencies(buildCtx).includes(depName);
};
const getDynamicImportFunction = (namespace) => `__sc_import_${namespace.replace(/\s|-/g, '_')}`;
const readPackageJson = async (config, compilerCtx, buildCtx) => {
  try {
    const pkgJson = await compilerCtx.fs.readFile(config.packageJsonFilePath);
    if (pkgJson) {
      const parseResults = parsePackageJson(pkgJson, config.packageJsonFilePath);
      if (parseResults.diagnostic) {
        buildCtx.diagnostics.push(parseResults.diagnostic);
      }
      else {
        buildCtx.packageJson = parseResults.data;
      }
    }
  }
  catch (e) {
    if (!config.outputTargets.some(o => o.type.includes('dist'))) {
      const diagnostic = buildError(buildCtx.diagnostics);
      diagnostic.header = `Missing "package.json"`;
      diagnostic.messageText = `Valid "package.json" file is required for distribution: ${config.packageJsonFilePath}`;
    }
  }
};
const parsePackageJson = (pkgJsonStr, pkgJsonFilePath) => {
  if (isString(pkgJsonFilePath)) {
    return parseJson(pkgJsonStr, pkgJsonFilePath);
  }
  return null;
};
const parseJson = (jsonStr, filePath) => {
  const rtn = {
    diagnostic: null,
    data: null,
    filePath,
  };
  if (isString(jsonStr)) {
    try {
      rtn.data = JSON.parse(jsonStr);
    }
    catch (e) {
      const msg = e.message;
      rtn.diagnostic = buildError();
      rtn.diagnostic.absFilePath = filePath;
      rtn.diagnostic.header = `Error Parsing JSON`;
      rtn.diagnostic.messageText = msg;
    }
  }
  else {
    rtn.diagnostic = buildError();
    rtn.diagnostic.absFilePath = filePath;
    rtn.diagnostic.header = `Error Parsing JSON`;
    rtn.diagnostic.messageText = `Invalid JSON input to parse`;
  }
  return rtn;
};
const SKIP_DEPS = ['@stencil/core'];

// MODULE: utils/validation.js
const validateComponentTag = (tag) => {
  if (tag !== tag.trim()) {
    return `Tag can not contain white spaces`;
  }
  if (tag !== tag.toLowerCase()) {
    return `Tag can not contain upper case characters`;
  }
  if (typeof tag !== 'string') {
    return `Tag "${tag}" must be a string type`;
  }
  if (tag.length === 0) {
    return `Received empty tag value`;
  }
  if (tag.indexOf(' ') > -1) {
    return `"${tag}" tag cannot contain a space`;
  }
  if (tag.indexOf(',') > -1) {
    return `"${tag}" tag cannot be used for multiple tags`;
  }
  const invalidChars = tag.replace(/\w|-/g, '');
  if (invalidChars !== '') {
    return `"${tag}" tag contains invalid characters: ${invalidChars}`;
  }
  if (tag.indexOf('-') === -1) {
    return `"${tag}" tag must contain a dash (-) to work as a valid web component`;
  }
  if (tag.indexOf('--') > -1) {
    return `"${tag}" tag cannot contain multiple dashes (--) next to each other`;
  }
  if (tag.indexOf('-') === 0) {
    return `"${tag}" tag cannot start with a dash (-)`;
  }
  if (tag.lastIndexOf('-') === tag.length - 1) {
    return `"${tag}" tag cannot end with a dash (-)`;
  }
  return undefined;
};

// MODULE: compiler/bundle/entry-alias-ids.js
const STENCIL_CORE_ID = '@stencil/core';
const STENCIL_INTERNAL_ID = '@stencil/core/internal';
const STENCIL_APP_DATA_ID = '@stencil/core/internal/app-data';
const STENCIL_APP_GLOBALS_ID = '@stencil/core/internal/app-globals';
const STENCIL_HYDRATE_FACTORY_ID = '@stencil/core/hydrate-factory';
const STENCIL_INTERNAL_CLIENT_ID = '@stencil/core/internal/client';
const STENCIL_INTERNAL_HYDRATE_ID = '@stencil/core/internal/hydrate';
const STENCIL_MOCK_DOC_ID = '@stencil/core/mock-doc';
const LAZY_BROWSER_ENTRY_ID = '@lazy-browser-entrypoint';
const LAZY_EXTERNAL_ENTRY_ID = '@lazy-external-entrypoint';
const USER_INDEX_ENTRY_ID = '@user-index-entrypoint';

// MODULE: ../node_modules/path-browserify/index.js

function assertPath(path) {
  if (typeof path !== 'string') {
  throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
  if (i < path.length)
    code = path.charCodeAt(i);
  else if (code === 47 /*/*/)
    break;
  else
    code = 47 /*/*/;
  if (code === 47 /*/*/) {
    if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
    if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
      if (res.length > 2) {
      var lastSlashIndex = res.lastIndexOf('/');
      if (lastSlashIndex !== res.length - 1) {
        if (lastSlashIndex === -1) {
        res = '';
        lastSegmentLength = 0;
        } else {
        res = res.slice(0, lastSlashIndex);
        lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
        }
        lastSlash = i;
        dots = 0;
        continue;
      }
      } else if (res.length === 2 || res.length === 1) {
      res = '';
      lastSegmentLength = 0;
      lastSlash = i;
      dots = 0;
      continue;
      }
    }
    if (allowAboveRoot) {
      if (res.length > 0)
      res += '/..';
      else
      res = '..';
      lastSegmentLength = 2;
    }
    } else {
    if (res.length > 0)
      res += '/' + path.slice(lastSlash + 1, i);
    else
      res = path.slice(lastSlash + 1, i);
    lastSegmentLength = i - lastSlash - 1;
    }
    lastSlash = i;
    dots = 0;
  } else if (code === 46 /*.*/ && dots !== -1) {
    ++dots;
  } else {
    dots = -1;
  }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
  return base;
  }
  if (dir === pathObject.root) {
  return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
  var resolvedPath = '';
  var resolvedAbsolute = false;
  var cwd;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path;
    if (i >= 0)
    path = arguments[i];
    else {
    if (cwd === undefined)
      cwd = process.cwd();
    path = cwd;
    }

    assertPath(path);

    // Skip empty entries
    if (path.length === 0) {
    continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
    return '/' + resolvedPath;
    else
    return '/';
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  } else {
    return '.';
  }
  },

  normalize: function normalize(path) {
  assertPath(path);

  if (path.length === 0) return '.';

  var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
  var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

  // Normalize the path
  path = normalizeStringPosix(path, !isAbsolute);

  if (path.length === 0 && !isAbsolute) path = '.';
  if (path.length > 0 && trailingSeparator) path += '/';

  if (isAbsolute) return '/' + path;
  return path;
  },

  isAbsolute: function isAbsolute(path) {
  assertPath(path);
  return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
  if (arguments.length === 0)
    return '.';
  var joined;
  for (var i = 0; i < arguments.length; ++i) {
    var arg = arguments[i];
    assertPath(arg);
    if (arg.length > 0) {
    if (joined === undefined)
      joined = arg;
    else
      joined += '/' + arg;
    }
  }
  if (joined === undefined)
    return '.';
  return posix.normalize(joined);
  },

  relative: function relative(from, to) {
  assertPath(from);
  assertPath(to);

  if (from === to) return '';

  from = posix.resolve(from);
  to = posix.resolve(to);

  if (from === to) return '';

  // Trim any leading backslashes
  var fromStart = 1;
  for (; fromStart < from.length; ++fromStart) {
    if (from.charCodeAt(fromStart) !== 47 /*/*/)
    break;
  }
  var fromEnd = from.length;
  var fromLen = fromEnd - fromStart;

  // Trim any leading backslashes
  var toStart = 1;
  for (; toStart < to.length; ++toStart) {
    if (to.charCodeAt(toStart) !== 47 /*/*/)
    break;
  }
  var toEnd = to.length;
  var toLen = toEnd - toStart;

  // Compare paths to find the longest common path from root
  var length = fromLen < toLen ? fromLen : toLen;
  var lastCommonSep = -1;
  var i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
    if (toLen > length) {
      if (to.charCodeAt(toStart + i) === 47 /*/*/) {
      // We get here if `from` is the exact base path for `to`.
      // For example: from='/foo/bar'; to='/foo/bar/baz'
      return to.slice(toStart + i + 1);
      } else if (i === 0) {
      // We get here if `from` is the root
      // For example: from='/'; to='/foo'
      return to.slice(toStart + i);
      }
    } else if (fromLen > length) {
      if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
      // We get here if `to` is the exact base path for `from`.
      // For example: from='/foo/bar/baz'; to='/foo/bar'
      lastCommonSep = i;
      } else if (i === 0) {
      // We get here if `to` is the root.
      // For example: from='/foo'; to='/'
      lastCommonSep = 0;
      }
    }
    break;
    }
    var fromCode = from.charCodeAt(fromStart + i);
    var toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
    break;
    else if (fromCode === 47 /*/*/)
    lastCommonSep = i;
  }

  var out = '';
  // Generate the relative path based on the path difference between `to`
  // and `from`
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
    if (out.length === 0)
      out += '..';
    else
      out += '/..';
    }
  }

  // Lastly, append the rest of the destination (`to`) path that comes after
  // the common path parts
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to.charCodeAt(toStart) === 47 /*/*/)
    ++toStart;
    return to.slice(toStart);
  }
  },

  _makeLong: function _makeLong(path) {
  return path;
  },

  dirname: function dirname(path) {
  assertPath(path);
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
      if (!matchedSlash) {
      end = i;
      break;
      }
    } else {
    // We saw the first non-path separator
    matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) return '//';
  return path.slice(0, end);
  },

  basename: function basename(path, ext) {
  if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
  assertPath(path);

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
    if (ext.length === path.length && ext === path) return '';
    var extIdx = ext.length - 1;
    var firstNonSlashEnd = -1;
    for (i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now
      if (!matchedSlash) {
        start = i + 1;
        break;
      }
      } else {
      if (firstNonSlashEnd === -1) {
      // We saw the first non-path separator, remember this index in case
      // we need it if the extension ends up not matching
      matchedSlash = false;
      firstNonSlashEnd = i + 1;
      }
      if (extIdx >= 0) {
      // Try to match the explicit extension
      if (code === ext.charCodeAt(extIdx)) {
        if (--extIdx === -1) {
        // We matched the extension, so mark this as the end of our path
        // component
        end = i;
        }
      } else {
        // Extension does not match, so our result is the entire path
        // component
        extIdx = -1;
        end = firstNonSlashEnd;
      }
      }
    }
    }

    if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
    return path.slice(start, end);
  } else {
    for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now
      if (!matchedSlash) {
        start = i + 1;
        break;
      }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
    }

    if (end === -1) return '';
    return path.slice(start, end);
  }
  },

  extname: function extname(path) {
  assertPath(path);
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now
      if (!matchedSlash) {
      startPart = i + 1;
      break;
      }
      continue;
    }
    if (end === -1) {
    // We saw the first non-path separator, mark this as the end of our
    // extension
    matchedSlash = false;
    end = i + 1;
    }
    if (code === 46 /*.*/) {
      // If this is our first dot, mark it as the start of our extension
      if (startDot === -1)
      startDot = i;
      else if (preDotState !== 1)
      preDotState = 1;
    } else if (startDot !== -1) {
    // We saw a non-dot and non-path separator before our dot, so we should
    // have a good chance at having a non-empty extension
    preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
  },

  format: function format(pathObject) {
  if (pathObject === null || typeof pathObject !== 'object') {
    throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
  }
  return _format('/', pathObject);
  },

  parse: function parse(path) {
  assertPath(path);

  var ret = { root: '', dir: '', base: '', ext: '', name: '' };
  if (path.length === 0) return ret;
  var code = path.charCodeAt(0);
  var isAbsolute = code === 47 /*/*/;
  var start;
  if (isAbsolute) {
    ret.root = '/';
    start = 1;
  } else {
    start = 0;
  }
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  var i = path.length - 1;

  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;

  // Get non-dir info
  for (; i >= start; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now
      if (!matchedSlash) {
      startPart = i + 1;
      break;
      }
      continue;
    }
    if (end === -1) {
    // We saw the first non-path separator, mark this as the end of our
    // extension
    matchedSlash = false;
    end = i + 1;
    }
    if (code === 46 /*.*/) {
      // If this is our first dot, mark it as the start of our extension
      if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
    // We saw a non-dot and non-path separator before our dot, so we should
    // have a good chance at having a non-empty extension
    preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
  // We saw a non-dot character immediately before the dot
  preDotState === 0 ||
  // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
    if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
    }
  } else {
    if (startPart === 0 && isAbsolute) {
    ret.name = path.slice(1, startDot);
    ret.base = path.slice(1, end);
    } else {
    ret.name = path.slice(startPart, startDot);
    ret.base = path.slice(startPart, end);
    }
    ret.ext = path.slice(startDot, end);
  }

  if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

  return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

var pathBrowserify = posix;

// MODULE: compiler/sys/modules/path.js
const path = {};
if (IS_NODE_ENV) {
  const nodePath = requireFunc('path');
  Object.assign(path, nodePath);
  path.join = (...args) => normalizePath(nodePath.join.apply(nodePath, args));
  path.normalize = (...args) => normalizePath(nodePath.normalize.apply(nodePath, args));
  path.relative = (...args) => normalizePath(nodePath.relative.apply(nodePath, args));
  path.resolve = (...args) => normalizePath(nodePath.resolve.apply(nodePath, args));
}
else {
  Object.assign(path, pathBrowserify);
}
const basename = path.basename;
const dirname = path.dirname;
const extname = path.extname;
const isAbsolute = path.isAbsolute;
const join = path.join;
const normalize = path.normalize;
const relative = path.relative;
const resolve = path.resolve;
const sep = path.sep;
const posix$1 = path.posix;

// MODULE: compiler/transformers/stencil-import-path.js
const serializeImportPath = (data) => {
  let p = data.importeePath;
  if (isString(p)) {
    if (isString(data.importerPath) && isAbsolute(data.importeePath)) {
      p = relative(dirname(data.importerPath), data.importeePath);
    }
    p = normalizePath(p);
    if (!p.startsWith('.')) {
      p = './' + p;
    }
    const paramData = {};
    if (isString(data.tag)) {
      paramData.tag = data.tag;
    }
    if (isString(data.mode) && data.mode !== DEFAULT_STYLE_MODE) {
      paramData.mode = data.mode;
    }
    if (isString(data.encapsulation) && data.encapsulation !== 'none') {
      paramData.encapsulation = data.encapsulation;
    }
    const paramEntries = Object.entries(paramData);
    if (paramEntries.length > 0) {
      const params = new URLSearchParams(paramEntries);
      p += '?' + params.toString();
    }
  }
  return p;
};
const parseImportPath = (importPath) => {
  const parsedPath = {
    importPath,
    basename: null,
    ext: null,
    data: null,
  };
  if (isString(importPath)) {
    const pathParts = importPath.split('?');
    parsedPath.basename = basename(pathParts[0].trim());
    const extParts = parsedPath.basename.toLowerCase().split('.');
    if (extParts.length > 1) {
      parsedPath.ext = extParts[extParts.length - 1];
      if (parsedPath.ext === 'ts' && extParts[extParts.length - 2] === 'd') {
        parsedPath.ext = 'd.ts';
      }
    }
    if (pathParts.length > 1) {
      const params = pathParts[1];
      const urlParams = new URLSearchParams(params);
      const tag = urlParams.get('tag');
      if (tag != null) {
        parsedPath.data = {
          tag,
          encapsulation: urlParams.get('encapsulation') || 'none',
          mode: urlParams.get('mode') || DEFAULT_STYLE_MODE,
        };
      }
    }
  }
  return parsedPath;
};

// MODULE: compiler/config/compile-module-options.js
const getCompileResults = (code, input) => {
  if (!isString(input.file)) {
    input.file = 'module.tsx';
  }
  const parsedImport = parseImportPath(input.file);
  const results = {
    code: typeof code === 'string' ? code : '',
    data: [],
    diagnostics: [],
    inputFileExtension: parsedImport.ext,
    inputFilePath: input.file,
    imports: [],
    map: null,
    outputFilePath: null,
  };
  return {
    importData: parsedImport.data,
    results,
  };
};
const getCompileModuleConfig = (input) => {
  const compileOpts = {
    componentExport: getCompileConfigOpt(input.componentExport, VALID_EXPORT, 'customelement'),
    componentMetadata: getCompileConfigOpt(input.componentMetadata, VALID_METADATA, null),
    coreImportPath: isString(input.coreImportPath) ? input.coreImportPath : STENCIL_INTERNAL_CLIENT_ID,
    currentDirectory: isString(input.currentDirectory) ? input.currentDirectory : '/',
    file: input.file,
    proxy: getCompileConfigOpt(input.proxy, VALID_PROXY, 'defineproperty'),
    module: getCompileConfigOpt(input.module, VALID_MODULE, 'esm'),
    sourceMap: input.sourceMap === 'inline' ? 'inline' : input.sourceMap !== false,
    style: getCompileConfigOpt(input.style, VALID_STYLE, 'static'),
    target: getCompileConfigOpt(input.target || input.script /* deprecated */, VALID_TARGET, 'latest'),
    typescriptPath: input.typescriptPath,
  };
  const tsCompilerOptions = {
    // best we always set this to true
    allowSyntheticDefaultImports: true,
    // best we always set this to true
    esModuleInterop: true,
    // always get source maps
    sourceMap: compileOpts.sourceMap !== false,
    // isolated per file transpiling
    isolatedModules: true,
    // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.
    suppressOutputPathCheck: true,
    // Filename can be non-ts file.
    allowNonTsExtensions: true,
    // We are not returning a sourceFile for lib file when asked by the program,
    // so pass --noLib to avoid reporting a file not found error.
    noLib: true,
    noResolve: true,
  };
  if (isString(input.baseUrl)) {
    compileOpts.baseUrl = input.baseUrl;
    tsCompilerOptions.baseUrl = compileOpts.baseUrl;
  }
  if (input.paths) {
    compileOpts.paths = Object.assign({}, input.paths);
    tsCompilerOptions.paths = Object.assign({}, compileOpts.paths);
  }
  const transformOpts = {
    coreImportPath: compileOpts.coreImportPath,
    componentExport: compileOpts.componentExport,
    componentMetadata: compileOpts.componentMetadata,
    currentDirectory: compileOpts.currentDirectory,
    module: compileOpts.module,
    proxy: compileOpts.proxy,
    file: compileOpts.file,
    style: compileOpts.style,
    target: compileOpts.target,
  };
  const config = {
    cwd: compileOpts.currentDirectory,
    rootDir: compileOpts.currentDirectory,
    srcDir: compileOpts.currentDirectory,
    devMode: true,
    minifyCss: true,
    minifyJs: false,
    _isTesting: true,
    validateTypes: false,
    enableCache: false,
    sys: null,
    tsCompilerOptions,
  };
  return {
    compileOpts,
    config,
    transformOpts,
  };
};
const getCompileCssConfig = (compileOpts, importData, results) => {
  const transformInput = {
    file: results.inputFilePath,
    input: results.code,
    tag: importData && importData.tag,
    encapsulation: importData && importData.encapsulation,
    mode: importData && importData.mode,
    sourceMap: compileOpts.sourceMap !== false,
    commentOriginalSelector: false,
    minify: false,
    autoprefixer: false,
    module: compileOpts.module,
  };
  return transformInput;
};
const getCompileConfigOpt = (value, validValues, defaultValue) => {
  if (value === null || value === 'null') {
    return null;
  }
  value = isString(value) ? value.toLowerCase().trim() : null;
  if (validValues.has(value)) {
    return value;
  }
  return defaultValue;
};
const VALID_EXPORT = new Set(['customelement', 'module']);
const VALID_METADATA = new Set(['compilerstatic', null]);
const VALID_MODULE = new Set(['cjs', 'esm']);
const VALID_PROXY = new Set(['defineproperty', null]);
const VALID_STYLE = new Set(['static']);
const VALID_TARGET = new Set(['latest', 'esnext', 'es2020', 'es2019', 'es2018', 'es2017', 'es2016', 'es2015', 'es5']);

// MODULE: compiler/transformers/decorators-to-static/decorators-constants.js
const CLASS_DECORATORS_TO_REMOVE = new Set(['Component']);
const MEMBER_DECORATORS_TO_REMOVE = new Set(['Element', 'Event', 'Listen', 'Method', 'Prop', 'PropDidChange', 'PropWillChange', 'State', 'Watch']);

// MODULE: compiler/sys/modules/typescript.js
// this "ts" object is patched by the dynamically loaded typescript
const ts = {};

// MODULE: compiler/transformers/transform-utils.js
const isMemberPrivate = (member) => {
  if (member.modifiers && member.modifiers.some(m => m.kind === ts.SyntaxKind.PrivateKeyword || m.kind === ts.SyntaxKind.ProtectedKeyword)) {
    return true;
  }
  return false;
};
const convertValueToLiteral = (val, refs = null) => {
  if (refs == null) {
    refs = new WeakSet();
  }
  if (val === String) {
    return ts.createIdentifier('String');
  }
  if (val === Number) {
    return ts.createIdentifier('Number');
  }
  if (val === Boolean) {
    return ts.createIdentifier('Boolean');
  }
  if (val === undefined) {
    return ts.createIdentifier('undefined');
  }
  if (val === null) {
    return ts.createIdentifier('null');
  }
  if (Array.isArray(val)) {
    return arrayToArrayLiteral(val, refs);
  }
  if (typeof val === 'object') {
    if (val.__identifier && val.__escapedText) {
      return ts.createIdentifier(val.__escapedText);
    }
    return objectToObjectLiteral(val, refs);
  }
  return ts.createLiteral(val);
};
const arrayToArrayLiteral = (list, refs) => {
  const newList = list.map(l => {
    return convertValueToLiteral(l, refs);
  });
  return ts.createArrayLiteral(newList);
};
const objectToObjectLiteral = (obj, refs) => {
  if (refs.has(obj)) {
    return ts.createIdentifier('undefined');
  }
  refs.add(obj);
  const newProperties = Object.keys(obj).map(key => {
    const prop = ts.createPropertyAssignment(ts.createLiteral(key), convertValueToLiteral(obj[key], refs));
    return prop;
  });
  return ts.createObjectLiteral(newProperties, true);
};
const createStaticGetter = (propName, returnExpression) => {
  return ts.createGetAccessor(undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], propName, undefined, undefined, ts.createBlock([ts.createReturn(returnExpression)]));
};
const getStaticValue = (staticMembers, staticName) => {
  const staticMember = staticMembers.find(member => member.name.escapedText === staticName);
  if (!staticMember || !staticMember.body || !staticMember.body.statements) {
    return null;
  }
  const rtnStatement = staticMember.body.statements.find(s => s.kind === ts.SyntaxKind.ReturnStatement);
  if (!rtnStatement || !rtnStatement.expression) {
    return null;
  }
  const expKind = rtnStatement.expression.kind;
  if (expKind === ts.SyntaxKind.StringLiteral) {
    return rtnStatement.expression.text;
  }
  if (expKind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) {
    return rtnStatement.expression.text;
  }
  if (expKind === ts.SyntaxKind.TrueKeyword) {
    return true;
  }
  if (expKind === ts.SyntaxKind.FalseKeyword) {
    return false;
  }
  if (expKind === ts.SyntaxKind.ObjectLiteralExpression) {
    return objectLiteralToObjectMap(rtnStatement.expression);
  }
  if (expKind === ts.SyntaxKind.ArrayLiteralExpression && rtnStatement.expression.elements) {
    return arrayLiteralToArray(rtnStatement.expression);
  }
  if (expKind === ts.SyntaxKind.Identifier) {
    const identifier = rtnStatement.expression;
    if (typeof identifier.escapedText === 'string') {
      return getIdentifierValue(identifier.escapedText);
    }
    if (identifier.escapedText) {
      const obj = {};
      Object.keys(identifier.escapedText).forEach(key => {
        obj[key] = getIdentifierValue(identifier.escapedText[key]);
      });
      return obj;
    }
  }
  return null;
};
const arrayLiteralToArray = (arr) => {
  return arr.elements.map(element => {
    let val;
    switch (element.kind) {
      case ts.SyntaxKind.ObjectLiteralExpression:
        val = objectLiteralToObjectMap(element);
        break;
      case ts.SyntaxKind.StringLiteral:
        val = element.text;
        break;
      case ts.SyntaxKind.TrueKeyword:
        val = true;
        break;
      case ts.SyntaxKind.FalseKeyword:
        val = false;
        break;
      case ts.SyntaxKind.Identifier:
        const escapedText = element.escapedText;
        if (escapedText === 'String') {
          val = String;
        }
        else if (escapedText === 'Number') {
          val = Number;
        }
        else if (escapedText === 'Boolean') {
          val = Boolean;
        }
        break;
      case ts.SyntaxKind.PropertyAccessExpression:
      default:
        val = element;
    }
    return val;
  });
};
const objectLiteralToObjectMap = (objectLiteral) => {
  const attrs = objectLiteral.properties;
  return attrs.reduce((final, attr) => {
    const attrName = getTextOfPropertyName(attr.name);
    let val;
    switch (attr.initializer.kind) {
      case ts.SyntaxKind.ArrayLiteralExpression:
        val = arrayLiteralToArray(attr.initializer);
        break;
      case ts.SyntaxKind.ObjectLiteralExpression:
        val = objectLiteralToObjectMap(attr.initializer);
        break;
      case ts.SyntaxKind.StringLiteral:
        val = attr.initializer.text;
        break;
      case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
        val = attr.initializer.text;
        break;
      case ts.SyntaxKind.TrueKeyword:
        val = true;
        break;
      case ts.SyntaxKind.FalseKeyword:
        val = false;
        break;
      case ts.SyntaxKind.Identifier:
        const escapedText = attr.initializer.escapedText;
        if (escapedText === 'String') {
          val = String;
        }
        else if (escapedText === 'Number') {
          val = Number;
        }
        else if (escapedText === 'Boolean') {
          val = Boolean;
        }
        else if (escapedText === 'undefined') {
          val = undefined;
        }
        else if (escapedText === 'null') {
          val = null;
        }
        else {
          val = getIdentifierValue(attr.initializer.escapedText);
        }
        break;
      case ts.SyntaxKind.PropertyAccessExpression:
      default:
        val = attr.initializer;
    }
    final[attrName] = val;
    return final;
  }, {});
};
const getIdentifierValue = (escapedText) => {
  const identifier = {
    __identifier: true,
    __escapedText: escapedText,
  };
  return identifier;
};
const getTextOfPropertyName = (propName) => {
  switch (propName.kind) {
    case ts.SyntaxKind.Identifier:
      return propName.text;
    case ts.SyntaxKind.StringLiteral:
    case ts.SyntaxKind.NumericLiteral:
      return propName.text;
    case ts.SyntaxKind.ComputedPropertyName:
      const expression = propName.expression;
      if (ts.isStringLiteral(expression) || ts.isNumericLiteral(expression)) {
        return propName.expression.text;
      }
  }
  return undefined;
};
const getAttributeTypeInfo = (baseNode, sourceFile) => {
  const allReferences = {};
  getAllTypeReferences(baseNode).forEach(rt => {
    allReferences[rt] = getTypeReferenceLocation(rt, sourceFile);
  });
  return allReferences;
};
const getEntityName = (entity) => {
  if (ts.isIdentifier(entity)) {
    return entity.escapedText.toString();
  }
  else {
    return getEntityName(entity.left);
  }
};
const getAllTypeReferences = (node) => {
  const referencedTypes = [];
  const visit = (node) => {
    if (ts.isTypeReferenceNode(node)) {
      referencedTypes.push(getEntityName(node.typeName));
      if (node.typeArguments) {
        node.typeArguments
          .filter(ta => ts.isTypeReferenceNode(ta))
          .forEach((tr) => {
          const typeName = tr.typeName;
          referencedTypes.push(typeName.escapedText.toString());
        });
      }
    }
    return ts.forEachChild(node, visit);
  };
  visit(node);
  return referencedTypes;
};
const validateReferences = (diagnostics, references, node) => {
  Object.keys(references).forEach(refName => {
    const ref = references[refName];
    if (ref.path === '@stencil/core' && MEMBER_DECORATORS_TO_REMOVE.has(refName)) {
      const err = buildError(diagnostics);
      augmentDiagnosticWithNode(err, node);
    }
  });
};
const getTypeReferenceLocation = (typeName, tsNode) => {
  const sourceFileObj = tsNode.getSourceFile();
  // Loop through all top level imports to find any reference to the type for 'import' reference location
  const importTypeDeclaration = sourceFileObj.statements.find(st => {
    const statement = ts.isImportDeclaration(st) &&
      st.importClause &&
      ts.isImportClause(st.importClause) &&
      st.importClause.namedBindings &&
      ts.isNamedImports(st.importClause.namedBindings) &&
      Array.isArray(st.importClause.namedBindings.elements) &&
      st.importClause.namedBindings.elements.find(nbe => nbe.name.getText() === typeName);
    if (!statement) {
      return false;
    }
    return true;
  });
  if (importTypeDeclaration) {
    const localImportPath = importTypeDeclaration.moduleSpecifier.text;
    return {
      location: 'import',
      path: localImportPath,
    };
  }
  // Loop through all top level exports to find if any reference to the type for 'local' reference location
  const isExported = sourceFileObj.statements.some(st => {
    // Is the interface defined in the file and exported
    const isInterfaceDeclarationExported = ts.isInterfaceDeclaration(st) &&
      st.name.getText() === typeName &&
      Array.isArray(st.modifiers) &&
      st.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword);
    const isTypeAliasDeclarationExported = ts.isTypeAliasDeclaration(st) &&
      st.name.getText() === typeName &&
      Array.isArray(st.modifiers) &&
      st.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword);
    // Is the interface exported through a named export
    const isTypeInExportDeclaration = ts.isExportDeclaration(st) && ts.isNamedExports(st.exportClause) && st.exportClause.elements.some(nee => nee.name.getText() === typeName);
    return isInterfaceDeclarationExported || isTypeAliasDeclarationExported || isTypeInExportDeclaration;
  });
  if (isExported) {
    return {
      location: 'local',
    };
  }
  // This is most likely a global type, if it is a local that is not exported then typescript will inform the dev
  return {
    location: 'global',
  };
};
const resolveType = (checker, type) => {
  const set = new Set();
  parseDocsType(checker, type, set);
  // normalize booleans
  const hasTrue = set.delete('true');
  const hasFalse = set.delete('false');
  if (hasTrue || hasFalse) {
    set.add('boolean');
  }
  let parts = Array.from(set.keys()).sort();
  if (parts.length > 1) {
    parts = parts.map(p => (p.indexOf('=>') >= 0 ? `(${p})` : p));
  }
  if (parts.length > 20) {
    return typeToString(checker, type);
  }
  else {
    return parts.join(' | ');
  }
};
const typeToString = (checker, type) => {
  const TYPE_FORMAT_FLAGS = ts.TypeFormatFlags.NoTruncation | ts.TypeFormatFlags.InTypeAlias | ts.TypeFormatFlags.InElementType;
  return checker.typeToString(type, undefined, TYPE_FORMAT_FLAGS);
};
const parseDocsType = (checker, type, parts) => {
  if (type.isUnion()) {
    type.types.forEach(t => {
      parseDocsType(checker, t, parts);
    });
  }
  else {
    const text = typeToString(checker, type);
    parts.add(text);
  }
};
const getModuleFromSourceFile = (compilerCtx, tsSourceFile) => {
  const sourceFilePath = normalizePath(tsSourceFile.fileName);
  const moduleFile = compilerCtx.moduleMap.get(sourceFilePath);
  if (moduleFile != null) {
    return moduleFile;
  }
  const moduleFiles = Array.from(compilerCtx.moduleMap.values());
  return moduleFiles.find(m => m.jsFilePath === sourceFilePath);
};
const getComponentMeta = (compilerCtx, tsSourceFile, node) => {
  const meta = compilerCtx.nodeMap.get(node);
  if (meta) {
    return meta;
  }
  const moduleFile = getModuleFromSourceFile(compilerCtx, tsSourceFile);
  if (moduleFile != null && node.members != null) {
    const staticMembers = node.members.filter(isStaticGetter);
    const tagName = getComponentTagName(staticMembers);
    if (typeof tagName === 'string') {
      return moduleFile.cmps.find(cmp => cmp.tagName === tagName);
    }
  }
  return undefined;
};
const getComponentTagName = (staticMembers) => {
  if (staticMembers.length > 0) {
    const tagName = getStaticValue(staticMembers, 'is');
    if (typeof tagName === 'string' && tagName.includes('-')) {
      return tagName;
    }
  }
  return null;
};
const isStaticGetter = (member) => {
  return member.kind === ts.SyntaxKind.GetAccessor && member.modifiers && member.modifiers.some(({ kind }) => kind === ts.SyntaxKind.StaticKeyword);
};
const serializeSymbol = (checker, symbol) => {
  if (!checker || !symbol) {
    return {
      tags: [],
      text: '',
    };
  }
  return {
    tags: symbol.getJsDocTags().map(tag => ({ text: tag.text, name: tag.name })),
    text: ts.displayPartsToString(symbol.getDocumentationComment(checker)),
  };
};
const isInternal = (jsDocs) => {
  return jsDocs && jsDocs.tags.some(s => s.name === 'internal');
};
const isMethod = (member, methodName) => {
  return ts.isMethodDeclaration(member) && member.name && member.name.escapedText === methodName;
};

// MODULE: compiler/transformers/add-component-meta-static.js
const addComponentMetaStatic = (cmpNode, cmpMeta) => {
  const publicCompilerMeta = getPublicCompilerMeta(cmpMeta);
  const cmpMetaStaticProp = createStaticGetter('COMPILER_META', convertValueToLiteral(publicCompilerMeta));
  const classMembers = [...cmpNode.members, cmpMetaStaticProp];
  return ts.updateClassDeclaration(cmpNode, cmpNode.decorators, cmpNode.modifiers, cmpNode.name, cmpNode.typeParameters, cmpNode.heritageClauses, classMembers);
};
const getPublicCompilerMeta = (cmpMeta) => {
  const publicCompilerMeta = Object.assign({}, cmpMeta);
  // no need to copy all compiler meta data
  delete publicCompilerMeta.assetsDirs;
  delete publicCompilerMeta.dependencies;
  delete publicCompilerMeta.excludeFromCollection;
  delete publicCompilerMeta.isCollectionDependency;
  delete publicCompilerMeta.docs;
  delete publicCompilerMeta.jsFilePath;
  delete publicCompilerMeta.potentialCmpRefs;
  delete publicCompilerMeta.styleDocs;
  delete publicCompilerMeta.sourceFilePath;
  return publicCompilerMeta;
};

// MODULE: compiler/sys/resolve/resolve-utils.js
const COMMON_DIR_MODULE_EXTS = ['.tsx', '.ts', '.mjs', '.js', '.jsx', '.json', '.md'];
const COMMON_DIR_FILENAMES = ['package.json', 'index.js', 'index.mjs'];
const isDtsFile$1 = (p) => p.endsWith('.d.ts');
const isTsFile = (p) => !isDtsFile$1(p) && p.endsWith('.ts');
const isTsxFile = (p) => p.endsWith('.tsx');
const isJsxFile = (p) => p.endsWith('.jsx');
const isJsFile = (p) => p.endsWith('.js');
const isJsonFile = (p) => p.endsWith('.json');
const getCommonDirName = (dirPath, fileName) => dirPath + '/' + fileName;
const isCommonDirModuleFile = (p) => COMMON_DIR_MODULE_EXTS.some(ext => p.endsWith(ext));
const setPackageVersion = (pkgVersions, pkgName, pkgVersion) => {
  pkgVersions.set(pkgName, pkgVersion);
};
const setPackageVersionByContent = (pkgVersions, pkgContent) => {
  try {
    const pkg = JSON.parse(pkgContent);
    if (pkg.name && pkg.version) {
      setPackageVersion(pkgVersions, pkg.name, pkg.version);
    }
  }
  catch (e) { }
};
const getNodeModulePath = (rootDir, ...pathParts) => normalizePath(join.apply(null, [rootDir, 'node_modules', ...pathParts]));
const getStencilModulePath = (rootDir, ...pathParts) => getNodeModulePath(rootDir, '@stencil', 'core', ...pathParts);
const getStencilInternalDtsPath = (rootDir) => getStencilModulePath(rootDir, 'internal', 'index.d.ts');
const isLocalModule = (p) => p.startsWith('.') || p.startsWith('/');
const isStencilCoreImport = (p) => p.startsWith('@stencil/core');
const shouldFetchModule = (p) => IS_FETCH_ENV && !IS_NODE_ENV && isNodeModulePath(p);
const isNodeModulePath = (p) => normalizePath(p)
  .split('/')
  .includes('node_modules');
const getPackageDirPath = (p, moduleId) => {
  const parts = normalizePath(p).split('/');
  for (let i = parts.length - 1; i >= 1; i--) {
    if (parts[i - 1] === 'node_modules' && parts[i] === moduleId) {
      return parts.slice(0, i + 1).join('/');
    }
  }
  return null;
};

// MODULE: compiler/sys/fetch/fetch-utils.js
const httpFetch = (sys, input, init) => {
  if (sys && isFunction(sys.fetch)) {
    return sys.fetch(input, init);
  }
  return fetch(input, init);
};
const packageVersions = new Map();
const known404Urls = new Set();
const isExternalUrl = (p) => {
  if (isString(p)) {
    p = p.toLowerCase();
    return p.startsWith('https://') || p.startsWith('http://');
  }
  return false;
};
const getRemoteModuleUrl = (sys, module) => {
  if (sys && isFunction(sys.getRemoteModuleUrl)) {
    return sys.getRemoteModuleUrl(module);
  }
  const nmBaseUrl = 'https://cdn.jsdelivr.net/npm/';
  const path = `${module.moduleId}${module.version ? '@' + module.version : ''}/${module.path}`;
  return new URL(path, nmBaseUrl).href;
};
const getRemotePackageJsonUrl = (sys, moduleId) => {
  return getRemoteModuleUrl(sys, {
    moduleId,
    path: `package.json`,
  });
};
const getStencilRootUrl = (compilerExe) => new URL('../', compilerExe).href;
const getStencilModuleUrl = (compilerExe, p) => {
  p = normalizePath(p);
  let parts = p.split('/');
  const nmIndex = parts.lastIndexOf('node_modules');
  if (nmIndex > -1 && nmIndex < parts.length - 1) {
    parts = parts.slice(nmIndex + 1);
    if (parts[0].startsWith('@')) {
      parts = parts.slice(2);
    }
    else {
      parts = parts.slice(1);
    }
    p = parts.join('/');
  }
  return new URL('./' + p, getStencilRootUrl(compilerExe)).href;
};
const getCommonDirUrl = (sys, pkgVersions, dirPath, fileName) => getNodeModuleFetchUrl(sys, pkgVersions, dirPath) + '/' + fileName;
const getNodeModuleFetchUrl = (sys, pkgVersions, filePath) => {
  // /node_modules/lodash/package.json
  filePath = normalizePath(filePath);
  // ["node_modules", "lodash", "package.json"]
  let pathParts = filePath.split('/').filter(p => p.length);
  const nmIndex = pathParts.lastIndexOf('node_modules');
  if (nmIndex > -1 && nmIndex < pathParts.length - 1) {
    pathParts = pathParts.slice(nmIndex + 1);
  }
  let moduleId = pathParts.shift();
  if (moduleId.startsWith('@')) {
    moduleId += '/' + pathParts.shift();
  }
  const path = pathParts.join('/');
  if (moduleId === '@stencil/core') {
    const compilerExe = sys.getCompilerExecutingPath();
    return getStencilModuleUrl(compilerExe, path);
  }
  return getRemoteModuleUrl(sys, {
    moduleId,
    version: pkgVersions.get(moduleId),
    path,
  });
};
const skipFilePathFetch = (filePath) => {
  if (isTsFile(filePath) || isTsxFile(filePath)) {
    // don't bother trying to resolve  node_module packages w/ typescript files
    // they should already be .js files
    return true;
  }
  const pathParts = filePath.split('/');
  const secondToLast = pathParts[pathParts.length - 2];
  const lastPart = pathParts[pathParts.length - 1];
  if (secondToLast === 'node_modules' && isCommonDirModuleFile(lastPart)) {
    // /node_modules/index.js
    // /node_modules/lodash.js
    // we just already know this is bogus, so don't bother
    return true;
  }
  return false;
};
const skipUrlFetch = (url) => 
// files we just already know not to try to resolve request
knownUrlSkips.some(knownSkip => url.endsWith(knownSkip));
const knownUrlSkips = [
  '/@stencil/core/internal.js',
  '/@stencil/core/internal.json',
  '/@stencil/core/internal.mjs',
  '/@stencil/core/internal/stencil-core.js/index.json',
  '/@stencil/core/internal/stencil-core.js.json',
  '/@stencil/core/internal/stencil-core.js/package.json',
  '/@stencil/core.js',
  '/@stencil/core.json',
  '/@stencil/core.mjs',
  '/@stencil/core.css',
  '/@stencil/core/index.js',
  '/@stencil/core/index.json',
  '/@stencil/core/index.mjs',
  '/@stencil/core/index.css',
  '/@stencil/package.json',
];

// MODULE: version.js
const minfyJsId = 'terser4.6.9_6';
const optimizeCssId = 'autoprefixer9.7.5_postcss7.0.27_6';
const rollupVersion = '1.32.0';
const terserVersion = '4.6.9';
const typescriptVersion = '3.8.3';
const version = '1.12.2';

// MODULE: compiler/sys/dependencies.js
const getRemoteTypeScriptUrl = (sys) => {
  const tsDep = dependencies.find(dep => dep.name === 'typescript');
  return getRemoteModuleUrl(sys, { moduleId: tsDep.name, version: tsDep.version, path: tsDep.main });
};
const dependencies = [
  {
    name: '@stencil/core',
    version: version,
    main: 'compiler/stencil.min.js',
    resources: [
      'internal/index.d.ts',
      'internal/package.json',
      'internal/stencil-core.js',
      'internal/stencil-core.d.ts',
      'internal/stencil-ext-modules.d.ts',
      'internal/stencil-private.d.ts',
      'internal/stencil-public-compiler.d.ts',
      'internal/stencil-public-docs.d.ts',
      'internal/stencil-public-runtime.d.ts',
      'internal/client/css-shim.mjs',
      'internal/client/dom.mjs',
      'internal/client/index.mjs',
      'internal/client/shadow-css.mjs',
      'internal/client/package.json',
      'package.json',
    ],
  },
  {
    name: 'typescript',
    version: typescriptVersion,
    main: 'lib/typescript.js',
    resources: [
      'lib/lib.dom.d.ts',
      'lib/lib.es2015.d.ts',
      'lib/lib.es5.d.ts',
      'lib/lib.es2015.core.d.ts',
      'lib/lib.es2015.collection.d.ts',
      'lib/lib.es2015.generator.d.ts',
      'lib/lib.es2015.iterable.d.ts',
      'lib/lib.es2015.symbol.d.ts',
      'lib/lib.es2015.promise.d.ts',
      'lib/lib.es2015.proxy.d.ts',
      'lib/lib.es2015.reflect.d.ts',
      'lib/lib.es2015.symbol.wellknown.d.ts',
      'package.json',
    ],
  },
  {
    name: 'rollup',
    version: rollupVersion,
    main: '/dist/rollup.browser.es.js',
  },
  {
    name: 'terser',
    version: terserVersion,
    main: '/dist/bundle.min.js',
  },
];

// MODULE: compiler/sys/fetch/write-fetch-success.js
const writeFetchSuccessSync = (sys, inMemoryFs, url, filePath, content, pkgVersions) => {
  if (url.endsWith('package.json')) {
    setPackageVersionByContent(pkgVersions, content);
  }
  let dir = dirname(filePath);
  while (dir !== '/' && dir !== '') {
    if (inMemoryFs) {
      inMemoryFs.clearFileCache(dir);
      inMemoryFs.sys.mkdirSync(dir);
    }
    else {
      sys.mkdirSync(dir);
    }
    dir = dirname(dir);
  }
  if (inMemoryFs) {
    inMemoryFs.clearFileCache(filePath);
    inMemoryFs.sys.writeFileSync(filePath, content);
  }
  else {
    sys.writeFileSync(filePath, content);
  }
};
const writeFetchSuccessAsync = async (sys, inMemoryFs, url, filePath, content, pkgVersions) => {
  if (url.endsWith('package.json')) {
    setPackageVersionByContent(pkgVersions, content);
  }
  let dir = dirname(filePath);
  while (dir !== '/' && dir !== '') {
    if (inMemoryFs) {
      inMemoryFs.clearFileCache(dir);
      await inMemoryFs.sys.mkdir(dir);
    }
    else {
      await sys.mkdir(dir);
    }
    dir = dirname(dir);
  }
  if (inMemoryFs) {
    inMemoryFs.clearFileCache(filePath);
    await inMemoryFs.sys.writeFile(filePath, content);
  }
  else {
    await sys.writeFile(filePath, content);
  }
};

// MODULE: compiler/sys/fetch/fetch-module-sync.js
const fetchModuleSync = (sys, inMemoryFs, pkgVersions, url, filePath) => {
  if (skipFilePathFetch(filePath)) {
    return undefined;
  }
  const content = fetchUrlSync(url);
  if (isString(content)) {
    writeFetchSuccessSync(sys, inMemoryFs, url, filePath, content, pkgVersions);
  }
  return content;
};
const fetchUrlSync = (url) => {
  if (known404Urls.has(url) || skipUrlFetch(url)) {
    return undefined;
  }
  try {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    if (xhr.status >= 200 && xhr.status <= 299) {
      return xhr.responseText;
    }
  }
  catch (e) { }
  known404Urls.add(url);
  return undefined;
};

// MODULE: compiler/sys/typescript/typescript-sys.js
const patchTypeScriptSys = (loadedTs, config, inMemoryFs) => {
  const stencilSys = config.sys;
  loadedTs.sys = loadedTs.sys || {};
  patchTsSystemFileSystem(config, stencilSys, inMemoryFs, loadedTs.sys);
  patchTsSystemWatch(stencilSys, loadedTs.sys);
  patchTsSystemUtils(loadedTs.sys);
};
const patchTsSystemFileSystem = (config, stencilSys, inMemoryFs, tsSys) => {
  const realpath = (path) => {
    const rp = stencilSys.realpathSync(path);
    if (rp) {
      return rp;
    }
    return path;
  };
  const getAccessibleFileSystemEntries = (path) => {
    try {
      const entries = stencilSys.readdirSync(path || '.').sort();
      const files = [];
      const directories = [];
      for (const absPath of entries) {
        // This is necessary because on some file system node fails to exclude
        // "." and "..". See https://github.com/nodejs/node/issues/4002
        const stat = inMemoryFs.statSync(absPath);
        if (!stat) {
          continue;
        }
        const entry = basename(absPath);
        if (stat.isFile) {
          files.push(entry);
        }
        else if (stat.isDirectory) {
          directories.push(entry);
        }
      }
      return { files, directories };
    }
    catch (e) {
      return { files: [], directories: [] };
    }
  };
  tsSys.createDirectory = p => stencilSys.mkdirSync(p);
  tsSys.directoryExists = p => {
    const s = inMemoryFs.statSync(p);
    return s.isDirectory;
  };
  tsSys.fileExists = p => {
    const s = inMemoryFs.statSync(p);
    return s.isFile;
  };
  tsSys.getDirectories = p => {
    const items = stencilSys.readdirSync(p);
    return items.filter(itemPath => {
      const s = inMemoryFs.statSync(itemPath);
      return !!(s && s.exists && s.isDirectory);
    });
  };
  tsSys.readDirectory = (path, extensions, exclude, include, depth) => {
    const cwd = stencilSys.getCurrentDirectory();
    return ts.matchFiles(path, extensions, exclude, include, IS_CASE_SENSITIVE_FILE_NAMES, cwd, depth, getAccessibleFileSystemEntries, realpath);
  };
  tsSys.readFile = p => {
    const isUrl = p.startsWith('https:') || p.startsWith('http:');
    let content = inMemoryFs.readFileSync(p, { useCache: isUrl });
    if (typeof content !== 'string' && isUrl) {
      if (IS_WEB_WORKER_ENV) {
        content = fetchUrlSync(p);
        if (typeof content === 'string') {
          inMemoryFs.writeFile(p, content);
        }
      }
      else {
        config.logger.error(`ts.sys can only request http resources from within a web worker: ${p}`);
      }
    }
    return content;
  };
  tsSys.writeFile = (p, data) => inMemoryFs.writeFile(p, data);
  return tsSys;
};
const patchTsSystemWatch = (stencilSys, tsSys) => {
  tsSys.watchDirectory = (p, cb, recursive) => {
    const watcher = stencilSys.watchDirectory(p, filePath => {
      cb(filePath);
    }, recursive);
    return {
      close() {
        watcher.close();
      },
    };
  };
  tsSys.watchFile = (p, cb) => {
    const watcher = stencilSys.watchFile(p, (filePath, eventKind) => {
      if (eventKind === 'fileAdd') {
        cb(filePath, ts.FileWatcherEventKind.Created);
      }
      else if (eventKind === 'fileUpdate') {
        cb(filePath, ts.FileWatcherEventKind.Changed);
      }
      else if (eventKind === 'fileDelete') {
        cb(filePath, ts.FileWatcherEventKind.Deleted);
      }
    });
    return {
      close() {
        watcher.close();
      },
    };
  };
};
const patchTsSystemUtils = (tsSys) => {
  if (!tsSys.getCurrentDirectory) {
    tsSys.getCurrentDirectory = () => '/';
  }
  if (!tsSys.args) {
    tsSys.args = [];
  }
  if (!tsSys.newLine) {
    tsSys.newLine = '\n';
  }
  if (!isBoolean(tsSys.useCaseSensitiveFileNames)) {
    tsSys.useCaseSensitiveFileNames = IS_CASE_SENSITIVE_FILE_NAMES;
  }
  if (!tsSys.exit) {
    tsSys.exit = noop;
  }
  if (!tsSys.resolvePath) {
    tsSys.resolvePath = p => resolve(p);
  }
  if (!tsSys.write) {
    tsSys.write = noop;
  }
};
const patchTypeScriptGetParsedCommandLineOfConfigFile = (loadedTs, _config) => {
  const orgGetParsedCommandLineOfConfigFile = loadedTs.getParsedCommandLineOfConfigFile;
  loadedTs.getParsedCommandLineOfConfigFile = (configFileName, optionsToExtend, host, extendedConfigCache) => {
    const results = orgGetParsedCommandLineOfConfigFile(configFileName, optionsToExtend, host, extendedConfigCache);
    // manually filter out any .spec or .e2e files
    results.fileNames = results.fileNames.filter(f => {
      // filter e2e tests
      if (f.includes('.e2e.') || f.includes('/e2e.')) {
        return false;
      }
      // filter spec tests
      if (f.includes('.spec.') || f.includes('/spec.')) {
        return false;
      }
      return true;
    });
    return results;
  };
};

// MODULE: compiler/sys/typescript/typescript-load.js
const loadTypescript = async (sys, diagnostics, typescriptPath) => {
  const tsSync = loadTypescriptSync(sys, diagnostics, typescriptPath);
  if (tsSync != null) {
    return tsSync;
  }
  if (IS_FETCH_ENV) {
    try {
      // browser main thread
      const tsUrl = typescriptPath || getRemoteTypeScriptUrl(sys);
      const rsp = await httpFetch(sys, tsUrl);
      const content = await rsp.text();
      const getTsFunction = new Function(content + ';return ts;');
      const fetchTs = getLoadedTs(getTsFunction(), 'fetch', tsUrl);
      if (fetchTs) {
        patchImportedTsSys(fetchTs, tsUrl);
        return fetchTs;
      }
    }
    catch (e) {
      catchError(diagnostics, e);
    }
  }
  return null;
};
const loadTypescriptSync = (sys, diagnostics, typescriptPath) => {
  try {
    if (ts.__loaded) {
      // already loaded
      return ts;
    }
    if (IS_GLOBAL_THIS_ENV) {
      // check if the global object has "ts" on it
      // could be browser main thread, browser web worker, or nodejs global
      const globalThisTs = getLoadedTs(globalThis.ts, 'globalThis', typescriptPath);
      if (globalThisTs) {
        return globalThisTs;
      }
    }
    if (IS_NODE_ENV) {
      // NodeJS
      const nodeModuleId = typescriptPath || 'typescript';
      const nodeTs = getLoadedTs(requireFunc(nodeModuleId), 'nodejs', nodeModuleId);
      if (nodeTs) {
        return nodeTs;
      }
    }
    if (IS_WEB_WORKER_ENV) {
      // browser web worker
      // doing this before the globalThis check cuz we'd
      // rather ensure we're using a valid typescript version
      const tsUrl = typescriptPath || getRemoteTypeScriptUrl(sys);
      // importScripts() will be synchronous within a web worker
      self.importScripts(tsUrl);
      const webWorkerTs = getLoadedTs(self.ts, 'importScripts', tsUrl);
      if (webWorkerTs) {
        patchImportedTsSys(webWorkerTs, tsUrl);
        return webWorkerTs;
      }
    }
  }
  catch (e) {
    catchError(diagnostics, e);
  }
  return null;
};
const patchImportedTsSys = (importedTs, tsUrl) => {
  importedTs.sys = importedTs.sys || {};
  importedTs.sys.getExecutingFilePath = () => tsUrl;
  patchTsSystemUtils(importedTs.sys);
};
const getLoadedTs = (loadedTs, source, typescriptPath) => {
  if (loadedTs != null && isFunction(loadedTs.transpileModule)) {
    loadedTs.__loaded = true;
    loadedTs.__source = source;
    loadedTs.__path = typescriptPath;
    return loadedTs;
  }
  return null;
};

// MODULE: ../ commonjsHelpers.js

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

// MODULE: compiler/sys/modules/util.js
const inherits = (ctor, superCtor) => {
  if (superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
  }
};
const inspect = (...args) => args.forEach(arg => console.log(arg));
const promisify = (fn) => {
  if (typeof fn[promisify.custom] === 'function') {
    // https://nodejs.org/api/util.html#util_custom_promisified_functions
    return function (...args) {
      return fn[promisify.custom].apply(this, args);
    };
  }
  return function (...args) {
    return new Promise((resolve, reject) => {
      args.push((err, result) => {
        if (err != null) {
          reject(err);
        }
        else {
          resolve(result);
        }
      });
      fn.apply(this, args);
    });
  };
};
promisify.custom = Symbol('promisify.custom');
const util = {
  inherits,
  inspect,
  promisify,
};

// MODULE: compiler/sys/modules/fs.js
class FsError extends Error {
  constructor(syscall, path, code = 'ENOENT', errno = -2) {
    super(`ENOENT: no such file or directory, ${syscall} '${path}'`);
    this.syscall = syscall;
    this.path = path;
    this.code = code;
    this.errno = errno;
  }
}
const fs = {
  __sys: {},
};
const exists = (fs.exists = (p, cb) => {
  fs.__sys.access(p).then(hasAccess => {
    cb(hasAccess);
  });
});
// https://nodejs.org/api/util.html#util_custom_promisified_functions
exists[promisify.custom] = (p) => fs.__sys.access(p);
const existsSync = (fs.existsSync = (p) => {
  // https://nodejs.org/api/fs.html#fs_fs_existssync_path
  return fs.__sys.accessSync(p);
});
const mkdirSync = (fs.mkdirSync = (p) => {
  const success = fs.__sys.mkdirSync(p);
  if (!success) {
    throw new FsError('mkdir', p);
  }
});
const readdirSync = (fs.readdirSync = (p) => {
  // sys.readdirSync includes full paths
  // but if fs.readdirSync was called, the expected
  // nodejs results are of just the basename for each dir item
  const dirItems = fs.__sys.readdirSync(p);
  return dirItems.map(dirItem => basename(dirItem));
});
const readFile = (fs.readFile = async (p, opts, cb) => {
  const encoding = typeof opts === 'object' ? opts.encoding : typeof opts === 'string' ? opts : 'utf-8';
  cb = typeof cb === 'function' ? cb : typeof opts === 'function' ? opts : null;
  fs.__sys.readFile(p, encoding).then(data => {
    if (cb) {
      if (typeof data === 'string') {
        cb(null, data);
      }
      else {
        cb(new FsError('open', p), data);
      }
    }
  });
});
const readFileSync = (fs.readFileSync = (p, opts) => {
  const encoding = typeof opts === 'object' ? opts.encoding : typeof opts === 'string' ? opts : 'utf-8';
  const data = fs.__sys.readFileSync(p, encoding);
  if (typeof data !== 'string') {
    throw new FsError('open', p);
  }
  return data;
});
const realpath = (fs.realpath = (p, opts, cb) => {
  cb = typeof cb === 'function' ? cb : typeof opts === 'function' ? opts : null;
  fs.__sys.realpath(p).then(data => {
    if (cb) {
      if (typeof data === 'string') {
        cb(null, data);
      }
      else {
        cb(new FsError('realpath', p), data);
      }
    }
  });
});
const realpathSync = (fs.realpathSync = (p) => {
  const data = fs.__sys.realpathSync(p);
  if (!data) {
    throw new FsError('realpathSync', p);
  }
  return data;
});
const statSync = (fs.statSync = (p) => {
  const s = fs.__sys.statSync(p);
  if (!s) {
    throw new FsError('statSync', p);
  }
  return s;
});
const lstatSync = (fs.lstatSync = statSync);
const stat = (fs.stat = (p, opts, cb) => {
  cb = typeof cb === 'function' ? cb : typeof opts === 'function' ? opts : null;
  fs.__sys.stat(p).then(success => {
    if (cb) {
      if (success) {
        cb(null);
      }
      else {
        cb(new FsError('stat', p));
      }
    }
  });
});
const watch = (fs.watch = () => {
  throw new Error(`fs.watch() not implemented`);
});
const writeFile = (fs.writeFile = (p, data, opts, cb) => {
  cb = typeof cb === 'function' ? cb : typeof opts === 'function' ? opts : null;
  fs.__sys.writeFile(p, data).then(success => {
    if (cb) {
      if (success) {
        cb(null);
      }
      else {
        cb(new FsError('writeFile', p));
      }
    }
  });
});

// MODULE: ../node_modules/resolve/lib/caller.js
var caller = function () {
  // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
  var origPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = function (_, stack) { return stack; };
  var stack = (new Error()).stack;
  Error.prepareStackTrace = origPrepareStackTrace;
  return stack[2].getFileName();
};

// MODULE: ../node_modules/path-parse/index.js

var pathParse = createCommonjsModule(function (module) {

var isWindows = process.platform === 'win32';

// Regex to split a windows path into three parts: [*, device, slash,
// tail] windows-only
var splitDeviceRe =
  /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

// Regex to split the tail part of the above into [*, dir, basename, ext]
var splitTailRe =
  /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

var win32 = {};

// Function to split a filename into [root, dir, basename, ext]
function win32SplitPath(filename) {
  // Separate device+slash from tail
  var result = splitDeviceRe.exec(filename),
    device = (result[1] || '') + (result[2] || ''),
    tail = result[3] || '';
  // Split the tail into dir, basename and extension
  var result2 = splitTailRe.exec(tail),
    dir = result2[1],
    basename = result2[2],
    ext = result2[3];
  return [device, dir, basename, ext];
}

win32.parse = function(pathString) {
  if (typeof pathString !== 'string') {
  throw new TypeError(
    "Parameter 'pathString' must be a string, not " + typeof pathString
  );
  }
  var allParts = win32SplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
  throw new TypeError("Invalid path '" + pathString + "'");
  }
  return {
  root: allParts[0],
  dir: allParts[0] + allParts[1].slice(0, -1),
  base: allParts[2],
  ext: allParts[3],
  name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};



// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
  /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var posix = {};


function posixSplitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}


posix.parse = function(pathString) {
  if (typeof pathString !== 'string') {
  throw new TypeError(
    "Parameter 'pathString' must be a string, not " + typeof pathString
  );
  }
  var allParts = posixSplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
  throw new TypeError("Invalid path '" + pathString + "'");
  }
  allParts[1] = allParts[1] || '';
  allParts[2] = allParts[2] || '';
  allParts[3] = allParts[3] || '';

  return {
  root: allParts[0],
  dir: allParts[0] + allParts[1].slice(0, -1),
  base: allParts[2],
  ext: allParts[3],
  name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};


if (isWindows)
  module.exports = win32.parse;
else /* posix */
  module.exports = posix.parse;

module.exports.posix = posix.parse;
module.exports.win32 = win32.parse;
});
var pathParse_1 = pathParse.posix;
var pathParse_2 = pathParse.win32;

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/path-parse/index.js?commonjs-proxy

// MODULE: ../node_modules/resolve/lib/node-modules-paths.js

var parse = path.parse || pathParse;

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
  var prefix = '/';
  if ((/^([A-Za-z]:)/).test(absoluteStart)) {
    prefix = '';
  } else if ((/^\\\\/).test(absoluteStart)) {
    prefix = '\\\\';
  }

  var paths = [absoluteStart];
  var parsed = parse(absoluteStart);
  while (parsed.dir !== paths[paths.length - 1]) {
    paths.push(parsed.dir);
    parsed = parse(parsed.dir);
  }

  return paths.reduce(function (dirs, aPath) {
    return dirs.concat(modules.map(function (moduleDir) {
      return path.resolve(prefix, aPath, moduleDir);
    }));
  }, []);
};

var nodeModulesPaths = function nodeModulesPaths(start, opts, request) {
  var modules = opts && opts.moduleDirectory
    ? [].concat(opts.moduleDirectory)
    : ['node_modules'];

  if (opts && typeof opts.paths === 'function') {
    return opts.paths(
      request,
      start,
      function () { return getNodeModulesDirs(start, modules); },
      opts
    );
  }

  var dirs = getNodeModulesDirs(start, modules);
  return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};

// MODULE: ../node_modules/resolve/lib/normalize-options.js
var normalizeOptions = function (x, opts) {
  /**
   * This file is purposefully a passthrough. It's expected that third-party
   * environments will override it at runtime in order to inject special logic
   * into `resolve` (by manipulating the options). One such example is the PnP
   * code path in Yarn.
   */

  return opts || {};
};

// MODULE: ../node_modules/resolve/lib/core.json
const assert = true;
const async_hooks = ">= 8";
const buffer_ieee754 = "< 0.9.7";
const buffer = true;
const child_process = true;
const cluster = true;
const console$1 = true;
const constants = true;
const crypto$1 = true;
const _debug_agent = ">= 1 && < 8";
const _debugger = "< 8";
const dgram = true;
const dns = true;
const domain = true;
const events = true;
const freelist = "< 6";
const fs$1 = true;
const _http_agent = ">= 0.11.1";
const _http_client = ">= 0.11.1";
const _http_common = ">= 0.11.1";
const _http_incoming = ">= 0.11.1";
const _http_outgoing = ">= 0.11.1";
const _http_server = ">= 0.11.1";
const http = true;
const http2 = ">= 8.8";
const https = true;
const inspector = ">= 8.0.0";
const _linklist = "< 8";
const module$1 = true;
const net = true;
const os = true;
const path$1 = true;
const perf_hooks = ">= 8.5";
const process$1 = ">= 1";
const punycode = true;
const querystring = true;
const readline = true;
const repl = true;
const smalloc = ">= 0.11.5 && < 3";
const _stream_duplex = ">= 0.9.4";
const _stream_transform = ">= 0.9.4";
const _stream_wrap = ">= 1.4.1";
const _stream_passthrough = ">= 0.9.4";
const _stream_readable = ">= 0.9.4";
const _stream_writable = ">= 0.9.4";
const stream = true;
const string_decoder = true;
const sys = true;
const timers = true;
const _tls_common = ">= 0.11.13";
const _tls_legacy = ">= 0.11.3 && < 10";
const _tls_wrap = ">= 0.11.3";
const tls = true;
const trace_events = ">= 10";
const tty = true;
const url = true;
const util$1 = true;
const v8 = ">= 1";
const vm = true;
const worker_threads = ">= 11.7";
const zlib = true;
const core = {
	assert: assert,
	async_hooks: async_hooks,
	buffer_ieee754: buffer_ieee754,
	buffer: buffer,
	child_process: child_process,
	cluster: cluster,
	console: console$1,
	constants: constants,
	crypto: crypto$1,
	_debug_agent: _debug_agent,
	_debugger: _debugger,
	dgram: dgram,
	dns: dns,
	domain: domain,
	events: events,
	freelist: freelist,
	fs: fs$1,
	"fs/promises": ">= 10 && < 10.1",
	_http_agent: _http_agent,
	_http_client: _http_client,
	_http_common: _http_common,
	_http_incoming: _http_incoming,
	_http_outgoing: _http_outgoing,
	_http_server: _http_server,
	http: http,
	http2: http2,
	https: https,
	inspector: inspector,
	_linklist: _linklist,
	module: module$1,
	net: net,
	"node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
	"node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
	"node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
	os: os,
	path: path$1,
	perf_hooks: perf_hooks,
	process: process$1,
	punycode: punycode,
	querystring: querystring,
	readline: readline,
	repl: repl,
	smalloc: smalloc,
	_stream_duplex: _stream_duplex,
	_stream_transform: _stream_transform,
	_stream_wrap: _stream_wrap,
	_stream_passthrough: _stream_passthrough,
	_stream_readable: _stream_readable,
	_stream_writable: _stream_writable,
	stream: stream,
	string_decoder: string_decoder,
	sys: sys,
	timers: timers,
	_tls_common: _tls_common,
	_tls_legacy: _tls_legacy,
	_tls_wrap: _tls_wrap,
	tls: tls,
	trace_events: trace_events,
	tty: tty,
	url: url,
	util: util$1,
	"v8/tools/arguments": ">= 10 && < 12",
	"v8/tools/codemap": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/consarray": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/csvparser": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/logreader": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/profile_view": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/splaytree": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	v8: v8,
	vm: vm,
	worker_threads: worker_threads,
	zlib: zlib
};

const core$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  assert: assert,
  async_hooks: async_hooks,
  buffer_ieee754: buffer_ieee754,
  buffer: buffer,
  child_process: child_process,
  cluster: cluster,
  console: console$1,
  constants: constants,
  crypto: crypto$1,
  _debug_agent: _debug_agent,
  _debugger: _debugger,
  dgram: dgram,
  dns: dns,
  domain: domain,
  events: events,
  freelist: freelist,
  fs: fs$1,
  _http_agent: _http_agent,
  _http_client: _http_client,
  _http_common: _http_common,
  _http_incoming: _http_incoming,
  _http_outgoing: _http_outgoing,
  _http_server: _http_server,
  http: http,
  http2: http2,
  https: https,
  inspector: inspector,
  _linklist: _linklist,
  module: module$1,
  net: net,
  os: os,
  path: path$1,
  perf_hooks: perf_hooks,
  process: process$1,
  punycode: punycode,
  querystring: querystring,
  readline: readline,
  repl: repl,
  smalloc: smalloc,
  _stream_duplex: _stream_duplex,
  _stream_transform: _stream_transform,
  _stream_wrap: _stream_wrap,
  _stream_passthrough: _stream_passthrough,
  _stream_readable: _stream_readable,
  _stream_writable: _stream_writable,
  stream: stream,
  string_decoder: string_decoder,
  sys: sys,
  timers: timers,
  _tls_common: _tls_common,
  _tls_legacy: _tls_legacy,
  _tls_wrap: _tls_wrap,
  tls: tls,
  trace_events: trace_events,
  tty: tty,
  url: url,
  util: util$1,
  v8: v8,
  vm: vm,
  worker_threads: worker_threads,
  zlib: zlib,
  'default': core
});

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/resolve/lib/core.json?commonjs-proxy
 const data = getCjsExportFromNamespace(core$1);

// MODULE: ../node_modules/resolve/lib/core.js

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
  var parts = specifier.split(' ');
  var op = parts.length > 1 ? parts[0] : '=';
  var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

  for (var i = 0; i < 3; ++i) {
    var cur = Number(current[i] || 0);
    var ver = Number(versionParts[i] || 0);
    if (cur === ver) {
      continue; // eslint-disable-line no-restricted-syntax, no-continue
    }
    if (op === '<') {
      return cur < ver;
    } else if (op === '>=') {
      return cur >= ver;
    } else {
      return false;
    }
  }
  return op === '>=';
}

function matchesRange(range) {
  var specifiers = range.split(/ ?&& ?/);
  if (specifiers.length === 0) { return false; }
  for (var i = 0; i < specifiers.length; ++i) {
    if (!specifierIncluded(specifiers[i])) { return false; }
  }
  return true;
}

function versionIncluded(specifierValue) {
  if (typeof specifierValue === 'boolean') { return specifierValue; }
  if (specifierValue && typeof specifierValue === 'object') {
    for (var i = 0; i < specifierValue.length; ++i) {
      if (matchesRange(specifierValue[i])) { return true; }
    }
    return false;
  }
  return matchesRange(specifierValue);
}



var core$2 = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
  if (Object.prototype.hasOwnProperty.call(data, mod)) {
    core$2[mod] = versionIncluded(data[mod]);
  }
}
var core_1 = core$2;

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/resolve/lib/core.js?commonjs-proxy

// MODULE: ../node_modules/resolve/lib/is-core.js

var isCore = function isCore(x) {
  return Object.prototype.hasOwnProperty.call(core_1, x);
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/resolve/lib/caller.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/resolve/lib/node-modules-paths.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/resolve/lib/normalize-options.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/resolve/lib/is-core.js?commonjs-proxy

// MODULE: ../node_modules/resolve/lib/async.js

var defaultIsFile = function isFile(file, cb) {
  fs.stat(file, function (err, stat) {
    if (!err) {
      return cb(null, stat.isFile() || stat.isFIFO());
    }
    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
    return cb(err);
  });
};

var defaultIsDir = function isDirectory(dir, cb) {
  fs.stat(dir, function (err, stat) {
    if (!err) {
      return cb(null, stat.isDirectory());
    }
    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
    return cb(err);
  });
};

var maybeUnwrapSymlink = function maybeUnwrapSymlink(x, opts, cb) {
  if (opts && opts.preserveSymlinks === false) {
    fs.realpath(x, function (realPathErr, realPath) {
      if (realPathErr && realPathErr.code !== 'ENOENT') cb(realPathErr);
      else cb(null, realPathErr ? x : realPath);
    });
  } else {
    cb(null, x);
  }
};

var async = function resolve(x, options, callback) {
  var cb = callback;
  var opts = options;
  if (typeof options === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof x !== 'string') {
    var err = new TypeError('Path must be a string.');
    return process.nextTick(function () {
      cb(err);
    });
  }

  opts = normalizeOptions(x, opts);

  var isFile = opts.isFile || defaultIsFile;
  var isDirectory = opts.isDirectory || defaultIsDir;
  var readFile = opts.readFile || fs.readFile;

  var extensions = opts.extensions || ['.js'];
  var basedir = opts.basedir || path.dirname(caller());
  var parent = opts.filename || basedir;

  opts.paths = opts.paths || [];

  // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
  var absoluteStart = path.resolve(basedir);

  maybeUnwrapSymlink(
    absoluteStart,
    opts,
    function (err, realStart) {
      if (err) cb(err);
      else init(realStart);
    }
  );

  var res;
  function init(basedir) {
    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
      res = path.resolve(basedir, x);
      if (x === '..' || x.slice(-1) === '/') res += '/';
      if ((/\/$/).test(x) && res === basedir) {
        loadAsDirectory(res, opts.package, onfile);
      } else loadAsFile(res, opts.package, onfile);
    } else loadNodeModules(x, basedir, function (err, n, pkg) {
      if (err) cb(err);
      else if (isCore(x)) return cb(null, x);
      else if (n) {
        return maybeUnwrapSymlink(n, opts, function (err, realN) {
          if (err) {
            cb(err);
          } else {
            cb(null, realN, pkg);
          }
        });
      } else {
        var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
        moduleError.code = 'MODULE_NOT_FOUND';
        cb(moduleError);
      }
    });
  }

  function onfile(err, m, pkg) {
    if (err) cb(err);
    else if (m) cb(null, m, pkg);
    else loadAsDirectory(res, function (err, d, pkg) {
      if (err) cb(err);
      else if (d) {
        maybeUnwrapSymlink(d, opts, function (err, realD) {
          if (err) {
            cb(err);
          } else {
            cb(null, realD, pkg);
          }
        });
      } else {
        var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
        moduleError.code = 'MODULE_NOT_FOUND';
        cb(moduleError);
      }
    });
  }

  function loadAsFile(x, thePackage, callback) {
    var loadAsFilePackage = thePackage;
    var cb = callback;
    if (typeof loadAsFilePackage === 'function') {
      cb = loadAsFilePackage;
      loadAsFilePackage = undefined;
    }

    var exts = [''].concat(extensions);
    load(exts, x, loadAsFilePackage);

    function load(exts, x, loadPackage) {
      if (exts.length === 0) return cb(null, undefined, loadPackage);
      var file = x + exts[0];

      var pkg = loadPackage;
      if (pkg) onpkg(null, pkg);
      else loadpkg(path.dirname(file), onpkg);

      function onpkg(err, pkg_, dir) {
        pkg = pkg_;
        if (err) return cb(err);
        if (dir && pkg && opts.pathFilter) {
          var rfile = path.relative(dir, file);
          var rel = rfile.slice(0, rfile.length - exts[0].length);
          var r = opts.pathFilter(pkg, x, rel);
          if (r) return load(
            [''].concat(extensions.slice()),
            path.resolve(dir, r),
            pkg
          );
        }
        isFile(file, onex);
      }
      function onex(err, ex) {
        if (err) return cb(err);
        if (ex) return cb(null, file, pkg);
        load(exts.slice(1), x, pkg);
      }
    }
  }

  function loadpkg(dir, cb) {
    if (dir === '' || dir === '/') return cb(null);
    if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
      return cb(null);
    }
    if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

    maybeUnwrapSymlink(dir, opts, function (unwrapErr, pkgdir) {
      if (unwrapErr) return loadpkg(path.dirname(dir), cb);
      var pkgfile = path.join(pkgdir, 'package.json');
      isFile(pkgfile, function (err, ex) {
        // on err, ex is false
        if (!ex) return loadpkg(path.dirname(dir), cb);

        readFile(pkgfile, function (err, body) {
          if (err) cb(err);
          try { var pkg = JSON.parse(body); } catch (jsonErr) {}

          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, pkgfile);
          }
          cb(null, pkg, dir);
        });
      });
    });
  }

  function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
    var cb = callback;
    var fpkg = loadAsDirectoryPackage;
    if (typeof fpkg === 'function') {
      cb = fpkg;
      fpkg = opts.package;
    }

    maybeUnwrapSymlink(x, opts, function (unwrapErr, pkgdir) {
      if (unwrapErr) return cb(unwrapErr);
      var pkgfile = path.join(pkgdir, 'package.json');
      isFile(pkgfile, function (err, ex) {
        if (err) return cb(err);
        if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

        readFile(pkgfile, function (err, body) {
          if (err) return cb(err);
          try {
            var pkg = JSON.parse(body);
          } catch (jsonErr) {}

          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, pkgfile);
          }

          if (pkg && pkg.main) {
            if (typeof pkg.main !== 'string') {
              var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
              mainError.code = 'INVALID_PACKAGE_MAIN';
              return cb(mainError);
            }
            if (pkg.main === '.' || pkg.main === './') {
              pkg.main = 'index';
            }
            loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
              if (err) return cb(err);
              if (m) return cb(null, m, pkg);
              if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

              var dir = path.resolve(x, pkg.main);
              loadAsDirectory(dir, pkg, function (err, n, pkg) {
                if (err) return cb(err);
                if (n) return cb(null, n, pkg);
                loadAsFile(path.join(x, 'index'), pkg, cb);
              });
            });
            return;
          }

          loadAsFile(path.join(x, '/index'), pkg, cb);
        });
      });
    });
  }

  function processDirs(cb, dirs) {
    if (dirs.length === 0) return cb(null, undefined);
    var dir = dirs[0];

    isDirectory(dir, isdir);

    function isdir(err, isdir) {
      if (err) return cb(err);
      if (!isdir) return processDirs(cb, dirs.slice(1));
      var file = path.join(dir, x);
      loadAsFile(file, opts.package, onfile);
    }

    function onfile(err, m, pkg) {
      if (err) return cb(err);
      if (m) return cb(null, m, pkg);
      loadAsDirectory(path.join(dir, x), opts.package, ondir);
    }

    function ondir(err, n, pkg) {
      if (err) return cb(err);
      if (n) return cb(null, n, pkg);
      processDirs(cb, dirs.slice(1));
    }
  }
  function loadNodeModules(x, start, cb) {
    processDirs(cb, nodeModulesPaths(start, opts, x));
  }
};

// MODULE: ../node_modules/resolve/lib/sync.js

var defaultIsFile$1 = function isFile(file) {
  try {
    var stat = fs.statSync(file);
  } catch (e) {
    if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
    throw e;
  }
  return stat.isFile() || stat.isFIFO();
};

var defaultIsDir$1 = function isDirectory(dir) {
  try {
    var stat = fs.statSync(dir);
  } catch (e) {
    if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
    throw e;
  }
  return stat.isDirectory();
};

var maybeUnwrapSymlink$1 = function maybeUnwrapSymlink(x, opts) {
  if (opts && opts.preserveSymlinks === false) {
    try {
      return fs.realpathSync(x);
    } catch (realPathErr) {
      if (realPathErr.code !== 'ENOENT') {
        throw realPathErr;
      }
    }
  }
  return x;
};

var sync = function (x, options) {
  if (typeof x !== 'string') {
    throw new TypeError('Path must be a string.');
  }
  var opts = normalizeOptions(x, options);

  var isFile = opts.isFile || defaultIsFile$1;
  var readFileSync = opts.readFileSync || fs.readFileSync;
  var isDirectory = opts.isDirectory || defaultIsDir$1;

  var extensions = opts.extensions || ['.js'];
  var basedir = opts.basedir || path.dirname(caller());
  var parent = opts.filename || basedir;

  opts.paths = opts.paths || [];

  // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
  var absoluteStart = maybeUnwrapSymlink$1(path.resolve(basedir), opts);

  if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
    var res = path.resolve(absoluteStart, x);
    if (x === '..' || x.slice(-1) === '/') res += '/';
    var m = loadAsFileSync(res) || loadAsDirectorySync(res);
    if (m) return maybeUnwrapSymlink$1(m, opts);
  } else if (isCore(x)) {
    return x;
  } else {
    var n = loadNodeModulesSync(x, absoluteStart);
    if (n) return maybeUnwrapSymlink$1(n, opts);
  }

  if (isCore(x)) return x;

  var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
  err.code = 'MODULE_NOT_FOUND';
  throw err;

  function loadAsFileSync(x) {
    var pkg = loadpkg(path.dirname(x));

    if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
      var rfile = path.relative(pkg.dir, x);
      var r = opts.pathFilter(pkg.pkg, x, rfile);
      if (r) {
        x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
      }
    }

    if (isFile(x)) {
      return x;
    }

    for (var i = 0; i < extensions.length; i++) {
      var file = x + extensions[i];
      if (isFile(file)) {
        return file;
      }
    }
  }

  function loadpkg(dir) {
    if (dir === '' || dir === '/') return;
    if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
      return;
    }
    if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

    var pkgfile = path.join(maybeUnwrapSymlink$1(dir, opts), 'package.json');

    if (!isFile(pkgfile)) {
      return loadpkg(path.dirname(dir));
    }

    var body = readFileSync(pkgfile);

    try {
      var pkg = JSON.parse(body);
    } catch (jsonErr) {}

    if (pkg && opts.packageFilter) {
      // v2 will pass pkgfile
      pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
    }

    return { pkg: pkg, dir: dir };
  }

  function loadAsDirectorySync(x) {
    var pkgfile = path.join(maybeUnwrapSymlink$1(x, opts), '/package.json');
    if (isFile(pkgfile)) {
      try {
        var body = readFileSync(pkgfile, 'UTF8');
        var pkg = JSON.parse(body);
      } catch (e) {}

      if (pkg && opts.packageFilter) {
        // v2 will pass pkgfile
        pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
      }

      if (pkg && pkg.main) {
        if (typeof pkg.main !== 'string') {
          var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
          mainError.code = 'INVALID_PACKAGE_MAIN';
          throw mainError;
        }
        if (pkg.main === '.' || pkg.main === './') {
          pkg.main = 'index';
        }
        try {
          var m = loadAsFileSync(path.resolve(x, pkg.main));
          if (m) return m;
          var n = loadAsDirectorySync(path.resolve(x, pkg.main));
          if (n) return n;
        } catch (e) {}
      }
    }

    return loadAsFileSync(path.join(x, '/index'));
  }

  function loadNodeModulesSync(x, start) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      var dir = dirs[i];
      if (isDirectory(dir)) {
        var m = loadAsFileSync(path.join(dir, '/', x));
        if (m) return m;
        var n = loadAsDirectorySync(path.join(dir, '/', x));
        if (n) return n;
      }
    }
  }
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/resolve/lib/async.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/resolve/lib/sync.js?commonjs-proxy

// MODULE: ../node_modules/resolve/index.js

var resolve$1 = createCommonjsModule(function (module, exports) {
async.core = core_1;
async.isCore = isCore;
async.sync = sync;
module.exports = async;
});

// MODULE: compiler/sys/resolve/resolve-module-sync.js
const resolveRemoteModuleIdSync = (config, inMemoryFs, opts) => {
  const packageJson = resolveRemotePackageJsonSync(config, inMemoryFs, opts.moduleId);
  if (packageJson) {
    const resolveModuleSyncOpts = Object.assign(Object.assign({}, opts), { exts: ['.js', '.mjs'] });
    const resolvedUrl = resolveModuleIdSync(config.sys, inMemoryFs, resolveModuleSyncOpts);
    if (typeof resolvedUrl === 'string') {
      return {
        resolvedUrl,
        packageJson,
      };
    }
  }
  return null;
};
const resolveRemotePackageJsonSync = (config, inMemoryFs, moduleId) => {
  const filePath = getNodeModulePath(config.rootDir, moduleId, 'package.json');
  let pkgJson = inMemoryFs.readFileSync(filePath);
  if (!isString(pkgJson) && IS_WEB_WORKER_ENV) {
    const url = getRemotePackageJsonUrl(config.sys, moduleId);
    pkgJson = fetchModuleSync(config.sys, inMemoryFs, packageVersions, url, filePath);
  }
  if (typeof pkgJson === 'string') {
    try {
      return JSON.parse(pkgJson);
    }
    catch (e) { }
  }
  return null;
};
const resolveModuleIdSync = (sys, inMemoryFs, opts) => {
  const resolverOpts = createCustomResolverSync(sys, inMemoryFs, opts.exts);
  resolverOpts.basedir = dirname(opts.containingFile);
  resolverOpts.packageFilter = opts.packageFilter;
  const resolvedModule = resolve$1.sync(opts.moduleId, resolverOpts);
  return resolvedModule;
};
const createCustomResolverSync = (sys, inMemoryFs, exts) => {
  return {
    isFile(filePath) {
      const fsFilePath = normalizeFsPath(filePath);
      const stat = inMemoryFs.statSync(fsFilePath);
      if (stat.isFile) {
        return true;
      }
      if (shouldFetchModule(fsFilePath)) {
        const endsWithExt = exts.some(ext => fsFilePath.endsWith(ext));
        if (!endsWithExt) {
          return false;
        }
        const url = getNodeModuleFetchUrl(sys, packageVersions, fsFilePath);
        const content = fetchModuleSync(sys, inMemoryFs, packageVersions, url, fsFilePath);
        return typeof content === 'string';
      }
      return false;
    },
    isDirectory(dirPath) {
      const fsDirPath = normalizeFsPath(dirPath);
      const stat = inMemoryFs.statSync(fsDirPath);
      if (stat.isDirectory) {
        return true;
      }
      if (shouldFetchModule(fsDirPath)) {
        if (basename(fsDirPath) === 'node_modules') {
          // just the /node_modules directory
          inMemoryFs.sys.mkdirSync(fsDirPath);
          inMemoryFs.clearFileCache(fsDirPath);
          return true;
        }
        if (isCommonDirModuleFile(fsDirPath)) {
          // don't bother seeing if it's a directory if it has a common file extension
          return false;
        }
        const checkFileExists = (fileName) => {
          const url = getCommonDirUrl(sys, packageVersions, fsDirPath, fileName);
          const filePath = getCommonDirName(fsDirPath, fileName);
          const content = fetchModuleSync(sys, inMemoryFs, packageVersions, url, filePath);
          return isString(content);
        };
        return COMMON_DIR_FILENAMES.some(checkFileExists);
      }
      return false;
    },
    readFileSync(p) {
      const data = inMemoryFs.readFileSync(p);
      if (isString(data)) {
        return data;
      }
      throw new Error(`file not found: ${p}`);
    },
    extensions: exts,
  };
};

// MODULE: compiler/sys/typescript/typescript-resolve-module.js
const patchTypeScriptResolveModule = (loadedTs, config, inMemoryFs) => {
  let compilerExe;
  if (config.sys) {
    compilerExe = config.sys.getCompilerExecutingPath();
  }
  else if (IS_LOCATION_ENV) {
    compilerExe = location.href;
  }
  if (shouldPatchRemoteTypeScript(compilerExe)) {
    const resolveModuleName = (loadedTs.__resolveModuleName = loadedTs.resolveModuleName);
    loadedTs.resolveModuleName = (moduleName, containingFile, compilerOptions, host, cache, redirectedReference) => {
      const resolvedModule = patchedTsResolveModule(config, inMemoryFs, moduleName, containingFile);
      if (resolvedModule) {
        return resolvedModule;
      }
      return resolveModuleName(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
    };
  }
};
const tsResolveModuleName = (config, compilerCtx, moduleName, containingFile) => {
  const resolveModuleName = ts.__resolveModuleName || ts.resolveModuleName;
  if (moduleName && resolveModuleName && config.tsCompilerOptions) {
    const host = patchTsSystemFileSystem(config, config.sys, compilerCtx.fs, {});
    const compilerOptions = Object.assign({}, config.tsCompilerOptions);
    compilerOptions.resolveJsonModule = true;
    return resolveModuleName(moduleName, containingFile, compilerOptions, host);
  }
  return null;
};
const tsResolveModuleNamePackageJsonPath = (config, compilerCtx, moduleName, containingFile) => {
  try {
    const resolvedModule = tsResolveModuleName(config, compilerCtx, moduleName, containingFile);
    if (resolvedModule && resolvedModule.resolvedModule && resolvedModule.resolvedModule.resolvedFileName) {
      const rootDir = resolve('/');
      let resolvedFileName = resolvedModule.resolvedModule.resolvedFileName;
      for (let i = 0; i < 30; i++) {
        if (rootDir === resolvedFileName) {
          return null;
        }
        resolvedFileName = dirname(resolvedFileName);
        const pkgJsonPath = join(resolvedFileName, 'package.json');
        const exists = config.sys.accessSync(pkgJsonPath);
        if (exists) {
          return normalizePath(pkgJsonPath);
        }
      }
    }
  }
  catch (e) {
    config.logger.error(e);
  }
  return null;
};
const patchedTsResolveModule = (config, inMemoryFs, moduleName, containingFile) => {
  if (isLocalModule(moduleName)) {
    const containingDir = dirname(containingFile);
    let resolvedFileName = join(containingDir, moduleName);
    resolvedFileName = normalizePath(ensureExtension(resolvedFileName, containingFile));
    if (!isAbsolute(resolvedFileName) && !resolvedFileName.startsWith('.') && !resolvedFileName.startsWith('/')) {
      resolvedFileName = './' + resolvedFileName;
    }
    return {
      resolvedModule: {
        extension: getTsResolveExtension(resolvedFileName),
        resolvedFileName,
        packageId: {
          name: moduleName,
          subModuleName: '',
          version,
        },
      },
    };
  }
  // node module id
  return tsResolveNodeModule(config, inMemoryFs, moduleName, containingFile);
};
const tsResolveNodeModule = (config, inMemoryFs, moduleId, containingFile) => {
  if (isStencilCoreImport(moduleId)) {
    return {
      resolvedModule: {
        extension: ts.Extension.Dts,
        resolvedFileName: getStencilInternalDtsPath(config.rootDir),
        packageId: {
          name: moduleId,
          subModuleName: '',
          version,
        },
      },
    };
  }
  const resolved = resolveRemoteModuleIdSync(config, inMemoryFs, {
    moduleId,
    containingFile,
  });
  if (resolved) {
    return {
      resolvedModule: {
        extension: ts.Extension.Js,
        resolvedFileName: resolved.resolvedUrl,
        packageId: {
          name: moduleId,
          subModuleName: '',
          version: resolved.packageJson.version,
        },
      },
    };
  }
  return null;
};
const ensureExtension = (fileName, containingFile) => {
  if (!basename(fileName).includes('.') && isString(containingFile)) {
    containingFile = containingFile.toLowerCase();
    if (isJsFile(containingFile)) {
      fileName += '.js';
    }
    else if (isDtsFile$1(containingFile)) {
      fileName += '.d.ts';
    }
    else if (isTsxFile(containingFile)) {
      fileName += '.tsx';
    }
    else if (isTsFile(containingFile)) {
      fileName += '.ts';
    }
    else if (isJsxFile(containingFile)) {
      fileName += '.jsx';
    }
  }
  return fileName;
};
const getTsResolveExtension = (p) => {
  if (isDtsFile$1(p)) {
    return ts.Extension.Dts;
  }
  if (isTsxFile(p)) {
    return ts.Extension.Tsx;
  }
  if (isJsFile(p)) {
    return ts.Extension.Js;
  }
  if (isJsxFile(p)) {
    return ts.Extension.Jsx;
  }
  if (isJsonFile(p)) {
    return ts.Extension.Json;
  }
  return ts.Extension.Ts;
};
const shouldPatchRemoteTypeScript = (compilerExe) => !IS_NODE_ENV && IS_WEB_WORKER_ENV && isExternalUrl(compilerExe);

// MODULE: compiler/sys/typescript/typescript-patch.js
const patchTypescript = async (config, diagnostics, inMemoryFs) => {
  // dynamically load the typescript dependency
  const loadedTs = await loadTypescript(config.sys, diagnostics, config.typescriptPath);
  patchTypescriptModule(config, diagnostics, inMemoryFs, loadedTs);
};
const patchTypescriptSync = (config, diagnostics, inMemoryFs) => {
  const loadedTs = loadTypescriptSync(config.sys, diagnostics, config.typescriptPath);
  patchTypescriptModule(config, diagnostics, inMemoryFs, loadedTs);
};
const patchTypescriptModule = async (config, diagnostics, inMemoryFs, loadedTs) => {
  if (loadedTs && !hasError(diagnostics)) {
    // override some properties on the original imported ts object
    patchTypeScriptSys(loadedTs, config, inMemoryFs);
    patchTypeScriptResolveModule(loadedTs, config, inMemoryFs);
    patchTypeScriptGetParsedCommandLineOfConfigFile(loadedTs);
    // the ts object you see imported here is actually a bogus {} object right now
    // so assign the loaded ts object to our project's imported "ts" object
    // our "ts" object is the one the rest of the compiler imports and uses
    Object.assign(ts, loadedTs);
  }
};

// MODULE: compiler/sys/modules/module.js
class Module {
}

// MODULE: ../@compiler-plugins

function createCommonjsModule$1(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace$1 (n) {
	return n && n['default'] || n;
}

const assert$1 = true;
const async_hooks$1 = ">= 8";
const buffer_ieee754$1 = "< 0.9.7";
const buffer$1 = true;
const child_process$1 = true;
const cluster$1 = true;
const console$1$1 = true;
const constants$1 = true;
const crypto$2 = true;
const _debug_agent$1 = ">= 1 && < 8";
const _debugger$1 = "< 8";
const dgram$1 = true;
const dns$1 = true;
const domain$1 = true;
const events$1 = true;
const freelist$1 = "< 6";
const fs$2 = true;
const _http_agent$1 = ">= 0.11.1";
const _http_client$1 = ">= 0.11.1";
const _http_common$1 = ">= 0.11.1";
const _http_incoming$1 = ">= 0.11.1";
const _http_outgoing$1 = ">= 0.11.1";
const _http_server$1 = ">= 0.11.1";
const http$1 = true;
const http2$1 = ">= 8.8";
const https$1 = true;
const inspector$1 = ">= 8.0.0";
const _linklist$1 = "< 8";
const module$2 = true;
const net$1 = true;
const os$1 = true;
const path$2 = true;
const perf_hooks$1 = ">= 8.5";
const process$1$1 = ">= 1";
const punycode$1 = true;
const querystring$1 = true;
const readline$1 = true;
const repl$1 = true;
const smalloc$1 = ">= 0.11.5 && < 3";
const _stream_duplex$1 = ">= 0.9.4";
const _stream_transform$1 = ">= 0.9.4";
const _stream_wrap$1 = ">= 1.4.1";
const _stream_passthrough$1 = ">= 0.9.4";
const _stream_readable$1 = ">= 0.9.4";
const _stream_writable$1 = ">= 0.9.4";
const stream$1 = true;
const string_decoder$1 = true;
const sys$1 = true;
const timers$1 = true;
const _tls_common$1 = ">= 0.11.13";
const _tls_legacy$1 = ">= 0.11.3 && < 10";
const _tls_wrap$1 = ">= 0.11.3";
const tls$1 = true;
const trace_events$1 = ">= 10";
const tty$1 = true;
const url$1 = true;
const util$2 = true;
const v8$1 = ">= 1";
const vm$1 = true;
const worker_threads$1 = ">= 11.7";
const zlib$1 = true;
var core$3 = {
	assert: assert$1,
	async_hooks: async_hooks$1,
	buffer_ieee754: buffer_ieee754$1,
	buffer: buffer$1,
	child_process: child_process$1,
	cluster: cluster$1,
	console: console$1$1,
	constants: constants$1,
	crypto: crypto$2,
	_debug_agent: _debug_agent$1,
	_debugger: _debugger$1,
	dgram: dgram$1,
	dns: dns$1,
	domain: domain$1,
	events: events$1,
	freelist: freelist$1,
	fs: fs$2,
	"fs/promises": ">= 10 && < 10.1",
	_http_agent: _http_agent$1,
	_http_client: _http_client$1,
	_http_common: _http_common$1,
	_http_incoming: _http_incoming$1,
	_http_outgoing: _http_outgoing$1,
	_http_server: _http_server$1,
	http: http$1,
	http2: http2$1,
	https: https$1,
	inspector: inspector$1,
	_linklist: _linklist$1,
	module: module$2,
	net: net$1,
	"node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
	"node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
	"node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
	os: os$1,
	path: path$2,
	perf_hooks: perf_hooks$1,
	process: process$1$1,
	punycode: punycode$1,
	querystring: querystring$1,
	readline: readline$1,
	repl: repl$1,
	smalloc: smalloc$1,
	_stream_duplex: _stream_duplex$1,
	_stream_transform: _stream_transform$1,
	_stream_wrap: _stream_wrap$1,
	_stream_passthrough: _stream_passthrough$1,
	_stream_readable: _stream_readable$1,
	_stream_writable: _stream_writable$1,
	stream: stream$1,
	string_decoder: string_decoder$1,
	sys: sys$1,
	timers: timers$1,
	_tls_common: _tls_common$1,
	_tls_legacy: _tls_legacy$1,
	_tls_wrap: _tls_wrap$1,
	tls: tls$1,
	trace_events: trace_events$1,
	tty: tty$1,
	url: url$1,
	util: util$2,
	"v8/tools/arguments": ">= 10 && < 12",
	"v8/tools/codemap": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/consarray": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/csvparser": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/logreader": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/profile_view": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/splaytree": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	v8: v8$1,
	vm: vm$1,
	worker_threads: worker_threads$1,
	zlib: zlib$1
};

var core$1$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	assert: assert$1,
	async_hooks: async_hooks$1,
	buffer_ieee754: buffer_ieee754$1,
	buffer: buffer$1,
	child_process: child_process$1,
	cluster: cluster$1,
	console: console$1$1,
	constants: constants$1,
	crypto: crypto$2,
	_debug_agent: _debug_agent$1,
	_debugger: _debugger$1,
	dgram: dgram$1,
	dns: dns$1,
	domain: domain$1,
	events: events$1,
	freelist: freelist$1,
	fs: fs$2,
	_http_agent: _http_agent$1,
	_http_client: _http_client$1,
	_http_common: _http_common$1,
	_http_incoming: _http_incoming$1,
	_http_outgoing: _http_outgoing$1,
	_http_server: _http_server$1,
	http: http$1,
	http2: http2$1,
	https: https$1,
	inspector: inspector$1,
	_linklist: _linklist$1,
	module: module$2,
	net: net$1,
	os: os$1,
	path: path$2,
	perf_hooks: perf_hooks$1,
	process: process$1$1,
	punycode: punycode$1,
	querystring: querystring$1,
	readline: readline$1,
	repl: repl$1,
	smalloc: smalloc$1,
	_stream_duplex: _stream_duplex$1,
	_stream_transform: _stream_transform$1,
	_stream_wrap: _stream_wrap$1,
	_stream_passthrough: _stream_passthrough$1,
	_stream_readable: _stream_readable$1,
	_stream_writable: _stream_writable$1,
	stream: stream$1,
	string_decoder: string_decoder$1,
	sys: sys$1,
	timers: timers$1,
	_tls_common: _tls_common$1,
	_tls_legacy: _tls_legacy$1,
	_tls_wrap: _tls_wrap$1,
	tls: tls$1,
	trace_events: trace_events$1,
	tty: tty$1,
	url: url$1,
	util: util$2,
	v8: v8$1,
	vm: vm$1,
	worker_threads: worker_threads$1,
	zlib: zlib$1,
	'default': core$3
});

var data$1 = getCjsExportFromNamespace$1(core$1$1);

var current$1 = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded$1(specifier) {
  var parts = specifier.split(' ');
  var op = parts.length > 1 ? parts[0] : '=';
  var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

  for (var i = 0; i < 3; ++i) {
    var cur = Number(current$1[i] || 0);
    var ver = Number(versionParts[i] || 0);
    if (cur === ver) {
      continue; // eslint-disable-line no-restricted-syntax, no-continue
    }
    if (op === '<') {
      return cur < ver;
    } else if (op === '>=') {
      return cur >= ver;
    } else {
      return false;
    }
  }
  return op === '>=';
}

function matchesRange$1(range) {
  var specifiers = range.split(/ ?&& ?/);
  if (specifiers.length === 0) { return false; }
  for (var i = 0; i < specifiers.length; ++i) {
    if (!specifierIncluded$1(specifiers[i])) { return false; }
  }
  return true;
}

function versionIncluded$1(specifierValue) {
  if (typeof specifierValue === 'boolean') { return specifierValue; }
  if (specifierValue && typeof specifierValue === 'object') {
    for (var i = 0; i < specifierValue.length; ++i) {
      if (matchesRange$1(specifierValue[i])) { return true; }
    }
    return false;
  }
  return matchesRange$1(specifierValue);
}



var core$2$1 = {};
for (var mod$1 in data$1) { // eslint-disable-line no-restricted-syntax
  if (Object.prototype.hasOwnProperty.call(data$1, mod$1)) {
    core$2$1[mod$1] = versionIncluded$1(data$1[mod$1]);
  }
}
var core_1$1 = core$2$1;

var caller$1 = function () {
  // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
  var origPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = function (_, stack) { return stack; };
  var stack = (new Error()).stack;
  Error.prepareStackTrace = origPrepareStackTrace;
  return stack[2].getFileName();
};

var pathParse$1 = createCommonjsModule$1(function (module) {

var isWindows = process.platform === 'win32';

// Regex to split a windows path into three parts: [*, device, slash,
// tail] windows-only
var splitDeviceRe =
  /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

// Regex to split the tail part of the above into [*, dir, basename, ext]
var splitTailRe =
  /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

var win32 = {};

// Function to split a filename into [root, dir, basename, ext]
function win32SplitPath(filename) {
  // Separate device+slash from tail
  var result = splitDeviceRe.exec(filename),
    device = (result[1] || '') + (result[2] || ''),
    tail = result[3] || '';
  // Split the tail into dir, basename and extension
  var result2 = splitTailRe.exec(tail),
    dir = result2[1],
    basename = result2[2],
    ext = result2[3];
  return [device, dir, basename, ext];
}

win32.parse = function(pathString) {
  if (typeof pathString !== 'string') {
  throw new TypeError(
    "Parameter 'pathString' must be a string, not " + typeof pathString
  );
  }
  var allParts = win32SplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
  throw new TypeError("Invalid path '" + pathString + "'");
  }
  return {
  root: allParts[0],
  dir: allParts[0] + allParts[1].slice(0, -1),
  base: allParts[2],
  ext: allParts[3],
  name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};



// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
  /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var posix = {};


function posixSplitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}


posix.parse = function(pathString) {
  if (typeof pathString !== 'string') {
  throw new TypeError(
    "Parameter 'pathString' must be a string, not " + typeof pathString
  );
  }
  var allParts = posixSplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
  throw new TypeError("Invalid path '" + pathString + "'");
  }
  allParts[1] = allParts[1] || '';
  allParts[2] = allParts[2] || '';
  allParts[3] = allParts[3] || '';

  return {
  root: allParts[0],
  dir: allParts[0] + allParts[1].slice(0, -1),
  base: allParts[2],
  ext: allParts[3],
  name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};


if (isWindows)
  module.exports = win32.parse;
else /* posix */
  module.exports = posix.parse;

module.exports.posix = posix.parse;
module.exports.win32 = win32.parse;
});
var pathParse_1$1 = pathParse$1.posix;
var pathParse_2$1 = pathParse$1.win32;

var parse$1 = path.parse || pathParse$1;

var getNodeModulesDirs$1 = function getNodeModulesDirs(absoluteStart, modules) {
  var prefix = '/';
  if ((/^([A-Za-z]:)/).test(absoluteStart)) {
    prefix = '';
  } else if ((/^\\\\/).test(absoluteStart)) {
    prefix = '\\\\';
  }

  var paths = [absoluteStart];
  var parsed = parse$1(absoluteStart);
  while (parsed.dir !== paths[paths.length - 1]) {
    paths.push(parsed.dir);
    parsed = parse$1(parsed.dir);
  }

  return paths.reduce(function (dirs, aPath) {
    return dirs.concat(modules.map(function (moduleDir) {
      return path.resolve(prefix, aPath, moduleDir);
    }));
  }, []);
};

var nodeModulesPaths$1 = function nodeModulesPaths(start, opts, request) {
  var modules = opts && opts.moduleDirectory
    ? [].concat(opts.moduleDirectory)
    : ['node_modules'];

  if (opts && typeof opts.paths === 'function') {
    return opts.paths(
      request,
      start,
      function () { return getNodeModulesDirs$1(start, modules); },
      opts
    );
  }

  var dirs = getNodeModulesDirs$1(start, modules);
  return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};

var normalizeOptions$1 = function (x, opts) {
  /**
   * This file is purposefully a passthrough. It's expected that third-party
   * environments will override it at runtime in order to inject special logic
   * into `resolve` (by manipulating the options). One such example is the PnP
   * code path in Yarn.
   */

  return opts || {};
};

var isCore$1 = function isCore(x) {
  return Object.prototype.hasOwnProperty.call(core_1$1, x);
};

var defaultIsFile$2 = function isFile(file, cb) {
  fs.stat(file, function (err, stat) {
    if (!err) {
      return cb(null, stat.isFile() || stat.isFIFO());
    }
    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
    return cb(err);
  });
};

var defaultIsDir$2 = function isDirectory(dir, cb) {
  fs.stat(dir, function (err, stat) {
    if (!err) {
      return cb(null, stat.isDirectory());
    }
    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
    return cb(err);
  });
};

var maybeUnwrapSymlink$2 = function maybeUnwrapSymlink(x, opts, cb) {
  if (opts && opts.preserveSymlinks === false) {
    fs.realpath(x, function (realPathErr, realPath) {
      if (realPathErr && realPathErr.code !== 'ENOENT') cb(realPathErr);
      else cb(null, realPathErr ? x : realPath);
    });
  } else {
    cb(null, x);
  }
};

var async$1 = function resolve(x, options, callback) {
  var cb = callback;
  var opts = options;
  if (typeof options === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof x !== 'string') {
    var err = new TypeError('Path must be a string.');
    return process.nextTick(function () {
      cb(err);
    });
  }

  opts = normalizeOptions$1(x, opts);

  var isFile = opts.isFile || defaultIsFile$2;
  var isDirectory = opts.isDirectory || defaultIsDir$2;
  var readFile = opts.readFile || fs.readFile;

  var extensions = opts.extensions || ['.js'];
  var basedir = opts.basedir || path.dirname(caller$1());
  var parent = opts.filename || basedir;

  opts.paths = opts.paths || [];

  // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
  var absoluteStart = path.resolve(basedir);

  maybeUnwrapSymlink$2(
    absoluteStart,
    opts,
    function (err, realStart) {
      if (err) cb(err);
      else init(realStart);
    }
  );

  var res;
  function init(basedir) {
    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
      res = path.resolve(basedir, x);
      if (x === '..' || x.slice(-1) === '/') res += '/';
      if ((/\/$/).test(x) && res === basedir) {
        loadAsDirectory(res, opts.package, onfile);
      } else loadAsFile(res, opts.package, onfile);
    } else loadNodeModules(x, basedir, function (err, n, pkg) {
      if (err) cb(err);
      else if (isCore$1(x)) return cb(null, x);
      else if (n) {
        return maybeUnwrapSymlink$2(n, opts, function (err, realN) {
          if (err) {
            cb(err);
          } else {
            cb(null, realN, pkg);
          }
        });
      } else {
        var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
        moduleError.code = 'MODULE_NOT_FOUND';
        cb(moduleError);
      }
    });
  }

  function onfile(err, m, pkg) {
    if (err) cb(err);
    else if (m) cb(null, m, pkg);
    else loadAsDirectory(res, function (err, d, pkg) {
      if (err) cb(err);
      else if (d) {
        maybeUnwrapSymlink$2(d, opts, function (err, realD) {
          if (err) {
            cb(err);
          } else {
            cb(null, realD, pkg);
          }
        });
      } else {
        var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
        moduleError.code = 'MODULE_NOT_FOUND';
        cb(moduleError);
      }
    });
  }

  function loadAsFile(x, thePackage, callback) {
    var loadAsFilePackage = thePackage;
    var cb = callback;
    if (typeof loadAsFilePackage === 'function') {
      cb = loadAsFilePackage;
      loadAsFilePackage = undefined;
    }

    var exts = [''].concat(extensions);
    load(exts, x, loadAsFilePackage);

    function load(exts, x, loadPackage) {
      if (exts.length === 0) return cb(null, undefined, loadPackage);
      var file = x + exts[0];

      var pkg = loadPackage;
      if (pkg) onpkg(null, pkg);
      else loadpkg(path.dirname(file), onpkg);

      function onpkg(err, pkg_, dir) {
        pkg = pkg_;
        if (err) return cb(err);
        if (dir && pkg && opts.pathFilter) {
          var rfile = path.relative(dir, file);
          var rel = rfile.slice(0, rfile.length - exts[0].length);
          var r = opts.pathFilter(pkg, x, rel);
          if (r) return load(
            [''].concat(extensions.slice()),
            path.resolve(dir, r),
            pkg
          );
        }
        isFile(file, onex);
      }
      function onex(err, ex) {
        if (err) return cb(err);
        if (ex) return cb(null, file, pkg);
        load(exts.slice(1), x, pkg);
      }
    }
  }

  function loadpkg(dir, cb) {
    if (dir === '' || dir === '/') return cb(null);
    if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
      return cb(null);
    }
    if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

    maybeUnwrapSymlink$2(dir, opts, function (unwrapErr, pkgdir) {
      if (unwrapErr) return loadpkg(path.dirname(dir), cb);
      var pkgfile = path.join(pkgdir, 'package.json');
      isFile(pkgfile, function (err, ex) {
        // on err, ex is false
        if (!ex) return loadpkg(path.dirname(dir), cb);

        readFile(pkgfile, function (err, body) {
          if (err) cb(err);
          try { var pkg = JSON.parse(body); } catch (jsonErr) {}

          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, pkgfile);
          }
          cb(null, pkg, dir);
        });
      });
    });
  }

  function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
    var cb = callback;
    var fpkg = loadAsDirectoryPackage;
    if (typeof fpkg === 'function') {
      cb = fpkg;
      fpkg = opts.package;
    }

    maybeUnwrapSymlink$2(x, opts, function (unwrapErr, pkgdir) {
      if (unwrapErr) return cb(unwrapErr);
      var pkgfile = path.join(pkgdir, 'package.json');
      isFile(pkgfile, function (err, ex) {
        if (err) return cb(err);
        if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

        readFile(pkgfile, function (err, body) {
          if (err) return cb(err);
          try {
            var pkg = JSON.parse(body);
          } catch (jsonErr) {}

          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, pkgfile);
          }

          if (pkg && pkg.main) {
            if (typeof pkg.main !== 'string') {
              var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
              mainError.code = 'INVALID_PACKAGE_MAIN';
              return cb(mainError);
            }
            if (pkg.main === '.' || pkg.main === './') {
              pkg.main = 'index';
            }
            loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
              if (err) return cb(err);
              if (m) return cb(null, m, pkg);
              if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

              var dir = path.resolve(x, pkg.main);
              loadAsDirectory(dir, pkg, function (err, n, pkg) {
                if (err) return cb(err);
                if (n) return cb(null, n, pkg);
                loadAsFile(path.join(x, 'index'), pkg, cb);
              });
            });
            return;
          }

          loadAsFile(path.join(x, '/index'), pkg, cb);
        });
      });
    });
  }

  function processDirs(cb, dirs) {
    if (dirs.length === 0) return cb(null, undefined);
    var dir = dirs[0];

    isDirectory(dir, isdir);

    function isdir(err, isdir) {
      if (err) return cb(err);
      if (!isdir) return processDirs(cb, dirs.slice(1));
      var file = path.join(dir, x);
      loadAsFile(file, opts.package, onfile);
    }

    function onfile(err, m, pkg) {
      if (err) return cb(err);
      if (m) return cb(null, m, pkg);
      loadAsDirectory(path.join(dir, x), opts.package, ondir);
    }

    function ondir(err, n, pkg) {
      if (err) return cb(err);
      if (n) return cb(null, n, pkg);
      processDirs(cb, dirs.slice(1));
    }
  }
  function loadNodeModules(x, start, cb) {
    processDirs(cb, nodeModulesPaths$1(start, opts, x));
  }
};

var defaultIsFile$1$1 = function isFile(file) {
  try {
    var stat = fs.statSync(file);
  } catch (e) {
    if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
    throw e;
  }
  return stat.isFile() || stat.isFIFO();
};

var defaultIsDir$1$1 = function isDirectory(dir) {
  try {
    var stat = fs.statSync(dir);
  } catch (e) {
    if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
    throw e;
  }
  return stat.isDirectory();
};

var maybeUnwrapSymlink$1$1 = function maybeUnwrapSymlink(x, opts) {
  if (opts && opts.preserveSymlinks === false) {
    try {
      return fs.realpathSync(x);
    } catch (realPathErr) {
      if (realPathErr.code !== 'ENOENT') {
        throw realPathErr;
      }
    }
  }
  return x;
};

var sync$1 = function (x, options) {
  if (typeof x !== 'string') {
    throw new TypeError('Path must be a string.');
  }
  var opts = normalizeOptions$1(x, options);

  var isFile = opts.isFile || defaultIsFile$1$1;
  var readFileSync = opts.readFileSync || fs.readFileSync;
  var isDirectory = opts.isDirectory || defaultIsDir$1$1;

  var extensions = opts.extensions || ['.js'];
  var basedir = opts.basedir || path.dirname(caller$1());
  var parent = opts.filename || basedir;

  opts.paths = opts.paths || [];

  // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
  var absoluteStart = maybeUnwrapSymlink$1$1(path.resolve(basedir), opts);

  if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
    var res = path.resolve(absoluteStart, x);
    if (x === '..' || x.slice(-1) === '/') res += '/';
    var m = loadAsFileSync(res) || loadAsDirectorySync(res);
    if (m) return maybeUnwrapSymlink$1$1(m, opts);
  } else if (isCore$1(x)) {
    return x;
  } else {
    var n = loadNodeModulesSync(x, absoluteStart);
    if (n) return maybeUnwrapSymlink$1$1(n, opts);
  }

  if (isCore$1(x)) return x;

  var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
  err.code = 'MODULE_NOT_FOUND';
  throw err;

  function loadAsFileSync(x) {
    var pkg = loadpkg(path.dirname(x));

    if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
      var rfile = path.relative(pkg.dir, x);
      var r = opts.pathFilter(pkg.pkg, x, rfile);
      if (r) {
        x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
      }
    }

    if (isFile(x)) {
      return x;
    }

    for (var i = 0; i < extensions.length; i++) {
      var file = x + extensions[i];
      if (isFile(file)) {
        return file;
      }
    }
  }

  function loadpkg(dir) {
    if (dir === '' || dir === '/') return;
    if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
      return;
    }
    if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

    var pkgfile = path.join(maybeUnwrapSymlink$1$1(dir, opts), 'package.json');

    if (!isFile(pkgfile)) {
      return loadpkg(path.dirname(dir));
    }

    var body = readFileSync(pkgfile);

    try {
      var pkg = JSON.parse(body);
    } catch (jsonErr) {}

    if (pkg && opts.packageFilter) {
      // v2 will pass pkgfile
      pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
    }

    return { pkg: pkg, dir: dir };
  }

  function loadAsDirectorySync(x) {
    var pkgfile = path.join(maybeUnwrapSymlink$1$1(x, opts), '/package.json');
    if (isFile(pkgfile)) {
      try {
        var body = readFileSync(pkgfile, 'UTF8');
        var pkg = JSON.parse(body);
      } catch (e) {}

      if (pkg && opts.packageFilter) {
        // v2 will pass pkgfile
        pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
      }

      if (pkg && pkg.main) {
        if (typeof pkg.main !== 'string') {
          var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
          mainError.code = 'INVALID_PACKAGE_MAIN';
          throw mainError;
        }
        if (pkg.main === '.' || pkg.main === './') {
          pkg.main = 'index';
        }
        try {
          var m = loadAsFileSync(path.resolve(x, pkg.main));
          if (m) return m;
          var n = loadAsDirectorySync(path.resolve(x, pkg.main));
          if (n) return n;
        } catch (e) {}
      }
    }

    return loadAsFileSync(path.join(x, '/index'));
  }

  function loadNodeModulesSync(x, start) {
    var dirs = nodeModulesPaths$1(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      var dir = dirs[i];
      if (isDirectory(dir)) {
        var m = loadAsFileSync(path.join(dir, '/', x));
        if (m) return m;
        var n = loadAsDirectorySync(path.join(dir, '/', x));
        if (n) return n;
      }
    }
  }
};

var resolve$2 = createCommonjsModule$1(function (module, exports) {
// rollup has troubles figuring out the exports
// even with a namedExports option in the commonjs plugin
// idk, this should fix it :)

exports = module.exports = async$1;
exports.core = core_1$1;
exports.isCore = function(x) {
  return core_1$1[x];
};
exports.sync = sync$1;
});
var resolve_1 = resolve$2.core;
var resolve_2 = resolve$2.isCore;
var resolve_3 = resolve$2.sync;

function walk(ast, { enter, leave }) {
	return visit(ast, null, enter, leave);
}

let should_skip = false;
let should_remove = false;
let replacement = null;
const context = {
	skip: () => should_skip = true,
	remove: () => should_remove = true,
	replace: (node) => replacement = node
};

function replace(parent, prop, index, node) {
	if (parent) {
		if (index !== null) {
			parent[prop][index] = node;
		} else {
			parent[prop] = node;
		}
	}
}

function remove(parent, prop, index) {
	if (parent) {
		if (index !== null) {
			parent[prop].splice(index, 1);
		} else {
			delete parent[prop];
		}
	}
}

function visit(
	node,
	parent,
	enter,
	leave,
	prop,
	index
) {
	if (node) {
		if (enter) {
			const _should_skip = should_skip;
			const _should_remove = should_remove;
			const _replacement = replacement;
			should_skip = false;
			should_remove = false;
			replacement = null;

			enter.call(context, node, parent, prop, index);

			if (replacement) {
				node = replacement;
				replace(parent, prop, index, node);
			}

			if (should_remove) {
				remove(parent, prop, index);
			}

			const skipped = should_skip;
			const removed = should_remove;

			should_skip = _should_skip;
			should_remove = _should_remove;
			replacement = _replacement;

			if (skipped) return node;
			if (removed) return null;
		}

		for (const key in node) {
			const value = (node )[key];

			if (typeof value !== 'object') {
				continue;
			}

			else if (Array.isArray(value)) {
				for (let j = 0, k = 0; j < value.length; j += 1, k += 1) {
					if (value[j] !== null && typeof value[j].type === 'string') {
						if (!visit(value[j], node, enter, leave, key, k)) {
							// removed
							j--;
						}
					}
				}
			}

			else if (value !== null && typeof value.type === 'string') {
				visit(value, node, enter, leave, key, null);
			}
		}

		if (leave) {
			const _replacement = replacement;
			const _should_remove = should_remove;
			replacement = null;
			should_remove = false;

			leave.call(context, node, parent, prop, index);

			if (replacement) {
				node = replacement;
				replace(parent, prop, index, node);
			}

			if (should_remove) {
				remove(parent, prop, index);
			}

			const removed = should_remove;

			replacement = _replacement;
			should_remove = _should_remove;

			if (removed) return null;
		}
	}

	return node;
}

const addExtension = function addExtension(filename, ext = '.js') {
  let result = `${filename}`;
  if (!extname(filename))
    result += ext;
  return result;
};

const extractors = {
  ArrayPattern(names, param) {
    for (const element of param.elements) {
      if (element)
        extractors[element.type](names, element);
    }
  },
  AssignmentPattern(names, param) {
    extractors[param.left.type](names, param.left);
  },
  Identifier(names, param) {
    names.push(param.name);
  },
  MemberExpression() { },
  ObjectPattern(names, param) {
    for (const prop of param.properties) {
      // @ts-ignore Typescript reports that this is not a valid type
      if (prop.type === 'RestElement') {
        extractors.RestElement(names, prop);
      }
      else {
        extractors[prop.value.type](names, prop.value);
      }
    }
  },
  RestElement(names, param) {
    extractors[param.argument.type](names, param.argument);
  }
};
const extractAssignedNames = function extractAssignedNames(param) {
  const names = [];
  extractors[param.type](names, param);
  return names;
};

const blockDeclarations = {
  const: true,
  let: true
};
class Scope {
  constructor(options = {}) {
    this.parent = options.parent;
    this.isBlockScope = !!options.block;
    this.declarations = Object.create(null);
    if (options.params) {
      options.params.forEach((param) => {
        extractAssignedNames(param).forEach((name) => {
          this.declarations[name] = true;
        });
      });
    }
  }
  addDeclaration(node, isBlockDeclaration, isVar) {
    if (!isBlockDeclaration && this.isBlockScope) {
      // it's a `var` or function node, and this
      // is a block scope, so we need to go up
      this.parent.addDeclaration(node, isBlockDeclaration, isVar);
    }
    else if (node.id) {
      extractAssignedNames(node.id).forEach((name) => {
        this.declarations[name] = true;
      });
    }
  }
  contains(name) {
    return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
  }
}
const attachScopes = function attachScopes(ast, propertyName = 'scope') {
  let scope = new Scope();
  walk(ast, {
    enter(n, parent) {
      const node = n;
      // function foo () {...}
      // class Foo {...}
      if (/(Function|Class)Declaration/.test(node.type)) {
        scope.addDeclaration(node, false, false);
      }
      // var foo = 1
      if (node.type === 'VariableDeclaration') {
        const { kind } = node;
        const isBlockDeclaration = blockDeclarations[kind];
        // don't add const/let declarations in the body of a for loop #113
        const parentType = parent ? parent.type : '';
        if (!(isBlockDeclaration && /ForOfStatement/.test(parentType))) {
          node.declarations.forEach((declaration) => {
            scope.addDeclaration(declaration, isBlockDeclaration, true);
          });
        }
      }
      let newScope;
      // create new function scope
      if (/Function/.test(node.type)) {
        const func = node;
        newScope = new Scope({
          parent: scope,
          block: false,
          params: func.params
        });
        // named function expressions - the name is considered
        // part of the function's scope
        if (func.type === 'FunctionExpression' && func.id) {
          newScope.addDeclaration(func, false, false);
        }
      }
      // create new block scope
      if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {
        newScope = new Scope({
          parent: scope,
          block: true
        });
      }
      // catch clause has its own block scope
      if (node.type === 'CatchClause') {
        newScope = new Scope({
          parent: scope,
          params: node.param ? [node.param] : [],
          block: true
        });
      }
      if (newScope) {
        Object.defineProperty(node, propertyName, {
          value: newScope,
          configurable: true
        });
        scope = newScope;
      }
    },
    leave(n) {
      const node = n;
      if (node[propertyName])
        scope = scope.parent;
    }
  });
  return scope;
};

function createCommonjsModule$1$1(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var utils = createCommonjsModule$1$1(function (module, exports) {

exports.isInteger = num => {
  if (typeof num === 'number') {
  return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
  return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
  if (node.escaped !== true) {
    node.value = '\\' + node.value;
    node.escaped = true;
  }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
  node.invalid = true;
  return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
  block.invalid = true;
  return true;
  }
  if (block.open !== true || block.close !== true) {
  block.invalid = true;
  return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
  return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
  for (let i = 0; i < arr.length; i++) {
    let ele = arr[i];
    Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
  }
  return result;
  };
  flat(args);
  return result;
};
});
var utils_1 = utils.isInteger;
var utils_2 = utils.find;
var utils_3 = utils.exceedsLimit;
var utils_4 = utils.escapeNode;
var utils_5 = utils.encloseBrace;
var utils_6 = utils.isInvalidBrace;
var utils_7 = utils.isOpenOrClose;
var utils_8 = utils.reduce;
var utils_9 = utils.flatten;

var stringify = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
  let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
  let invalidNode = node.invalid === true && options.escapeInvalid === true;
  let output = '';

  if (node.value) {
    if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
    return '\\' + node.value;
    }
    return node.value;
  }

  if (node.value) {
    return node.value;
  }

  if (node.nodes) {
    for (let child of node.nodes) {
    output += stringify(child);
    }
  }
  return output;
  };

  return stringify(ast);
};

/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */

var isNumber$1 = function(num) {
  if (typeof num === 'number') {
  return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
  return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};

const toRegexRange = (min, max, options) => {
  if (isNumber$1(min) === false) {
  throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
  return String(min);
  }

  if (isNumber$1(max) === false) {
  throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
  opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
  return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
  let result = min + '|' + max;
  if (opts.capture) {
    return `(${result})`;
  }
  if (opts.wrap === false) {
    return result;
  }
  return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
  state.isPadded = isPadded;
  state.maxLen = String(state.max).length;
  }

  if (a < 0) {
  let newMin = b < 0 ? Math.abs(b) : 1;
  negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
  a = state.a = 0;
  }

  if (b >= 0) {
  positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives);

  if (opts.capture === true) {
  state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
  state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false) || [];
  let intersected = filterPatterns(neg, pos, '-?', true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
  stops.add(stop);
  nines += 1;
  stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
  stops.add(stop);
  zeros += 1;
  stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
  return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
  let [startDigit, stopDigit] = zipped[i];

  if (startDigit === stopDigit) {
    pattern += startDigit;

  } else if (startDigit !== '0' || stopDigit !== '9') {
    pattern += toCharacterClass(startDigit, stopDigit);

  } else {
    count++;
  }
  }

  if (count) {
  pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
  let max = ranges[i];
  let obj = rangeToPattern(String(start), String(max), options);
  let zeros = '';

  if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
    if (prev.count.length > 1) {
    prev.count.pop();
    }

    prev.count.push(obj.count[0]);
    prev.string = prev.pattern + toQuantifier(prev.count);
    start = max + 1;
    continue;
  }

  if (tok.isPadded) {
    zeros = padZeros(max, tok, options);
  }

  obj.string = zeros + obj.pattern + toQuantifier(obj.count);
  tokens.push(obj);
  start = max + 1;
  prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
  let { string } = ele;

  // only push if _both_ are negative...
  if (!intersection && !contains(comparison, 'string', string)) {
    result.push(prefix + string);
  }

  // or _both_ are positive
  if (intersection && contains(comparison, 'string', string)) {
    result.push(prefix + string);
  }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
  return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
  return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
  case 0:
    return '';
  case 1:
    return relax ? '0?' : '0';
  case 2:
    return relax ? '0{0,2}' : '00';
  default: {
    return relax ? `0{0,${diff}}` : `0{${diff}}`;
  }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

var toRegexRange_1 = toRegexRange;

const isObject$1 = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber$1$1 = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify$1 = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
  return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
  let dash = input[0] === '-' ? '-' : '';
  if (dash) input = input.slice(1);
  input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
  return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
  input = input.slice(1);
  maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
  positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
  negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
  result = `${positives}|${negatives}`;
  } else {
  result = positives || negatives;
  }

  if (options.wrap) {
  return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
  return toRegexRange_1(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
  let wrap = options.wrap === true;
  let prefix = options.capture ? '' : '?:';
  return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange_1(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
  throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify$1(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
  return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
  if (options.toRegex === true && step > 1) {
    push(a);
  } else {
    range.push(pad(format(a, index), maxLen, toNumber));
  }
  a = descending ? a - step : a + step;
  index++;
  }

  if (options.toRegex === true) {
  return step > 1
    ? toSequence(parts, options)
    : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber$1$1(start) && start.length > 1) || (!isNumber$1$1(end) && end.length > 1)) {
  return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
  return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
  range.push(format(a, index));
  a = descending ? a - step : a + step;
  index++;
  }

  if (options.toRegex === true) {
  return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
  return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
  return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
  return fill(start, end, 1, { transform: step });
  }

  if (isObject$1(step)) {
  return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber$1$1(step)) {
  if (step != null && !isObject$1(step)) return invalidStep(step, opts);
  return fill(start, end, 1, step);
  }

  if (isNumber$1$1(start) && isNumber$1$1(end)) {
  return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

var fillRange = fill;

const compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
  let invalidBlock = utils.isInvalidBrace(parent);
  let invalidNode = node.invalid === true && options.escapeInvalid === true;
  let invalid = invalidBlock === true || invalidNode === true;
  let prefix = options.escapeInvalid === true ? '\\' : '';
  let output = '';

  if (node.isOpen === true) {
    return prefix + node.value;
  }
  if (node.isClose === true) {
    return prefix + node.value;
  }

  if (node.type === 'open') {
    return invalid ? (prefix + node.value) : '(';
  }

  if (node.type === 'close') {
    return invalid ? (prefix + node.value) : ')';
  }

  if (node.type === 'comma') {
    return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
  }

  if (node.value) {
    return node.value;
  }

  if (node.nodes && node.ranges > 0) {
    let args = utils.reduce(node.nodes);
    let range = fillRange(...args, { ...options, wrap: false, toRegex: true });

    if (range.length !== 0) {
    return args.length > 1 && range.length > 1 ? `(${range})` : range;
    }
  }

  if (node.nodes) {
    for (let child of node.nodes) {
    output += walk(child, node);
    }
  }
  return output;
  };

  return walk(ast);
};

var compile_1 = compile;

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
  return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
  if (Array.isArray(item)) {
    for (let value of item) {
    result.push(append(value, stash, enclose));
    }
  } else {
    for (let ele of stash) {
    if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
    result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
    }
  }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
  node.queue = [];

  let p = parent;
  let q = parent.queue;

  while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
    p = p.parent;
    q = p.queue;
  }

  if (node.invalid || node.dollar) {
    q.push(append(q.pop(), stringify(node, options)));
    return;
  }

  if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
    q.push(append(q.pop(), ['{}']));
    return;
  }

  if (node.nodes && node.ranges > 0) {
    let args = utils.reduce(node.nodes);

    if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
    throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
    }

    let range = fillRange(...args, options);
    if (range.length === 0) {
    range = stringify(node, options);
    }

    q.push(append(q.pop(), range));
    node.nodes = [];
    return;
  }

  let enclose = utils.encloseBrace(node);
  let queue = node.queue;
  let block = node;

  while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
    block = block.parent;
    queue = block.queue;
  }

  for (let i = 0; i < node.nodes.length; i++) {
    let child = node.nodes[i];

    if (child.type === 'comma' && node.type === 'brace') {
    if (i === 1) queue.push('');
    queue.push('');
    continue;
    }

    if (child.type === 'close') {
    q.push(append(q.pop(), queue, enclose));
    continue;
    }

    if (child.value && child.type !== 'open') {
    queue.push(append(queue.pop(), child.value));
    continue;
    }

    if (child.nodes) {
    walk(child, node);
    }
  }

  return queue;
  };

  return utils.flatten(walk(ast));
};

var expand_1 = expand;

var constants$1$1 = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = constants$1$1;

/**
 * parse
 */

const parse$1$1 = (input, options = {}) => {
  if (typeof input !== 'string') {
  throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
  throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
  if (node.type === 'text' && prev.type === 'dot') {
    prev.type = 'text';
  }

  if (prev && prev.type === 'text' && node.type === 'text') {
    prev.value += node.value;
    return;
  }

  block.nodes.push(node);
  node.parent = block;
  node.prev = prev;
  prev = node;
  return node;
  };

  push({ type: 'bos' });

  while (index < length) {
  block = stack[stack.length - 1];
  value = advance();

  /**
   * Invalid chars
   */

  if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
    continue;
  }

  /**
   * Escaped chars
   */

  if (value === CHAR_BACKSLASH) {
    push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
    continue;
  }

  /**
   * Right square bracket (literal): ']'
   */

  if (value === CHAR_RIGHT_SQUARE_BRACKET) {
    push({ type: 'text', value: '\\' + value });
    continue;
  }

  /**
   * Left square bracket: '['
   */

  if (value === CHAR_LEFT_SQUARE_BRACKET) {
    brackets++;
    let next;

    while (index < length && (next = advance())) {
    value += next;

    if (next === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;
      continue;
    }

    if (next === CHAR_BACKSLASH) {
      value += advance();
      continue;
    }

    if (next === CHAR_RIGHT_SQUARE_BRACKET) {
      brackets--;

      if (brackets === 0) {
      break;
      }
    }
    }

    push({ type: 'text', value });
    continue;
  }

  /**
   * Parentheses
   */

  if (value === CHAR_LEFT_PARENTHESES) {
    block = push({ type: 'paren', nodes: [] });
    stack.push(block);
    push({ type: 'text', value });
    continue;
  }

  if (value === CHAR_RIGHT_PARENTHESES) {
    if (block.type !== 'paren') {
    push({ type: 'text', value });
    continue;
    }
    block = stack.pop();
    push({ type: 'text', value });
    block = stack[stack.length - 1];
    continue;
  }

  /**
   * Quotes: '|"|`
   */

  if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
    let open = value;
    let next;

    if (options.keepQuotes !== true) {
    value = '';
    }

    while (index < length && (next = advance())) {
    if (next === CHAR_BACKSLASH) {
      value += next + advance();
      continue;
    }

    if (next === open) {
      if (options.keepQuotes === true) value += next;
      break;
    }

    value += next;
    }

    push({ type: 'text', value });
    continue;
  }

  /**
   * Left curly brace: '{'
   */

  if (value === CHAR_LEFT_CURLY_BRACE) {
    depth++;

    let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
    let brace = {
    type: 'brace',
    open: true,
    close: false,
    dollar,
    depth,
    commas: 0,
    ranges: 0,
    nodes: []
    };

    block = push(brace);
    stack.push(block);
    push({ type: 'open', value });
    continue;
  }

  /**
   * Right curly brace: '}'
   */

  if (value === CHAR_RIGHT_CURLY_BRACE) {
    if (block.type !== 'brace') {
    push({ type: 'text', value });
    continue;
    }

    let type = 'close';
    block = stack.pop();
    block.close = true;

    push({ type, value });
    depth--;

    block = stack[stack.length - 1];
    continue;
  }

  /**
   * Comma: ','
   */

  if (value === CHAR_COMMA && depth > 0) {
    if (block.ranges > 0) {
    block.ranges = 0;
    let open = block.nodes.shift();
    block.nodes = [open, { type: 'text', value: stringify(block) }];
    }

    push({ type: 'comma', value });
    block.commas++;
    continue;
  }

  /**
   * Dot: '.'
   */

  if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
    let siblings = block.nodes;

    if (depth === 0 || siblings.length === 0) {
    push({ type: 'text', value });
    continue;
    }

    if (prev.type === 'dot') {
    block.range = [];
    prev.value += value;
    prev.type = 'range';

    if (block.nodes.length !== 3 && block.nodes.length !== 5) {
      block.invalid = true;
      block.ranges = 0;
      prev.type = 'text';
      continue;
    }

    block.ranges++;
    block.args = [];
    continue;
    }

    if (prev.type === 'range') {
    siblings.pop();

    let before = siblings[siblings.length - 1];
    before.value += prev.value + value;
    prev = before;
    block.ranges--;
    continue;
    }

    push({ type: 'dot', value });
    continue;
  }

  /**
   * Text
   */

  push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
  block = stack.pop();

  if (block.type !== 'root') {
    block.nodes.forEach(node => {
    if (!node.nodes) {
      if (node.type === 'open') node.isOpen = true;
      if (node.type === 'close') node.isClose = true;
      if (!node.nodes) node.type = 'text';
      node.invalid = true;
    }
    });

    // get the location of the block on parent.nodes (block's siblings)
    let parent = stack[stack.length - 1];
    let index = parent.nodes.indexOf(block);
    // replace the (invalid) block with it's nodes
    parent.nodes.splice(index, 1, ...block.nodes);
  }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

var parse_1 = parse$1$1;

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
  for (let pattern of input) {
    let result = braces.create(pattern, options);
    if (Array.isArray(result)) {
    output.push(...result);
    } else {
    output.push(result);
    }
  }
  } else {
  output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
  output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse_1(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
  return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
  input = braces.parse(input, options);
  }
  return compile_1(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
  input = braces.parse(input, options);
  }

  let result = expand_1(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
  result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
  result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
  return [input];
  }

 return options.expand !== true
  ? braces.compile(input, options)
  : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

var braces_1 = braces;

const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

var constants$1$1$1 = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
  '***': '*',
  '**/**': '**',
  '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
  return {
    '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
    '?': { type: 'qmark', open: '(?:', close: ')?' },
    '+': { type: 'plus', open: '(?:', close: ')+' },
    '*': { type: 'star', open: '(?:', close: ')*' },
    '@': { type: 'at', open: '(?:', close: ')' }
  };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
  return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};

var utils$1 = createCommonjsModule$1$1(function (module, exports) {


const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = constants$1$1$1;

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
  return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
  return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
  return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
  output = output.slice(2);
  state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
  output = `(?:^(?!${output}).*$)`;
  }
  return output;
};
});
var utils_1$1 = utils$1.isObject;
var utils_2$1 = utils$1.hasRegexChars;
var utils_3$1 = utils$1.isRegexChar;
var utils_4$1 = utils$1.escapeRegex;
var utils_5$1 = utils$1.toPosixSlashes;
var utils_6$1 = utils$1.removeBackslashes;
var utils_7$1 = utils$1.supportsLookbehinds;
var utils_8$1 = utils$1.isWindows;
var utils_9$1 = utils$1.escapeLast;
var utils_10 = utils$1.removePrefix;
var utils_11 = utils$1.wrapOutput;

const {
  CHAR_ASTERISK,       /* * */
  CHAR_AT,           /* @ */
  CHAR_BACKWARD_SLASH,     /* \ */
  CHAR_COMMA: CHAR_COMMA$1,        /* , */
  CHAR_DOT: CHAR_DOT$1,          /* . */
  CHAR_EXCLAMATION_MARK,   /* ! */
  CHAR_FORWARD_SLASH,    /* / */
  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,   /* { */
  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,   /* ( */
  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,  /* [ */
  CHAR_PLUS,         /* + */
  CHAR_QUESTION_MARK,    /* ? */
  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,  /* } */
  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,  /* ) */
  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1  /* ] */
} = constants$1$1$1;

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
  token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
  prev = code;
  return str.charCodeAt(++index);
  };

  while (index < length) {
  code = advance();
  let next;

  if (code === CHAR_BACKWARD_SLASH) {
    backslashes = token.backslashes = true;
    code = advance();

    if (code === CHAR_LEFT_CURLY_BRACE$1) {
    braceEscaped = true;
    }
    continue;
  }

  if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {
    braces++;

    while (eos() !== true && (code = advance())) {
    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      advance();
      continue;
    }

    if (code === CHAR_LEFT_CURLY_BRACE$1) {
      braces++;
      continue;
    }

    if (braceEscaped !== true && code === CHAR_DOT$1 && (code = advance()) === CHAR_DOT$1) {
      isBrace = token.isBrace = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
      continue;
      }

      break;
    }

    if (braceEscaped !== true && code === CHAR_COMMA$1) {
      isBrace = token.isBrace = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
      continue;
      }

      break;
    }

    if (code === CHAR_RIGHT_CURLY_BRACE$1) {
      braces--;

      if (braces === 0) {
      braceEscaped = false;
      isBrace = token.isBrace = true;
      finished = true;
      break;
      }
    }
    }

    if (scanToEnd === true) {
    continue;
    }

    break;
  }

  if (code === CHAR_FORWARD_SLASH) {
    slashes.push(index);
    tokens.push(token);
    token = { value: '', depth: 0, isGlob: false };

    if (finished === true) continue;
    if (prev === CHAR_DOT$1 && index === (start + 1)) {
    start += 2;
    continue;
    }

    lastIndex = index + 1;
    continue;
  }

  if (opts.noext !== true) {
    const isExtglobChar = code === CHAR_PLUS
    || code === CHAR_AT
    || code === CHAR_ASTERISK
    || code === CHAR_QUESTION_MARK
    || code === CHAR_EXCLAMATION_MARK;

    if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES$1) {
    isGlob = token.isGlob = true;
    isExtglob = token.isExtglob = true;
    finished = true;

    if (scanToEnd === true) {
      while (eos() !== true && (code = advance())) {
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        continue;
      }

      if (code === CHAR_RIGHT_PARENTHESES$1) {
        isGlob = token.isGlob = true;
        finished = true;
        break;
      }
      }
      continue;
    }
    break;
    }
  }

  if (code === CHAR_ASTERISK) {
    if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
    isGlob = token.isGlob = true;
    finished = true;

    if (scanToEnd === true) {
    continue;
    }
    break;
  }

  if (code === CHAR_QUESTION_MARK) {
    isGlob = token.isGlob = true;
    finished = true;

    if (scanToEnd === true) {
    continue;
    }
    break;
  }

  if (code === CHAR_LEFT_SQUARE_BRACKET$1) {
    while (eos() !== true && (next = advance())) {
    if (next === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      advance();
      continue;
    }

    if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
      isBracket = token.isBracket = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
      continue;
      }
      break;
    }
    }
  }

  if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
    negated = token.negated = true;
    start++;
    continue;
  }

  if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$1) {
    while (eos() !== true && (code = advance())) {
    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();
      continue;
    }

    if (code === CHAR_RIGHT_PARENTHESES$1) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
      continue;
      }
      break;
    }
    }
  }

  if (isGlob === true) {
    finished = true;

    if (scanToEnd === true) {
    continue;
    }

    break;
  }
  }

  if (opts.noext === true) {
  isExtglob = false;
  isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
  prefix = str.slice(0, start);
  str = str.slice(start);
  lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
  base = str.slice(0, lastIndex);
  glob = str.slice(lastIndex);
  } else if (isGlob === true) {
  base = '';
  glob = str;
  } else {
  base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
  if (isPathSeparator(base.charCodeAt(base.length - 1))) {
    base = base.slice(0, -1);
  }
  }

  if (opts.unescape === true) {
  if (glob) glob = utils$1.removeBackslashes(glob);

  if (base && backslashes === true) {
    base = utils$1.removeBackslashes(base);
  }
  }

  const state = {
  prefix,
  input,
  start,
  base,
  glob,
  isBrace,
  isBracket,
  isGlob,
  isExtglob,
  isGlobstar,
  negated
  };

  if (opts.tokens === true) {
  state.maxDepth = 0;
  if (!isPathSeparator(code)) {
    tokens.push(token);
  }
  state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
  let prevIndex;

  for (let idx = 0; idx < slashes.length; idx++) {
    const n = prevIndex ? prevIndex + 1 : start;
    const i = slashes[idx];
    const value = input.slice(n, i);
    if (opts.tokens) {
    if (idx === 0 && start !== 0) {
      tokens[idx].isPrefix = true;
      tokens[idx].value = prefix;
    } else {
      tokens[idx].value = value;
    }
    depth(tokens[idx]);
    state.maxDepth += tokens[idx].depth;
    }
    if (idx !== 0 || value !== '') {
    parts.push(value);
    }
    prevIndex = i;
  }

  if (prevIndex && prevIndex + 1 < input.length) {
    const value = input.slice(prevIndex + 1);
    parts.push(value);

    if (opts.tokens) {
    tokens[tokens.length - 1].value = value;
    depth(tokens[tokens.length - 1]);
    state.maxDepth += tokens[tokens.length - 1].depth;
    }
  }

  state.slashes = slashes;
  state.parts = parts;
  }

  return state;
};

var scan_1 = scan;

/**
 * Constants
 */

const {
  MAX_LENGTH: MAX_LENGTH$1,
  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants$1$1$1;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
  return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
  /* eslint-disable-next-line no-new */
  new RegExp(value);
  } catch (ex) {
  return args.map(v => utils$1.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse$1$1$1 = (input, options) => {
  if (typeof input !== 'string') {
  throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;

  let len = input.length;
  if (len > max) {
  throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils$1.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants$1$1$1.globChars(win32);
  const EXTGLOB_CHARS = constants$1$1$1.extglobChars(PLATFORM_CHARS);

  const {
  DOT_LITERAL,
  PLUS_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = (opts) => {
  return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
  star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
  opts.noextglob = opts.noext;
  }

  const state = {
  input,
  index: -1,
  start: 0,
  dot: opts.dot === true,
  consumed: '',
  output: '',
  prefix: '',
  backtrack: false,
  negated: false,
  brackets: 0,
  braces: 0,
  parens: 0,
  quotes: 0,
  globstar: false,
  tokens
  };

  input = utils$1.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index];
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
  state.consumed += value;
  state.index += num;
  };
  const append = token => {
  state.output += token.output != null ? token.output : token.value;
  consume(token.value);
  };

  const negate = () => {
  let count = 1;

  while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
    advance();
    state.start++;
    count++;
  }

  if (count % 2 === 0) {
    return false;
  }

  state.negated = true;
  state.start++;
  return true;
  };

  const increment = type => {
  state[type]++;
  stack.push(type);
  };

  const decrement = type => {
  state[type]--;
  stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
  if (prev.type === 'globstar') {
    const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
    const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

    if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
    state.output = state.output.slice(0, -prev.output.length);
    prev.type = 'star';
    prev.value = '*';
    prev.output = star;
    state.output += prev.output;
    }
  }

  if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
    extglobs[extglobs.length - 1].inner += tok.value;
  }

  if (tok.value || tok.output) append(tok);
  if (prev && prev.type === 'text' && tok.type === 'text') {
    prev.value += tok.value;
    prev.output = (prev.output || '') + tok.value;
    return;
  }

  tok.prev = prev;
  tokens.push(tok);
  prev = tok;
  };

  const extglobOpen = (type, value) => {
  const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

  token.prev = prev;
  token.parens = state.parens;
  token.output = state.output;
  const output = (opts.capture ? '(' : '') + token.open;

  increment('parens');


  push({ type, value, output: state.output ? '' : ONE_CHAR });
  push({ type: 'paren', extglob: true, value: advance(), output });
  extglobs.push(token);
  };

  const extglobClose = token => {
  let output = token.close + (opts.capture ? ')' : '');

  if (token.type === 'negate') {
    let extglobStar = star;

    if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
    extglobStar = globstar(opts);
    }

    if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
    output = token.close = `)$))${extglobStar}`;
    }

    if (token.prev.type === 'bos' && eos()) {
    state.negatedExtglob = true;
    }
  }

  push({ type: 'paren', extglob: true, value, output });
  decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
  let backslashes = false;

  let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
    if (first === '\\') {
    backslashes = true;
    return m;
    }

    if (first === '?') {
    if (esc) {
      return esc + first + (rest ? QMARK.repeat(rest.length) : '');
    }
    if (index === 0) {
      return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
    }
    return QMARK.repeat(chars.length);
    }

    if (first === '.') {
    return DOT_LITERAL.repeat(chars.length);
    }

    if (first === '*') {
    if (esc) {
      return esc + first + (rest ? star : '');
    }
    return star;
    }
    return esc ? m : `\\${m}`;
  });

  if (backslashes === true) {
    if (opts.unescape === true) {
    output = output.replace(/\\/g, '');
    } else {
    output = output.replace(/\\+/g, m => {
      return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
    });
    }
  }

  if (output === input && opts.contains === true) {
    state.output = input;
    return state;
  }

  state.output = utils$1.wrapOutput(output, state, options);
  return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
  value = advance();

  if (value === '\u0000') {
    continue;
  }

  /**
   * Escaped characters
   */

  if (value === '\\') {
    const next = peek();

    if (next === '/' && opts.bash !== true) {
    continue;
    }

    if (next === '.' || next === ';') {
    continue;
    }

    if (!next) {
    value += '\\';
    push({ type: 'text', value });
    continue;
    }

    // collapse slashes to reduce potential for exploits
    const match = /^\\+/.exec(remaining());
    let slashes = 0;

    if (match && match[0].length > 2) {
    slashes = match[0].length;
    state.index += slashes;
    if (slashes % 2 !== 0) {
      value += '\\';
    }
    }

    if (opts.unescape === true) {
    value = advance() || '';
    } else {
    value += advance() || '';
    }

    if (state.brackets === 0) {
    push({ type: 'text', value });
    continue;
    }
  }

  /**
   * If we're inside a regex character class, continue
   * until we reach the closing bracket.
   */

  if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
    if (opts.posix !== false && value === ':') {
    const inner = prev.value.slice(1);
    if (inner.includes('[')) {
      prev.posix = true;

      if (inner.includes(':')) {
      const idx = prev.value.lastIndexOf('[');
      const pre = prev.value.slice(0, idx);
      const rest = prev.value.slice(idx + 2);
      const posix = POSIX_REGEX_SOURCE$1[rest];
      if (posix) {
        prev.value = pre + posix;
        state.backtrack = true;
        advance();

        if (!bos.output && tokens.indexOf(prev) === 1) {
        bos.output = ONE_CHAR;
        }
        continue;
      }
      }
    }
    }

    if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
    value = `\\${value}`;
    }

    if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
    value = `\\${value}`;
    }

    if (opts.posix === true && value === '!' && prev.value === '[') {
    value = '^';
    }

    prev.value += value;
    append({ value });
    continue;
  }

  /**
   * If we're inside a quoted string, continue
   * until we reach the closing double quote.
   */

  if (state.quotes === 1 && value !== '"') {
    value = utils$1.escapeRegex(value);
    prev.value += value;
    append({ value });
    continue;
  }

  /**
   * Double quotes
   */

  if (value === '"') {
    state.quotes = state.quotes === 1 ? 0 : 1;
    if (opts.keepQuotes === true) {
    push({ type: 'text', value });
    }
    continue;
  }

  /**
   * Parentheses
   */

  if (value === '(') {
    increment('parens');
    push({ type: 'paren', value });
    continue;
  }

  if (value === ')') {
    if (state.parens === 0 && opts.strictBrackets === true) {
    throw new SyntaxError(syntaxError('opening', '('));
    }

    const extglob = extglobs[extglobs.length - 1];
    if (extglob && state.parens === extglob.parens + 1) {
    extglobClose(extglobs.pop());
    continue;
    }

    push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
    decrement('parens');
    continue;
  }

  /**
   * Square brackets
   */

  if (value === '[') {
    if (opts.nobracket === true || !remaining().includes(']')) {
    if (opts.nobracket !== true && opts.strictBrackets === true) {
      throw new SyntaxError(syntaxError('closing', ']'));
    }

    value = `\\${value}`;
    } else {
    increment('brackets');
    }

    push({ type: 'bracket', value });
    continue;
  }

  if (value === ']') {
    if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
    push({ type: 'text', value, output: `\\${value}` });
    continue;
    }

    if (state.brackets === 0) {
    if (opts.strictBrackets === true) {
      throw new SyntaxError(syntaxError('opening', '['));
    }

    push({ type: 'text', value, output: `\\${value}` });
    continue;
    }

    decrement('brackets');

    const prevValue = prev.value.slice(1);
    if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
    value = `/${value}`;
    }

    prev.value += value;
    append({ value });

    // when literal brackets are explicitly disabled
    // assume we should match with a regex character class
    if (opts.literalBrackets === false || utils$1.hasRegexChars(prevValue)) {
    continue;
    }

    const escaped = utils$1.escapeRegex(prev.value);
    state.output = state.output.slice(0, -prev.value.length);

    // when literal brackets are explicitly enabled
    // assume we should escape the brackets to match literal characters
    if (opts.literalBrackets === true) {
    state.output += escaped;
    prev.value = escaped;
    continue;
    }

    // when the user specifies nothing, try to match both
    prev.value = `(${capture}${escaped}|${prev.value})`;
    state.output += prev.value;
    continue;
  }

  /**
   * Braces
   */

  if (value === '{' && opts.nobrace !== true) {
    increment('braces');

    const open = {
    type: 'brace',
    value,
    output: '(',
    outputIndex: state.output.length,
    tokensIndex: state.tokens.length
    };

    braces.push(open);
    push(open);
    continue;
  }

  if (value === '}') {
    const brace = braces[braces.length - 1];

    if (opts.nobrace === true || !brace) {
    push({ type: 'text', value, output: value });
    continue;
    }

    let output = ')';

    if (brace.dots === true) {
    const arr = tokens.slice();
    const range = [];

    for (let i = arr.length - 1; i >= 0; i--) {
      tokens.pop();
      if (arr[i].type === 'brace') {
      break;
      }
      if (arr[i].type !== 'dots') {
      range.unshift(arr[i].value);
      }
    }

    output = expandRange(range, opts);
    state.backtrack = true;
    }

    if (brace.comma !== true && brace.dots !== true) {
    const out = state.output.slice(0, brace.outputIndex);
    const toks = state.tokens.slice(brace.tokensIndex);
    brace.value = brace.output = '\\{';
    value = output = `\\}`;
    state.output = out;
    for (const t of toks) {
      state.output += (t.output || t.value);
    }
    }

    push({ type: 'brace', value, output });
    decrement('braces');
    braces.pop();
    continue;
  }

  /**
   * Pipes
   */

  if (value === '|') {
    if (extglobs.length > 0) {
    extglobs[extglobs.length - 1].conditions++;
    }
    push({ type: 'text', value });
    continue;
  }

  /**
   * Commas
   */

  if (value === ',') {
    let output = value;

    const brace = braces[braces.length - 1];
    if (brace && stack[stack.length - 1] === 'braces') {
    brace.comma = true;
    output = '|';
    }

    push({ type: 'comma', value, output });
    continue;
  }

  /**
   * Slashes
   */

  if (value === '/') {
    // if the beginning of the glob is "./", advance the start
    // to the current index, and don't add the "./" characters
    // to the state. This greatly simplifies lookbehinds when
    // checking for BOS characters like "!" and "." (not "./")
    if (prev.type === 'dot' && state.index === state.start + 1) {
    state.start = state.index + 1;
    state.consumed = '';
    state.output = '';
    tokens.pop();
    prev = bos; // reset "prev" to the first token
    continue;
    }

    push({ type: 'slash', value, output: SLASH_LITERAL });
    continue;
  }

  /**
   * Dots
   */

  if (value === '.') {
    if (state.braces > 0 && prev.type === 'dot') {
    if (prev.value === '.') prev.output = DOT_LITERAL;
    const brace = braces[braces.length - 1];
    prev.type = 'dots';
    prev.output += value;
    prev.value += value;
    brace.dots = true;
    continue;
    }

    if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
    push({ type: 'text', value, output: DOT_LITERAL });
    continue;
    }

    push({ type: 'dot', value, output: DOT_LITERAL });
    continue;
  }

  /**
   * Question marks
   */

  if (value === '?') {
    const isGroup = prev && prev.value === '(';
    if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
    extglobOpen('qmark', value);
    continue;
    }

    if (prev && prev.type === 'paren') {
    const next = peek();
    let output = value;

    if (next === '<' && !utils$1.supportsLookbehinds()) {
      throw new Error('Node.js v10 or higher is required for regex lookbehinds');
    }

    if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
      output = `\\${value}`;
    }

    push({ type: 'text', value, output });
    continue;
    }

    if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
    push({ type: 'qmark', value, output: QMARK_NO_DOT });
    continue;
    }

    push({ type: 'qmark', value, output: QMARK });
    continue;
  }

  /**
   * Exclamation
   */

  if (value === '!') {
    if (opts.noextglob !== true && peek() === '(') {
    if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
      extglobOpen('negate', value);
      continue;
    }
    }

    if (opts.nonegate !== true && state.index === 0) {
    negate();
    continue;
    }
  }

  /**
   * Plus
   */

  if (value === '+') {
    if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
    extglobOpen('plus', value);
    continue;
    }

    if ((prev && prev.value === '(') || opts.regex === false) {
    push({ type: 'plus', value, output: PLUS_LITERAL });
    continue;
    }

    if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
    push({ type: 'plus', value });
    continue;
    }

    push({ type: 'plus', value: PLUS_LITERAL });
    continue;
  }

  /**
   * Plain text
   */

  if (value === '@') {
    if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
    push({ type: 'at', extglob: true, value, output: '' });
    continue;
    }

    push({ type: 'text', value });
    continue;
  }

  /**
   * Plain text
   */

  if (value !== '*') {
    if (value === '$' || value === '^') {
    value = `\\${value}`;
    }

    const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
    if (match) {
    value += match[0];
    state.index += match[0].length;
    }

    push({ type: 'text', value });
    continue;
  }

  /**
   * Stars
   */

  if (prev && (prev.type === 'globstar' || prev.star === true)) {
    prev.type = 'star';
    prev.star = true;
    prev.value += value;
    prev.output = star;
    state.backtrack = true;
    state.globstar = true;
    consume(value);
    continue;
  }

  let rest = remaining();
  if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
    extglobOpen('star', value);
    continue;
  }

  if (prev.type === 'star') {
    if (opts.noglobstar === true) {
    consume(value);
    continue;
    }

    const prior = prev.prev;
    const before = prior.prev;
    const isStart = prior.type === 'slash' || prior.type === 'bos';
    const afterStar = before && (before.type === 'star' || before.type === 'globstar');

    if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
    push({ type: 'star', value, output: '' });
    continue;
    }

    const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
    const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
    if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
    push({ type: 'star', value, output: '' });
    continue;
    }

    // strip consecutive `/**/`
    while (rest.slice(0, 3) === '/**') {
    const after = input[state.index + 4];
    if (after && after !== '/') {
      break;
    }
    rest = rest.slice(3);
    consume('/**', 3);
    }

    if (prior.type === 'bos' && eos()) {
    prev.type = 'globstar';
    prev.value += value;
    prev.output = globstar(opts);
    state.output = prev.output;
    state.globstar = true;
    consume(value);
    continue;
    }

    if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
    state.output = state.output.slice(0, -(prior.output + prev.output).length);
    prior.output = `(?:${prior.output}`;

    prev.type = 'globstar';
    prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
    prev.value += value;
    state.globstar = true;
    state.output += prior.output + prev.output;
    consume(value);
    continue;
    }

    if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
    const end = rest[1] !== void 0 ? '|$' : '';

    state.output = state.output.slice(0, -(prior.output + prev.output).length);
    prior.output = `(?:${prior.output}`;

    prev.type = 'globstar';
    prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
    prev.value += value;

    state.output += prior.output + prev.output;
    state.globstar = true;

    consume(value + advance());

    push({ type: 'slash', value: '/', output: '' });
    continue;
    }

    if (prior.type === 'bos' && rest[0] === '/') {
    prev.type = 'globstar';
    prev.value += value;
    prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
    state.output = prev.output;
    state.globstar = true;
    consume(value + advance());
    push({ type: 'slash', value: '/', output: '' });
    continue;
    }

    // remove single star from output
    state.output = state.output.slice(0, -prev.output.length);

    // reset previous token to globstar
    prev.type = 'globstar';
    prev.output = globstar(opts);
    prev.value += value;

    // reset output with globstar
    state.output += prev.output;
    state.globstar = true;
    consume(value);
    continue;
  }

  const token = { type: 'star', value, output: star };

  if (opts.bash === true) {
    token.output = '.*?';
    if (prev.type === 'bos' || prev.type === 'slash') {
    token.output = nodot + token.output;
    }
    push(token);
    continue;
  }

  if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
    token.output = value;
    push(token);
    continue;
  }

  if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
    if (prev.type === 'dot') {
    state.output += NO_DOT_SLASH;
    prev.output += NO_DOT_SLASH;

    } else if (opts.dot === true) {
    state.output += NO_DOTS_SLASH;
    prev.output += NO_DOTS_SLASH;

    } else {
    state.output += nodot;
    prev.output += nodot;
    }

    if (peek() !== '*') {
    state.output += ONE_CHAR;
    prev.output += ONE_CHAR;
    }
  }

  push(token);
  }

  while (state.brackets > 0) {
  if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
  state.output = utils$1.escapeLast(state.output, '[');
  decrement('brackets');
  }

  while (state.parens > 0) {
  if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
  state.output = utils$1.escapeLast(state.output, '(');
  decrement('parens');
  }

  while (state.braces > 0) {
  if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
  state.output = utils$1.escapeLast(state.output, '{');
  decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
  push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
  state.output = '';

  for (const token of state.tokens) {
    state.output += token.output != null ? token.output : token.value;

    if (token.suffix) {
    state.output += token.suffix;
    }
  }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse$1$1$1.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
  const len = input.length;
  if (len > max) {
  throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils$1.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
  DOT_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOTS_SLASH,
  STAR,
  START_ANCHOR
  } = constants$1$1$1.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
  star = `(${star})`;
  }

  const globstar = (opts) => {
  if (opts.noglobstar === true) return star;
  return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
  switch (str) {
    case '*':
    return `${nodot}${ONE_CHAR}${star}`;

    case '.*':
    return `${DOT_LITERAL}${ONE_CHAR}${star}`;

    case '*.*':
    return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

    case '*/*':
    return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

    case '**':
    return nodot + globstar(opts);

    case '**/*':
    return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

    case '**/*.*':
    return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

    case '**/.*':
    return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

    default: {
    const match = /^(.*?)\.(\w+)$/.exec(str);
    if (!match) return;

    const source = create(match[1]);
    if (!source) return;

    return source + DOT_LITERAL + match[2];
    }
  }
  };

  const output = utils$1.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
  source += `${SLASH_LITERAL}?`;
  }

  return source;
};

var parse_1$1 = parse$1$1$1;

const isObject$1$1 = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
  const fns = glob.map(input => picomatch(input, options, returnState));
  const arrayMatcher = str => {
    for (const isMatch of fns) {
    const state = isMatch(str);
    if (state) return state;
    }
    return false;
  };
  return arrayMatcher;
  }

  const isState = isObject$1$1(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
  throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils$1.isWindows(options);
  const regex = isState
  ? picomatch.compileRe(glob, options)
  : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
  const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
  isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
  const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
  const result = { glob, state, regex, posix, input, output, match, isMatch };

  if (typeof opts.onResult === 'function') {
    opts.onResult(result);
  }

  if (isMatch === false) {
    result.isMatch = false;
    return returnObject ? result : false;
  }

  if (isIgnored(input)) {
    if (typeof opts.onIgnore === 'function') {
    opts.onIgnore(result);
    }
    result.isMatch = false;
    return returnObject ? result : false;
  }

  if (typeof opts.onMatch === 'function') {
    opts.onMatch(result);
  }
  return returnObject ? result : true;
  };

  if (returnState) {
  matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
  throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
  return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils$1.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
  output = format ? format(input) : input;
  match = output === glob;
  }

  if (match === false || opts.capture === true) {
  if (opts.matchBase === true || opts.basename === true) {
    match = picomatch.matchBase(input, regex, options, posix);
  } else {
    match = regex.exec(output);
  }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils$1.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse_1$1(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan_1(input, options);

/**
 * Create a regular expression from a glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.makeRe(input[, options]);
 *
 * console.log(picomatch.makeRe('*.js'));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `input` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
  return parsed.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${parsed.output})${append}`;
  if (parsed && parsed.negated === true) {
  source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
  regex.state = parsed;
  }

  return regex;
};

picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
  throw new TypeError('Expected a non-empty string');
  }

  const opts = options || {};
  let parsed = { negated: false, fastpaths: true };
  let prefix = '';
  let output;

  if (input.startsWith('./')) {
  input = input.slice(2);
  prefix = parsed.prefix = './';
  }

  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
  output = parse_1$1.fastpaths(input, options);
  }

  if (output === undefined) {
  parsed = parse_1$1(input, options);
  parsed.prefix = prefix + (parsed.prefix || '');
  } else {
  parsed.output = output;
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
  const opts = options || {};
  return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
  if (options && options.debug === true) throw err;
  return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants$1$1$1;

/**
 * Expose "picomatch"
 */

var picomatch_1 = picomatch;

var picomatch$1 = picomatch_1;

const isEmptyString = val => typeof val === 'string' && (val === '' || val === './');

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} list List of strings to match.
 * @param {String|Array<string>} patterns One or more glob patterns to use for matching.
 * @param {Object} options See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
  items.add(state.output);
  if (options && options.onResult) {
    options.onResult(state);
  }
  };

  for (let i = 0; i < patterns.length; i++) {
  let isMatch = picomatch$1(String(patterns[i]), { ...options, onResult }, true);
  let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
  if (negated) negatives++;

  for (let item of list) {
    let matched = isMatch(item, true);

    let match = negated ? !matched.isMatch : matched.isMatch;
    if (!match) continue;

    if (negated) {
    omit.add(matched.output);
    } else {
    omit.delete(matched.output);
    keep.add(matched.output);
    }
  }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
  if (options.failglob === true) {
    throw new Error(`No matches found for "${patterns.join(', ')}"`);
  }

  if (options.nonull === true || options.nullglob === true) {
    return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
  }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch$1(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
  if (options.onResult) options.onResult(state);
  items.push(state.output);
  };

  let matches = micromatch(list, patterns, { ...options, onResult });

  for (let item of items) {
  if (!matches.includes(item)) {
    result.add(item);
  }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
  throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
  return pattern.some(p => micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
  if (isEmptyString(str) || isEmptyString(pattern)) {
    return false;
  }

  if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
    return true;
  }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => {
  if (!utils$1.isObject(obj)) {
  throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
  let isMatch = picomatch$1(String(pattern), options);
  if (items.some(item => isMatch(item))) {
    return true;
  }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
  let isMatch = picomatch$1(String(pattern), options);
  if (!items.every(item => isMatch(item))) {
    return false;
  }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
  throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch$1(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) => {
  let posix = utils$1.isWindows(options);
  let regex = picomatch$1.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils$1.toPosixSlashes(input) : input);

  if (match) {
  return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) => picomatch$1.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch.scan = (...args) => picomatch$1.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
  for (let str of braces_1(String(pattern), options)) {
    res.push(picomatch$1.parse(str, options));
  }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
  return [pattern];
  }
  return braces_1(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

var micromatch_1 = micromatch;

// Helper since Typescript can't detect readonly arrays with Array.isArray
function isArray(arg) {
  return Array.isArray(arg);
}
function ensureArray(thing) {
  if (isArray(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}

function getMatcherString(id, resolutionBase) {
  if (resolutionBase === false) {
    return id;
  }
  // resolve('') is valid and will default to process.cwd()
  const basePath = resolve(resolutionBase || '')
    .split(sep)
    .join('/')
    // escape all possible (posix + win) path characters that might interfere with regex
    .replace(/[-^$*+?.()|[\]{}]/g, '\\$&');
  // Note that we use posix.join because:
  // 1. the basePath has been normalized to use /
  // 2. the incoming glob (id) matcher, also uses /
  // otherwise Node will force backslash (\) on windows
  return posix$1.join(basePath, id);
}
const createFilter = function createFilter(include, exclude, options) {
  const resolutionBase = options && options.resolve;
  const getMatcher = (id) => id instanceof RegExp
    ? id
    : {
      test: (what) => {
        // this refactor is a tad overly verbose but makes for easy debugging
        const pattern = getMatcherString(id, resolutionBase);
        const fn = micromatch_1.matcher(pattern, { dot: true });
        const result = fn(what);
        return result;
      }
    };
  const includeMatchers = ensureArray(include).map(getMatcher);
  const excludeMatchers = ensureArray(exclude).map(getMatcher);
  return function result(id) {
    if (typeof id !== 'string')
      return false;
    if (/\0/.test(id))
      return false;
    const pathId = id.split(sep).join('/');
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher = excludeMatchers[i];
      if (matcher.test(pathId))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher = includeMatchers[i];
      if (matcher.test(pathId))
        return true;
    }
    return !includeMatchers.length;
  };
};

const reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';
const builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
const forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));
forbiddenIdentifiers.add('');
const makeLegalIdentifier = function makeLegalIdentifier(str) {
  let identifier = str
    .replace(/-(\w)/g, (_, letter) => letter.toUpperCase())
    .replace(/[^$_a-zA-Z0-9]/g, '_');
  if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {
    identifier = `_${identifier}`;
  }
  return identifier || '_';
};

function stringify$2(obj) {
  return (JSON.stringify(obj) || 'undefined').replace(/[\u2028\u2029]/g, (char) => `\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);
}
function serializeArray(arr, indent, baseIndent) {
  let output = '[';
  const separator = indent ? `\n${baseIndent}${indent}` : '';
  for (let i = 0; i < arr.length; i++) {
    const key = arr[i];
    output += `${i > 0 ? ',' : ''}${separator}${serialize(key, indent, baseIndent + indent)}`;
  }
  return `${output}${indent ? `\n${baseIndent}` : ''}]`;
}
function serializeObject(obj, indent, baseIndent) {
  let output = '{';
  const separator = indent ? `\n${baseIndent}${indent}` : '';
  const entries = Object.entries(obj);
  for (let i = 0; i < entries.length; i++) {
    const [key, value] = entries[i];
    const stringKey = makeLegalIdentifier(key) === key ? key : stringify$2(key);
    output += `${i > 0 ? ',' : ''}${separator}${stringKey}:${indent ? ' ' : ''}${serialize(value, indent, baseIndent + indent)}`;
  }
  return `${output}${indent ? `\n${baseIndent}` : ''}}`;
}
function serialize(obj, indent, baseIndent) {
  if (obj === Infinity)
    return 'Infinity';
  if (obj === -Infinity)
    return '-Infinity';
  if (obj === 0 && 1 / obj === -Infinity)
    return '-0';
  if (obj instanceof Date)
    return `new Date(${obj.getTime()})`;
  if (obj instanceof RegExp)
    return obj.toString();
  if (obj !== obj)
    return 'NaN'; // eslint-disable-line no-self-compare
  if (Array.isArray(obj))
    return serializeArray(obj, indent, baseIndent);
  if (obj === null)
    return 'null';
  if (typeof obj === 'object')
    return serializeObject(obj, indent, baseIndent);
  return stringify$2(obj);
}
const dataToEsm = function dataToEsm(data, options = {}) {
  const t = options.compact ? '' : 'indent' in options ? options.indent : '\t';
  const _ = options.compact ? '' : ' ';
  const n = options.compact ? '' : '\n';
  const declarationType = options.preferConst ? 'const' : 'var';
  if (options.namedExports === false ||
    typeof data !== 'object' ||
    Array.isArray(data) ||
    data instanceof Date ||
    data instanceof RegExp ||
    data === null) {
    const code = serialize(data, options.compact ? null : t, '');
    const magic = _ || (/^[{[\-\/]/.test(code) ? '' : ' '); // eslint-disable-line no-useless-escape
    return `export default${magic}${code};`;
  }
  let namedExportCode = '';
  const defaultExportRows = [];
  for (const [key, value] of Object.entries(data)) {
    if (key === makeLegalIdentifier(key)) {
      if (options.objectShorthand)
        defaultExportRows.push(key);
      else
        defaultExportRows.push(`${key}:${_}${key}`);
      namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value, options.compact ? null : t, '')};${n}`;
    }
    else {
      defaultExportRows.push(`${stringify$2(key)}:${_}${serialize(value, options.compact ? null : t, '')}`);
    }
  }
  return `${namedExportCode}export default${_}{${n}${t}${defaultExportRows.join(`,${n}${t}`)}${n}};${n}`;
};

// TODO: remove this in next major
var index = {
  addExtension,
  attachScopes,
  createFilter,
  dataToEsm,
  extractAssignedNames,
  makeLegalIdentifier
};

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
function encode(decoded) {
  var sourceFileIndex = 0; // second field
  var sourceCodeLine = 0; // third field
  var sourceCodeColumn = 0; // fourth field
  var nameIndex = 0; // fifth field
  var mappings = '';
  for (var i = 0; i < decoded.length; i++) {
    var line = decoded[i];
    if (i > 0)
      mappings += ';';
    if (line.length === 0)
      continue;
    var generatedCodeColumn = 0; // first field
    var lineMappings = [];
    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
      var segment = line_1[_i];
      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
      generatedCodeColumn = segment[0];
      if (segment.length > 1) {
        segmentMappings +=
          encodeInteger(segment[1] - sourceFileIndex) +
            encodeInteger(segment[2] - sourceCodeLine) +
            encodeInteger(segment[3] - sourceCodeColumn);
        sourceFileIndex = segment[1];
        sourceCodeLine = segment[2];
        sourceCodeColumn = segment[3];
      }
      if (segment.length === 5) {
        segmentMappings += encodeInteger(segment[4] - nameIndex);
        nameIndex = segment[4];
      }
      lineMappings.push(segmentMappings);
    }
    mappings += lineMappings.join(',');
  }
  return mappings;
}
function encodeInteger(num) {
  var result = '';
  num = num < 0 ? (-num << 1) | 1 : num << 1;
  do {
    var clamped = num & 31;
    num >>>= 5;
    if (num > 0) {
      clamped |= 32;
    }
    result += chars[clamped];
  } while (num > 0);
  return result;
}

var BitSet = function BitSet(arg) {
	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
};

BitSet.prototype.add = function add (n) {
	this.bits[n >> 5] |= 1 << (n & 31);
};

BitSet.prototype.has = function has (n) {
	return !!(this.bits[n >> 5] & (1 << (n & 31)));
};

var Chunk = function Chunk(start, end, content) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties(this, {
		previous: { writable: true, value: null },
		next:   { writable: true, value: null }
	});
};

Chunk.prototype.appendLeft = function appendLeft (content) {
	this.outro += content;
};

Chunk.prototype.appendRight = function appendRight (content) {
	this.intro = this.intro + content;
};

Chunk.prototype.clone = function clone () {
	var chunk = new Chunk(this.start, this.end, this.original);

	chunk.intro = this.intro;
	chunk.outro = this.outro;
	chunk.content = this.content;
	chunk.storeName = this.storeName;
	chunk.edited = this.edited;

	return chunk;
};

Chunk.prototype.contains = function contains (index) {
	return this.start < index && index < this.end;
};

Chunk.prototype.eachNext = function eachNext (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.next;
	}
};

Chunk.prototype.eachPrevious = function eachPrevious (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.previous;
	}
};

Chunk.prototype.edit = function edit (content, storeName, contentOnly) {
	this.content = content;
	if (!contentOnly) {
		this.intro = '';
		this.outro = '';
	}
	this.storeName = storeName;

	this.edited = true;

	return this;
};

Chunk.prototype.prependLeft = function prependLeft (content) {
	this.outro = content + this.outro;
};

Chunk.prototype.prependRight = function prependRight (content) {
	this.intro = content + this.intro;
};

Chunk.prototype.split = function split (index) {
	var sliceIndex = index - this.start;

	var originalBefore = this.original.slice(0, sliceIndex);
	var originalAfter = this.original.slice(sliceIndex);

	this.original = originalBefore;

	var newChunk = new Chunk(index, this.end, originalAfter);
	newChunk.outro = this.outro;
	this.outro = '';

	this.end = index;

	if (this.edited) {
		// TODO is this block necessary?...
		newChunk.edit('', false);
		this.content = '';
	} else {
		this.content = originalBefore;
	}

	newChunk.next = this.next;
	if (newChunk.next) { newChunk.next.previous = newChunk; }
	newChunk.previous = this;
	this.next = newChunk;

	return newChunk;
};

Chunk.prototype.toString = function toString () {
	return this.intro + this.content + this.outro;
};

Chunk.prototype.trimEnd = function trimEnd (rx) {
	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.start + trimmed.length).edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }
	}
};

Chunk.prototype.trimStart = function trimStart (rx) {
	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.end - trimmed.length);
			this.edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }
	}
};

var btoa$1 = function () {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	btoa$1 = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
} else if (typeof Buffer === 'function') {
	btoa$1 = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
}

var SourceMap = function SourceMap(properties) {
	this.version = 3;
	this.file = properties.file;
	this.sources = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names = properties.names;
	this.mappings = encode(properties.mappings);
};

SourceMap.prototype.toString = function toString () {
	return JSON.stringify(this);
};

SourceMap.prototype.toUrl = function toUrl () {
	return 'data:application/json;charset=utf-8;base64,' + btoa$1(this.toString());
};

function guessIndent(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
	var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	var fromParts = from.split(/[/\\]/);
	var toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) { fromParts[i] = '..'; }
	}

	return fromParts.concat(toParts).join('/');
}

var toString = Object.prototype.toString;

function isObject$2(thing) {
	return toString.call(thing) === '[object Object]';
}

function getLocator(source) {
	var originalLines = source.split('\n');
	var lineOffsets = [];

	for (var i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		var i = 0;
		var j = lineOffsets.length;
		while (i < j) {
			var m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		var line = i - 1;
		var column = index - lineOffsets[line];
		return { line: line, column: column };
	};
}

var Mappings = function Mappings(hires) {
	this.hires = hires;
	this.generatedCodeLine = 0;
	this.generatedCodeColumn = 0;
	this.raw = [];
	this.rawSegments = this.raw[this.generatedCodeLine] = [];
	this.pending = null;
};

Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
	if (content.length) {
		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
		if (nameIndex >= 0) {
			segment.push(nameIndex);
		}
		this.rawSegments.push(segment);
	} else if (this.pending) {
		this.rawSegments.push(this.pending);
	}

	this.advance(content);
	this.pending = null;
};

Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
	var originalCharIndex = chunk.start;
	var first = true;

	while (originalCharIndex < chunk.end) {
		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
		}

		if (original[originalCharIndex] === '\n') {
			loc.line += 1;
			loc.column = 0;
			this.generatedCodeLine += 1;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
			this.generatedCodeColumn = 0;
			first = true;
		} else {
			loc.column += 1;
			this.generatedCodeColumn += 1;
			first = false;
		}

		originalCharIndex += 1;
	}

	this.pending = null;
};

Mappings.prototype.advance = function advance (str) {
	if (!str) { return; }

	var lines = str.split('\n');

	if (lines.length > 1) {
		for (var i = 0; i < lines.length - 1; i++) {
			this.generatedCodeLine++;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
		}
		this.generatedCodeColumn = 0;
	}

	this.generatedCodeColumn += lines[lines.length - 1].length;
};

var n = '\n';

var warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};

var MagicString = function MagicString(string, options) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk(0, string.length, string);

	Object.defineProperties(this, {
		original:        { writable: true, value: string },
		outro:         { writable: true, value: '' },
		intro:         { writable: true, value: '' },
		firstChunk:      { writable: true, value: chunk },
		lastChunk:       { writable: true, value: chunk },
		lastSearchedChunk:   { writable: true, value: chunk },
		byStart:         { writable: true, value: {} },
		byEnd:         { writable: true, value: {} },
		filename:        { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations:  { writable: true, value: new BitSet() },
		storedNames:       { writable: true, value: {} },
		indentStr:       { writable: true, value: guessIndent(string) }
	});

	this.byStart[0] = chunk;
	this.byEnd[string.length] = chunk;
};

MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
	this.sourcemapLocations.add(char);
};

MagicString.prototype.append = function append (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.outro += content;
	return this;
};

MagicString.prototype.appendLeft = function appendLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.appendLeft(content);
	} else {
		this.intro += content;
	}
	return this;
};

MagicString.prototype.appendRight = function appendRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.appendRight(content);
	} else {
		this.outro += content;
	}
	return this;
};

MagicString.prototype.clone = function clone () {
	var cloned = new MagicString(this.original, { filename: this.filename });

	var originalChunk = this.firstChunk;
	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

	while (originalChunk) {
		cloned.byStart[clonedChunk.start] = clonedChunk;
		cloned.byEnd[clonedChunk.end] = clonedChunk;

		var nextOriginalChunk = originalChunk.next;
		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

		if (nextClonedChunk) {
			clonedChunk.next = nextClonedChunk;
			nextClonedChunk.previous = clonedChunk;

			clonedChunk = nextClonedChunk;
		}

		originalChunk = nextOriginalChunk;
	}

	cloned.lastChunk = clonedChunk;

	if (this.indentExclusionRanges) {
		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
	}

	cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

	cloned.intro = this.intro;
	cloned.outro = this.outro;

	return cloned;
};

MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1 = this;

	options = options || {};

	var sourceIndex = 0;
	var names = Object.keys(this.storedNames);
	var mappings = new Mappings(options.hires);

	var locate = getLocator(this.original);

	if (this.intro) {
		mappings.advance(this.intro);
	}

	this.firstChunk.eachNext(function (chunk) {
		var loc = locate(chunk.start);

		if (chunk.intro.length) { mappings.advance(chunk.intro); }

		if (chunk.edited) {
			mappings.addEdit(
				sourceIndex,
				chunk.content,
				loc,
				chunk.storeName ? names.indexOf(chunk.original) : -1
			);
		} else {
			mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
		}

		if (chunk.outro.length) { mappings.advance(chunk.outro); }
	});

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
		sourcesContent: options.includeContent ? [this.original] : [null],
		names: names,
		mappings: mappings.raw
	};
};

MagicString.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
};

MagicString.prototype.getIndentString = function getIndentString () {
	return this.indentStr === null ? '\t' : this.indentStr;
};

MagicString.prototype.indent = function indent (indentStr, options) {
	var pattern = /^[^\r\n]/gm;

	if (isObject$2(indentStr)) {
		options = indentStr;
		indentStr = undefined;
	}

	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

	if (indentStr === '') { return this; } // noop

	options = options || {};

	// Process exclusion ranges
	var isExcluded = {};

	if (options.exclude) {
		var exclusions =
			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
		exclusions.forEach(function (exclusion) {
			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
				isExcluded[i] = true;
			}
		});
	}

	var shouldIndentNextCharacter = options.indentStart !== false;
	var replacer = function (match) {
		if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
		shouldIndentNextCharacter = true;
		return match;
	};

	this.intro = this.intro.replace(pattern, replacer);

	var charIndex = 0;
	var chunk = this.firstChunk;

	while (chunk) {
		var end = chunk.end;

		if (chunk.edited) {
			if (!isExcluded[charIndex]) {
				chunk.content = chunk.content.replace(pattern, replacer);

				if (chunk.content.length) {
					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
				}
			}
		} else {
			charIndex = chunk.start;

			while (charIndex < end) {
				if (!isExcluded[charIndex]) {
					var char = this.original[charIndex];

					if (char === '\n') {
						shouldIndentNextCharacter = true;
					} else if (char !== '\r' && shouldIndentNextCharacter) {
						shouldIndentNextCharacter = false;

						if (charIndex === chunk.start) {
							chunk.prependRight(indentStr);
						} else {
							this._splitChunk(chunk, charIndex);
							chunk = chunk.next;
							chunk.prependRight(indentStr);
						}
					}
				}

				charIndex += 1;
			}
		}

		charIndex = chunk.end;
		chunk = chunk.next;
	}

	this.outro = this.outro.replace(pattern, replacer);

	return this;
};

MagicString.prototype.insert = function insert () {
	throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
};

MagicString.prototype.insertLeft = function insertLeft (index, content) {
	if (!warned.insertLeft) {
		console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
		warned.insertLeft = true;
	}

	return this.appendLeft(index, content);
};

MagicString.prototype.insertRight = function insertRight (index, content) {
	if (!warned.insertRight) {
		console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
		warned.insertRight = true;
	}

	return this.prependRight(index, content);
};

MagicString.prototype.move = function move (start, end, index) {
	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }

	this._split(start);
	this._split(end);
	this._split(index);

	var first = this.byStart[start];
	var last = this.byEnd[end];

	var oldLeft = first.previous;
	var oldRight = last.next;

	var newRight = this.byStart[index];
	if (!newRight && last === this.lastChunk) { return this; }
	var newLeft = newRight ? newRight.previous : this.lastChunk;

	if (oldLeft) { oldLeft.next = oldRight; }
	if (oldRight) { oldRight.previous = oldLeft; }

	if (newLeft) { newLeft.next = first; }
	if (newRight) { newRight.previous = last; }

	if (!first.previous) { this.firstChunk = last.next; }
	if (!last.next) {
		this.lastChunk = first.previous;
		this.lastChunk.next = null;
	}

	first.previous = newLeft;
	last.next = newRight || null;

	if (!newLeft) { this.firstChunk = first; }
	if (!newRight) { this.lastChunk = last; }
	return this;
};

MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (end > this.original.length) { throw new Error('end is out of bounds'); }
	if (start === end)
		{ throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead'); }

	this._split(start);
	this._split(end);

	if (options === true) {
		if (!warned.storeName) {
			console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
			warned.storeName = true;
		}

		options = { storeName: true };
	}
	var storeName = options !== undefined ? options.storeName : false;
	var contentOnly = options !== undefined ? options.contentOnly : false;

	if (storeName) {
		var original = this.original.slice(start, end);
		this.storedNames[original] = true;
	}

	var first = this.byStart[start];
	var last = this.byEnd[end];

	if (first) {
		if (end > first.end && first.next !== this.byStart[first.end]) {
			throw new Error('Cannot overwrite across a split point');
		}

		first.edit(content, storeName, contentOnly);

		if (first !== last) {
			var chunk = first.next;
			while (chunk !== last) {
				chunk.edit('', false);
				chunk = chunk.next;
			}

			chunk.edit('', false);
		}
	} else {
		// must be inserting at the end
		var newChunk = new Chunk(start, end, '').edit(content, storeName);

		// TODO last chunk in the array may not be the last chunk, if it's moved...
		last.next = newChunk;
		newChunk.previous = last;
	}
	return this;
};

MagicString.prototype.prepend = function prepend (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.intro = content + this.intro;
	return this;
};

MagicString.prototype.prependLeft = function prependLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.prependLeft(content);
	} else {
		this.intro = content + this.intro;
	}
	return this;
};

MagicString.prototype.prependRight = function prependRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.prependRight(content);
	} else {
		this.outro = content + this.outro;
	}
	return this;
};

MagicString.prototype.remove = function remove (start, end) {
	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (start === end) { return this; }

	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
	if (start > end) { throw new Error('end must be greater than start'); }

	this._split(start);
	this._split(end);

	var chunk = this.byStart[start];

	while (chunk) {
		chunk.intro = '';
		chunk.outro = '';
		chunk.edit('');

		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
	}
	return this;
};

MagicString.prototype.lastChar = function lastChar () {
	if (this.outro.length)
		{ return this.outro[this.outro.length - 1]; }
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length)
			{ return chunk.outro[chunk.outro.length - 1]; }
		if (chunk.content.length)
			{ return chunk.content[chunk.content.length - 1]; }
		if (chunk.intro.length)
			{ return chunk.intro[chunk.intro.length - 1]; }
	} while (chunk = chunk.previous);
	if (this.intro.length)
		{ return this.intro[this.intro.length - 1]; }
	return '';
};

MagicString.prototype.lastLine = function lastLine () {
	var lineIndex = this.outro.lastIndexOf(n);
	if (lineIndex !== -1)
		{ return this.outro.substr(lineIndex + 1); }
	var lineStr = this.outro;
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length > 0) {
			lineIndex = chunk.outro.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.outro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.outro + lineStr;
		}

		if (chunk.content.length > 0) {
			lineIndex = chunk.content.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.content.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.content + lineStr;
		}

		if (chunk.intro.length > 0) {
			lineIndex = chunk.intro.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.intro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.intro + lineStr;
		}
	} while (chunk = chunk.previous);
	lineIndex = this.intro.lastIndexOf(n);
	if (lineIndex !== -1)
		{ return this.intro.substr(lineIndex + 1) + lineStr; }
	return this.intro + lineStr;
};

MagicString.prototype.slice = function slice (start, end) {
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	var result = '';

	// find start chunk
	var chunk = this.firstChunk;
	while (chunk && (chunk.start > start || chunk.end <= start)) {
		// found end chunk before start
		if (chunk.start < end && chunk.end >= end) {
			return result;
		}

		chunk = chunk.next;
	}

	if (chunk && chunk.edited && chunk.start !== start)
		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

	var startChunk = chunk;
	while (chunk) {
		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
			result += chunk.intro;
		}

		var containsEnd = chunk.start < end && chunk.end >= end;
		if (containsEnd && chunk.edited && chunk.end !== end)
			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

		result += chunk.content.slice(sliceStart, sliceEnd);

		if (chunk.outro && (!containsEnd || chunk.end === end)) {
			result += chunk.outro;
		}

		if (containsEnd) {
			break;
		}

		chunk = chunk.next;
	}

	return result;
};

// TODO deprecate this? not really very useful
MagicString.prototype.snip = function snip (start, end) {
	var clone = this.clone();
	clone.remove(0, start);
	clone.remove(end, clone.original.length);

	return clone;
};

MagicString.prototype._split = function _split (index) {
	if (this.byStart[index] || this.byEnd[index]) { return; }

	var chunk = this.lastSearchedChunk;
	var searchForward = index > chunk.end;

	while (chunk) {
		if (chunk.contains(index)) { return this._splitChunk(chunk, index); }

		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
	}
};

MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
	if (chunk.edited && chunk.content.length) {
		// zero-length edited chunks are a special case (overlapping replacements)
		var loc = getLocator(this.original)(index);
		throw new Error(
			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")")
		);
	}

	var newChunk = chunk.split(index);

	this.byEnd[index] = chunk;
	this.byStart[index] = newChunk;
	this.byEnd[newChunk.end] = newChunk;

	if (chunk === this.lastChunk) { this.lastChunk = newChunk; }

	this.lastSearchedChunk = chunk;
	return true;
};

MagicString.prototype.toString = function toString () {
	var str = this.intro;

	var chunk = this.firstChunk;
	while (chunk) {
		str += chunk.toString();
		chunk = chunk.next;
	}

	return str + this.outro;
};

MagicString.prototype.isEmpty = function isEmpty () {
	var chunk = this.firstChunk;
	do {
		if (chunk.intro.length && chunk.intro.trim() ||
				chunk.content.length && chunk.content.trim() ||
				chunk.outro.length && chunk.outro.trim())
			{ return false; }
	} while (chunk = chunk.next);
	return true;
};

MagicString.prototype.length = function length () {
	var chunk = this.firstChunk;
	var length = 0;
	do {
		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
	} while (chunk = chunk.next);
	return length;
};

MagicString.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
};

MagicString.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
};

MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var chunk = this.lastChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimEnd(rx);

		// if chunk was trimmed, we have a new lastChunk
		if (chunk.end !== end) {
			if (this.lastChunk === chunk) {
				this.lastChunk = chunk.next;
			}

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.previous;
	} while (chunk);

	return false;
};

MagicString.prototype.trimEnd = function trimEnd (charType) {
	this.trimEndAborted(charType);
	return this;
};
MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');

	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var chunk = this.firstChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimStart(rx);

		if (chunk.end !== end) {
			// special case...
			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.next;
	} while (chunk);

	return false;
};

MagicString.prototype.trimStart = function trimStart (charType) {
	this.trimStartAborted(charType);
	return this;
};

function isReference(node, parent) {
  if (node.type === 'MemberExpression') {
    return !node.computed && isReference(node.object, node);
  }
  if (node.type === 'Identifier') {
    if (!parent)
      return true;
    switch (parent.type) {
      // disregard `bar` in `foo.bar`
      case 'MemberExpression': return parent.computed || node === parent.object;
      // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
      case 'MethodDefinition': return parent.computed;
      // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
      case 'Property': return parent.computed || node === parent.value;
      // disregard the `bar` in `export { foo as bar }` or
      // the foo in `import { foo as bar }`
      case 'ExportSpecifier':
      case 'ImportSpecifier': return node === parent.local;
      // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
      case 'LabeledStatement':
      case 'BreakStatement':
      case 'ContinueStatement': return false;
      default: return true;
    }
  }
  return false;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
  return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
    _arr.push(_s.value);

    if (i && _arr.length === i) break;
  }
  } catch (err) {
  _d = true;
  _e = err;
  } finally {
  try {
    if (!_n && _i["return"] != null) _i["return"]();
  } finally {
    if (_d) throw _e;
  }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var peerDependencies = {
	rollup: "^1.20.0"
};

const PROXY_SUFFIX = '?commonjs-proxy';
const getProxyId = id => `\0${id}${PROXY_SUFFIX}`;
const getIdFromProxyId = proxyId => proxyId.slice(1, -PROXY_SUFFIX.length);
const EXTERNAL_SUFFIX = '?commonjs-external';
const getExternalProxyId = id => `\0${id}${EXTERNAL_SUFFIX}`;
const getIdFromExternalProxyId = proxyId => proxyId.slice(1, -EXTERNAL_SUFFIX.length);
const HELPERS_ID = '\0commonjsHelpers.js'; // `x['default']` is used instead of `x.default` for backward compatibility with ES3 browsers.
// Minifiers like uglify will usually transpile it back if compatibility with ES3 is not enabled.

const HELPERS = `
export var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

export function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

export function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

export function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

export function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}`;

/* eslint-disable no-undefined */
const isCjsPromises = new Map();
function getIsCjsPromise(id) {
  let isCjsPromise = isCjsPromises.get(id);
  if (isCjsPromise) return isCjsPromise.promise;
  const promise = new Promise(resolve => {
  isCjsPromise = {
    resolve,
    promise: undefined
  };
  isCjsPromises.set(id, isCjsPromise);
  });
  isCjsPromise.promise = promise;
  return promise;
}
function setIsCjsPromise(id, resolution) {
  const isCjsPromise = isCjsPromises.get(id);

  if (isCjsPromise) {
  if (isCjsPromise.resolve) {
    isCjsPromise.resolve(resolution);
    isCjsPromise.resolve = undefined;
  }
  } else {
  isCjsPromises.set(id, {
    promise: Promise.resolve(resolution),
    resolve: undefined
  });
  }
}

/* eslint-disable no-param-reassign, no-undefined */

function getCandidatesForExtension(resolved, extension) {
  return [resolved + extension, `${resolved}${sep}index${extension}`];
}

function getCandidates(resolved, extensions) {
  return extensions.reduce((paths, extension) => paths.concat(getCandidatesForExtension(resolved, extension)), [resolved]);
}

function getResolveId(extensions) {
  function resolveExtensions(importee, importer) {
  // not our problem
  if (importee[0] !== '.' || !importer) return undefined;
  const resolved = resolve(dirname(importer), importee);
  const candidates = getCandidates(resolved, extensions);

  for (let i = 0; i < candidates.length; i += 1) {
    try {
    const stats = statSync(candidates[i]);
    if (stats.isFile()) return {
      id: candidates[i]
    };
    } catch (err) {
    /* noop */
    }
  }

  return undefined;
  }

  function resolveId(importee, importer) {
  const isProxyModule = importee.endsWith(PROXY_SUFFIX);

  if (isProxyModule) {
    importee = getIdFromProxyId(importee);
  } else if (importee.startsWith('\0')) {
    if (importee === HELPERS_ID) {
    return importee;
    }

    return null;
  }

  if (importer && importer.endsWith(PROXY_SUFFIX)) {
    importer = getIdFromProxyId(importer);
  }

  return this.resolve(importee, importer, {
    skipSelf: true
  }).then(resolved => {
    if (!resolved) {
    resolved = resolveExtensions(importee, importer);
    }

    if (isProxyModule) {
    if (!resolved) {
      return {
      id: getExternalProxyId(importee),
      external: false
      };
    }

    resolved.id = (resolved.external ? getExternalProxyId : getProxyId)(resolved.id);
    resolved.external = false;
    return resolved;
    }

    return resolved;
  });
  }

  return resolveId;
}

/* eslint-disable no-undefined */
const operators = {
  '==': x => equals(x.left, x.right, false),
  '!=': x => not(operators['=='](x)),
  '===': x => equals(x.left, x.right, true),
  '!==': x => not(operators['==='](x)),
  '!': x => isFalsy(x.argument),
  '&&': x => isTruthy(x.left) && isTruthy(x.right),
  '||': x => isTruthy(x.left) || isTruthy(x.right)
};
function flatten(node) {
  const parts = [];

  while (node.type === 'MemberExpression') {
  if (node.computed) return null;
  parts.unshift(node.property.name); // eslint-disable-next-line no-param-reassign

  node = node.object;
  }

  if (node.type !== 'Identifier') return null;
  const _node = node,
    name = _node.name;
  parts.unshift(name);
  return {
  name,
  keypath: parts.join('.')
  };
}

function isTruthy(node) {
  if (node.type === 'Literal') return !!node.value;
  if (node.type === 'ParenthesizedExpression') return isTruthy(node.expression);
  if (node.operator in operators) return operators[node.operator](node);
  return undefined;
}
function isFalsy(node) {
  return not(isTruthy(node));
}

function not(value) {
  return value === undefined ? value : !value;
}

function equals(a, b, strict) {
  if (a.type !== b.type) return undefined; // eslint-disable-next-line eqeqeq

  if (a.type === 'Literal') return strict ? a.value === b.value : a.value == b.value;
  return undefined;
}

/* eslint-disable import/prefer-default-export */
function getName(id) {
  const name = makeLegalIdentifier(basename(id, extname(id)));

  if (name !== 'index') {
  return name;
  }

  const segments = dirname(id).split(sep);
  return makeLegalIdentifier(segments[segments.length - 1]);
}

const reserved = 'process location abstract arguments boolean break byte case catch char class const continue debugger default delete do double else enum eval export extends false final finally float for from function goto if implements import in instanceof int interface let long native new null package private protected public return short static super switch synchronized this throw throws transient true try typeof var void volatile while with yield'.split(' ');
const blacklist = {
  __esModule: true
};
reserved.forEach(word => blacklist[word] = true);
const exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;
const firstpassGlobal = /\b(?:require|module|exports|global)\b/;
const firstpassNoGlobal = /\b(?:require|module|exports)\b/;
const importExportDeclaration = /^(?:Import|Export(?:Named|Default))Declaration/;
const functionType = /^(?:FunctionDeclaration|FunctionExpression|ArrowFunctionExpression)$/;

function deconflict(scope, globals, identifier) {
  let i = 1;
  let deconflicted = identifier;

  while (scope.contains(deconflicted) || globals.has(deconflicted) || deconflicted in blacklist) {
  deconflicted = `${identifier}_${i}`;
  i += 1;
  }

  scope.declarations[deconflicted] = true;
  return deconflicted;
}

function tryParse(parse, code, id) {
  try {
  return parse(code, {
    allowReturnOutsideFunction: true
  });
  } catch (err) {
  err.message += ` in ${id}`;
  throw err;
  }
}

function hasCjsKeywords(code, ignoreGlobal) {
  const firstpass = ignoreGlobal ? firstpassNoGlobal : firstpassGlobal;
  return firstpass.test(code);
}
function checkEsModule(parse, code, id) {
  const ast = tryParse(parse, code, id);
  let isEsModule = false;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
  for (var _iterator = ast.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    const node = _step.value;
    if (node.type === 'ExportDefaultDeclaration') return {
    isEsModule: true,
    hasDefaultExport: true,
    ast
    };

    if (node.type === 'ExportNamedDeclaration') {
    isEsModule = true;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = node.specifiers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      const specifier = _step2.value;

      if (specifier.exported.name === 'default') {
        return {
        isEsModule: true,
        hasDefaultExport: true,
        ast
        };
      }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
      } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
      }
    }
    } else if (importExportDeclaration.test(node.type)) isEsModule = true;
  }
  } catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
  } finally {
  try {
    if (!_iteratorNormalCompletion && _iterator.return != null) {
    _iterator.return();
    }
  } finally {
    if (_didIteratorError) {
    throw _iteratorError;
    }
  }
  }

  return {
  isEsModule,
  hasDefaultExport: false,
  ast
  };
}
function transformCommonjs(parse, code, id, isEntry, ignoreGlobal, ignoreRequire, customNamedExports, sourceMap, allowDynamicRequire, astCache) {
  const ast = astCache || tryParse(parse, code, id);
  const magicString = new MagicString(code);
  const required = {}; // Because objects have no guaranteed ordering, yet we need it,
  // we need to keep track of the order in a array

  const sources = [];
  let uid = 0;
  let scope = attachScopes(ast, 'scope');
  const uses = {
  module: false,
  exports: false,
  global: false,
  require: false
  };
  let lexicalDepth = 0;
  let programDepth = 0;
  const globals = new Set(); // TODO technically wrong since globals isn't populated yet, but ¯\_(ツ)_/¯

  const HELPERS_NAME = deconflict(scope, globals, 'commonjsHelpers');
  const namedExports = {}; // TODO handle transpiled modules

  let shouldWrap = /__esModule/.test(code);

  function isRequireStatement(node) {
  if (!node) return false;
  if (node.type !== 'CallExpression') return false;
  if (node.callee.name !== 'require' || scope.contains('require')) return false; // Weird case of require() without arguments

  if (node.arguments.length === 0) return false;
  return true;
  }

  function hasDynamicArguments(node) {
  return node.arguments.length > 1 || node.arguments[0].type !== 'Literal' && (node.arguments[0].type !== 'TemplateLiteral' || node.arguments[0].expressions.length > 0);
  }

  function isStaticRequireStatement(node) {
  if (!isRequireStatement(node)) return false;
  if (hasDynamicArguments(node)) return false;
  if (ignoreRequire(node.arguments[0].value)) return false;
  return true;
  }

  function getRequireStringArg(node) {
  return node.arguments[0].type === 'Literal' ? node.arguments[0].value : node.arguments[0].quasis[0].value.cooked;
  }

  function getRequired(node, name) {
  const sourceId = getRequireStringArg(node);
  const existing = required[sourceId]; // eslint-disable-next-line no-undefined

  if (existing === undefined) {
    if (!name) {
    do {
      name = `require$$${uid}`;
      uid += 1;
    } while (scope.contains(name));
    }

    sources.push(sourceId);
    required[sourceId] = {
    source: sourceId,
    name,
    importsDefault: false
    };
  }

  return required[sourceId];
  } // do a first pass, see which names are assigned to. This is necessary to prevent
  // illegally replacing `var foo = require('foo')` with `import foo from 'foo'`,
  // where `foo` is later reassigned. (This happens in the wild. CommonJS, sigh)


  const assignedTo = new Set();
  walk(ast, {
  enter(node) {
    if (node.type !== 'AssignmentExpression') return;
    if (node.left.type === 'MemberExpression') return;
    extractAssignedNames(node.left).forEach(name => {
    assignedTo.add(name);
    });
  }

  });
  walk(ast, {
  enter(node, parent) {
    if (sourceMap) {
    magicString.addSourcemapLocation(node.start);
    magicString.addSourcemapLocation(node.end);
    } // skip dead branches


    if (parent && (parent.type === 'IfStatement' || parent.type === 'ConditionalExpression')) {
    if (node === parent.consequent && isFalsy(parent.test)) {
      this.skip();
      return;
    }

    if (node === parent.alternate && isTruthy(parent.test)) {
      this.skip();
      return;
    }
    }

    if (node._skip) {
    this.skip();
    return;
    }

    programDepth += 1;

    if (node.scope) {
    scope = node.scope;
    }

    if (functionType.test(node.type)) lexicalDepth += 1; // if toplevel return, we need to wrap it

    if (node.type === 'ReturnStatement' && lexicalDepth === 0) {
    shouldWrap = true;
    } // rewrite `this` as `commonjsHelpers.commonjsGlobal`


    if (node.type === 'ThisExpression' && lexicalDepth === 0) {
    uses.global = true;
    if (!ignoreGlobal) magicString.overwrite(node.start, node.end, `${HELPERS_NAME}.commonjsGlobal`, {
      storeName: true
    });
    return;
    } // rewrite `typeof module`, `typeof module.exports` and `typeof exports` (https://github.com/rollup/rollup-plugin-commonjs/issues/151)


    if (node.type === 'UnaryExpression' && node.operator === 'typeof') {
    const flattened = flatten(node.argument);
    if (!flattened) return;
    if (scope.contains(flattened.name)) return;

    if (flattened.keypath === 'module.exports' || flattened.keypath === 'module' || flattened.keypath === 'exports') {
      magicString.overwrite(node.start, node.end, `'object'`, {
      storeName: false
      });
    }
    } // rewrite `require` (if not already handled) `global` and `define`, and handle free references to
    // `module` and `exports` as these mean we need to wrap the module in commonjsHelpers.createCommonjsModule


    if (node.type === 'Identifier') {
    if (isReference(node, parent) && !scope.contains(node.name)) {
      if (node.name in uses) {
      if (node.name === 'require') {
        if (allowDynamicRequire) return;
        magicString.overwrite(node.start, node.end, `${HELPERS_NAME}.commonjsRequire`, {
        storeName: true
        });
      }

      uses[node.name] = true;

      if (node.name === 'global' && !ignoreGlobal) {
        magicString.overwrite(node.start, node.end, `${HELPERS_NAME}.commonjsGlobal`, {
        storeName: true
        });
      } // if module or exports are used outside the context of an assignment
      // expression, we need to wrap the module


      if (node.name === 'module' || node.name === 'exports') {
        shouldWrap = true;
      }
      }

      if (node.name === 'define') {
      magicString.overwrite(node.start, node.end, 'undefined', {
        storeName: true
      });
      }

      globals.add(node.name);
    }

    return;
    } // Is this an assignment to exports or module.exports?


    if (node.type === 'AssignmentExpression') {
    if (node.left.type !== 'MemberExpression') return;
    const flattened = flatten(node.left);
    if (!flattened) return;
    if (scope.contains(flattened.name)) return;
    const match = exportsPattern.exec(flattened.keypath);
    if (!match || flattened.keypath === 'exports') return;
    uses[flattened.name] = true; // we're dealing with `module.exports = ...` or `[module.]exports.foo = ...` –
    // if this isn't top-level, we'll need to wrap the module

    if (programDepth > 3) shouldWrap = true;
    node.left._skip = true;

    if (flattened.keypath === 'module.exports' && node.right.type === 'ObjectExpression') {
      node.right.properties.forEach(prop => {
      if (prop.computed || !('key' in prop) || prop.key.type !== 'Identifier') return;
      const name = prop.key.name;
      if (name === makeLegalIdentifier(name)) namedExports[name] = true;
      });
      return;
    }

    if (match[1]) namedExports[match[1]] = true;
    return;
    } // if this is `var x = require('x')`, we can do `import x from 'x'`


    if (node.type === 'VariableDeclarator' && node.id.type === 'Identifier' && isStaticRequireStatement(node.init)) {
    // for now, only do this for top-level requires. maybe fix this in future
    if (scope.parent) return; // edge case — CJS allows you to assign to imports. ES doesn't

    if (assignedTo.has(node.id.name)) return;
    const required = getRequired(node.init, node.id.name);
    required.importsDefault = true;

    if (required.name === node.id.name) {
      node._shouldRemove = true;
    }
    }

    if (!isStaticRequireStatement(node)) return;
    const required = getRequired(node);

    if (parent.type === 'ExpressionStatement') {
    // is a bare import, e.g. `require('foo');`
    magicString.remove(parent.start, parent.end);
    } else {
    required.importsDefault = true;
    magicString.overwrite(node.start, node.end, required.name);
    }

    node.callee._skip = true;
  },

  leave(node) {
    programDepth -= 1;
    if (node.scope) scope = scope.parent;
    if (functionType.test(node.type)) lexicalDepth -= 1;

    if (node.type === 'VariableDeclaration') {
    let keepDeclaration = false;
    let c = node.declarations[0].start;

    for (let i = 0; i < node.declarations.length; i += 1) {
      const declarator = node.declarations[i];

      if (declarator._shouldRemove) {
      magicString.remove(c, declarator.end);
      } else {
      if (!keepDeclaration) {
        magicString.remove(c, declarator.start);
        keepDeclaration = true;
      }

      c = declarator.end;
      }
    }

    if (!keepDeclaration) {
      magicString.remove(node.start, node.end);
    }
    }
  }

  });

  if (!sources.length && !uses.module && !uses.exports && !uses.require && (ignoreGlobal || !uses.global)) {
  if (Object.keys(namedExports).length) {
    throw new Error(`Custom named exports were specified for ${id} but it does not appear to be a CommonJS module`);
  } // not a CommonJS module


  return null;
  }

  const includeHelpers = shouldWrap || uses.global || uses.require;
  const importBlock = `${(includeHelpers ? [`import * as ${HELPERS_NAME} from '${HELPERS_ID}';`] : []).concat(sources.map(source => // import the actual module before the proxy, so that we know
  // what kind of proxy to build
  `import '${source}';`), sources.map(source => {
  const _required$source = required[source],
      name = _required$source.name,
      importsDefault = _required$source.importsDefault;
  return `import ${importsDefault ? `${name} from ` : ``}'${getProxyId(source)}';`;
  })).join('\n')}\n\n`;
  const namedExportDeclarations = [];
  let wrapperStart = '';
  let wrapperEnd = '';
  const moduleName = deconflict(scope, globals, getName(id));

  if (!isEntry) {
  const exportModuleExports = {
    str: `export { ${moduleName} as __moduleExports };`,
    name: '__moduleExports'
  };
  namedExportDeclarations.push(exportModuleExports);
  }

  const name = getName(id);

  function addExport(x) {
  const deconflicted = deconflict(scope, globals, name);
  const declaration = deconflicted === name ? `export var ${x} = ${moduleName}.${x};` : `var ${deconflicted} = ${moduleName}.${x};\nexport { ${deconflicted} as ${x} };`;
  namedExportDeclarations.push({
    str: declaration,
    name: x
  });
  }

  if (customNamedExports) customNamedExports.forEach(addExport);
  const defaultExportPropertyAssignments = [];
  let hasDefaultExport = false;

  if (shouldWrap) {
  const args = `module${uses.exports ? ', exports' : ''}`;
  wrapperStart = `var ${moduleName} = ${HELPERS_NAME}.createCommonjsModule(function (${args}) {\n`;
  wrapperEnd = `\n});`;
  } else {
  const names = [];
  ast.body.forEach(node => {
    if (node.type === 'ExpressionStatement' && node.expression.type === 'AssignmentExpression') {
    const left = node.expression.left;
    const flattened = flatten(left);
    if (!flattened) return;
    const match = exportsPattern.exec(flattened.keypath);
    if (!match) return;

    if (flattened.keypath === 'module.exports') {
      hasDefaultExport = true;
      magicString.overwrite(left.start, left.end, `var ${moduleName}`);
    } else {
      const _match = _slicedToArray(match, 2),
        name = _match[1];

      const deconflicted = deconflict(scope, globals, name);
      names.push({
      name,
      deconflicted
      });
      magicString.overwrite(node.start, left.end, `var ${deconflicted}`);
      const declaration = name === deconflicted ? `export { ${name} };` : `export { ${deconflicted} as ${name} };`;

      if (name !== 'default') {
      namedExportDeclarations.push({
        str: declaration,
        name
      });
      delete namedExports[name];
      }

      defaultExportPropertyAssignments.push(`${moduleName}.${name} = ${deconflicted};`);
    }
    }
  });

  if (!hasDefaultExport && (names.length || !isEntry)) {
    wrapperEnd = `\n\nvar ${moduleName} = {\n${names.map(({
    name,
    deconflicted
    }) => `\t${name}: ${deconflicted}`).join(',\n')}\n};`;
  }
  }

  Object.keys(namedExports).filter(key => !blacklist[key]).forEach(addExport);
  const defaultExport = /__esModule/.test(code) ? `export default ${HELPERS_NAME}.unwrapExports(${moduleName});` : `export default ${moduleName};`;
  const named = namedExportDeclarations.filter(x => x.name !== 'default' || !hasDefaultExport).map(x => x.str);
  const exportBlock = `\n\n${[defaultExport].concat(named).concat(hasDefaultExport ? defaultExportPropertyAssignments : []).join('\n')}`;
  magicString.trim().prepend(importBlock + wrapperStart).trim().append(wrapperEnd);

  if (hasDefaultExport || named.length > 0 || shouldWrap || !isEntry) {
  magicString.append(exportBlock);
  }

  code = magicString.toString();
  const map = sourceMap ? magicString.generateMap() : null;
  return {
  code,
  map
  };
}

function commonjs(options = {}) {
  const extensions = options.extensions || ['.js'];
  const filter = createFilter(options.include, options.exclude);
  const ignoreGlobal = options.ignoreGlobal;
  const customNamedExports = {};

  if (options.namedExports) {
  Object.keys(options.namedExports).forEach(id => {
    let resolveId = id;
    let resolvedId;

    if (resolve_2(id)) {
    // resolve will not find npm modules with the same name as
    // core modules without a trailing slash. Since core modules
    // must be external, we can assume any core modules defined
    // here are npm modules by that name.
    resolveId += '/';
    }

    try {
    resolvedId = resolve_3(resolveId, {
      basedir: process.cwd()
    });
    } catch (err) {
    resolvedId = resolve(id);
    } // Note: customNamedExport's keys must be normalized file paths.
    // resolve and nodeResolveSync both return normalized file paths
    // so no additional normalization is necessary.


    customNamedExports[resolvedId] = options.namedExports[id];

    if (existsSync(resolvedId)) {
    const realpath = realpathSync(resolvedId);

    if (realpath !== resolvedId) {
      customNamedExports[realpath] = options.namedExports[id];
    }
    }
  });
  }

  const esModulesWithoutDefaultExport = new Set();
  const esModulesWithDefaultExport = new Set(); // TODO maybe this should be configurable?

  const allowDynamicRequire = !!options.ignore;
  const ignoreRequire = typeof options.ignore === 'function' ? options.ignore : Array.isArray(options.ignore) ? id => options.ignore.includes(id) : () => false;
  const resolveId = getResolveId(extensions);
  const sourceMap = options.sourceMap !== false;

  function transformAndCheckExports(code, id) {
  const _checkEsModule = checkEsModule(this.parse, code, id),
      isEsModule = _checkEsModule.isEsModule,
      hasDefaultExport = _checkEsModule.hasDefaultExport,
      ast = _checkEsModule.ast;

  if (isEsModule) {
    (hasDefaultExport ? esModulesWithDefaultExport : esModulesWithoutDefaultExport).add(id);
    return null;
  } // it is not an ES module but it does not have CJS-specific elements.


  if (!hasCjsKeywords(code, ignoreGlobal)) {
    esModulesWithoutDefaultExport.add(id);
    return null;
  }

  const normalizedId = normalize(id);
  const transformed = transformCommonjs(this.parse, code, id, this.getModuleInfo(id).isEntry, ignoreGlobal, ignoreRequire, customNamedExports[normalizedId], sourceMap, allowDynamicRequire, ast);

  if (!transformed) {
    esModulesWithoutDefaultExport.add(id);
    return null;
  }

  return transformed;
  }

  return {
  name: 'commonjs',

  buildStart() {
    const _this$meta$rollupVers = this.meta.rollupVersion.split('.').map(Number),
      _this$meta$rollupVers2 = _slicedToArray(_this$meta$rollupVers, 2),
      major = _this$meta$rollupVers2[0],
      minor = _this$meta$rollupVers2[1];

    const minVersion = peerDependencies.rollup.slice(2);

    const _minVersion$split$map = minVersion.split('.').map(Number),
      _minVersion$split$map2 = _slicedToArray(_minVersion$split$map, 2),
      minMajor = _minVersion$split$map2[0],
      minMinor = _minVersion$split$map2[1];

    if (major < minMajor || major === minMajor && minor < minMinor) {
    this.error(`Insufficient Rollup version: "@rollup/plugin-commonjs" requires at least rollup@${minVersion} but found rollup@${this.meta.rollupVersion}.`);
    }
  },

  resolveId,

  load(id) {
    if (id === HELPERS_ID) return HELPERS; // generate proxy modules

    if (id.endsWith(EXTERNAL_SUFFIX)) {
    const actualId = getIdFromExternalProxyId(id);
    const name = getName(actualId);
    return `import ${name} from ${JSON.stringify(actualId)}; export default ${name};`;
    }

    if (id.endsWith(PROXY_SUFFIX)) {
    const actualId = getIdFromProxyId(id);
    const name = getName(actualId);
    return getIsCjsPromise(actualId).then(isCjs => {
      if (isCjs) return `import { __moduleExports } from ${JSON.stringify(actualId)}; export default __moduleExports;`;else if (esModulesWithoutDefaultExport.has(actualId)) return `import * as ${name} from ${JSON.stringify(actualId)}; export default ${name};`;else if (esModulesWithDefaultExport.has(actualId)) {
      return `export {default} from ${JSON.stringify(actualId)};`;
      }
      return `import * as ${name} from ${JSON.stringify(actualId)}; import {getCjsExportFromNamespace} from "${HELPERS_ID}"; export default getCjsExportFromNamespace(${name})`;
    });
    }

    return null;
  },

  transform(code, id) {
    if (!filter(id) || extensions.indexOf(extname(id)) === -1) {
    setIsCjsPromise(id, null);
    return null;
    }

    let transformed;

    try {
    transformed = transformAndCheckExports.call(this, code, id);
    } catch (err) {
    transformed = null;
    this.error(err, err.loc);
    }

    setIsCjsPromise(id, Boolean(transformed));
    return transformed;
  }

  };
}

function json(options) {
  if ( options === void 0 ) options = {};

  var filter = createFilter(options.include, options.exclude);
  var indent = 'indent' in options ? options.indent : '\t';

  return {
  name: 'json',

  // eslint-disable-next-line no-shadow
  transform: function transform(json, id) {
    if (id.slice(-5) !== '.json' || !filter(id)) { return null; }

    return {
    code: dataToEsm(JSON.parse(json), {
      preferConst: options.preferConst,
      compact: options.compact,
      namedExports: options.namedExports,
      indent: indent
    }),
    map: { mappings: '' }
    };
  }
  };
}

const {builtinModules} = Module;

const blacklist$1 = [
	'sys'
];

// eslint-disable-next-line node/no-deprecated-api
var builtinModules_1 = (builtinModules || Object.keys(process.binding('natives')))
	.filter(x => !/^_|^(internal|v8|node-inspect)\/|\//.test(x) && !blacklist$1.includes(x))
	.sort();

// no idea what these regular expressions do,
// but i extracted it from https://github.com/yahoo/js-module-formats/blob/master/index.js#L18
var ES6ImportExportRegExp = /(?:^\s*|[}{\(\);,\n]\s*)(import\s+['"]|(import|module)\s+[^"'\(\)\n;]+\s+from\s+['"]|export\s+(\*|\{|default|function|var|const|let|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*))/;

var ES6AliasRegExp = /(?:^\s*|[}{\(\);,\n]\s*)(export\s*\*\s*from\s*(?:'([^']+)'|"([^"]+)"))/;

var isModule = function (sauce) {
  return ES6ImportExportRegExp.test(sauce)
  || ES6AliasRegExp.test(sauce);
};

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
  var info = gen[key](arg);
  var value = info.value;
  } catch (error) {
  reject(error);
  return;
  }

  if (info.done) {
  resolve(value);
  } else {
  Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
  var self = this,
    args = arguments;
  return new Promise(function (resolve, reject) {
    var gen = fn.apply(self, args);

    function _next(value) {
    asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
    }

    function _throw(err) {
    asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
    }

    _next(undefined);
  });
  };
}

const exists$1 = promisify(fs.exists);
const readFile$1 = promisify(fs.readFile);
const realpath$1 = promisify(fs.realpath);
const stat$1 = promisify(fs.stat);

const onError = error => {
  if (error.code === 'ENOENT') {
  return false;
  }

  throw error;
};

const makeCache = fn => {
  const cache = new Map();

  const wrapped =
  /*#__PURE__*/
  function () {
  var _ref = _asyncToGenerator(function* (param, done) {
    if (cache.has(param) === false) {
    cache.set(param, fn(param).catch(err => {
      cache.delete(param);
      throw err;
    }));
    }

    try {
    const result = cache.get(param);
    const value = yield result;
    return done(null, value);
    } catch (error) {
    return done(error);
    }
  });

  return function wrapped(_x, _x2) {
    return _ref.apply(this, arguments);
  };
  }();

  wrapped.clear = () => cache.clear();

  return wrapped;
};

const isDirCached = makeCache(
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(function* (file) {
  try {
    const stats = yield stat$1(file);
    return stats.isDirectory();
  } catch (error) {
    return onError(error);
  }
  });

  return function (_x3) {
  return _ref2.apply(this, arguments);
  };
}());
const isFileCached = makeCache(
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(function* (file) {
  try {
    const stats = yield stat$1(file);
    return stats.isFile();
  } catch (error) {
    return onError(error);
  }
  });

  return function (_x4) {
  return _ref3.apply(this, arguments);
  };
}());
const readCachedFile = makeCache(readFile$1);

const resolveId = promisify(resolve$2); // returns the imported package name for bare module imports

function getPackageName(id) {
  if (id.startsWith('.') || id.startsWith('/')) {
  return null;
  }

  const split = id.split('/'); // @my-scope/my-package/foo.js -> @my-scope/my-package
  // @my-scope/my-package -> @my-scope/my-package

  if (split[0][0] === '@') {
  return `${split[0]}/${split[1]}`;
  } // my-package/foo.js -> my-package
  // my-package -> my-package


  return split[0];
}
function getMainFields(options) {
  let mainFields;

  if (options.mainFields) {
  mainFields = options.mainFields;
  } else {
  mainFields = ['module', 'main'];
  }

  if (options.browser && mainFields.indexOf('browser') === -1) {
  return ['browser'].concat(mainFields);
  }

  if (!mainFields.length) {
  throw new Error('Please ensure at least one `mainFields` value is specified');
  }

  return mainFields;
}
function getPackageInfo(options) {
  const cache = options.cache,
    extensions = options.extensions,
    pkg = options.pkg,
    mainFields = options.mainFields,
    preserveSymlinks = options.preserveSymlinks,
    useBrowserOverrides = options.useBrowserOverrides;
  let pkgPath = options.pkgPath;

  if (cache.has(pkgPath)) {
  return cache.get(pkgPath);
  } // browserify/resolve doesn't realpath paths returned in its packageFilter callback


  if (!preserveSymlinks) {
  pkgPath = realpathSync(pkgPath);
  }

  const pkgRoot = dirname(pkgPath);
  const packageInfo = {
  // copy as we are about to munge the `main` field of `pkg`.
  packageJson: Object.assign({}, pkg),
  // path to package.json file
  packageJsonPath: pkgPath,
  // directory containing the package.json
  root: pkgRoot,
  // which main field was used during resolution of this module (main, module, or browser)
  resolvedMainField: 'main',
  // whether the browser map was used to resolve the entry point to this module
  browserMappedMain: false,
  // the entry point of the module with respect to the selected main field and any
  // relevant browser mappings.
  resolvedEntryPoint: ''
  };
  let overriddenMain = false;

  for (let i = 0; i < mainFields.length; i++) {
  const field = mainFields[i];

  if (typeof pkg[field] === 'string') {
    pkg.main = pkg[field];
    packageInfo.resolvedMainField = field;
    overriddenMain = true;
    break;
  }
  }

  const internalPackageInfo = {
  cachedPkg: pkg,
  hasModuleSideEffects: () => null,
  hasPackageEntry: overriddenMain !== false || mainFields.indexOf('main') !== -1,
  packageBrowserField: useBrowserOverrides && typeof pkg.browser === 'object' && Object.keys(pkg.browser).reduce((browser, key) => {
    let resolved = pkg.browser[key];

    if (resolved && resolved[0] === '.') {
    resolved = resolve(pkgRoot, resolved);
    }
    /* eslint-disable no-param-reassign */


    browser[key] = resolved;

    if (key[0] === '.') {
    const absoluteKey = resolve(pkgRoot, key);
    browser[absoluteKey] = resolved;

    if (!extname(key)) {
      extensions.reduce((subBrowser, ext) => {
      subBrowser[absoluteKey + ext] = subBrowser[key];
      return subBrowser;
      }, browser);
    }
    }

    return browser;
  }, {}),
  packageInfo
  };
  const browserMap = internalPackageInfo.packageBrowserField;

  if (useBrowserOverrides && typeof pkg.browser === 'object' && // eslint-disable-next-line no-prototype-builtins
  browserMap.hasOwnProperty(pkg.main)) {
  packageInfo.resolvedEntryPoint = browserMap[pkg.main];
  packageInfo.browserMappedMain = true;
  } else {
  // index.node is technically a valid default entrypoint as well...
  packageInfo.resolvedEntryPoint = resolve(pkgRoot, pkg.main || 'index.js');
  packageInfo.browserMappedMain = false;
  }

  const packageSideEffects = pkg.sideEffects;

  if (typeof packageSideEffects === 'boolean') {
  internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;
  } else if (Array.isArray(packageSideEffects)) {
  internalPackageInfo.hasModuleSideEffects = createFilter(packageSideEffects, null, {
    resolve: pkgRoot
  });
  }

  cache.set(pkgPath, internalPackageInfo);
  return internalPackageInfo;
}
function normalizeInput(input) {
  if (Array.isArray(input)) {
  return input;
  } else if (typeof input === 'object') {
  return Object.values(input);
  } // otherwise it's a string


  return input;
} // Resolve module specifiers in order. Promise resolves to the first module that resolves
// successfully, or the error that resulted from the last attempted module resolution.

function resolveImportSpecifiers(importSpecifierList, resolveOptions) {
  let promise = Promise.resolve();

  for (let i = 0; i < importSpecifierList.length; i++) {
  promise = promise.then(value => {
    // if we've already resolved to something, just return it.
    if (value) {
    return value;
    }

    return resolveId(importSpecifierList[i], resolveOptions);
  });

  if (i < importSpecifierList.length - 1) {
    // swallow MODULE_NOT_FOUND errors from all but the last resolution
    promise = promise.catch(error => {
    if (error.code !== 'MODULE_NOT_FOUND') {
      throw error;
    }
    });
  }
  }

  return promise;
}

const builtins$1 = new Set(builtinModules_1);
const ES6_BROWSER_EMPTY = '\0node-resolve:empty.js';

const nullFn = () => null;

const defaults = {
  customResolveOptions: {},
  dedupe: [],
  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules
  // which deploy both ESM .mjs and CommonJS .js files as ESM.
  extensions: ['.mjs', '.js', '.json', '.node'],
  resolveOnly: []
};
function nodeResolve(opts = {}) {
  const options = Object.assign({}, defaults, opts);
  const customResolveOptions = options.customResolveOptions,
    extensions = options.extensions,
    jail = options.jail;
  const warnings = [];
  const packageInfoCache = new Map();
  const idToPackageInfo = new Map();
  const mainFields = getMainFields(options);
  const useBrowserOverrides = mainFields.indexOf('browser') !== -1;
  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;
  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;
  const rootDir = options.rootDir || process.cwd();
  let dedupe = options.dedupe;
  let rollupOptions;

  if (options.only) {
  warnings.push('node-resolve: The `only` options is deprecated, please use `resolveOnly`');
  options.resolveOnly = options.only;
  }

  if (typeof dedupe !== 'function') {
  dedupe = importee => options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));
  }

  const resolveOnly = options.resolveOnly.map(pattern => {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  const normalized = pattern.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
  return new RegExp(`^${normalized}$`);
  });
  const browserMapCache = new Map();
  let preserveSymlinks;
  return {
  name: 'node-resolve',

  buildStart(options) {
    rollupOptions = options;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
    for (var _iterator = warnings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      const warning = _step.value;
      this.warn(warning);
    }
    } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
    } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
      _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
      throw _iteratorError;
      }
    }
    }

    preserveSymlinks = options.preserveSymlinks;
  },

  generateBundle() {
    readCachedFile.clear();
    isFileCached.clear();
    isDirCached.clear();
  },

  resolveId(importee, importer) {
    var _this = this;

    return _asyncToGenerator(function* () {
    if (importee === ES6_BROWSER_EMPTY) {
      return importee;
    } // ignore IDs with null character, these belong to other plugins


    if (/\0/.test(importee)) return null;
    const basedir = !importer || dedupe(importee) ? rootDir : dirname(importer); // https://github.com/defunctzombie/package-browser-field-spec

    const browser = browserMapCache.get(importer);

    if (useBrowserOverrides && browser) {
      const resolvedImportee = resolve(basedir, importee);

      if (browser[importee] === false || browser[resolvedImportee] === false) {
      return ES6_BROWSER_EMPTY;
      }

      const browserImportee = browser[importee] || browser[resolvedImportee] || browser[`${resolvedImportee}.js`] || browser[`${resolvedImportee}.json`];

      if (browserImportee) {
      importee = browserImportee;
      }
    }

    const parts = importee.split(/[/\\]/);
    let id = parts.shift();

    if (id[0] === '@' && parts.length > 0) {
      // scoped packages
      id += `/${parts.shift()}`;
    } else if (id[0] === '.') {
      // an import relative to the parent dir of the importer
      id = resolve(basedir, importee);
    }

    const input = normalizeInput(rollupOptions.input);

    if (resolveOnly.length && !resolveOnly.some(pattern => pattern.test(id))) {
      if (input.includes(id)) {
      return null;
      }

      return false;
    }

    let hasModuleSideEffects = nullFn;
    let hasPackageEntry = true;
    let packageBrowserField = false;
    let packageInfo;

    const filter = (pkg, pkgPath) => {
      const info = getPackageInfo({
      cache: packageInfoCache,
      extensions,
      pkg,
      pkgPath,
      mainFields,
      preserveSymlinks,
      useBrowserOverrides
      });
      packageInfo = info.packageInfo;
      hasModuleSideEffects = info.hasModuleSideEffects;
      hasPackageEntry = info.hasPackageEntry;
      packageBrowserField = info.packageBrowserField;
      return info.cachedPkg;
    };

    let resolveOptions = {
      basedir,
      packageFilter: filter,
      readFile: readCachedFile,
      isFile: isFileCached,
      isDirectory: isDirCached,
      extensions
    };

    if (preserveSymlinks !== undefined) {
      resolveOptions.preserveSymlinks = preserveSymlinks;
    }

    const importSpecifierList = [];

    if (importer === undefined && !importee[0].match(/^\.?\.?\//)) {
      // For module graph roots (i.e. when importer is undefined), we
      // need to handle 'path fragments` like `foo/bar` that are commonly
      // found in rollup config files. If importee doesn't look like a
      // relative or absolute path, we make it relative and attempt to
      // resolve it. If we don't find anything, we try resolving it as we
      // got it.
      importSpecifierList.push(`./${importee}`);
    }

    const importeeIsBuiltin = builtins$1.has(importee);

    if (importeeIsBuiltin && (!preferBuiltins || !isPreferBuiltinsSet)) {
      // The `resolve` library will not resolve packages with the same
      // name as a node built-in module. If we're resolving something
      // that's a builtin, and we don't prefer to find built-ins, we
      // first try to look up a local module with that name. If we don't
      // find anything, we resolve the builtin which just returns back
      // the built-in's name.
      importSpecifierList.push(`${importee}/`);
    }

    importSpecifierList.push(importee);
    resolveOptions = Object.assign(resolveOptions, customResolveOptions);

    try {
      let resolved = yield resolveImportSpecifiers(importSpecifierList, resolveOptions);

      if (resolved && packageBrowserField) {
      if (Object.prototype.hasOwnProperty.call(packageBrowserField, resolved)) {
        if (!packageBrowserField[resolved]) {
        browserMapCache.set(resolved, packageBrowserField);
        return ES6_BROWSER_EMPTY;
        }

        resolved = packageBrowserField[resolved];
      }

      browserMapCache.set(resolved, packageBrowserField);
      }

      if (hasPackageEntry && !preserveSymlinks && resolved) {
      const fileExists = yield exists$1(resolved);

      if (fileExists) {
        resolved = yield realpath$1(resolved);
      }
      }

      idToPackageInfo.set(resolved, packageInfo);

      if (hasPackageEntry) {
      if (builtins$1.has(resolved) && preferBuiltins && isPreferBuiltinsSet) {
        return null;
      } else if (importeeIsBuiltin && preferBuiltins) {
        if (!isPreferBuiltinsSet) {
        _this.warn(`preferring built-in module '${importee}' over local alternative at '${resolved}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`);
        }

        return null;
      } else if (jail && resolved.indexOf(normalize(jail.trim(sep))) !== 0) {
        return null;
      }
      }

      if (resolved && options.modulesOnly) {
      const code = yield readFile$1(resolved, 'utf-8');

      if (isModule(code)) {
        return {
        id: resolved,
        moduleSideEffects: hasModuleSideEffects(resolved)
        };
      }

      return null;
      }

      const result = {
      id: resolved,
      moduleSideEffects: hasModuleSideEffects(resolved)
      };
      return result;
    } catch (error) {
      return null;
    }
    })();
  },

  load(importee) {
    if (importee === ES6_BROWSER_EMPTY) {
    return 'export default {};';
    }

    return null;
  },

  getPackageInfoForId(id) {
    return idToPackageInfo.get(id);
  }

  };
}

function escape(str) {
  return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
}

function ensureFunction(functionOrValue) {
  if (typeof functionOrValue === 'function') { return functionOrValue; }
  return function () { return functionOrValue; };
}

function longest(a, b) {
  return b.length - a.length;
}

function getReplacements(options) {
  if (options.values) {
  return Object.assign({}, options.values);
  }
  var values = Object.assign({}, options);
  delete values.delimiters;
  delete values.include;
  delete values.exclude;
  delete values.sourcemap;
  delete values.sourceMap;
  return values;
}

function mapToFunctions(object) {
  return Object.keys(object).reduce(function (fns, key) {
  var functions = Object.assign({}, fns);
  functions[key] = ensureFunction(object[key]);
  return functions;
  }, {});
}

function replace$1(options) {
  if ( options === void 0 ) options = {};

  var filter = createFilter(options.include, options.exclude);
  var delimiters = options.delimiters;
  var functionValues = mapToFunctions(getReplacements(options));
  var keys = Object.keys(functionValues)
  .sort(longest)
  .map(escape);
  var pattern = delimiters
  ? new RegExp(((escape(delimiters[0])) + "(" + (keys.join('|')) + ")" + (escape(delimiters[1]))), 'g')
  : new RegExp(("\\b(" + (keys.join('|')) + ")\\b"), 'g');

  return {
  name: 'replace',

  renderChunk: function renderChunk(code, chunk) {
    var id = chunk.fileName;
    if (!keys.length) { return null; }
    if (!filter(id)) { return null; }
    return executeReplacement(code, id);
  },

  transform: function transform(code, id) {
    if (!keys.length) { return null; }
    if (!filter(id)) { return null; }
    return executeReplacement(code, id);
  }
  };

  function executeReplacement(code, id) {
  var magicString = new MagicString(code);
  if (!codeHasReplacements(code, id, magicString)) {
    return null;
  }

  var result = { code: magicString.toString() };
  if (isSourceMapEnabled()) {
    result.map = magicString.generateMap({ hires: true });
  }
  return result;
  }

  function codeHasReplacements(code, id, magicString) {
  var result = false;
  var match;

  // eslint-disable-next-line no-cond-assign
  while ((match = pattern.exec(code))) {
    result = true;

    var start = match.index;
    var end = start + match[0].length;
    var replacement = String(functionValues[match[1]](id));
    magicString.overwrite(start, end, replacement);
  }
  return result;
  }

  function isSourceMapEnabled() {
  return options.sourceMap !== false && options.sourcemap !== false;
  }
}

// MODULE: compiler/style/scope-css.js
const getScopeId = (tagName, mode) => {
  return 'sc-' + tagName + (mode && mode !== DEFAULT_STYLE_MODE ? '-' + mode : '');
};

// MODULE: compiler/optimize/autoprefixer.js
let cssProcessor;
const autoprefixCss = async (cssText, opts) => {
  const output = {
    output: cssText,
    diagnostics: [],
  };
  if (!IS_NODE_ENV) {
    return output;
  }
  try {
    const autoprefixerOpts = opts != null && typeof opts === 'object' ? opts : DEFAULT_AUTOPREFIX_LEGACY;
    const processor = getProcessor(autoprefixerOpts);
    const result = await processor.process(cssText, { map: null });
    result.warnings().forEach((warning) => {
      output.diagnostics.push({
        header: `Autoprefix CSS: ${warning.plugin}`,
        messageText: warning.text,
        level: 'warn',
        type: 'css',
      });
    });
    output.output = result.css;
  }
  catch (e) {
    const diagnostic = {
      header: `Autoprefix CSS`,
      messageText: `CSS Error` + e,
      level: `error`,
      type: `css`,
    };
    if (typeof e.name === 'string') {
      diagnostic.header = e.name;
    }
    if (typeof e.reason === 'string') {
      diagnostic.messageText = e.reason;
    }
    if (typeof e.source === 'string' && typeof e.line === 'number') {
      const lines = e.source.replace(/\r/g, '\n').split('\n');
      if (lines.length > 0) {
        const addLine = (lineNumber) => {
          const line = lines[lineNumber];
          if (typeof line === 'string') {
            const printLine = {
              lineIndex: -1,
              lineNumber: -1,
              text: line,
              errorCharStart: -1,
              errorLength: -1,
            };
            diagnostic.lines = diagnostic.lines || [];
            diagnostic.lines.push(printLine);
          }
        };
        addLine(e.line - 3);
        addLine(e.line - 2);
        addLine(e.line - 1);
        addLine(e.line);
        addLine(e.line + 1);
        addLine(e.line + 2);
        addLine(e.line + 3);
      }
    }
    output.diagnostics.push(diagnostic);
  }
  return output;
};
const getProcessor = (autoprefixerOpts) => {
  const { postcss, autoprefixer } = requireFunc('../sys/node/autoprefixer.js');
  if (!cssProcessor) {
    cssProcessor = postcss([autoprefixer(autoprefixerOpts)]);
  }
  return cssProcessor;
};
const DEFAULT_AUTOPREFIX_LEGACY = {
  overrideBrowserslist: ['last 2 versions', 'iOS >= 9', 'Android >= 4.4', 'Explorer >= 11', 'ExplorerMobile >= 11'],
  cascade: false,
  remove: false,
  flexbox: 'no-2009',
};

// MODULE: compiler/style/css-parser/parse-css.js
const parseCss = (css, filePath) => {
  let lineno = 1;
  let column = 1;
  const diagnostics = [];
  const updatePosition = (str) => {
    const lines = str.match(/\n/g);
    if (lines)
      lineno += lines.length;
    const i = str.lastIndexOf('\n');
    column = ~i ? str.length - i : column + str.length;
  };
  const position = () => {
    const start = { line: lineno, column: column };
    return (node) => {
      node.position = new ParsePosition(start);
      whitespace();
      return node;
    };
  };
  const error = (msg) => {
    const srcLines = css.split('\n');
    const d = {
      level: 'error',
      type: 'css',
      language: 'css',
      header: 'CSS Parse',
      messageText: msg,
      absFilePath: filePath,
      lines: [
        {
          lineIndex: lineno - 1,
          lineNumber: lineno,
          errorCharStart: column,
          text: css[lineno - 1],
        },
      ],
    };
    if (lineno > 1) {
      const previousLine = {
        lineIndex: lineno - 1,
        lineNumber: lineno - 1,
        text: css[lineno - 2],
        errorCharStart: -1,
        errorLength: -1,
      };
      d.lines.unshift(previousLine);
    }
    if (lineno + 2 < srcLines.length) {
      const nextLine = {
        lineIndex: lineno,
        lineNumber: lineno + 1,
        text: srcLines[lineno],
        errorCharStart: -1,
        errorLength: -1,
      };
      d.lines.push(nextLine);
    }
    diagnostics.push(d);
    return null;
  };
  const stylesheet = () => {
    const rulesList = rules();
    return {
      type: 'stylesheet',
      stylesheet: {
        source: filePath,
        rules: rulesList,
      },
    };
  };
  const open = () => match(/^{\s*/);
  const close = () => match(/^}/);
  const match = (re) => {
    const m = re.exec(css);
    if (!m)
      return;
    const str = m[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m;
  };
  const rules = () => {
    let node;
    const rules = [];
    whitespace();
    comments(rules);
    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
      if (node !== false) {
        rules.push(node);
        comments(rules);
      }
    }
    return rules;
  };
  /**
   * Parse whitespace.
   */
  const whitespace = () => match(/^\s*/);
  const comments = (rules) => {
    let c;
    rules = rules || [];
    while ((c = comment())) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  };
  const comment = () => {
    const pos = position();
    if ('/' !== css.charAt(0) || '*' !== css.charAt(1))
      return null;
    let i = 2;
    while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1)))
      ++i;
    i += 2;
    if ('' === css.charAt(i - 1)) {
      return error('End of comment missing');
    }
    const comment = css.slice(2, i - 2);
    column += 2;
    updatePosition(comment);
    css = css.slice(i);
    column += 2;
    return pos({
      type: 'comment',
      comment,
    });
  };
  const selector = () => {
    const m = match(/^([^{]+)/);
    if (!m)
      return null;
    return trim(m[0])
      .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
      .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (m) {
      return m.replace(/,/g, '\u200C');
    })
      .split(/\s*(?![^(]*\)),\s*/)
      .map(function (s) {
      return s.replace(/\u200C/g, ',');
    });
  };
  const declaration = () => {
    const pos = position();
    // prop
    let prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!prop)
      return null;
    prop = trim(prop[0]);
    // :
    if (!match(/^:\s*/))
      return error(`property missing ':'`);
    // val
    const val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
    const ret = pos({
      type: 'declaration',
      property: prop.replace(commentre, ''),
      value: val ? trim(val[0]).replace(commentre, '') : '',
    });
    match(/^[;\s]*/);
    return ret;
  };
  const declarations = () => {
    const decls = [];
    if (!open())
      return error(`missing '{'`);
    comments(decls);
    // declarations
    let decl;
    while ((decl = declaration())) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }
    if (!close())
      return error(`missing '}'`);
    return decls;
  };
  const keyframe = () => {
    let m;
    const values = [];
    const pos = position();
    while ((m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/))) {
      values.push(m[1]);
      match(/^,\s*/);
    }
    if (!values.length)
      return null;
    return pos({
      type: 'keyframe',
      values,
      declarations: declarations(),
    });
  };
  const atkeyframes = () => {
    const pos = position();
    let m = match(/^@([-\w]+)?keyframes\s*/);
    if (!m)
      return null;
    const vendor = m[1];
    // identifier
    m = match(/^([-\w]+)\s*/);
    if (!m)
      return error(`@keyframes missing name`);
    const name = m[1];
    if (!open())
      return error(`@keyframes missing '{'`);
    let frame;
    let frames = comments();
    while ((frame = keyframe())) {
      frames.push(frame);
      frames = frames.concat(comments());
    }
    if (!close())
      return error(`@keyframes missing '}'`);
    return pos({
      type: 'keyframes',
      name: name,
      vendor: vendor,
      keyframes: frames,
    });
  };
  const atsupports = () => {
    const pos = position();
    const m = match(/^@supports *([^{]+)/);
    if (!m)
      return null;
    const supports = trim(m[1]);
    if (!open())
      return error(`@supports missing '{'`);
    const style = comments().concat(rules());
    if (!close())
      return error(`@supports missing '}'`);
    return pos({
      type: 'supports',
      supports: supports,
      rules: style,
    });
  };
  const athost = () => {
    const pos = position();
    const m = match(/^@host\s*/);
    if (!m)
      return null;
    if (!open())
      return error(`@host missing '{'`);
    const style = comments().concat(rules());
    if (!close())
      return error(`@host missing '}'`);
    return pos({
      type: 'host',
      rules: style,
    });
  };
  const atmedia = () => {
    const pos = position();
    const m = match(/^@media *([^{]+)/);
    if (!m)
      return null;
    const media = trim(m[1]);
    if (!open())
      return error(`@media missing '{'`);
    const style = comments().concat(rules());
    if (!close())
      return error(`@media missing '}'`);
    return pos({
      type: 'media',
      media: media,
      rules: style,
    });
  };
  const atcustommedia = () => {
    const pos = position();
    const m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
    if (!m)
      return null;
    return pos({
      type: 'custom-media',
      name: trim(m[1]),
      media: trim(m[2]),
    });
  };
  const atpage = () => {
    const pos = position();
    const m = match(/^@page */);
    if (!m)
      return null;
    const sel = selector() || [];
    if (!open())
      return error(`@page missing '{'`);
    let decls = comments();
    let decl;
    while ((decl = declaration())) {
      decls.push(decl);
      decls = decls.concat(comments());
    }
    if (!close())
      return error(`@page missing '}'`);
    return pos({
      type: 'page',
      selectors: sel,
      declarations: decls,
    });
  };
  const atdocument = () => {
    const pos = position();
    const m = match(/^@([-\w]+)?document *([^{]+)/);
    if (!m)
      return null;
    const vendor = trim(m[1]);
    const doc = trim(m[2]);
    if (!open())
      return error(`@document missing '{'`);
    const style = comments().concat(rules());
    if (!close())
      return error(`@document missing '}'`);
    return pos({
      type: 'document',
      document: doc,
      vendor: vendor,
      rules: style,
    });
  };
  const atfontface = () => {
    const pos = position();
    const m = match(/^@font-face\s*/);
    if (!m)
      return null;
    if (!open())
      return error(`@font-face missing '{'`);
    let decls = comments();
    let decl;
    while ((decl = declaration())) {
      decls.push(decl);
      decls = decls.concat(comments());
    }
    if (!close())
      return error(`@font-face missing '}'`);
    return pos({
      type: 'font-face',
      declarations: decls,
    });
  };
  const _compileAtrule = (name) => {
    const re = new RegExp('^@' + name + '\\s*([^;]+);');
    return () => {
      const pos = position();
      const m = match(re);
      if (!m)
        return null;
      const ret = { type: name };
      ret[name] = m[1].trim();
      return pos(ret);
    };
  };
  const atimport = _compileAtrule('import');
  const atcharset = _compileAtrule('charset');
  const atnamespace = _compileAtrule('namespace');
  const atrule = () => {
    if (css[0] !== '@')
      return null;
    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
  };
  const rule = () => {
    const pos = position();
    const sel = selector();
    if (!sel)
      return error('selector missing');
    comments();
    return pos({
      type: 'rule',
      selectors: sel,
      declarations: declarations(),
    });
  };
  class ParsePosition {
    constructor(start) {
      this.start = start;
      this.end = { line: lineno, column: column };
      this.source = filePath;
    }
  }
  ParsePosition.prototype.content = css;
  return Object.assign({ diagnostics }, addParent(stylesheet()));
};
const trim = (str) => (str ? str.trim() : '');
/**
 * Adds non-enumerable parent node reference to each node.
 */
const addParent = (obj, parent) => {
  const isNode = obj && typeof obj.type === 'string';
  const childParent = isNode ? obj : parent;
  for (const k in obj) {
    const value = obj[k];
    if (Array.isArray(value)) {
      value.forEach(function (v) {
        addParent(v, childParent);
      });
    }
    else if (value && typeof value === 'object') {
      addParent(value, childParent);
    }
  }
  if (isNode) {
    Object.defineProperty(obj, 'parent', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null,
    });
  }
  return obj;
};
// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
const commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

// MODULE: compiler/style/css-parser/get-css-selectors.js
const getCssSelectors = (sel) => {
  // reusing global SELECTORS since this is a synchronous operation
  SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
  sel = sel
    .replace(/\./g, ' .')
    .replace(/\#/g, ' #')
    .replace(/\[/g, ' [')
    .replace(/\>/g, ' > ')
    .replace(/\+/g, ' + ')
    .replace(/\~/g, ' ~ ')
    .replace(/\*/g, ' * ')
    .replace(/\:not\((.*?)\)/g, ' ');
  const items = sel.split(' ');
  for (let i = 0, l = items.length; i < l; i++) {
    items[i] = items[i].split(':')[0];
    if (items[i].length === 0)
      continue;
    if (items[i].charAt(0) === '.') {
      SELECTORS.classNames.push(items[i].substr(1));
    }
    else if (items[i].charAt(0) === '#') {
      SELECTORS.ids.push(items[i].substr(1));
    }
    else if (items[i].charAt(0) === '[') {
      items[i] = items[i]
        .substr(1)
        .split('=')[0]
        .split(']')[0]
        .trim();
      SELECTORS.attrs.push(items[i].toLowerCase());
    }
    else if (/[a-z]/g.test(items[i].charAt(0))) {
      SELECTORS.tags.push(items[i].toLowerCase());
    }
  }
  SELECTORS.classNames = SELECTORS.classNames.sort((a, b) => {
    if (a.length < b.length)
      return -1;
    if (a.length > b.length)
      return 1;
    return 0;
  });
  return SELECTORS;
};
const SELECTORS = {
  all: [],
  tags: [],
  classNames: [],
  ids: [],
  attrs: [],
};

// MODULE: compiler/style/css-parser/serialize-css.js
const serializeCss = (stylesheet, serializeOpts) => {
  const usedSelectors = serializeOpts.usedSelectors || null;
  const opts = {
    usedSelectors: usedSelectors || null,
    hasUsedAttrs: !!usedSelectors && usedSelectors.attrs.size > 0,
    hasUsedClassNames: !!usedSelectors && usedSelectors.classNames.size > 0,
    hasUsedIds: !!usedSelectors && usedSelectors.ids.size > 0,
    hasUsedTags: !!usedSelectors && usedSelectors.tags.size > 0,
  };
  const rules = stylesheet.rules;
  if (!rules) {
    return '';
  }
  const rulesLen = rules.length;
  const out = [];
  for (let i = 0; i < rulesLen; i++) {
    out.push(serializeCssVisitNode(opts, rules[i], i, rulesLen));
  }
  return out.join('');
};
const serializeCssVisitNode = (opts, node, index, len) => {
  const nodeType = node.type;
  if (nodeType === 'declaration') {
    return serializeCssDeclaration(node, index, len);
  }
  if (nodeType === 'rule') {
    return serializeCssRule(opts, node);
  }
  if (nodeType === 'comment') {
    if (node.comment[0] === '!') {
      return `/*${node.comment}*/`;
    }
    else {
      return '';
    }
  }
  if (nodeType === 'media') {
    return serializeCssMedia(opts, node);
  }
  if (nodeType === 'keyframes') {
    return serializeCssKeyframes(opts, node);
  }
  if (nodeType === 'keyframe') {
    return serializeCssKeyframe(opts, node);
  }
  if (nodeType === 'font-face') {
    return serializeCssFontFace(opts, node);
  }
  if (nodeType === 'supports') {
    return serializeCssSupports(opts, node);
  }
  if (nodeType === 'import') {
    return '@import ' + node.import + ';';
  }
  if (nodeType === 'charset') {
    return '@charset ' + node.charset + ';';
  }
  if (nodeType === 'page') {
    return serializeCssPage(opts, node);
  }
  if (nodeType === 'host') {
    return '@host{' + serializeCssMapVisit(opts, node.rules) + '}';
  }
  if (nodeType === 'custom-media') {
    return '@custom-media ' + node.name + ' ' + node.media + ';';
  }
  if (nodeType === 'document') {
    return serializeCssDocument(opts, node);
  }
  if (nodeType === 'namespace') {
    return '@namespace ' + node.namespace + ';';
  }
  return '';
};
const serializeCssRule = (opts, node) => {
  const decls = node.declarations;
  const usedSelectors = opts.usedSelectors;
  const selectors = node.selectors.slice();
  if (decls == null || decls.length === 0) {
    return '';
  }
  if (usedSelectors) {
    let i;
    let j;
    let include = true;
    for (i = selectors.length - 1; i >= 0; i--) {
      const sel = getCssSelectors(selectors[i]);
      include = true;
      // classes
      let jlen = sel.classNames.length;
      if (jlen > 0 && opts.hasUsedClassNames) {
        for (j = 0; j < jlen; j++) {
          if (!usedSelectors.classNames.has(sel.classNames[j])) {
            include = false;
            break;
          }
        }
      }
      // tags
      if (include && opts.hasUsedTags) {
        jlen = sel.tags.length;
        if (jlen > 0) {
          for (j = 0; j < jlen; j++) {
            if (!usedSelectors.tags.has(sel.tags[j])) {
              include = false;
              break;
            }
          }
        }
      }
      // attrs
      if (include && opts.hasUsedAttrs) {
        jlen = sel.attrs.length;
        if (jlen > 0) {
          for (j = 0; j < jlen; j++) {
            if (!usedSelectors.attrs.has(sel.attrs[j])) {
              include = false;
              break;
            }
          }
        }
      }
      // ids
      if (include && opts.hasUsedIds) {
        jlen = sel.ids.length;
        if (jlen > 0) {
          for (j = 0; j < jlen; j++) {
            if (!usedSelectors.ids.has(sel.ids[j])) {
              include = false;
              break;
            }
          }
        }
      }
      if (!include) {
        selectors.splice(i, 1);
      }
    }
  }
  if (selectors.length === 0) {
    return '';
  }
  const cleanedSelectors = [];
  let cleanedSelector = '';
  for (const selector of node.selectors) {
    cleanedSelector = removeSelectorWhitespace(selector);
    if (!cleanedSelectors.includes(cleanedSelector)) {
      cleanedSelectors.push(cleanedSelector);
    }
  }
  return `${cleanedSelectors}{${serializeCssMapVisit(opts, decls)}}`;
};
const serializeCssDeclaration = (node, index, len) => {
  if (node.value === '') {
    return '';
  }
  if (len - 1 === index) {
    return node.property + ':' + node.value;
  }
  return node.property + ':' + node.value + ';';
};
const serializeCssMedia = (opts, node) => {
  const mediaCss = serializeCssMapVisit(opts, node.rules);
  if (mediaCss === '') {
    return '';
  }
  return '@media ' + removeMediaWhitespace(node.media) + '{' + mediaCss + '}';
};
const serializeCssKeyframes = (opts, node) => {
  const keyframesCss = serializeCssMapVisit(opts, node.keyframes);
  if (keyframesCss === '') {
    return '';
  }
  return '@' + (node.vendor || '') + 'keyframes ' + node.name + '{' + keyframesCss + '}';
};
const serializeCssKeyframe = (opts, node) => {
  return node.values.join(',') + '{' + serializeCssMapVisit(opts, node.declarations) + '}';
};
const serializeCssFontFace = (opts, node) => {
  const fontCss = serializeCssMapVisit(opts, node.declarations);
  if (fontCss === '') {
    return '';
  }
  return '@font-face{' + fontCss + '}';
};
const serializeCssSupports = (opts, node) => {
  const supportsCss = serializeCssMapVisit(opts, node.rules);
  if (supportsCss === '') {
    return '';
  }
  return '@supports ' + node.supports + '{' + supportsCss + '}';
};
const serializeCssPage = (opts, node) => {
  const sel = node.selectors.join(', ');
  return '@page ' + sel + '{' + serializeCssMapVisit(opts, node.declarations) + '}';
};
const serializeCssDocument = (opts, node) => {
  const documentCss = serializeCssMapVisit(opts, node.rules);
  const doc = '@' + (node.vendor || '') + 'document ' + node.document;
  if (documentCss === '') {
    return '';
  }
  return doc + '{' + documentCss + '}';
};
const serializeCssMapVisit = (opts, nodes) => {
  let rtn = '';
  if (nodes) {
    for (let i = 0, len = nodes.length; i < len; i++) {
      rtn += serializeCssVisitNode(opts, nodes[i], i, len);
    }
  }
  return rtn;
};
const removeSelectorWhitespace = (selector) => {
  let rtn = '';
  let char = '';
  let inAttr = false;
  selector = selector.trim();
  for (let i = 0, l = selector.length; i < l; i++) {
    char = selector[i];
    if (char === '[' && rtn[rtn.length - 1] !== '\\') {
      inAttr = true;
    }
    else if (char === ']' && rtn[rtn.length - 1] !== '\\') {
      inAttr = false;
    }
    if (!inAttr && CSS_WS_REG.test(char)) {
      if (CSS_NEXT_CHAR_REG.test(selector[i + 1])) {
        continue;
      }
      if (CSS_PREV_CHAR_REG.test(rtn[rtn.length - 1])) {
        continue;
      }
      rtn += ' ';
    }
    else {
      rtn += char;
    }
  }
  return rtn;
};
const removeMediaWhitespace = (media) => {
  let rtn = '';
  let char = '';
  media = media.trim();
  for (let i = 0, l = media.length; i < l; i++) {
    char = media[i];
    if (CSS_WS_REG.test(char)) {
      if (CSS_WS_REG.test(rtn[rtn.length - 1])) {
        continue;
      }
      rtn += ' ';
    }
    else {
      rtn += char;
    }
  }
  return rtn;
};
const CSS_WS_REG = /\s/;
const CSS_NEXT_CHAR_REG = /[>\(\)\~\,\+\s]/;
const CSS_PREV_CHAR_REG = /[>\(\~\,\+]/;

// MODULE: compiler/optimize/minify-css.js
const minifyCss = (cssString) => {
  const parseResults = parseCss(cssString);
  if (hasError(parseResults.diagnostics)) {
    return cssString;
  }
  const output = serializeCss(parseResults.stylesheet, {});
  return output;
};

// MODULE: compiler/optimize/optimize-css.js
const optimizeCss = async (inputOpts) => {
  let result = {
    output: inputOpts.input,
    diagnostics: [],
  };
  if (inputOpts.autoprefixer !== false && inputOpts.autoprefixer !== null) {
    result = await autoprefixCss(inputOpts.input, inputOpts.autoprefixer);
    if (hasError(result.diagnostics)) {
      return result;
    }
  }
  if (inputOpts.minify !== false) {
    result.output = minifyCss(result.output);
  }
  return result;
};

// MODULE: utils/shadow-css.js
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 *
 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
 * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts
 */
const safeSelector = (selector) => {
  const placeholders = [];
  let index = 0;
  let content;
  // Replaces attribute selectors with placeholders.
  // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
  selector = selector.replace(/(\[[^\]]*\])/g, (_, keep) => {
    const replaceBy = `__ph-${index}__`;
    placeholders.push(keep);
    index++;
    return replaceBy;
  });
  // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
  // WS and "+" would otherwise be interpreted as selector separators.
  content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
    const replaceBy = `__ph-${index}__`;
    placeholders.push(exp);
    index++;
    return pseudo + replaceBy;
  });
  const ss = {
    content,
    placeholders,
  };
  return ss;
};
const restoreSafeSelector = (placeholders, content) => {
  return content.replace(/__ph-(\d+)__/g, (_, index) => placeholders[+index]);
};
const _polyfillHost = '-shadowcsshost';
const _polyfillSlotted = '-shadowcssslotted';
// note: :host-context pre-processed to -shadowcsshostcontext.
const _polyfillHostContext = '-shadowcsscontext';
const _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
const _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
const _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
const _cssColonSlottedRe = new RegExp('(' + _polyfillSlotted + _parenSuffix, 'gim');
const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
const _shadowDOMSelectorsRe = [/::shadow/g, /::content/g];
const _selectorReSuffix = '([>\\s~+[.,{:][\\s\\S]*)?$';
const _polyfillHostRe = /-shadowcsshost/gim;
const _colonHostRe = /:host/gim;
const _colonSlottedRe = /::slotted/gim;
const _colonHostContextRe = /:host-context/gim;
const _commentRe = /\/\*\s*[\s\S]*?\*\//g;
const stripComments = (input) => {
  return input.replace(_commentRe, '');
};
const _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
const extractCommentsWithHash = (input) => {
  return input.match(_commentWithHashRe) || [];
};
const _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
const _curlyRe = /([{}])/g;
const OPEN_CURLY = '{';
const CLOSE_CURLY = '}';
const BLOCK_PLACEHOLDER = '%BLOCK%';
const processRules = (input, ruleCallback) => {
  const inputWithEscapedBlocks = escapeBlocks(input);
  let nextBlockIndex = 0;
  return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {
    const selector = m[2];
    let content = '';
    let suffix = m[4];
    let contentPrefix = '';
    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
      contentPrefix = '{';
    }
    const cssRule = {
      selector,
      content,
    };
    const rule = ruleCallback(cssRule);
    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
  });
};
const escapeBlocks = (input) => {
  const inputParts = input.split(_curlyRe);
  const resultParts = [];
  const escapedBlocks = [];
  let bracketCount = 0;
  let currentBlockParts = [];
  for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {
    const part = inputParts[partIndex];
    if (part === CLOSE_CURLY) {
      bracketCount--;
    }
    if (bracketCount > 0) {
      currentBlockParts.push(part);
    }
    else {
      if (currentBlockParts.length > 0) {
        escapedBlocks.push(currentBlockParts.join(''));
        resultParts.push(BLOCK_PLACEHOLDER);
        currentBlockParts = [];
      }
      resultParts.push(part);
    }
    if (part === OPEN_CURLY) {
      bracketCount++;
    }
  }
  if (currentBlockParts.length > 0) {
    escapedBlocks.push(currentBlockParts.join(''));
    resultParts.push(BLOCK_PLACEHOLDER);
  }
  const strEscapedBlocks = {
    escapedString: resultParts.join(''),
    blocks: escapedBlocks,
  };
  return strEscapedBlocks;
};
const insertPolyfillHostInCssText = (selector) => {
  selector = selector
    .replace(_colonHostContextRe, _polyfillHostContext)
    .replace(_colonHostRe, _polyfillHost)
    .replace(_colonSlottedRe, _polyfillSlotted);
  return selector;
};
const convertColonRule = (cssText, regExp, partReplacer) => {
  // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
  return cssText.replace(regExp, (...m) => {
    if (m[2]) {
      const parts = m[2].split(',');
      const r = [];
      for (let i = 0; i < parts.length; i++) {
        const p = parts[i].trim();
        if (!p)
          break;
        r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
      }
      return r.join(',');
    }
    else {
      return _polyfillHostNoCombinator + m[3];
    }
  });
};
const colonHostPartReplacer = (host, part, suffix) => {
  return host + part.replace(_polyfillHost, '') + suffix;
};
const convertColonHost = (cssText) => {
  return convertColonRule(cssText, _cssColonHostRe, colonHostPartReplacer);
};
const colonHostContextPartReplacer = (host, part, suffix) => {
  if (part.indexOf(_polyfillHost) > -1) {
    return colonHostPartReplacer(host, part, suffix);
  }
  else {
    return host + part + suffix + ', ' + part + ' ' + host + suffix;
  }
};
const convertColonSlotted = (cssText, slotScopeId) => {
  const slotClass = '.' + slotScopeId + ' > ';
  const selectors = [];
  cssText = cssText.replace(_cssColonSlottedRe, (...m) => {
    if (m[2]) {
      const compound = m[2].trim();
      const suffix = m[3];
      const slottedSelector = slotClass + compound + suffix;
      let prefixSelector = '';
      for (let i = m[4] - 1; i >= 0; i--) {
        const char = m[5][i];
        if (char === '}' || char === ',') {
          break;
        }
        prefixSelector = char + prefixSelector;
      }
      const orgSelector = prefixSelector + slottedSelector;
      const addedSelector = `${prefixSelector.trimRight()}${slottedSelector.trim()}`;
      if (orgSelector.trim() !== addedSelector.trim()) {
        const updatedSelector = `${addedSelector}, ${orgSelector}`;
        selectors.push({
          orgSelector,
          updatedSelector,
        });
      }
      return slottedSelector;
    }
    else {
      return _polyfillHostNoCombinator + m[3];
    }
  });
  return {
    selectors,
    cssText,
  };
};
const convertColonHostContext = (cssText) => {
  return convertColonRule(cssText, _cssColonHostContextRe, colonHostContextPartReplacer);
};
const convertShadowDOMSelectors = (cssText) => {
  return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
};
const makeScopeMatcher = (scopeSelector) => {
  const lre = /\[/g;
  const rre = /\]/g;
  scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
  return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
};
const selectorNeedsScoping = (selector, scopeSelector) => {
  const re = makeScopeMatcher(scopeSelector);
  return !re.test(selector);
};
const applySimpleSelectorScope = (selector, scopeSelector, hostSelector) => {
  // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
  _polyfillHostRe.lastIndex = 0;
  if (_polyfillHostRe.test(selector)) {
    const replaceBy = `.${hostSelector}`;
    return selector
      .replace(_polyfillHostNoCombinatorRe, (_, selector) => {
      return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
        return before + replaceBy + colon + after;
      });
    })
      .replace(_polyfillHostRe, replaceBy + ' ');
  }
  return scopeSelector + ' ' + selector;
};
const applyStrictSelectorScope = (selector, scopeSelector, hostSelector) => {
  const isRe = /\[is=([^\]]*)\]/g;
  scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
  const className = '.' + scopeSelector;
  const _scopeSelectorPart = (p) => {
    let scopedP = p.trim();
    if (!scopedP) {
      return '';
    }
    if (p.indexOf(_polyfillHostNoCombinator) > -1) {
      scopedP = applySimpleSelectorScope(p, scopeSelector, hostSelector);
    }
    else {
      // remove :host since it should be unnecessary
      const t = p.replace(_polyfillHostRe, '');
      if (t.length > 0) {
        const matches = t.match(/([^:]*)(:*)(.*)/);
        if (matches) {
          scopedP = matches[1] + className + matches[2] + matches[3];
        }
      }
    }
    return scopedP;
  };
  const safeContent = safeSelector(selector);
  selector = safeContent.content;
  let scopedSelector = '';
  let startIndex = 0;
  let res;
  const sep = /( |>|\+|~(?!=))\s*/g;
  // If a selector appears before :host it should not be shimmed as it
  // matches on ancestor elements and not on elements in the host's shadow
  // `:host-context(div)` is transformed to
  // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`
  // the `div` is not part of the component in the 2nd selectors and should not be scoped.
  // Historically `component-tag:host` was matching the component so we also want to preserve
  // this behavior to avoid breaking legacy apps (it should not match).
  // The behavior should be:
  // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)
  // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a
  //   `:host-context(tag)`)
  const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
  // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present
  let shouldScope = !hasHost;
  while ((res = sep.exec(selector)) !== null) {
    const separator = res[1];
    const part = selector.slice(startIndex, res.index).trim();
    shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
    const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;
    scopedSelector += `${scopedPart} ${separator} `;
    startIndex = sep.lastIndex;
  }
  const part = selector.substring(startIndex);
  shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
  scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
  // replace the placeholders with their original values
  return restoreSafeSelector(safeContent.placeholders, scopedSelector);
};
const scopeSelector = (selector, scopeSelectorText, hostSelector, slotSelector) => {
  return selector
    .split(',')
    .map(shallowPart => {
    if (slotSelector && shallowPart.indexOf('.' + slotSelector) > -1) {
      return shallowPart.trim();
    }
    if (selectorNeedsScoping(shallowPart, scopeSelectorText)) {
      return applyStrictSelectorScope(shallowPart, scopeSelectorText, hostSelector).trim();
    }
    else {
      return shallowPart.trim();
    }
  })
    .join(', ');
};
const scopeSelectors = (cssText, scopeSelectorText, hostSelector, slotSelector, commentOriginalSelector) => {
  return processRules(cssText, (rule) => {
    let selector = rule.selector;
    let content = rule.content;
    if (rule.selector[0] !== '@') {
      selector = scopeSelector(rule.selector, scopeSelectorText, hostSelector, slotSelector);
    }
    else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') || rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
      content = scopeSelectors(rule.content, scopeSelectorText, hostSelector, slotSelector);
    }
    const cssRule = {
      selector: selector.replace(/\s{2,}/g, ' ').trim(),
      content,
    };
    return cssRule;
  });
};
const scopeCssText = (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector) => {
  cssText = insertPolyfillHostInCssText(cssText);
  cssText = convertColonHost(cssText);
  cssText = convertColonHostContext(cssText);
  const slotted = convertColonSlotted(cssText, slotScopeId);
  cssText = slotted.cssText;
  cssText = convertShadowDOMSelectors(cssText);
  if (scopeId) {
    cssText = scopeSelectors(cssText, scopeId, hostScopeId, slotScopeId);
  }
  cssText = cssText.replace(/-shadowcsshost-no-combinator/g, `.${hostScopeId}`);
  cssText = cssText.replace(/>\s*\*\s+([^{, ]+)/gm, ' $1 ');
  return {
    cssText: cssText.trim(),
    slottedSelectors: slotted.selectors,
  };
};
const scopeCss = (cssText, scopeId, commentOriginalSelector) => {
  const hostScopeId = scopeId + '-h';
  const slotScopeId = scopeId + '-s';
  const commentsWithHash = extractCommentsWithHash(cssText);
  cssText = stripComments(cssText);
  const orgSelectors = [];
  if (commentOriginalSelector) {
    const processCommentedSelector = (rule) => {
      const placeholder = `/*!@___${orgSelectors.length}___*/`;
      const comment = `/*!@${rule.selector}*/`;
      orgSelectors.push({ placeholder, comment });
      rule.selector = placeholder + rule.selector;
      return rule;
    };
    cssText = processRules(cssText, rule => {
      if (rule.selector[0] !== '@') {
        return processCommentedSelector(rule);
      }
      else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') || rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
        rule.content = processRules(rule.content, processCommentedSelector);
        return rule;
      }
      return rule;
    });
  }
  const scoped = scopeCssText(cssText, scopeId, hostScopeId, slotScopeId);
  cssText = [scoped.cssText, ...commentsWithHash].join('\n');
  if (commentOriginalSelector) {
    orgSelectors.forEach(({ placeholder, comment }) => {
      cssText = cssText.replace(placeholder, comment);
    });
  }
  scoped.slottedSelectors.forEach(slottedSelector => {
    cssText = cssText.replace(slottedSelector.orgSelector, slottedSelector.updatedSelector);
  });
  return cssText;
};

// MODULE: compiler/style/style-utils.js
const stripCssComments = (input) => {
  let isInsideString = null;
  let currentCharacter = '';
  let returnValue = '';
  for (let i = 0; i < input.length; i++) {
    currentCharacter = input[i];
    if (input[i - 1] !== '\\') {
      if (currentCharacter === '"' || currentCharacter === "'") {
        if (isInsideString === currentCharacter) {
          isInsideString = null;
        }
        else if (!isInsideString) {
          isInsideString = currentCharacter;
        }
      }
    }
    // Find beginning of /* type comment
    if (!isInsideString && currentCharacter === '/' && input[i + 1] === '*') {
      // Ignore important comment when configured to preserve comments using important syntax: /*!
      let j = i + 2;
      // Iterate over comment
      for (; j < input.length; j++) {
        // Find end of comment
        if (input[j] === '*' && input[j + 1] === '/') {
          break;
        }
      }
      // Resume iteration over CSS string from the end of the comment
      i = j + 1;
      continue;
    }
    returnValue += currentCharacter;
  }
  return returnValue;
};

// MODULE: ../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js
var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
function encode$1(decoded) {
  var sourceFileIndex = 0; // second field
  var sourceCodeLine = 0; // third field
  var sourceCodeColumn = 0; // fourth field
  var nameIndex = 0; // fifth field
  var mappings = '';
  for (var i = 0; i < decoded.length; i++) {
    var line = decoded[i];
    if (i > 0)
      mappings += ';';
    if (line.length === 0)
      continue;
    var generatedCodeColumn = 0; // first field
    var lineMappings = [];
    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
      var segment = line_1[_i];
      var segmentMappings = encodeInteger$1(segment[0] - generatedCodeColumn);
      generatedCodeColumn = segment[0];
      if (segment.length > 1) {
        segmentMappings +=
          encodeInteger$1(segment[1] - sourceFileIndex) +
            encodeInteger$1(segment[2] - sourceCodeLine) +
            encodeInteger$1(segment[3] - sourceCodeColumn);
        sourceFileIndex = segment[1];
        sourceCodeLine = segment[2];
        sourceCodeColumn = segment[3];
      }
      if (segment.length === 5) {
        segmentMappings += encodeInteger$1(segment[4] - nameIndex);
        nameIndex = segment[4];
      }
      lineMappings.push(segmentMappings);
    }
    mappings += lineMappings.join(',');
  }
  return mappings;
}
function encodeInteger$1(num) {
  var result = '';
  num = num < 0 ? (-num << 1) | 1 : num << 1;
  do {
    var clamped = num & 31;
    num >>>= 5;
    if (num > 0) {
      clamped |= 32;
    }
    result += chars$1[clamped];
  } while (num > 0);
  return result;
}

// MODULE: ../node_modules/magic-string/dist/magic-string.es.js

var BitSet$1 = function BitSet(arg) {
	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
};

BitSet$1.prototype.add = function add (n) {
	this.bits[n >> 5] |= 1 << (n & 31);
};

BitSet$1.prototype.has = function has (n) {
	return !!(this.bits[n >> 5] & (1 << (n & 31)));
};

var Chunk$1 = function Chunk(start, end, content) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties(this, {
		previous: { writable: true, value: null },
		next:   { writable: true, value: null }
	});
};

Chunk$1.prototype.appendLeft = function appendLeft (content) {
	this.outro += content;
};

Chunk$1.prototype.appendRight = function appendRight (content) {
	this.intro = this.intro + content;
};

Chunk$1.prototype.clone = function clone () {
	var chunk = new Chunk$1(this.start, this.end, this.original);

	chunk.intro = this.intro;
	chunk.outro = this.outro;
	chunk.content = this.content;
	chunk.storeName = this.storeName;
	chunk.edited = this.edited;

	return chunk;
};

Chunk$1.prototype.contains = function contains (index) {
	return this.start < index && index < this.end;
};

Chunk$1.prototype.eachNext = function eachNext (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.next;
	}
};

Chunk$1.prototype.eachPrevious = function eachPrevious (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.previous;
	}
};

Chunk$1.prototype.edit = function edit (content, storeName, contentOnly) {
	this.content = content;
	if (!contentOnly) {
		this.intro = '';
		this.outro = '';
	}
	this.storeName = storeName;

	this.edited = true;

	return this;
};

Chunk$1.prototype.prependLeft = function prependLeft (content) {
	this.outro = content + this.outro;
};

Chunk$1.prototype.prependRight = function prependRight (content) {
	this.intro = content + this.intro;
};

Chunk$1.prototype.split = function split (index) {
	var sliceIndex = index - this.start;

	var originalBefore = this.original.slice(0, sliceIndex);
	var originalAfter = this.original.slice(sliceIndex);

	this.original = originalBefore;

	var newChunk = new Chunk$1(index, this.end, originalAfter);
	newChunk.outro = this.outro;
	this.outro = '';

	this.end = index;

	if (this.edited) {
		// TODO is this block necessary?...
		newChunk.edit('', false);
		this.content = '';
	} else {
		this.content = originalBefore;
	}

	newChunk.next = this.next;
	if (newChunk.next) { newChunk.next.previous = newChunk; }
	newChunk.previous = this;
	this.next = newChunk;

	return newChunk;
};

Chunk$1.prototype.toString = function toString () {
	return this.intro + this.content + this.outro;
};

Chunk$1.prototype.trimEnd = function trimEnd (rx) {
	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.start + trimmed.length).edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }
	}
};

Chunk$1.prototype.trimStart = function trimStart (rx) {
	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.end - trimmed.length);
			this.edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }
	}
};

var btoa$2 = function () {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	btoa$2 = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
} else if (typeof Buffer === 'function') {
	btoa$2 = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
}

var SourceMap$1 = function SourceMap(properties) {
	this.version = 3;
	this.file = properties.file;
	this.sources = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names = properties.names;
	this.mappings = encode$1(properties.mappings);
};

SourceMap$1.prototype.toString = function toString () {
	return JSON.stringify(this);
};

SourceMap$1.prototype.toUrl = function toUrl () {
	return 'data:application/json;charset=utf-8;base64,' + btoa$2(this.toString());
};

function guessIndent$1(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
	var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath$1(from, to) {
	var fromParts = from.split(/[/\\]/);
	var toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) { fromParts[i] = '..'; }
	}

	return fromParts.concat(toParts).join('/');
}

var toString$1 = Object.prototype.toString;

function isObject$3(thing) {
	return toString$1.call(thing) === '[object Object]';
}

function getLocator$1(source) {
	var originalLines = source.split('\n');
	var lineOffsets = [];

	for (var i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		var i = 0;
		var j = lineOffsets.length;
		while (i < j) {
			var m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		var line = i - 1;
		var column = index - lineOffsets[line];
		return { line: line, column: column };
	};
}

var Mappings$1 = function Mappings(hires) {
	this.hires = hires;
	this.generatedCodeLine = 0;
	this.generatedCodeColumn = 0;
	this.raw = [];
	this.rawSegments = this.raw[this.generatedCodeLine] = [];
	this.pending = null;
};

Mappings$1.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
	if (content.length) {
		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
		if (nameIndex >= 0) {
			segment.push(nameIndex);
		}
		this.rawSegments.push(segment);
	} else if (this.pending) {
		this.rawSegments.push(this.pending);
	}

	this.advance(content);
	this.pending = null;
};

Mappings$1.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
	var originalCharIndex = chunk.start;
	var first = true;

	while (originalCharIndex < chunk.end) {
		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
		}

		if (original[originalCharIndex] === '\n') {
			loc.line += 1;
			loc.column = 0;
			this.generatedCodeLine += 1;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
			this.generatedCodeColumn = 0;
			first = true;
		} else {
			loc.column += 1;
			this.generatedCodeColumn += 1;
			first = false;
		}

		originalCharIndex += 1;
	}

	this.pending = null;
};

Mappings$1.prototype.advance = function advance (str) {
	if (!str) { return; }

	var lines = str.split('\n');

	if (lines.length > 1) {
		for (var i = 0; i < lines.length - 1; i++) {
			this.generatedCodeLine++;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
		}
		this.generatedCodeColumn = 0;
	}

	this.generatedCodeColumn += lines[lines.length - 1].length;
};

var n$1 = '\n';

var warned$1 = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};

var MagicString$1 = function MagicString(string, options) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk$1(0, string.length, string);

	Object.defineProperties(this, {
		original:        { writable: true, value: string },
		outro:         { writable: true, value: '' },
		intro:         { writable: true, value: '' },
		firstChunk:      { writable: true, value: chunk },
		lastChunk:       { writable: true, value: chunk },
		lastSearchedChunk:   { writable: true, value: chunk },
		byStart:         { writable: true, value: {} },
		byEnd:         { writable: true, value: {} },
		filename:        { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations:  { writable: true, value: new BitSet$1() },
		storedNames:       { writable: true, value: {} },
		indentStr:       { writable: true, value: guessIndent$1(string) }
	});

	this.byStart[0] = chunk;
	this.byEnd[string.length] = chunk;
};

MagicString$1.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
	this.sourcemapLocations.add(char);
};

MagicString$1.prototype.append = function append (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.outro += content;
	return this;
};

MagicString$1.prototype.appendLeft = function appendLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.appendLeft(content);
	} else {
		this.intro += content;
	}
	return this;
};

MagicString$1.prototype.appendRight = function appendRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.appendRight(content);
	} else {
		this.outro += content;
	}
	return this;
};

MagicString$1.prototype.clone = function clone () {
	var cloned = new MagicString$1(this.original, { filename: this.filename });

	var originalChunk = this.firstChunk;
	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

	while (originalChunk) {
		cloned.byStart[clonedChunk.start] = clonedChunk;
		cloned.byEnd[clonedChunk.end] = clonedChunk;

		var nextOriginalChunk = originalChunk.next;
		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

		if (nextClonedChunk) {
			clonedChunk.next = nextClonedChunk;
			nextClonedChunk.previous = clonedChunk;

			clonedChunk = nextClonedChunk;
		}

		originalChunk = nextOriginalChunk;
	}

	cloned.lastChunk = clonedChunk;

	if (this.indentExclusionRanges) {
		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
	}

	cloned.sourcemapLocations = new BitSet$1(this.sourcemapLocations);

	cloned.intro = this.intro;
	cloned.outro = this.outro;

	return cloned;
};

MagicString$1.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1 = this;

	options = options || {};

	var sourceIndex = 0;
	var names = Object.keys(this.storedNames);
	var mappings = new Mappings$1(options.hires);

	var locate = getLocator$1(this.original);

	if (this.intro) {
		mappings.advance(this.intro);
	}

	this.firstChunk.eachNext(function (chunk) {
		var loc = locate(chunk.start);

		if (chunk.intro.length) { mappings.advance(chunk.intro); }

		if (chunk.edited) {
			mappings.addEdit(
				sourceIndex,
				chunk.content,
				loc,
				chunk.storeName ? names.indexOf(chunk.original) : -1
			);
		} else {
			mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
		}

		if (chunk.outro.length) { mappings.advance(chunk.outro); }
	});

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: [options.source ? getRelativePath$1(options.file || '', options.source) : null],
		sourcesContent: options.includeContent ? [this.original] : [null],
		names: names,
		mappings: mappings.raw
	};
};

MagicString$1.prototype.generateMap = function generateMap (options) {
	return new SourceMap$1(this.generateDecodedMap(options));
};

MagicString$1.prototype.getIndentString = function getIndentString () {
	return this.indentStr === null ? '\t' : this.indentStr;
};

MagicString$1.prototype.indent = function indent (indentStr, options) {
	var pattern = /^[^\r\n]/gm;

	if (isObject$3(indentStr)) {
		options = indentStr;
		indentStr = undefined;
	}

	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

	if (indentStr === '') { return this; } // noop

	options = options || {};

	// Process exclusion ranges
	var isExcluded = {};

	if (options.exclude) {
		var exclusions =
			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
		exclusions.forEach(function (exclusion) {
			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
				isExcluded[i] = true;
			}
		});
	}

	var shouldIndentNextCharacter = options.indentStart !== false;
	var replacer = function (match) {
		if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
		shouldIndentNextCharacter = true;
		return match;
	};

	this.intro = this.intro.replace(pattern, replacer);

	var charIndex = 0;
	var chunk = this.firstChunk;

	while (chunk) {
		var end = chunk.end;

		if (chunk.edited) {
			if (!isExcluded[charIndex]) {
				chunk.content = chunk.content.replace(pattern, replacer);

				if (chunk.content.length) {
					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
				}
			}
		} else {
			charIndex = chunk.start;

			while (charIndex < end) {
				if (!isExcluded[charIndex]) {
					var char = this.original[charIndex];

					if (char === '\n') {
						shouldIndentNextCharacter = true;
					} else if (char !== '\r' && shouldIndentNextCharacter) {
						shouldIndentNextCharacter = false;

						if (charIndex === chunk.start) {
							chunk.prependRight(indentStr);
						} else {
							this._splitChunk(chunk, charIndex);
							chunk = chunk.next;
							chunk.prependRight(indentStr);
						}
					}
				}

				charIndex += 1;
			}
		}

		charIndex = chunk.end;
		chunk = chunk.next;
	}

	this.outro = this.outro.replace(pattern, replacer);

	return this;
};

MagicString$1.prototype.insert = function insert () {
	throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
};

MagicString$1.prototype.insertLeft = function insertLeft (index, content) {
	if (!warned$1.insertLeft) {
		console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
		warned$1.insertLeft = true;
	}

	return this.appendLeft(index, content);
};

MagicString$1.prototype.insertRight = function insertRight (index, content) {
	if (!warned$1.insertRight) {
		console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
		warned$1.insertRight = true;
	}

	return this.prependRight(index, content);
};

MagicString$1.prototype.move = function move (start, end, index) {
	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }

	this._split(start);
	this._split(end);
	this._split(index);

	var first = this.byStart[start];
	var last = this.byEnd[end];

	var oldLeft = first.previous;
	var oldRight = last.next;

	var newRight = this.byStart[index];
	if (!newRight && last === this.lastChunk) { return this; }
	var newLeft = newRight ? newRight.previous : this.lastChunk;

	if (oldLeft) { oldLeft.next = oldRight; }
	if (oldRight) { oldRight.previous = oldLeft; }

	if (newLeft) { newLeft.next = first; }
	if (newRight) { newRight.previous = last; }

	if (!first.previous) { this.firstChunk = last.next; }
	if (!last.next) {
		this.lastChunk = first.previous;
		this.lastChunk.next = null;
	}

	first.previous = newLeft;
	last.next = newRight || null;

	if (!newLeft) { this.firstChunk = first; }
	if (!newRight) { this.lastChunk = last; }
	return this;
};

MagicString$1.prototype.overwrite = function overwrite (start, end, content, options) {
	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (end > this.original.length) { throw new Error('end is out of bounds'); }
	if (start === end)
		{ throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead'); }

	this._split(start);
	this._split(end);

	if (options === true) {
		if (!warned$1.storeName) {
			console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
			warned$1.storeName = true;
		}

		options = { storeName: true };
	}
	var storeName = options !== undefined ? options.storeName : false;
	var contentOnly = options !== undefined ? options.contentOnly : false;

	if (storeName) {
		var original = this.original.slice(start, end);
		this.storedNames[original] = true;
	}

	var first = this.byStart[start];
	var last = this.byEnd[end];

	if (first) {
		if (end > first.end && first.next !== this.byStart[first.end]) {
			throw new Error('Cannot overwrite across a split point');
		}

		first.edit(content, storeName, contentOnly);

		if (first !== last) {
			var chunk = first.next;
			while (chunk !== last) {
				chunk.edit('', false);
				chunk = chunk.next;
			}

			chunk.edit('', false);
		}
	} else {
		// must be inserting at the end
		var newChunk = new Chunk$1(start, end, '').edit(content, storeName);

		// TODO last chunk in the array may not be the last chunk, if it's moved...
		last.next = newChunk;
		newChunk.previous = last;
	}
	return this;
};

MagicString$1.prototype.prepend = function prepend (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.intro = content + this.intro;
	return this;
};

MagicString$1.prototype.prependLeft = function prependLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.prependLeft(content);
	} else {
		this.intro = content + this.intro;
	}
	return this;
};

MagicString$1.prototype.prependRight = function prependRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.prependRight(content);
	} else {
		this.outro = content + this.outro;
	}
	return this;
};

MagicString$1.prototype.remove = function remove (start, end) {
	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (start === end) { return this; }

	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
	if (start > end) { throw new Error('end must be greater than start'); }

	this._split(start);
	this._split(end);

	var chunk = this.byStart[start];

	while (chunk) {
		chunk.intro = '';
		chunk.outro = '';
		chunk.edit('');

		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
	}
	return this;
};

MagicString$1.prototype.lastChar = function lastChar () {
	if (this.outro.length)
		{ return this.outro[this.outro.length - 1]; }
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length)
			{ return chunk.outro[chunk.outro.length - 1]; }
		if (chunk.content.length)
			{ return chunk.content[chunk.content.length - 1]; }
		if (chunk.intro.length)
			{ return chunk.intro[chunk.intro.length - 1]; }
	} while (chunk = chunk.previous);
	if (this.intro.length)
		{ return this.intro[this.intro.length - 1]; }
	return '';
};

MagicString$1.prototype.lastLine = function lastLine () {
	var lineIndex = this.outro.lastIndexOf(n$1);
	if (lineIndex !== -1)
		{ return this.outro.substr(lineIndex + 1); }
	var lineStr = this.outro;
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length > 0) {
			lineIndex = chunk.outro.lastIndexOf(n$1);
			if (lineIndex !== -1)
				{ return chunk.outro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.outro + lineStr;
		}

		if (chunk.content.length > 0) {
			lineIndex = chunk.content.lastIndexOf(n$1);
			if (lineIndex !== -1)
				{ return chunk.content.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.content + lineStr;
		}

		if (chunk.intro.length > 0) {
			lineIndex = chunk.intro.lastIndexOf(n$1);
			if (lineIndex !== -1)
				{ return chunk.intro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.intro + lineStr;
		}
	} while (chunk = chunk.previous);
	lineIndex = this.intro.lastIndexOf(n$1);
	if (lineIndex !== -1)
		{ return this.intro.substr(lineIndex + 1) + lineStr; }
	return this.intro + lineStr;
};

MagicString$1.prototype.slice = function slice (start, end) {
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	var result = '';

	// find start chunk
	var chunk = this.firstChunk;
	while (chunk && (chunk.start > start || chunk.end <= start)) {
		// found end chunk before start
		if (chunk.start < end && chunk.end >= end) {
			return result;
		}

		chunk = chunk.next;
	}

	if (chunk && chunk.edited && chunk.start !== start)
		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

	var startChunk = chunk;
	while (chunk) {
		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
			result += chunk.intro;
		}

		var containsEnd = chunk.start < end && chunk.end >= end;
		if (containsEnd && chunk.edited && chunk.end !== end)
			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

		result += chunk.content.slice(sliceStart, sliceEnd);

		if (chunk.outro && (!containsEnd || chunk.end === end)) {
			result += chunk.outro;
		}

		if (containsEnd) {
			break;
		}

		chunk = chunk.next;
	}

	return result;
};

// TODO deprecate this? not really very useful
MagicString$1.prototype.snip = function snip (start, end) {
	var clone = this.clone();
	clone.remove(0, start);
	clone.remove(end, clone.original.length);

	return clone;
};

MagicString$1.prototype._split = function _split (index) {
	if (this.byStart[index] || this.byEnd[index]) { return; }

	var chunk = this.lastSearchedChunk;
	var searchForward = index > chunk.end;

	while (chunk) {
		if (chunk.contains(index)) { return this._splitChunk(chunk, index); }

		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
	}
};

MagicString$1.prototype._splitChunk = function _splitChunk (chunk, index) {
	if (chunk.edited && chunk.content.length) {
		// zero-length edited chunks are a special case (overlapping replacements)
		var loc = getLocator$1(this.original)(index);
		throw new Error(
			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")")
		);
	}

	var newChunk = chunk.split(index);

	this.byEnd[index] = chunk;
	this.byStart[index] = newChunk;
	this.byEnd[newChunk.end] = newChunk;

	if (chunk === this.lastChunk) { this.lastChunk = newChunk; }

	this.lastSearchedChunk = chunk;
	return true;
};

MagicString$1.prototype.toString = function toString () {
	var str = this.intro;

	var chunk = this.firstChunk;
	while (chunk) {
		str += chunk.toString();
		chunk = chunk.next;
	}

	return str + this.outro;
};

MagicString$1.prototype.isEmpty = function isEmpty () {
	var chunk = this.firstChunk;
	do {
		if (chunk.intro.length && chunk.intro.trim() ||
				chunk.content.length && chunk.content.trim() ||
				chunk.outro.length && chunk.outro.trim())
			{ return false; }
	} while (chunk = chunk.next);
	return true;
};

MagicString$1.prototype.length = function length () {
	var chunk = this.firstChunk;
	var length = 0;
	do {
		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
	} while (chunk = chunk.next);
	return length;
};

MagicString$1.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
};

MagicString$1.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
};

MagicString$1.prototype.trimEndAborted = function trimEndAborted (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var chunk = this.lastChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimEnd(rx);

		// if chunk was trimmed, we have a new lastChunk
		if (chunk.end !== end) {
			if (this.lastChunk === chunk) {
				this.lastChunk = chunk.next;
			}

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.previous;
	} while (chunk);

	return false;
};

MagicString$1.prototype.trimEnd = function trimEnd (charType) {
	this.trimEndAborted(charType);
	return this;
};
MagicString$1.prototype.trimStartAborted = function trimStartAborted (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');

	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var chunk = this.firstChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimStart(rx);

		if (chunk.end !== end) {
			// special case...
			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.next;
	} while (chunk);

	return false;
};

MagicString$1.prototype.trimStart = function trimStart (charType) {
	this.trimStartAborted(charType);
	return this;
};

// MODULE: compiler/docs/style-docs.js
function parseStyleDocs(styleDocs, styleText) {
  if (typeof styleText !== 'string') {
    return;
  }
  let startIndex;
  while ((startIndex = styleText.indexOf(CSS_DOC_START)) > -1) {
    styleText = styleText.substring(startIndex + CSS_DOC_START.length);
    const endIndex = styleText.indexOf(CSS_DOC_END);
    if (endIndex === -1) {
      break;
    }
    const comment = styleText.substring(0, endIndex);
    parseCssComment(styleDocs, comment);
    styleText = styleText.substring(endIndex + CSS_DOC_END.length);
  }
}
function parseCssComment(styleDocs, comment) {
  /**
   * @prop --max-width: Max width of the alert
   */
  const lines = comment.split(/\r?\n/).map(line => {
    line = line.trim();
    while (line.startsWith('*')) {
      line = line.substring(1).trim();
    }
    return line;
  });
  comment = lines
    .join(' ')
    .replace(/\t/g, ' ')
    .trim();
  while (comment.includes('  ')) {
    comment = comment.replace('  ', ' ');
  }
  const docs = comment.split(CSS_PROP_ANNOTATION);
  docs.forEach(d => {
    const doc = d.trim();
    if (!doc.startsWith(`--`)) {
      return;
    }
    const splt = doc.split(`:`);
    const cssDoc = {
      name: splt[0].trim(),
      docs: (splt.shift() && splt.join(`:`)).trim(),
      annotation: 'prop',
    };
    if (!styleDocs.some(c => c.name === cssDoc.name && c.annotation === 'prop')) {
      styleDocs.push(cssDoc);
    }
  });
  return styleDocs;
}
const CSS_DOC_START = `/**`;
const CSS_DOC_END = `*/`;
const CSS_PROP_ANNOTATION = `@prop`;

// MODULE: compiler/style/css-to-esm.js
const transformCssToEsm = async (input) => {
  const results = transformCssToEsmModule(input);
  const optimizeResults = await optimizeCss({
    autoprefixer: input.autoprefixer,
    input: results.styleText,
    filePath: input.file,
    minify: true,
    sourceMap: input.sourceMap,
  });
  results.diagnostics.push(...optimizeResults.diagnostics);
  if (hasError(optimizeResults.diagnostics)) {
    return results;
  }
  results.styleText = optimizeResults.output;
  return generateTransformCssToEsm(input, results);
};
const transformCssToEsmSync = (input) => {
  const results = transformCssToEsmModule(input);
  return generateTransformCssToEsm(input, results);
};
const transformCssToEsmModule = (input) => {
  const results = {
    styleText: input.input,
    output: '',
    map: null,
    diagnostics: [],
    imports: [],
    defaultVarName: createCssVarName(input.file, input.mode),
    styleDocs: [],
  };
  if (input.docs) {
    parseStyleDocs(results.styleDocs, input.input);
  }
  try {
    const varNames = new Set([results.defaultVarName]);
    if (isString(input.tag)) {
      if (input.encapsulation === 'scoped' || (input.encapsulation === 'shadow' && input.commentOriginalSelector)) {
        const scopeId = getScopeId(input.tag, input.mode);
        results.styleText = scopeCss(results.styleText, scopeId, input.commentOriginalSelector);
      }
    }
    const cssImports = getCssToEsmImports(varNames, results.styleText, input.file, input.mode);
    cssImports.forEach(cssImport => {
      // remove the original css @imports
      results.styleText = results.styleText.replace(cssImport.srcImportText, '');
      const importPath = serializeImportPath({
        importeePath: cssImport.filePath,
        importerPath: input.file,
        tag: input.tag,
        encapsulation: input.encapsulation,
        mode: input.mode,
      });
      // str.append(`import ${cssImport.varName} from '${importPath}';\n`);
      results.imports.push({
        varName: cssImport.varName,
        importPath,
      });
    });
  }
  catch (e) {
    catchError(results.diagnostics, e);
  }
  return results;
};
const generateTransformCssToEsm = (input, results) => {
  const s = new MagicString$1('');
  if (input.module === 'cjs') {
    // CommonJS
    results.imports.forEach(cssImport => {
      s.append(`const ${cssImport.varName} = require('${cssImport.importPath}');\n`);
    });
    s.append(`const ${results.defaultVarName} = `);
    results.imports.forEach(cssImport => {
      s.append(`${cssImport.varName} + `);
    });
    s.append(`${JSON.stringify(results.styleText)};\n`);
    s.append(`module.exports = ${results.defaultVarName};`);
  }
  else {
    // ESM
    results.imports.forEach(cssImport => {
      s.append(`import ${cssImport.varName} from '${cssImport.importPath}';\n`);
    });
    s.append(`const ${results.defaultVarName} = `);
    results.imports.forEach(cssImport => {
      s.append(`${cssImport.varName} + `);
    });
    s.append(`${JSON.stringify(results.styleText)};\n`);
    s.append(`export default ${results.defaultVarName};`);
  }
  results.output = s.toString();
  return results;
};
const getCssToEsmImports = (varNames, cssText, filePath, modeName) => {
  const cssImports = [];
  if (!cssText.includes('@import')) {
    // no @import at all, so don't bother
    return cssImports;
  }
  cssText = stripCssComments(cssText);
  const dir = path.dirname(filePath);
  let r;
  while ((r = CSS_IMPORT_RE.exec(cssText))) {
    const cssImportData = {
      srcImportText: r[0],
      url: r[4].replace(/[\"\'\)]/g, ''),
      filePath: null,
      varName: null,
    };
    if (!isLocalCssImport(cssImportData.srcImportText)) {
      // do nothing for @import url(http://external.css)
      continue;
    }
    else if (isCssNodeModule(cssImportData.url)) {
      // do not resolve this path cuz it starts with node resolve id ~
      continue;
    }
    else if (path.isAbsolute(cssImportData.url)) {
      // absolute path already
      cssImportData.filePath = normalizePath(cssImportData.url);
    }
    else {
      // relative path
      cssImportData.filePath = normalizePath(path.resolve(dir, cssImportData.url));
    }
    cssImportData.varName = createCssVarName(cssImportData.filePath, modeName);
    if (varNames.has(cssImportData.varName)) {
      cssImportData.varName += varNames.size;
    }
    varNames.add(cssImportData.varName);
    cssImports.push(cssImportData);
  }
  return cssImports;
};
const CSS_IMPORT_RE = /(@import)\s+(url\()?\s?(.*?)\s?\)?([^;]*);?/gi;
const isCssNodeModule = (url) => {
  return url.startsWith('~');
};
const isLocalCssImport = (srcImport) => {
  srcImport = srcImport.toLowerCase();
  if (srcImport.includes('url(')) {
    srcImport = srcImport.replace(/\"/g, '');
    srcImport = srcImport.replace(/\'/g, '');
    srcImport = srcImport.replace(/\s/g, '');
    if (srcImport.includes('url(http') || srcImport.includes('url(//')) {
      return false;
    }
  }
  return true;
};
const createCssVarName = (filePath, modeName) => {
  let varName = path.basename(filePath);
  if (modeName && modeName !== DEFAULT_STYLE_MODE && !varName.includes(modeName)) {
    varName = modeName + '-' + varName;
  }
  return createJsVarName(varName);
};

// MODULE: compiler/build/build-ctx.js
/**
 * A new BuildCtx object is created for every build
 * and rebuild.
 */
class BuildContext {
  constructor(config, compilerCtx) {
    this.buildId = -1;
    this.buildMessages = [];
    this.buildResults = null;
    this.buildResults_next = null;
    this.bundleBuildCount = 0;
    this.collections = [];
    this.completedTasks = [];
    this.components = [];
    this.componentGraph = new Map();
    this.data = {};
    this.diagnostics = [];
    this.dirsAdded = [];
    this.dirsDeleted = [];
    this.entryModules = [];
    this.filesAdded = [];
    this.filesChanged = [];
    this.filesDeleted = [];
    this.filesUpdated = [];
    this.filesWritten = [];
    this.globalStyle = undefined;
    this.hasConfigChanges = false;
    this.hasFinished = false;
    this.hasHtmlChanges = false;
    this.hasPrintedResults = false;
    this.hasServiceWorkerChanges = false;
    this.hasScriptChanges = true;
    this.hasStyleChanges = true;
    this.hydrateAppFilePath = null;
    this.indexBuildCount = 0;
    this.indexDoc = undefined;
    this.isRebuild = false;
    this.moduleFiles = [];
    this.outputs = [];
    this.packageJson = {};
    this.packageJsonFilePath = null;
    this.pendingCopyTasks = [];
    this.requiresFullBuild = true;
    this.scriptsAdded = [];
    this.scriptsDeleted = [];
    this.startTime = Date.now();
    this.styleBuildCount = 0;
    this.stylesPromise = null;
    this.stylesUpdated = [];
    this.timeSpan = null;
    this.transpileBuildCount = 0;
    this.config = config;
    this.compilerCtx = compilerCtx;
    this.buildId = ++this.compilerCtx.activeBuildId;
    this.debug = config.logger.debug.bind(config.logger);
  }
  start() {
    // get the build id from the incremented activeBuildId
    // print out a good message
    const msg = `${this.isRebuild ? 'rebuild' : 'build'}, ${this.config.fsNamespace}, ${this.config.devMode ? 'dev' : 'prod'} mode, started`;
    const buildLog = {
      buildId: this.buildId,
      messages: [],
      progress: 0,
    };
    this.compilerCtx.events.emit('buildLog', buildLog);
    // create a timespan for this build
    this.timeSpan = this.createTimeSpan(msg);
    // create a build timestamp for this build
    this.timestamp = getBuildTimestamp();
    // debug log our new build
    this.debug(`start build, ${this.timestamp}`);
    const buildStart = {
      buildId: this.buildId,
      timestamp: this.timestamp,
    };
    this.compilerCtx.events.emit('buildStart', buildStart);
  }
  createTimeSpan(msg, debug) {
    if (!this.hasFinished || debug) {
      if (debug) {
        if (this.config.watch) {
          msg = `${this.config.logger.cyan('[' + this.buildId + ']')} ${msg}`;
        }
      }
      const timeSpan = this.config.logger.createTimeSpan(msg, debug, this.buildMessages);
      if (!debug && this.compilerCtx.events) {
        const buildLog = {
          buildId: this.buildId,
          messages: this.buildMessages,
          progress: getProgress(this.completedTasks),
        };
        this.compilerCtx.events.emit('buildLog', buildLog);
      }
      return {
        duration: () => {
          return timeSpan.duration();
        },
        finish: (finishedMsg, color, bold, newLineSuffix) => {
          if (!this.hasFinished || debug) {
            if (debug) {
              if (this.config.watch) {
                finishedMsg = `${this.config.logger.cyan('[' + this.buildId + ']')} ${finishedMsg}`;
              }
            }
            timeSpan.finish(finishedMsg, color, bold, newLineSuffix);
            if (!debug) {
              const buildLog = {
                buildId: this.buildId,
                messages: this.buildMessages.slice(),
                progress: getProgress(this.completedTasks),
              };
              this.compilerCtx.events.emit('buildLog', buildLog);
            }
          }
          return timeSpan.duration();
        },
      };
    }
    return {
      duration() {
        return 0;
      },
      finish() {
        return 0;
      },
    };
  }
  debug(msg) {
    this.config.logger.debug(msg);
  }
  get hasError() {
    return hasError(this.diagnostics);
  }
  get hasWarning() {
    return hasWarning(this.diagnostics);
  }
  progress(t) {
    this.completedTasks.push(t);
  }
  async validateTypesBuild() {
    if (this.hasError) {
      // no need to wait on this one since
      // we already aborted this build
      return;
    }
    if (!this.validateTypesPromise) {
      // there is no pending validate types promise
      // so it probably already finished
      // so no need to wait on anything
      return;
    }
    if (!this.config.watch) {
      // this is not a watch build, so we need to make
      // sure that the type validation has finished
      this.debug(`build, non-watch, waiting on validateTypes`);
      await this.validateTypesPromise;
      this.debug(`build, non-watch, finished waiting on validateTypes`);
    }
  }
}
const getBuildTimestamp = () => {
  const d = new Date();
  // YYYY-MM-DDThh:mm:ss
  let timestamp = d.getUTCFullYear() + '-';
  timestamp += ('0' + (d.getUTCMonth() + 1)).slice(-2) + '-';
  timestamp += ('0' + d.getUTCDate()).slice(-2) + 'T';
  timestamp += ('0' + d.getUTCHours()).slice(-2) + ':';
  timestamp += ('0' + d.getUTCMinutes()).slice(-2) + ':';
  timestamp += ('0' + d.getUTCSeconds()).slice(-2);
  return timestamp;
};
const getProgress = (completedTasks) => {
  let progressIndex = 0;
  const taskKeys = Object.keys(ProgressTask);
  taskKeys.forEach((taskKey, index) => {
    if (completedTasks.includes(ProgressTask[taskKey])) {
      progressIndex = index;
    }
  });
  return (progressIndex + 1) / taskKeys.length;
};
const ProgressTask = {
  emptyOutputTargets: {},
  transpileApp: {},
  generateStyles: {},
  generateOutputTargets: {},
  validateTypesBuild: {},
  writeBuildFiles: {},
};

// MODULE: compiler/events.js
const buildEvents = () => {
  const evCallbacks = [];
  const off = (callback) => {
    const index = evCallbacks.findIndex(ev => ev.callback === callback);
    if (index > -1) {
      evCallbacks.splice(index, 1);
      return true;
    }
    return false;
  };
  const on = (arg0, arg1) => {
    if (typeof arg0 === 'function') {
      const eventName = null;
      const callback = arg0;
      evCallbacks.push({
        eventName,
        callback,
      });
      return () => off(callback);
    }
    else if (typeof arg0 === 'string' && typeof arg1 === 'function') {
      const eventName = arg0.toLowerCase().trim();
      const callback = arg1;
      evCallbacks.push({
        eventName,
        callback,
      });
      return () => off(callback);
    }
    return () => false;
  };
  const emit = (eventName, data) => {
    const normalizedEventName = eventName.toLowerCase().trim();
    for (const ev of evCallbacks) {
      if (ev.eventName == null) {
        try {
          ev.callback(eventName, data);
        }
        catch (e) {
          console.error(e);
        }
      }
      else if (ev.eventName === normalizedEventName) {
        try {
          ev.callback(data);
        }
        catch (e) {
          console.error(e);
        }
      }
    }
  };
  const unsubscribeAll = () => {
    evCallbacks.length = 0;
  };
  return {
    emit,
    on,
    unsubscribeAll,
  };
};

// MODULE: compiler/build/compiler-ctx.js
/**
 * The CompilerCtx is a persistent object that's reused throughout
 * all builds and rebuilds. The data within this object is used
 * for in-memory caching, and can be reset, but the object itself
 * is always the same.
 */
class CompilerContext {
  constructor() {
    this.version = 2;
    this.activeBuildId = -1;
    this.activeFilesAdded = [];
    this.activeFilesDeleted = [];
    this.activeFilesUpdated = [];
    this.activeDirsAdded = [];
    this.activeDirsDeleted = [];
    this.cachedStyleMeta = new Map();
    this.collections = [];
    this.compilerOptions = null;
    this.events = buildEvents();
    this.fsWatcher = null;
    this.hasFsWatcherEvents = false;
    this.hasLoggedServerUrl = false;
    this.hasSuccessfulBuild = false;
    this.isActivelyBuilding = false;
    this.lastBuildResults = null;
    this.lastBuildStyles = new Map();
    this.lastComponentStyleInput = new Map();
    this.moduleMap = new Map();
    this.nodeMap = new WeakMap();
    this.resolvedCollections = new Set();
    this.rollupCacheHydrate = null;
    this.rollupCacheLazy = null;
    this.rollupCacheNative = null;
    this.rootTsFiles = [];
    this.tsService = null;
    this.styleModeNames = new Set();
    this.rollupCache = new Map();
    this.changedModules = new Set();
    this.changedFiles = new Set();
    this.worker = null;
  }
  reset() {
    this.cache.clear();
    this.cachedStyleMeta.clear();
    this.cachedGlobalStyle = null;
    this.collections.length = 0;
    this.compilerOptions = null;
    this.lastComponentStyleInput.clear();
    this.rollupCacheHydrate = null;
    this.rollupCacheLazy = null;
    this.rollupCacheNative = null;
    this.moduleMap.clear();
    this.resolvedCollections.clear();
    this.rootTsFiles.length = 0;
    this.tsService = null;
    if (this.fs != null) {
      this.fs.clearCache();
    }
  }
}
const getModuleLegacy = (_config, compilerCtx, sourceFilePath) => {
  sourceFilePath = normalizePath(sourceFilePath);
  const moduleFile = compilerCtx.moduleMap.get(sourceFilePath);
  if (moduleFile != null) {
    return moduleFile;
  }
  else {
    const sourceFileDir = dirname(sourceFilePath);
    const sourceFileExt = extname(sourceFilePath);
    const sourceFileName = basename(sourceFilePath, sourceFileExt);
    const jsFilePath = join(sourceFileDir, sourceFileName + '.js');
    const moduleFile = {
      sourceFilePath: sourceFilePath,
      jsFilePath: jsFilePath,
      cmps: [],
      coreRuntimeApis: [],
      collectionName: null,
      dtsFilePath: null,
      excludeFromCollection: false,
      externalImports: [],
      hasVdomAttribute: false,
      hasVdomXlink: false,
      hasVdomClass: false,
      hasVdomFunctional: false,
      hasVdomKey: false,
      hasVdomListener: false,
      hasVdomPropOrAttr: false,
      hasVdomRef: false,
      hasVdomRender: false,
      hasVdomStyle: false,
      hasVdomText: false,
      htmlAttrNames: [],
      htmlTagNames: [],
      isCollectionDependency: false,
      isLegacy: false,
      localImports: [],
      originalCollectionComponentPath: null,
      originalImports: [],
      potentialCmpRefs: [],
      staticSourceFile: null,
      staticSourceFileText: '',
    };
    compilerCtx.moduleMap.set(sourceFilePath, moduleFile);
    return moduleFile;
  }
};
const resetModuleLegacy = (moduleFile) => {
  moduleFile.cmps.length = 0;
  moduleFile.coreRuntimeApis.length = 0;
  moduleFile.collectionName = null;
  moduleFile.dtsFilePath = null;
  moduleFile.excludeFromCollection = false;
  moduleFile.externalImports.length = 0;
  moduleFile.isCollectionDependency = false;
  moduleFile.localImports.length = 0;
  moduleFile.originalCollectionComponentPath = null;
  moduleFile.originalImports.length = 0;
  moduleFile.hasVdomXlink = false;
  moduleFile.hasVdomAttribute = false;
  moduleFile.hasVdomClass = false;
  moduleFile.hasVdomFunctional = false;
  moduleFile.hasVdomKey = false;
  moduleFile.hasVdomListener = false;
  moduleFile.hasVdomRef = false;
  moduleFile.hasVdomRender = false;
  moduleFile.hasVdomStyle = false;
  moduleFile.hasVdomText = false;
  moduleFile.htmlAttrNames.length = 0;
  moduleFile.htmlTagNames.length = 0;
  moduleFile.potentialCmpRefs.length = 0;
};

// MODULE: compiler/transformers/decorators-to-static/decorator-utils.js
const getDeclarationParameters = (decorator) => {
  if (!ts.isCallExpression(decorator.expression)) {
    return [];
  }
  return decorator.expression.arguments.map(getDeclarationParameter);
};
const getDeclarationParameter = (arg) => {
  if (ts.isObjectLiteralExpression(arg)) {
    return objectLiteralToObjectMap(arg);
  }
  else if (ts.isStringLiteral(arg)) {
    return arg.text;
  }
  throw new Error(`invalid decorator argument: ${arg.getText()}`);
};
const isDecoratorNamed = (propName) => {
  return (dec) => {
    return ts.isCallExpression(dec.expression) && dec.expression.expression.getText() === propName;
  };
};

// MODULE: compiler/transformers/decorators-to-static/style-to-static.js
const styleToStatic = (newMembers, componentOptions) => {
  const defaultModeStyles = [];
  if (componentOptions.styleUrls) {
    if (Array.isArray(componentOptions.styleUrls)) {
      defaultModeStyles.push(...normalizeStyleUrl(componentOptions.styleUrls));
    }
    else {
      defaultModeStyles.push(...normalizeStyleUrl(componentOptions.styleUrls[DEFAULT_STYLE_MODE]));
    }
  }
  if (componentOptions.styleUrl) {
    defaultModeStyles.push(...normalizeStyleUrl(componentOptions.styleUrl));
  }
  let styleUrls = {};
  if (componentOptions.styleUrls && !Array.isArray(componentOptions.styleUrls)) {
    styleUrls = normalizeStyleUrls(componentOptions.styleUrls);
  }
  if (defaultModeStyles.length > 0) {
    styleUrls[DEFAULT_STYLE_MODE] = defaultModeStyles;
  }
  if (Object.keys(styleUrls).length > 0) {
    const originalStyleUrls = convertValueToLiteral(styleUrls);
    newMembers.push(createStaticGetter('originalStyleUrls', originalStyleUrls));
    const norlizedStyleExt = normalizeExtension(styleUrls);
    const normalizedStyleExp = convertValueToLiteral(norlizedStyleExt);
    newMembers.push(createStaticGetter('styleUrls', normalizedStyleExp));
  }
  if (typeof componentOptions.styles === 'string') {
    const styles = componentOptions.styles.trim();
    if (styles.length > 0) {
      // @Component({
      //   styles: ":host {...}"
      // })
      newMembers.push(createStaticGetter('styles', ts.createLiteral(styles)));
    }
  }
  else if (componentOptions.styles) {
    const convertIdentifier = componentOptions.styles;
    if (convertIdentifier.__identifier) {
      // import styles from './styles.css';
      // @Component({
      //   styles
      // })
      const stylesIdentifier = convertIdentifier.__escapedText;
      newMembers.push(createStaticGetter('styles', ts.createIdentifier(stylesIdentifier)));
    }
    else if (typeof convertIdentifier === 'object') {
      // import ios from './ios.css';
      // import md from './md.css';
      // @Component({
      //   styles: {
      //   ios
      //   md
      //   }
      // })
      if (Object.keys(convertIdentifier).length > 0) {
        newMembers.push(createStaticGetter('styles', convertValueToLiteral(convertIdentifier)));
      }
    }
  }
};
const normalizeExtension = (styleUrls) => {
  const compilerStyleUrls = {};
  Object.keys(styleUrls).forEach(key => {
    compilerStyleUrls[key] = styleUrls[key].map(s => useCss(s));
  });
  return compilerStyleUrls;
};
const useCss = (stylePath) => {
  const sourceFileDir = dirname(stylePath);
  const sourceFileExt = extname(stylePath);
  const sourceFileName = basename(stylePath, sourceFileExt);
  return join(sourceFileDir, sourceFileName + '.css');
};
const normalizeStyleUrls = (styleUrls) => {
  const compilerStyleUrls = {};
  Object.keys(styleUrls).forEach(key => {
    compilerStyleUrls[key] = normalizeStyleUrl(styleUrls[key]);
  });
  return compilerStyleUrls;
};
const normalizeStyleUrl = (style) => {
  if (Array.isArray(style)) {
    return style;
  }
  if (style) {
    return [style];
  }
  return [];
};

// MODULE: compiler/transformers/decorators-to-static/component-decorator.js
const componentDecoratorToStatic = (config, typeChecker, diagnostics, cmpNode, newMembers, componentDecorator) => {
  const [componentOptions] = getDeclarationParameters(componentDecorator);
  if (!componentOptions) {
    return;
  }
  if (!validateComponent(config, diagnostics, typeChecker, componentOptions, cmpNode, componentDecorator)) {
    return;
  }
  newMembers.push(createStaticGetter('is', convertValueToLiteral(componentOptions.tag.trim())));
  if (componentOptions.shadow) {
    newMembers.push(createStaticGetter('encapsulation', convertValueToLiteral('shadow')));
    if (typeof componentOptions.shadow !== 'boolean') {
      if (componentOptions.shadow.delegatesFocus === true) {
        newMembers.push(createStaticGetter('delegatesFocus', convertValueToLiteral(true)));
      }
    }
  }
  else if (componentOptions.scoped) {
    newMembers.push(createStaticGetter('encapsulation', convertValueToLiteral('scoped')));
  }
  styleToStatic(newMembers, componentOptions);
  let assetsDirs = componentOptions.assetsDirs || [];
  if (componentOptions.assetsDir) {
    assetsDirs = [...assetsDirs, componentOptions.assetsDir];
  }
  if (assetsDirs.length > 0) {
    newMembers.push(createStaticGetter('assetsDirs', convertValueToLiteral(assetsDirs)));
  }
};
const validateComponent = (config, diagnostics, typeChecker, componentOptions, cmpNode, componentDecorator) => {
  const extendNode = cmpNode.heritageClauses && cmpNode.heritageClauses.find(c => c.token === ts.SyntaxKind.ExtendsKeyword);
  if (extendNode) {
    const err = buildError(diagnostics);
    err.messageText = `Classes decorated with @Component can not extend from a base class.
  Stencil needs to be able to switch between different base classes in order to implement the different output targets such as: lazy and raw web components.`;
    augmentDiagnosticWithNode(err, extendNode);
    return false;
  }
  if (componentOptions.shadow && componentOptions.scoped) {
    const err = buildError(diagnostics);
    err.messageText = `Components cannot be "scoped" and "shadow" at the same time, they are mutually exclusive configurations.`;
    augmentDiagnosticWithNode(err, findTagNode('scoped', componentDecorator));
    return false;
  }
  const constructor = cmpNode.members.find(ts.isConstructorDeclaration);
  if (constructor && constructor.parameters.length > 0) {
    const err = buildError(diagnostics);
    err.messageText = `Classes decorated with @Component can not have a "constructor" that takes arguments.
  All data required by a component must be passed by using class properties decorated with @Prop()`;
    augmentDiagnosticWithNode(err, constructor.parameters[0]);
    return false;
  }
  // check if class has more than one decorator
  const otherDecorator = cmpNode.decorators && cmpNode.decorators.find(d => d !== componentDecorator);
  if (otherDecorator) {
    const err = buildError(diagnostics);
    err.messageText = `Classes decorated with @Component can not be decorated with more decorators.
  Stencil performs extensive static analysis on top of your components in order to generate the necessary metadata, runtime decorators at the components level make this task very hard.`;
    augmentDiagnosticWithNode(err, otherDecorator);
    return false;
  }
  const tag = componentOptions.tag;
  if (typeof tag !== 'string' || tag.trim().length === 0) {
    const err = buildError(diagnostics);
    err.messageText = `tag missing in component decorator`;
    augmentDiagnosticWithNode(err, componentDecorator);
    return false;
  }
  const tagError = validateComponentTag(tag);
  if (tagError) {
    const err = buildError(diagnostics);
    err.messageText = `${tagError}. Please refer to https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name for more info.`;
    augmentDiagnosticWithNode(err, findTagNode('tag', componentDecorator));
    return false;
  }
  if (!config._isTesting) {
    const nonTypeExports = typeChecker
      .getExportsOfModule(typeChecker.getSymbolAtLocation(cmpNode.getSourceFile()))
      .filter(symbol => (symbol.flags & (ts.SymbolFlags.Interface | ts.SymbolFlags.TypeAlias)) === 0)
      .filter(symbol => symbol.name !== cmpNode.name.text);
    nonTypeExports.forEach(symbol => {
      const err = buildError(diagnostics);
      err.messageText = `To allow efficient bundling, modules using @Component() can only have a single export which is the component class itself.
    Any other exports should be moved to a separate file.
    For further information check out: https://stenciljs.com/docs/module-bundling`;
      const errorNode = symbol.valueDeclaration ? symbol.valueDeclaration : symbol.declarations[0];
      augmentDiagnosticWithNode(err, errorNode);
    });
    if (nonTypeExports.length > 0) {
      return false;
    }
  }
  return true;
};
const findTagNode = (propName, node) => {
  if (ts.isDecorator(node) && ts.isCallExpression(node.expression)) {
    const arg = node.expression.arguments[0];
    if (ts.isObjectLiteralExpression(arg)) {
      arg.properties.forEach(p => {
        if (ts.isPropertyAssignment(p)) {
          if (p.name.getText() === propName) {
            node = p.initializer;
          }
        }
      });
    }
  }
  return node;
};

// MODULE: compiler/transformers/decorators-to-static/element-decorator.js
const elementDecoratorsToStatic = (diagnostics, decoratedMembers, typeChecker, newMembers) => {
  const elementRefs = decoratedMembers
    .filter(ts.isPropertyDeclaration)
    .map(prop => parseElementDecorator(diagnostics, typeChecker, prop))
    .filter(element => !!element);
  if (elementRefs.length > 0) {
    newMembers.push(createStaticGetter('elementRef', ts.createLiteral(elementRefs[0])));
    if (elementRefs.length > 1) {
      const error = buildError(diagnostics);
      error.messageText = `It's not valid to add more than one Element() decorator`;
    }
  }
};
const parseElementDecorator = (_diagnostics, _typeChecker, prop) => {
  const elementDecorator = prop.decorators && prop.decorators.find(isDecoratorNamed('Element'));
  if (elementDecorator == null) {
    return null;
  }
  return prop.name.getText();
};

// MODULE: compiler/transformers/decorators-to-static/event-decorator.js
const eventDecoratorsToStatic = (diagnostics, decoratedProps, typeChecker, newMembers) => {
  const events = decoratedProps
    .filter(ts.isPropertyDeclaration)
    .map(prop => parseEventDecorator(diagnostics, typeChecker, prop))
    .filter(ev => !!ev);
  if (events.length > 0) {
    newMembers.push(createStaticGetter('events', convertValueToLiteral(events)));
  }
};
const parseEventDecorator = (diagnostics, typeChecker, prop) => {
  const eventDecorator = prop.decorators.find(isDecoratorNamed('Event'));
  if (eventDecorator == null) {
    return null;
  }
  const [opts] = getDeclarationParameters(eventDecorator);
  const memberName = prop.name.getText();
  if (!memberName) {
    return null;
  }
  const symbol = typeChecker.getSymbolAtLocation(prop.name);
  const name = getEventName(opts, memberName);
  validateEventName(diagnostics, prop.name, name);
  const eventMeta = {
    method: memberName,
    name,
    bubbles: opts && typeof opts.bubbles === 'boolean' ? opts.bubbles : true,
    cancelable: opts && typeof opts.cancelable === 'boolean' ? opts.cancelable : true,
    composed: opts && typeof opts.composed === 'boolean' ? opts.composed : true,
    docs: serializeSymbol(typeChecker, symbol),
    complexType: getComplexType(typeChecker, prop),
  };
  validateReferences(diagnostics, eventMeta.complexType.references, prop.type);
  return eventMeta;
};
const getEventName = (eventOptions, memberName) => {
  if (eventOptions && typeof eventOptions.eventName === 'string' && eventOptions.eventName.trim().length > 0) {
    // always use the event name if given
    return eventOptions.eventName.trim();
  }
  return memberName;
};
const getComplexType = (typeChecker, node) => {
  const sourceFile = node.getSourceFile();
  const eventType = node.type ? getEventType(node.type) : null;
  return {
    original: eventType ? eventType.getText() : 'any',
    resolved: eventType ? resolveType(typeChecker, typeChecker.getTypeFromTypeNode(eventType)) : 'any',
    references: eventType ? getAttributeTypeInfo(eventType, sourceFile) : {},
  };
};
const getEventType = (type) => {
  if (ts.isTypeReferenceNode(type) && ts.isIdentifier(type.typeName) && type.typeName.text === 'EventEmitter' && type.typeArguments && type.typeArguments.length > 0) {
    return type.typeArguments[0];
  }
  return null;
};
const validateEventName = (diagnostics, node, eventName) => {
  if (/^[A-Z]/.test(eventName)) {
    const diagnostic = buildWarn(diagnostics);
    diagnostic.messageText = [
      `In order to be compatible with all event listeners on elements, the event name `,
      `cannot start with a capital letter. `,
      `Please lowercase the first character for the event to best work with all listeners.`,
    ].join('');
    augmentDiagnosticWithNode(diagnostic, node);
    return;
  }
  if (/^on[A-Z]/.test(eventName)) {
    const warn = buildWarn(diagnostics);
    const suggestedEventName = eventName[2].toLowerCase() + eventName.slice(3);
    warn.messageText = `Events decorated with @Event() should describe the actual DOM event name, not the handler. In other words "${eventName}" would be better named as "${suggestedEventName}".`;
    augmentDiagnosticWithNode(warn, node);
    return;
  }
  if (DOM_EVENT_NAMES.has(eventName.toLowerCase())) {
    const diagnostic = buildWarn(diagnostics);
    diagnostic.messageText = `The event name conflicts with the "${eventName}" native DOM event name.`;
    augmentDiagnosticWithNode(diagnostic, node);
    return;
  }
};
const DOM_EVENT_NAMES = new Set([
  'CheckboxStateChange',
  'DOMContentLoaded',
  'DOMMenuItemActive',
  'DOMMenuItemInactive',
  'DOMMouseScroll',
  'MSManipulationStateChanged',
  'MSPointerHover',
  'MozAudioAvailable',
  'MozGamepadButtonDown',
  'MozGamepadButtonUp',
  'MozMousePixelScroll',
  'MozOrientation',
  'MozScrolledAreaChanged',
  'RadioStateChange',
  'SVGAbort',
  'SVGError',
  'SVGLoad',
  'SVGResize',
  'SVGScroll',
  'SVGUnload',
  'SVGZoom',
  'ValueChange',
  'abort',
  'afterprint',
  'afterscriptexecute',
  'alerting',
  'animationcancel',
  'animationend',
  'animationiteration',
  'animationstart',
  'appinstalled',
  'audioend',
  'audioprocess',
  'audiostart',
  'auxclick',
  'beforeinstallprompt',
  'beforeprint',
  'beforescriptexecute',
  'beforeunload',
  'beginEvent',
  'blur',
  'boundary',
  'broadcast',
  'busy',
  'callschanged',
  'canplay',
  'canplaythrough',
  'cardstatechange',
  'cfstatechange',
  'change',
  'chargingchange',
  'chargingtimechange',
  'checking',
  'click',
  'command',
  'commandupdate',
  'compassneedscalibration',
  'complete',
  'compositionend',
  'compositionstart',
  'compositionupdate',
  'connected',
  'connecting',
  'connectionInfoUpdate',
  'contextmenu',
  'copy',
  'cut',
  'datachange',
  'dataerror',
  'dblclick',
  'delivered',
  'devicechange',
  'devicemotion',
  'deviceorientation',
  'dialing',
  'disabled',
  'dischargingtimechange',
  'disconnected',
  'disconnecting',
  'downloading',
  'drag',
  'dragend',
  'dragenter',
  'dragleave',
  'dragover',
  'dragstart',
  'drop',
  'durationchange',
  'emptied',
  'enabled',
  'end',
  'endEvent',
  'ended',
  'error',
  'focus',
  'focusin',
  'focusout',
  'fullscreenchange',
  'fullscreenerror',
  'gamepadconnected',
  'gamepaddisconnected',
  'gotpointercapture',
  'hashchange',
  'held',
  'holding',
  'icccardlockerror',
  'iccinfochange',
  'incoming',
  'input',
  'invalid',
  'keydown',
  'keypress',
  'keyup',
  'languagechange',
  'levelchange',
  'load',
  'loadeddata',
  'loadedmetadata',
  'loadend',
  'loadstart',
  'localized',
  'lostpointercapture',
  'mark',
  'message',
  'messageerror',
  'mousedown',
  'mouseenter',
  'mouseleave',
  'mousemove',
  'mouseout',
  'mouseover',
  'mouseup',
  'mousewheel',
  'mozbrowseractivitydone',
  'mozbrowserasyncscroll',
  'mozbrowseraudioplaybackchange',
  'mozbrowsercaretstatechanged',
  'mozbrowserclose',
  'mozbrowsercontextmenu',
  'mozbrowserdocumentfirstpaint',
  'mozbrowsererror',
  'mozbrowserfindchange',
  'mozbrowserfirstpaint',
  'mozbrowsericonchange',
  'mozbrowserloadend',
  'mozbrowserloadstart',
  'mozbrowserlocationchange',
  'mozbrowsermanifestchange',
  'mozbrowsermetachange',
  'mozbrowseropensearch',
  'mozbrowseropentab',
  'mozbrowseropenwindow',
  'mozbrowserresize',
  'mozbrowserscroll',
  'mozbrowserscrollareachanged',
  'mozbrowserscrollviewchange',
  'mozbrowsersecuritychange',
  'mozbrowserselectionstatechanged',
  'mozbrowsershowmodalprompt',
  'mozbrowsertitlechange',
  'mozbrowserusernameandpasswordrequired',
  'mozbrowservisibilitychange',
  'moztimechange',
  'msContentZoom',
  'nomatch',
  'notificationclick',
  'noupdate',
  'obsolete',
  'offline',
  'online',
  'orientationchange',
  'overflow',
  'pagehide',
  'pageshow',
  'paste',
  'pause',
  'play',
  'playing',
  'pointercancel',
  'pointerdown',
  'pointerenter',
  'pointerleave',
  'pointerlockchange',
  'pointerlockerror',
  'pointermove',
  'pointerout',
  'pointerover',
  'pointerup',
  'popstate',
  'popuphidden',
  'popuphiding',
  'popupshowing',
  'popupshown',
  'progress',
  'push',
  'pushsubscriptionchange',
  'ratechange',
  'readystatechange',
  'received',
  'repeatEvent',
  'reset',
  'resize',
  'resourcetimingbufferfull',
  'result',
  'resume',
  'resuming',
  'scroll',
  'seeked',
  'seeking',
  'select',
  'selectionchange',
  'selectstart',
  'sent',
  'show',
  'slotchange',
  'smartcard-insert',
  'smartcard-remove',
  'soundend',
  'soundstart',
  'speechend',
  'speechstart',
  'stalled',
  'start',
  'statechange',
  'statuschange',
  'stkcommand',
  'stksessionend',
  'storage',
  'submit',
  'suspend',
  'timeout',
  'timeupdate',
  'touchcancel',
  'touchend',
  'touchenter',
  'touchleave',
  'touchmove',
  'touchstart',
  'transitioncancel',
  'transitionend',
  'transitionrun',
  'transitionstart',
  'underflow',
  'unload',
  'updateready',
  'userproximity',
  'ussdreceived',
  'visibilitychange',
  'voicechange',
  'voiceschanged',
  'volumechange',
  'vrdisplayactivate',
  'vrdisplayblur',
  'vrdisplayconnect',
  'vrdisplaydeactivate',
  'vrdisplaydisconnect',
  'vrdisplayfocus',
  'vrdisplaypresentchange',
  'waiting',
  'wheel',
].map(e => e.toLowerCase()));

// MODULE: compiler/transformers/decorators-to-static/listen-decorator.js
const listenDecoratorsToStatic = (diagnostics, decoratedMembers, newMembers) => {
  const listeners = decoratedMembers.filter(ts.isMethodDeclaration).map(method => parseListenDecorators(diagnostics, method));
  const flatListeners = flatOne(listeners);
  if (flatListeners.length > 0) {
    newMembers.push(createStaticGetter('listeners', convertValueToLiteral(flatListeners)));
  }
};
const parseListenDecorators = (diagnostics, method) => {
  const listenDecorators = method.decorators.filter(isDecoratorNamed('Listen'));
  if (listenDecorators.length === 0) {
    return [];
  }
  return listenDecorators.map(listenDecorator => {
    const methodName = method.name.getText();
    const [listenText, listenOptions] = getDeclarationParameters(listenDecorator);
    const eventNames = listenText.split(',');
    if (eventNames.length > 1) {
      const err = buildError(diagnostics);
      err.messageText = 'Please use multiple @Listen() decorators instead of comma-separated names.';
      augmentDiagnosticWithNode(err, listenDecorator);
    }
    return parseListener(diagnostics, eventNames[0], listenOptions, methodName, listenDecorator);
  });
};
const parseListener = (diagnostics, eventName, opts = {}, methodName, decoratorNode) => {
  let rawEventName = eventName.trim();
  let target = opts.target;
  // DEPRECATED: handle old syntax (`TARGET:event`)
  if (!target) {
    const splt = eventName.split(':');
    const prefix = splt[0].toLowerCase().trim();
    if (splt.length > 1 && isValidTargetValue(prefix)) {
      rawEventName = splt[1].trim();
      target = prefix;
      const warn = buildWarn(diagnostics);
      warn.messageText = `Deprecated @Listen() feature on "${methodName}". Use @Listen('${rawEventName}', { target: '${prefix}' }) instead.`;
      augmentDiagnosticWithNode(warn, decoratorNode);
    }
  }
  // DEPRECATED: handle keycode syntax (`event:KEY`)
  const [finalEvent, keycode, rest] = rawEventName.split('.');
  if (rest === undefined && isValidKeycodeSuffix(keycode)) {
    rawEventName = finalEvent;
    const warn = buildError(diagnostics);
    warn.messageText = `Deprecated @Listen() feature on "${methodName}". Using "${rawEventName}" is no longer supported, use "event.key" within the function itself instead.`;
    augmentDiagnosticWithNode(warn, decoratorNode);
  }
  const listener = {
    name: rawEventName,
    method: methodName,
    target,
    capture: typeof opts.capture === 'boolean' ? opts.capture : false,
    passive: typeof opts.passive === 'boolean'
      ? opts.passive
      : // if the event name is kown to be a passive event then set it to true
        PASSIVE_TRUE_DEFAULTS.has(rawEventName.toLowerCase()),
  };
  return listener;
};
const isValidTargetValue = (prefix) => {
  return VALID_ELEMENT_REF_PREFIXES.has(prefix);
};
const isValidKeycodeSuffix = (prefix) => {
  return VALID_KEYCODE_SUFFIX.has(prefix);
};
const PASSIVE_TRUE_DEFAULTS = new Set([
  'dragstart',
  'drag',
  'dragend',
  'dragenter',
  'dragover',
  'dragleave',
  'drop',
  'mouseenter',
  'mouseover',
  'mousemove',
  'mousedown',
  'mouseup',
  'mouseleave',
  'mouseout',
  'mousewheel',
  'pointerover',
  'pointerenter',
  'pointerdown',
  'pointermove',
  'pointerup',
  'pointercancel',
  'pointerout',
  'pointerleave',
  'resize',
  'scroll',
  'touchstart',
  'touchmove',
  'touchend',
  'touchenter',
  'touchleave',
  'touchcancel',
  'wheel',
]);
const VALID_ELEMENT_REF_PREFIXES = new Set(['parent', 'body', 'document', 'window']);
const VALID_KEYCODE_SUFFIX = new Set(['enter', 'escape', 'space', 'tab', 'up', 'right', 'down', 'left']);

// MODULE: compiler/transformers/reserved-public-members.js
const validatePublicName = (diagnostics, memberName, decorator, memberType, node) => {
  if (RESERVED_PUBLIC_MEMBERS.has(memberName.toLowerCase())) {
    const warn = buildWarn(diagnostics);
    warn.messageText = [
      `The ${decorator} name "${memberName}" is a reserved public name. `,
      `Please rename the "${memberName}" ${memberType} so it does not conflict with an existing standardized prototype member. `,
      `Reusing ${memberType} names that are already defined on the element's prototype may cause `,
      `unexpected runtime errors or user-interface issues on various browsers, so it's best to avoid them entirely.`,
    ].join('');
    augmentDiagnosticWithNode(warn, node);
    return;
  }
};
const HTML_ELEMENT_KEYS = [
  'title',
  'lang',
  'translate',
  'dir',
  // 'dataset',
  // 'hidden',
  'tabIndex',
  'accessKey',
  'draggable',
  // 'spellcheck',
  // 'autocapitalize',
  'contentEditable',
  'isContentEditable',
  // 'inputMode',
  'offsetParent',
  'offsetTop',
  'offsetLeft',
  'offsetWidth',
  'offsetHeight',
  'style',
  'innerText',
  'outerText',
  'oncopy',
  'oncut',
  'onpaste',
  'onabort',
  'onblur',
  'oncancel',
  'oncanplay',
  'oncanplaythrough',
  'onchange',
  'onclick',
  'onclose',
  'oncontextmenu',
  'oncuechange',
  'ondblclick',
  'ondrag',
  'ondragend',
  'ondragenter',
  'ondragleave',
  'ondragover',
  'ondragstart',
  'ondrop',
  'ondurationchange',
  'onemptied',
  'onended',
  'onerror',
  'onfocus',
  'oninput',
  'oninvalid',
  'onkeydown',
  'onkeypress',
  'onkeyup',
  'onload',
  'onloadeddata',
  'onloadedmetadata',
  'onloadstart',
  'onmousedown',
  'onmouseenter',
  'onmouseleave',
  'onmousemove',
  'onmouseout',
  'onmouseover',
  'onmouseup',
  'onmousewheel',
  'onpause',
  'onplay',
  'onplaying',
  'onprogress',
  'onratechange',
  'onreset',
  'onresize',
  'onscroll',
  'onseeked',
  'onseeking',
  'onselect',
  'onstalled',
  'onsubmit',
  'onsuspend',
  'ontimeupdate',
  'ontoggle',
  'onvolumechange',
  'onwaiting',
  'onwheel',
  'onauxclick',
  'ongotpointercapture',
  'onlostpointercapture',
  'onpointerdown',
  'onpointermove',
  'onpointerup',
  'onpointercancel',
  'onpointerover',
  'onpointerout',
  'onpointerenter',
  'onpointerleave',
  'onselectstart',
  'onselectionchange',
  'nonce',
  'click',
  'focus',
  'blur',
];
const ELEMENT_KEYS = [
  'namespaceURI',
  'prefix',
  'localName',
  'tagName',
  'id',
  'className',
  'classList',
  'slot',
  'attributes',
  'shadowRoot',
  'assignedSlot',
  'innerHTML',
  'outerHTML',
  'scrollTop',
  'scrollLeft',
  'scrollWidth',
  'scrollHeight',
  'clientTop',
  'clientLeft',
  'clientWidth',
  'clientHeight',
  'attributeStyleMap',
  'onbeforecopy',
  'onbeforecut',
  'onbeforepaste',
  'onsearch',
  'previousElementSibling',
  'nextElementSibling',
  'children',
  'firstElementChild',
  'lastElementChild',
  'childElementCount',
  'onfullscreenchange',
  'onfullscreenerror',
  'onwebkitfullscreenchange',
  'onwebkitfullscreenerror',
  'setPointerCapture',
  'releasePointerCapture',
  'hasPointerCapture',
  'hasAttributes',
  'getAttributeNames',
  'getAttribute',
  'getAttributeNS',
  'setAttribute',
  'setAttributeNS',
  'removeAttribute',
  'removeAttributeNS',
  'hasAttribute',
  'hasAttributeNS',
  'toggleAttribute',
  'getAttributeNode',
  'getAttributeNodeNS',
  'setAttributeNode',
  'setAttributeNodeNS',
  'removeAttributeNode',
  'closest',
  'matches',
  'webkitMatchesSelector',
  'attachShadow',
  'getElementsByTagName',
  'getElementsByTagNameNS',
  'getElementsByClassName',
  'insertAdjacentElement',
  'insertAdjacentText',
  'insertAdjacentHTML',
  'requestPointerLock',
  'getClientRects',
  'getBoundingClientRect',
  'scrollIntoView',
  'scroll',
  'scrollTo',
  'scrollBy',
  'scrollIntoViewIfNeeded',
  'animate',
  'computedStyleMap',
  'before',
  'after',
  'replaceWith',
  'remove',
  'prepend',
  'append',
  'querySelector',
  'querySelectorAll',
  'requestFullscreen',
  'webkitRequestFullScreen',
  'webkitRequestFullscreen',
  'part',
  'createShadowRoot',
  'getDestinationInsertionPoints',
];
const NODE_KEYS = [
  'ELEMENT_NODE',
  'ATTRIBUTE_NODE',
  'TEXT_NODE',
  'CDATA_SECTION_NODE',
  'ENTITY_REFERENCE_NODE',
  'ENTITY_NODE',
  'PROCESSING_INSTRUCTION_NODE',
  'COMMENT_NODE',
  'DOCUMENT_NODE',
  'DOCUMENT_TYPE_NODE',
  'DOCUMENT_FRAGMENT_NODE',
  'NOTATION_NODE',
  'DOCUMENT_POSITION_DISCONNECTED',
  'DOCUMENT_POSITION_PRECEDING',
  'DOCUMENT_POSITION_FOLLOWING',
  'DOCUMENT_POSITION_CONTAINS',
  'DOCUMENT_POSITION_CONTAINED_BY',
  'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
  'nodeType',
  'nodeName',
  'baseURI',
  'isConnected',
  'ownerDocument',
  'parentNode',
  'parentElement',
  'childNodes',
  'firstChild',
  'lastChild',
  'previousSibling',
  'nextSibling',
  'nodeValue',
  'textContent',
  'hasChildNodes',
  'getRootNode',
  'normalize',
  'cloneNode',
  'isEqualNode',
  'isSameNode',
  'compareDocumentPosition',
  'contains',
  'lookupPrefix',
  'lookupNamespaceURI',
  'isDefaultNamespace',
  'insertBefore',
  'appendChild',
  'replaceChild',
  'removeChild',
];
const JSX_KEYS = ['ref', 'key'];
const ALL_KEYS = [...HTML_ELEMENT_KEYS, ...ELEMENT_KEYS, ...NODE_KEYS, ...JSX_KEYS].map(p => p.toLowerCase());
const RESERVED_PUBLIC_MEMBERS = new Set(ALL_KEYS);

// MODULE: compiler/transformers/decorators-to-static/method-decorator.js
const methodDecoratorsToStatic = (config, diagnostics, cmpNode, decoratedProps, typeChecker, newMembers) => {
  const tsSourceFile = cmpNode.getSourceFile();
  const methods = decoratedProps
    .filter(ts.isMethodDeclaration)
    .map(method => parseMethodDecorator(config, diagnostics, tsSourceFile, typeChecker, method))
    .filter(method => !!method);
  if (methods.length > 0) {
    newMembers.push(createStaticGetter('methods', ts.createObjectLiteral(methods, true)));
  }
};
const parseMethodDecorator = (config, diagnostics, tsSourceFile, typeChecker, method) => {
  const methodDecorator = method.decorators.find(isDecoratorNamed('Method'));
  if (methodDecorator == null) {
    return null;
  }
  const methodName = method.name.getText();
  const flags = ts.TypeFormatFlags.WriteArrowStyleSignature | ts.TypeFormatFlags.NoTruncation;
  const signature = typeChecker.getSignatureFromDeclaration(method);
  const returnType = typeChecker.getReturnTypeOfSignature(signature);
  const returnTypeNode = typeChecker.typeToTypeNode(returnType);
  let returnString = typeToString(typeChecker, returnType);
  let signatureString = typeChecker.signatureToString(signature, method, flags, ts.SignatureKind.Call);
  if (!config._isTesting) {
    if (returnString === 'void') {
      const warn = buildWarn(diagnostics);
      warn.header = '@Method requires async';
      warn.messageText = `External @Method() ${methodName}() must return a Promise.\n\n Consider prefixing the method with async, such as @Method async ${methodName}().`;
      augmentDiagnosticWithNode(warn, method.name);
      returnString = 'Promise<void>';
      signatureString = signatureString.replace(/=> void$/, '=> Promise<void>');
    }
    else if (!isTypePromise(returnString)) {
      const err = buildError(diagnostics);
      err.header = '@Method requires async';
      err.messageText = `External @Method() ${methodName}() must return a Promise.\n\n Consider prefixing the method with async, such as @Method async ${methodName}().`;
      augmentDiagnosticWithNode(err, method.name);
    }
  }
  if (isMemberPrivate(method)) {
    const err = buildError(diagnostics);
    err.messageText = 'Methods decorated with the @Method() decorator cannot be "private" nor "protected". More info: https://stenciljs.com/docs/methods';
    augmentDiagnosticWithNode(err, method.modifiers[0]);
  }
  // Validate if the method name does not conflict with existing public names
  validatePublicName(diagnostics, methodName, '@Method()', 'method', method.name);
  const methodMeta = {
    complexType: {
      signature: signatureString,
      parameters: signature.parameters.map(symbol => serializeSymbol(typeChecker, symbol)),
      references: Object.assign(Object.assign({}, getAttributeTypeInfo(returnTypeNode, tsSourceFile)), getAttributeTypeInfo(method, tsSourceFile)),
      return: returnString,
    },
    docs: {
      text: ts.displayPartsToString(signature.getDocumentationComment(typeChecker)),
      tags: signature.getJsDocTags(),
    },
  };
  validateReferences(diagnostics, methodMeta.complexType.references, method.type || method.name);
  const staticProp = ts.createPropertyAssignment(ts.createLiteral(methodName), convertValueToLiteral(methodMeta));
  return staticProp;
};
const isTypePromise = (typeStr) => {
  return /^Promise<.+>$/.test(typeStr);
};

// MODULE: compiler/transformers/decorators-to-static/prop-decorator.js
const propDecoratorsToStatic = (diagnostics, decoratedProps, typeChecker, watchable, newMembers) => {
  const connect = [];
  const context = [];
  const properties = decoratedProps
    .filter(ts.isPropertyDeclaration)
    .map(prop => parsePropDecorator(diagnostics, typeChecker, prop, context, connect, watchable, newMembers))
    .filter(prop => prop != null);
  if (properties.length > 0) {
    newMembers.push(createStaticGetter('properties', ts.createObjectLiteral(properties, true)));
  }
  if (context.length > 0) {
    newMembers.push(createStaticGetter('contextProps', convertValueToLiteral(context)));
  }
  if (connect.length > 0) {
    newMembers.push(createStaticGetter('connectProps', convertValueToLiteral(connect)));
  }
};
const parsePropDecorator = (diagnostics, typeChecker, prop, context, connect, watchable, newMembers) => {
  const propDecorator = prop.decorators.find(isDecoratorNamed('Prop'));
  if (propDecorator == null) {
    return null;
  }
  const propName = prop.name.getText();
  const propOptions = getPropOptions(propDecorator, diagnostics);
  if (propOptions.context) {
    context.push({
      name: propName,
      context: propOptions.context,
    });
    removeProp(prop, newMembers);
    return null;
  }
  if (propOptions.connect) {
    connect.push({
      name: propName,
      connect: propOptions.connect,
    });
    removeProp(prop, newMembers);
    return null;
  }
  if (isMemberPrivate(prop)) {
    const err = buildError(diagnostics);
    err.messageText = 'Properties decorated with the @Prop() decorator cannot be "private" nor "protected". More info: https://stenciljs.com/docs/properties';
    augmentDiagnosticWithNode(err, prop.modifiers[0]);
  }
  if (/^on(-|[A-Z])/.test(propName)) {
    const warn = buildWarn(diagnostics);
    warn.messageText = `The @Prop() name "${propName}" looks like an event. Please use the "@Event()" decorator to expose events instead, not properties or methods.`;
    augmentDiagnosticWithNode(warn, prop.name);
  }
  else {
    validatePublicName(diagnostics, propName, '@Prop()', 'prop', prop.name);
  }
  const symbol = typeChecker.getSymbolAtLocation(prop.name);
  const type = typeChecker.getTypeAtLocation(prop);
  const typeStr = propTypeFromTSType(type);
  const propMeta = {
    type: typeStr,
    mutable: !!propOptions.mutable,
    complexType: getComplexType$1(typeChecker, prop, type),
    required: prop.exclamationToken !== undefined && propName !== 'mode',
    optional: prop.questionToken !== undefined,
    docs: serializeSymbol(typeChecker, symbol),
  };
  validateReferences(diagnostics, propMeta.complexType.references, prop.type);
  // prop can have an attribute if type is NOT "unknown"
  if (typeStr !== 'unknown') {
    propMeta.attribute = getAttributeName(diagnostics, propName, propOptions, propDecorator);
    propMeta.reflect = getReflect(diagnostics, propOptions);
  }
  // extract default value
  const initializer = prop.initializer;
  if (initializer) {
    propMeta.defaultValue = initializer.getText();
  }
  const staticProp = ts.createPropertyAssignment(ts.createLiteral(propName), convertValueToLiteral(propMeta));
  watchable.add(propName);
  return staticProp;
};
const getAttributeName = (diagnostics, propName, propOptions, node) => {
  if (propOptions.attribute === null) {
    return undefined;
  }
  if (typeof propOptions.attribute === 'string' && propOptions.attribute.trim().length > 0) {
    return propOptions.attribute.trim().toLowerCase();
  }
  if (typeof propOptions.attr === 'string' && propOptions.attr.trim().length > 0) {
    const diagnostic = buildWarn(diagnostics);
    diagnostic.messageText = `@Prop option "attr" has been deprecated. Please use "attribute" instead.`;
    augmentDiagnosticWithNode(diagnostic, node);
    return propOptions.attr.trim().toLowerCase();
  }
  return toDashCase(propName);
};
const getReflect = (_diagnostics, propOptions) => {
  if (typeof propOptions.reflect === 'boolean') {
    return propOptions.reflect;
  }
  if (typeof propOptions.reflectToAttr === 'boolean') {
    // const diagnostic = buildWarn(diagnostics);
    // diagnostic.messageText = `@Prop option "reflectToAttr" has been depreciated. Please use "reflect" instead.`;
    return propOptions.reflectToAttr;
  }
  return false;
};
const getPropOptions = (propDecorator, diagnostics) => {
  if (propDecorator.expression == null) {
    return {};
  }
  const suppliedOptions = propDecorator.expression.arguments.map(arg => {
    try {
      const fnStr = `return ${arg.getText()};`;
      return new Function(fnStr)();
    }
    catch (e) {
      catchError(diagnostics, e, `parse prop options: ${e}`);
    }
  });
  const propOptions = suppliedOptions[0];
  return propOptions || {};
};
const getComplexType$1 = (typeChecker, node, type) => {
  const nodeType = node.type;
  return {
    original: nodeType ? nodeType.getText() : typeToString(typeChecker, type),
    resolved: resolveType(typeChecker, type),
    references: getAttributeTypeInfo(node, node.getSourceFile()),
  };
};
const propTypeFromTSType = (type) => {
  const isAnyType = checkType(type, isAny);
  if (isAnyType) {
    return 'any';
  }
  const isStr = checkType(type, isString$1);
  const isNu = checkType(type, isNumber$2);
  const isBool = checkType(type, isBoolean$1);
  // if type is more than a primitive type at the same time, we mark it as any
  if (Number(isStr) + Number(isNu) + Number(isBool) > 1) {
    return 'any';
  }
  // at this point we know the prop's type is NOT the mix of primitive types
  if (isStr) {
    return 'string';
  }
  if (isNu) {
    return 'number';
  }
  if (isBool) {
    return 'boolean';
  }
  return 'unknown';
};
const checkType = (type, check) => {
  if (type.flags & ts.TypeFlags.Union) {
    const union = type;
    if (union.types.some(type => checkType(type, check))) {
      return true;
    }
  }
  return check(type);
};
const isBoolean$1 = (t) => {
  if (t) {
    return !!(t.flags & (ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLike | ts.TypeFlags.BooleanLike));
  }
  return false;
};
const isNumber$2 = (t) => {
  if (t) {
    return !!(t.flags & (ts.TypeFlags.Number | ts.TypeFlags.NumberLike | ts.TypeFlags.NumberLiteral));
  }
  return false;
};
const isString$1 = (t) => {
  if (t) {
    return !!(t.flags & (ts.TypeFlags.String | ts.TypeFlags.StringLike | ts.TypeFlags.StringLiteral));
  }
  return false;
};
const isAny = (t) => {
  if (t) {
    return !!(t.flags & ts.TypeFlags.Any);
  }
  return false;
};
const removeProp = (prop, classElements) => {
  const index = classElements.findIndex(p => prop === p);
  if (index >= 0) {
    classElements.splice(index, 1);
  }
};

// MODULE: compiler/transformers/decorators-to-static/state-decorator.js
const stateDecoratorsToStatic = (_diagnostics, decoratedProps, _typeChecker, watchable, newMembers) => {
  const states = decoratedProps
    .filter(ts.isPropertyDeclaration)
    .map(prop => stateDecoratorToStatic(prop, watchable))
    .filter(state => !!state);
  if (states.length > 0) {
    newMembers.push(createStaticGetter('states', ts.createObjectLiteral(states, true)));
  }
};
const stateDecoratorToStatic = (prop, watchable) => {
  const stateDecorator = prop.decorators.find(isDecoratorNamed('State'));
  if (stateDecorator == null) {
    return null;
  }
  const stateName = prop.name.getText();
  watchable.add(stateName);
  return ts.createPropertyAssignment(ts.createLiteral(stateName), ts.createObjectLiteral([], true));
};

// MODULE: compiler/transformers/decorators-to-static/watch-decorator.js
const watchDecoratorsToStatic = (config, diagnostics, decoratedProps, watchable, newMembers) => {
  const watchers = decoratedProps.filter(ts.isMethodDeclaration).map(method => parseWatchDecorator(config, diagnostics, watchable, method));
  const flatWatchers = flatOne(watchers);
  if (flatWatchers.length > 0) {
    newMembers.push(createStaticGetter('watchers', convertValueToLiteral(flatWatchers)));
  }
};
const isWatchDecorator = isDecoratorNamed('Watch');
const isPropWillChangeDecorator = isDecoratorNamed('PropWillChange');
const isPropDidChangeDecorator = isDecoratorNamed('PropDidChange');
const parseWatchDecorator = (config, diagnostics, watchable, method) => {
  const methodName = method.name.getText();
  return method.decorators
    .filter(decorator => isWatchDecorator(decorator) || isPropWillChangeDecorator(decorator) || isPropDidChangeDecorator(decorator))
    .map(decorator => {
    const [propName] = getDeclarationParameters(decorator);
    if (!watchable.has(propName)) {
      const dianostic = config.devMode ? buildWarn(diagnostics) : buildError(diagnostics);
      dianostic.messageText = `@Watch('${propName}') is trying to watch for changes in a property that does not exist.
    Make sure only properties decorated with @State() or @Prop() are watched.`;
      augmentDiagnosticWithNode(dianostic, decorator);
    }
    return {
      propName,
      methodName,
    };
  });
};

// MODULE: compiler/transformers/decorators-to-static/convert-decorators.js
const convertDecoratorsToStatic = (config, diagnostics, typeChecker) => {
  return transformCtx => {
    const visit = (node) => {
      if (ts.isClassDeclaration(node)) {
        return visitClassDeclaration(config, diagnostics, typeChecker, node);
      }
      return ts.visitEachChild(node, visit, transformCtx);
    };
    return tsSourceFile => {
      return ts.visitEachChild(tsSourceFile, visit, transformCtx);
    };
  };
};
const visitClassDeclaration = (config, diagnostics, typeChecker, classNode) => {
  if (!classNode.decorators) {
    return classNode;
  }
  const componentDecorator = classNode.decorators.find(isDecoratorNamed('Component'));
  if (!componentDecorator) {
    return classNode;
  }
  const decoratedMembers = classNode.members.filter(member => Array.isArray(member.decorators) && member.decorators.length > 0);
  const newMembers = removeStencilDecorators(Array.from(classNode.members));
  // parser component decorator (Component)
  componentDecoratorToStatic(config, typeChecker, diagnostics, classNode, newMembers, componentDecorator);
  // parse member decorators (Prop, State, Listen, Event, Method, Element and Watch)
  const watchable = new Set();
  if (decoratedMembers.length > 0) {
    propDecoratorsToStatic(diagnostics, decoratedMembers, typeChecker, watchable, newMembers);
    stateDecoratorsToStatic(diagnostics, decoratedMembers, typeChecker, watchable, newMembers);
    eventDecoratorsToStatic(diagnostics, decoratedMembers, typeChecker, newMembers);
    methodDecoratorsToStatic(config, diagnostics, classNode, decoratedMembers, typeChecker, newMembers);
    elementDecoratorsToStatic(diagnostics, decoratedMembers, typeChecker, newMembers);
    watchDecoratorsToStatic(config, diagnostics, decoratedMembers, watchable, newMembers);
    listenDecoratorsToStatic(diagnostics, decoratedMembers, newMembers);
  }
  return ts.updateClassDeclaration(classNode, removeDecorators(classNode, CLASS_DECORATORS_TO_REMOVE), classNode.modifiers, classNode.name, classNode.typeParameters, classNode.heritageClauses, newMembers);
};
const removeStencilDecorators = (classMembers) => {
  return classMembers.map(m => {
    const currentDecorators = m.decorators;
    const newDecorators = removeDecorators(m, MEMBER_DECORATORS_TO_REMOVE);
    if (currentDecorators !== newDecorators) {
      if (ts.isMethodDeclaration(m)) {
        return ts.updateMethod(m, newDecorators, m.modifiers, m.asteriskToken, m.name, m.questionToken, m.typeParameters, m.parameters, m.type, m.body);
      }
      else if (ts.isPropertyDeclaration(m)) {
        return ts.updateProperty(m, newDecorators, m.modifiers, m.name, m.questionToken, m.type, m.initializer);
      }
      else {
        console.log('unknown class node');
      }
    }
    return m;
  });
};
const removeDecorators = (node, decoratorNames) => {
  if (node.decorators) {
    const updatedDecoratorList = node.decorators.filter(dec => {
      const name = ts.isCallExpression(dec.expression) && ts.isIdentifier(dec.expression.expression) && dec.expression.expression.text;
      return !decoratorNames.has(name);
    });
    if (updatedDecoratorList.length === 0) {
      return undefined;
    }
    else if (updatedDecoratorList.length !== node.decorators.length) {
      return ts.createNodeArray(updatedDecoratorList);
    }
  }
  return node.decorators;
};

// MODULE: compiler/transformers/static-to-meta/vdom.js
const gatherVdomMeta = (m, args) => {
  m.hasVdomRender = true;
  // Parse vdom tag
  const hTag = args[0];
  if (!ts.isStringLiteral(hTag) && (!ts.isIdentifier(hTag) || hTag.text !== 'Host')) {
    m.hasVdomFunctional = true;
  }
  // Parse attributes
  if (args.length > 1) {
    const objectLiteral = args[1];
    if (ts.isCallExpression(objectLiteral) || ts.isIdentifier(objectLiteral)) {
      m.hasVdomAttribute = true;
      m.hasVdomClass = true;
      m.hasVdomKey = true;
      m.hasVdomListener = true;
      m.hasVdomPropOrAttr = true;
      m.hasVdomRef = true;
      m.hasVdomStyle = true;
      m.hasVdomXlink = true;
    }
    else if (ts.isObjectLiteralExpression(objectLiteral)) {
      objectLiteral.properties.forEach(prop => {
        m.hasVdomAttribute = true;
        if (ts.isSpreadAssignment(prop) || ts.isComputedPropertyName(prop.name)) {
          m.hasVdomClass = true;
          m.hasVdomKey = true;
          m.hasVdomListener = true;
          m.hasVdomPropOrAttr = true;
          m.hasVdomRef = true;
          m.hasVdomStyle = true;
          m.hasVdomXlink = true;
        }
        else if (prop.name && prop.name.text && prop.name.text.length > 0) {
          const attrName = prop.name.text;
          if (attrName === 'key') {
            m.hasVdomKey = true;
          }
          else if (attrName === 'ref') {
            m.hasVdomRef = true;
          }
          else if (attrName === 'class' || attrName === 'className') {
            m.hasVdomClass = true;
          }
          else if (attrName === 'style') {
            m.hasVdomStyle = true;
          }
          else if (/^on(-|[A-Z])/.test(attrName)) {
            m.hasVdomListener = true;
          }
          else if (attrName.startsWith('xlink')) {
            m.hasVdomXlink = true;
            m.hasVdomPropOrAttr = true;
          }
          else {
            m.hasVdomPropOrAttr = true;
          }
          m.htmlAttrNames.push(attrName);
        }
      });
    }
  }
  // Parse children
  if (!m.hasVdomText) {
    for (let i = 2; i < args.length; i++) {
      const arg = args[i];
      if (!ts.isCallExpression(arg) || !ts.isIdentifier(arg.expression) || arg.expression.text !== 'h') {
        m.hasVdomText = true;
        break;
      }
    }
  }
};

// MODULE: compiler/transformers/core-runtime-apis.js
const ATTACH_SHADOW = '__stencil_attachShadow';
const CREATE_EVENT = '__stencil_createEvent';
const DEFINE_CUSTOM_ELEMENT = '__stencil_defineCustomElement';
const GET_CONNECT = '__stencil_getConnect';
const GET_CONTEXT = '__stencil_getContext';
const GET_ELEMENT = '__stencil_getElement';
const HOST = '__stencil_Host';
const HTML_ELEMENT = 'HTMLElement';
const PROXY_CUSTOM_ELEMENT = '__stencil_proxyCustomElement';
const REGISTER_INSTANCE = '__stencil_registerInstance';
const REGISTER_HOST = '__stencil_registerHost';
const H = '__stencil_h';
const RUNTIME_APIS = {
  attachShadow: `attachShadow as ${ATTACH_SHADOW}`,
  createEvent: `createEvent as ${CREATE_EVENT}`,
  defineCustomElement: `defineCustomElement as ${DEFINE_CUSTOM_ELEMENT}`,
  getConnect: `getConnect as ${GET_CONNECT}`,
  getContext: `getContext as ${GET_CONTEXT}`,
  getElement: `getElement as ${GET_ELEMENT}`,
  h: `h as ${H}`,
  legacyH: `h`,
  Host: `Host as ${HOST}`,
  HTMLElement: HTML_ELEMENT,
  proxyCustomElement: `proxyCustomElement as ${PROXY_CUSTOM_ELEMENT}`,
  registerHost: `registerHost as ${REGISTER_HOST}`,
  registerInstance: `registerInstance as ${REGISTER_INSTANCE}`,
};
const addCoreRuntimeApi = (moduleFile, coreRuntimeApi) => {
  if (!moduleFile.coreRuntimeApis.includes(coreRuntimeApi)) {
    moduleFile.coreRuntimeApis.push(coreRuntimeApi);
  }
};
const addLegacyApis = (moduleFile) => {
  addCoreRuntimeApi(moduleFile, RUNTIME_APIS.legacyH);
};

// MODULE: compiler/transformers/static-to-meta/call-expression.js
const parseCallExpression = (m, node) => {
  if (node.arguments != null && node.arguments.length > 0) {
    if (ts.isIdentifier(node.expression)) {
      // h('tag')
      visitCallExpressionArgs(m, node.expression, node.arguments);
    }
    else if (ts.isPropertyAccessExpression(node.expression)) {
      // document.createElement('tag')
      const n = node.expression.name;
      if (ts.isIdentifier(n) && n) {
        visitCallExpressionArgs(m, n, node.arguments);
      }
    }
  }
};
const visitCallExpressionArgs = (m, callExpressionName, args) => {
  const fnName = callExpressionName.escapedText;
  if (fnName === 'h' || fnName === H || fnName === 'createElement') {
    visitCallExpressionArg(m, args[0]);
    if (fnName === 'h' || fnName === H) {
      gatherVdomMeta(m, args);
    }
  }
  else if (args.length > 1 && fnName === 'createElementNS') {
    visitCallExpressionArg(m, args[1]);
  }
  else if (fnName === 'require' && args.length > 0 && m.originalImports) {
    const arg = args[0];
    if (ts.isStringLiteral(arg)) {
      if (!m.originalImports.includes(arg.text)) {
        m.originalImports.push(arg.text);
      }
    }
  }
};
const visitCallExpressionArg = (m, arg) => {
  if (ts.isStringLiteral(arg)) {
    let tag = arg.text;
    if (typeof tag === 'string') {
      tag = tag.toLowerCase();
      m.htmlTagNames.push(tag);
      if (tag.includes('-')) {
        m.potentialCmpRefs.push(tag);
      }
    }
  }
};

// MODULE: compiler/transformers/component-build-conditionals.js
const setComponentBuildConditionals = (cmpMeta) => {
  if (cmpMeta.properties.length > 0) {
    cmpMeta.hasProp = true;
    cmpMeta.hasPropMutable = cmpMeta.properties.some(p => p.mutable);
    cmpMeta.hasReflect = cmpMeta.properties.some(p => p.reflect);
    cmpMeta.hasAttribute = cmpMeta.properties.some(p => typeof p.attribute === 'string');
    cmpMeta.hasPropBoolean = cmpMeta.properties.some(p => p.type === 'boolean');
    cmpMeta.hasPropNumber = cmpMeta.properties.some(p => p.type === 'number');
    cmpMeta.hasPropString = cmpMeta.properties.some(p => p.type === 'string');
  }
  if (cmpMeta.states.length > 0) {
    cmpMeta.hasState = true;
  }
  if (cmpMeta.watchers.length > 0) {
    cmpMeta.hasWatchCallback = true;
  }
  if (cmpMeta.methods.length > 0) {
    cmpMeta.hasMethod = true;
  }
  if (cmpMeta.events.length > 0) {
    cmpMeta.hasEvent = true;
  }
  if (cmpMeta.listeners.length > 0) {
    cmpMeta.hasListener = true;
    cmpMeta.hasListenerTargetWindow = cmpMeta.listeners.some(l => l.target === 'window');
    cmpMeta.hasListenerTargetDocument = cmpMeta.listeners.some(l => l.target === 'document');
    cmpMeta.hasListenerTargetBody = cmpMeta.listeners.some(l => l.target === 'body');
    cmpMeta.hasListenerTargetParent = cmpMeta.listeners.some(l => l.target === 'parent');
    cmpMeta.hasListenerTarget = cmpMeta.listeners.some(l => !!l.target);
  }
  cmpMeta.hasMember = cmpMeta.hasProp || cmpMeta.hasState || cmpMeta.hasElement || cmpMeta.hasMethod;
  cmpMeta.isUpdateable = cmpMeta.hasProp || cmpMeta.hasState;
  if (cmpMeta.styles.length > 0) {
    cmpMeta.hasStyle = true;
    cmpMeta.hasMode = cmpMeta.styles.some(s => s.modeName !== DEFAULT_STYLE_MODE);
  }
  cmpMeta.hasLifecycle =
    cmpMeta.hasComponentWillLoadFn ||
      cmpMeta.hasComponentDidLoadFn ||
      cmpMeta.hasComponentShouldUpdateFn ||
      cmpMeta.hasComponentWillUpdateFn ||
      cmpMeta.hasComponentDidUpdateFn ||
      cmpMeta.hasComponentWillRenderFn ||
      cmpMeta.hasComponentDidRenderFn;
  cmpMeta.isPlain = !cmpMeta.hasMember && !cmpMeta.hasStyle && !cmpMeta.hasLifecycle && !cmpMeta.hasListener && !cmpMeta.hasVdomRender;
};

// MODULE: compiler/transformers/collections/parse-collection-deprecated.js
const parseComponentsDeprecated = (config, compilerCtx, collection, collectionDir, collectionManifest) => {
  if (collectionManifest.components) {
    collectionManifest.components.forEach(cmpData => {
      parseComponentDeprecated(config, compilerCtx, collection, collectionDir, cmpData);
    });
  }
};
function parseComponentDeprecated(config, compilerCtx, collection, collectionDir, cmpData) {
  const sourceFilePath = normalizePath(join(collectionDir, cmpData.componentPath));
  const moduleFile = getModuleLegacy(config, compilerCtx, sourceFilePath);
  moduleFile.isCollectionDependency = true;
  moduleFile.isLegacy = true;
  moduleFile.collectionName = collection.collectionName;
  moduleFile.excludeFromCollection = excludeFromCollection(config, cmpData);
  moduleFile.originalCollectionComponentPath = cmpData.componentPath;
  moduleFile.jsFilePath = parseJsFilePath(collectionDir, cmpData);
  const cmpMeta = {
    isLegacy: moduleFile.isLegacy,
    excludeFromCollection: moduleFile.excludeFromCollection,
    isCollectionDependency: moduleFile.isCollectionDependency,
    tagName: parseTag(cmpData),
    componentClassName: parseComponentClass(cmpData),
    virtualProperties: [],
    docs: {
      text: '',
      tags: [],
    },
    internal: false,
    jsFilePath: moduleFile.jsFilePath,
    sourceFilePath: '',
    styleDocs: [],
    assetsDirs: parseAssetsDir(collectionDir, cmpData),
    styles: parseStyles(collectionDir, cmpData),
    properties: parseProps(cmpData),
    states: parseStates(cmpData),
    listeners: parseListeners(cmpData),
    methods: parseMethods(cmpData),
    elementRef: parseHostElementMember(cmpData),
    events: parseEvents(cmpData),
    encapsulation: parseEncapsulation(cmpData),
    shadowDelegatesFocus: null,
    watchers: parseWatchers(cmpData),
    legacyConnect: parseConnectProps(cmpData),
    legacyContext: parseContextProps(cmpData),
    hasAttributeChangedCallbackFn: false,
    hasComponentWillLoadFn: true,
    hasComponentDidLoadFn: true,
    hasComponentShouldUpdateFn: true,
    hasComponentWillUpdateFn: true,
    hasComponentDidUpdateFn: true,
    hasComponentWillRenderFn: false,
    hasComponentDidRenderFn: false,
    hasComponentDidUnloadFn: true,
    hasConnectedCallbackFn: false,
    hasDisconnectedCallbackFn: false,
    hasElement: false,
    hasEvent: false,
    hasLifecycle: false,
    hasListener: false,
    hasListenerTarget: false,
    hasListenerTargetWindow: false,
    hasListenerTargetDocument: false,
    hasListenerTargetBody: false,
    hasListenerTargetParent: false,
    hasMember: false,
    hasMethod: false,
    hasMode: false,
    hasAttribute: false,
    hasProp: false,
    hasPropNumber: false,
    hasPropBoolean: false,
    hasPropString: false,
    hasPropMutable: false,
    hasReflect: false,
    hasRenderFn: false,
    hasState: false,
    hasStyle: false,
    hasVdomAttribute: true,
    hasVdomClass: true,
    hasVdomFunctional: true,
    hasVdomKey: true,
    hasVdomListener: true,
    hasVdomPropOrAttr: true,
    hasVdomRef: true,
    hasVdomRender: false,
    hasVdomStyle: true,
    hasVdomText: true,
    hasVdomXlink: true,
    hasWatchCallback: false,
    isPlain: false,
    htmlAttrNames: [],
    htmlTagNames: [],
    isUpdateable: false,
    potentialCmpRefs: [],
  };
  setComponentBuildConditionals(cmpMeta);
  moduleFile.cmps = [cmpMeta];
  // parseComponentDependencies(cmpData, cmpMeta);
  // parseContextMember(cmpData, cmpMeta);
  // parseConnectMember(cmpData, cmpMeta);
  collection.moduleFiles.push(moduleFile);
}
function excludeFromCollection(config, cmpData) {
  // this is a component from a collection dependency
  // however, this project may also become a collection
  // for example, "ionicons" is a dependency of "ionic"
  // and "ionic" is it's own stand-alone collection, so within
  // ionic's collection we want ionicons to just work
  // cmpData is a component from a collection dependency
  // if this component is listed in this config's bundles
  // then we'll need to ensure it also becomes apart of this collection
  const isInBundle = config.bundles &&
    config.bundles.some(bundle => {
      return bundle.components && bundle.components.some(tag => tag === cmpData.tag);
    });
  // if it's not in the config bundle then it's safe to exclude
  // this component from going into this build's collection
  return !isInBundle;
}
function parseTag(cmpData) {
  return cmpData.tag;
}
function parseJsFilePath(collectionDir, cmpData) {
  // convert the path that's relative to the collection file
  // into an absolute path to the component's js file path
  if (typeof cmpData.componentPath !== 'string') {
    throw new Error(`parseModuleJsFilePath, "componentPath" missing on cmpData: ${cmpData.tag}`);
  }
  return normalizePath(join(collectionDir, cmpData.componentPath));
}
// function parseComponentDependencies(cmpData: d.ComponentDataDeprecated, cmpMeta: d.ComponentCompilerMeta) {
//   if (invalidArrayData(cmpData.dependencies)) {
//   cmpMeta.dependencies = [];
//   } else {
//   cmpMeta.dependencies = cmpData.dependencies.sort();
//   }
// }
function parseComponentClass(cmpData) {
  return cmpData.componentClass;
}
function parseStyles(collectionDir, cmpData) {
  const stylesData = cmpData.styles;
  if (stylesData) {
    const modeNames = Object.keys(stylesData);
    return modeNames.map(modeName => {
      return parseStyle(collectionDir, cmpData, stylesData[modeName], modeName.toLowerCase());
    });
  }
  else {
    return [];
  }
}
function parseAssetsDir(collectionDir, cmpData) {
  if (invalidArrayData(cmpData.assetPaths)) {
    return [];
  }
  return cmpData.assetPaths
    .map(assetsPath => {
    const assetsMeta = {
      absolutePath: normalizePath(join(collectionDir, assetsPath)),
      cmpRelativePath: normalizePath(relative(dirname(cmpData.componentPath), assetsPath)),
      originalComponentPath: normalizePath(assetsPath),
    };
    return assetsMeta;
  })
    .sort((a, b) => {
    if (a.cmpRelativePath < b.cmpRelativePath)
      return -1;
    if (a.cmpRelativePath > b.cmpRelativePath)
      return 1;
    return 0;
  });
}
function parseStyle(collectionDir, cmpData, modeStyleData, modeName) {
  const modeStyle = {
    modeName: modeName,
    styleId: cmpData.tag,
    styleStr: modeStyleData.style,
    styleIdentifier: null,
    externalStyles: [],
    compiledStyleText: null,
    compiledStyleTextScoped: null,
    compiledStyleTextScopedCommented: null,
  };
  if (Array.isArray(modeStyleData.stylePaths)) {
    modeStyleData.stylePaths.forEach(stylePath => {
      const externalStyle = {
        absolutePath: normalizePath(join(collectionDir, stylePath)),
        relativePath: normalizePath(relative(dirname(cmpData.componentPath), stylePath)),
        originalComponentPath: stylePath,
      };
      modeStyle.externalStyles.push(externalStyle);
    });
  }
  return modeStyle;
}
function parseProps(cmpData) {
  const propsData = cmpData.props;
  if (invalidArrayData(propsData)) {
    return [];
  }
  return propsData.map(propData => {
    const type = convertType(propData.type);
    const prop = {
      name: propData.name,
      attribute: typeof propData.attr === 'string' ? propData.attr : null,
      mutable: !!propData.mutable,
      optional: true,
      required: false,
      reflect: !!propData.reflectToAttr,
      type,
      internal: false,
      complexType: {
        original: type === 'unknown' ? 'any' : type,
        resolved: type,
        references: {},
      },
      docs: {
        text: '',
        tags: [],
      },
    };
    return prop;
  });
}
function parseConnectProps(cmpData) {
  const connectData = cmpData.connect;
  if (invalidArrayData(connectData)) {
    return [];
  }
  return connectData.map(propData => {
    const prop = {
      name: propData.name,
      connect: propData.tag,
    };
    return prop;
  });
}
function parseContextProps(cmpData) {
  const contextData = cmpData.context;
  if (invalidArrayData(contextData)) {
    return [];
  }
  return contextData.map(propData => {
    return {
      name: propData.name,
      context: propData.id,
    };
  });
}
function parseStates(cmpData) {
  if (invalidArrayData(cmpData.states)) {
    return [];
  }
  return cmpData.states.map(state => {
    return {
      name: state.name,
    };
  });
}
function parseWatchers(cmpData) {
  if (invalidArrayData(cmpData.props)) {
    return [];
  }
  const watchers = [];
  cmpData.props
    .filter(prop => prop.watch && prop.watch.length > 0)
    .forEach(prop => {
    prop.watch.forEach(watch => {
      watchers.push({
        propName: prop.name,
        methodName: watch,
      });
    });
  });
  return watchers;
}
function parseListeners(cmpData) {
  const listenersData = cmpData.listeners;
  if (invalidArrayData(listenersData)) {
    return [];
  }
  return listenersData.map(listenerData => {
    const listener = {
      name: listenerData.event,
      method: listenerData.method,
      target: undefined,
      passive: listenerData.passive !== false,
      capture: listenerData.capture !== false,
    };
    return listener;
  });
}
function parseMethods(cmpData) {
  if (invalidArrayData(cmpData.methods)) {
    return [];
  }
  return cmpData.methods.map(methodData => {
    const method = {
      name: methodData.name,
      internal: false,
      complexType: {
        signature: '(...args: any[]) => Promise<any>',
        parameters: [],
        return: 'Promise<any>',
        references: {},
      },
      docs: {
        text: '',
        tags: [],
      },
    };
    return method;
  });
}
function convertType(type) {
  switch (type) {
    case 'String':
      return 'string';
    case 'Any':
      return 'any';
    case 'Number':
      return 'number';
    case 'Boolean':
      return 'boolean';
    default:
      return 'unknown';
  }
}
// function parseContextMember(cmpData: d.ComponentDataDeprecated, cmpMeta: d.ComponentCompilerMeta) {
//   if (invalidArrayData(cmpData.context)) {
//   return;
//   }
//   cmpData.context.forEach(methodData => {
//   if (methodData.id) {
//     cmpMeta.membersMeta = cmpMeta.membersMeta || {};
//     cmpMeta.membersMeta[methodData.name] = {
//     memberType: MEMBER_FLAGS.PropContext,
//     ctrlId: methodData.id
//     };
//   }
//   });
// }
// function parseConnectMember(cmpData: d.ComponentDataDeprecated, cmpMeta: d.ComponentCompilerMeta) {
//   if (invalidArrayData(cmpData.connect)) {
//   return;
//   }
//   cmpData.connect.forEach(methodData => {
//   if (methodData.tag) {
//     cmpMeta.membersMeta = cmpMeta.membersMeta || {};
//     cmpMeta.membersMeta[methodData.name] = {
//     memberType: MEMBER_FLAGS.PropConnect,
//     ctrlId: methodData.tag
//     };
//   }
//   });
// }
function parseHostElementMember(cmpData) {
  if (!cmpData.hostElement) {
    return undefined;
  }
  return cmpData.hostElement.name;
}
function parseEvents(cmpData) {
  const eventsData = cmpData.events;
  if (invalidArrayData(eventsData)) {
    return [];
  }
  return eventsData.map(eventData => {
    const event = {
      name: eventData.event,
      method: eventData.method ? eventData.method : eventData.event,
      bubbles: eventData.bubbles !== false,
      cancelable: eventData.cancelable !== false,
      composed: eventData.composed !== false,
      internal: false,
      docs: {
        text: '',
        tags: [],
      },
      complexType: {
        original: 'any',
        resolved: 'any',
        references: {},
      },
    };
    return event;
  });
}
function parseEncapsulation(cmpData) {
  if (cmpData.shadow === true) {
    return 'shadow';
  }
  else if (cmpData.scoped === true) {
    return 'scoped';
  }
  else {
    return 'none';
  }
}
function invalidArrayData(arr) {
  return !arr || !Array.isArray(arr) || arr.length === 0;
}

// MODULE: compiler/transpile/transpiled-module.js
const getModule = (compilerCtx, filePath) => compilerCtx.moduleMap.get(normalizePath(filePath));
const createModule = (staticSourceFile, // this is NOT the original
staticSourceFileText, emitFilepath) => ({
  sourceFilePath: normalizePath(staticSourceFile.fileName),
  jsFilePath: emitFilepath,
  staticSourceFile,
  staticSourceFileText,
  cmps: [],
  coreRuntimeApis: [],
  collectionName: null,
  dtsFilePath: null,
  excludeFromCollection: false,
  externalImports: [],
  hasVdomAttribute: false,
  hasVdomClass: false,
  hasVdomFunctional: false,
  hasVdomKey: false,
  hasVdomListener: false,
  hasVdomPropOrAttr: false,
  hasVdomRef: false,
  hasVdomRender: false,
  hasVdomStyle: false,
  hasVdomText: false,
  hasVdomXlink: false,
  htmlAttrNames: [],
  htmlTagNames: [],
  isCollectionDependency: false,
  isLegacy: false,
  localImports: [],
  originalCollectionComponentPath: null,
  originalImports: [],
  potentialCmpRefs: [],
});

// MODULE: compiler/transformers/static-to-meta/methods.js
const parseStaticMethods = (staticMembers) => {
  const parsedMethods = getStaticValue(staticMembers, 'methods');
  if (!parsedMethods) {
    return [];
  }
  const methodNames = Object.keys(parsedMethods);
  if (methodNames.length === 0) {
    return [];
  }
  return methodNames.map(methodName => {
    return {
      name: methodName,
      docs: parsedMethods[methodName].docs,
      complexType: parsedMethods[methodName].complexType,
      internal: isInternal(parsedMethods[methodName].docs),
    };
  });
};

// MODULE: compiler/transformers/static-to-meta/listeners.js
const parseStaticListeners = (staticMembers) => {
  const parsedListeners = getStaticValue(staticMembers, 'listeners');
  if (!parsedListeners || parsedListeners.length === 0) {
    return [];
  }
  return parsedListeners.map(parsedListener => {
    return {
      name: parsedListener.name,
      method: parsedListener.method,
      capture: !!parsedListener.capture,
      passive: !!parsedListener.passive,
      target: parsedListener.target,
    };
  });
};

// MODULE: compiler/transformers/static-to-meta/class-methods.js
const parseClassMethods = (cmpNode, cmpMeta) => {
  const classMembers = cmpNode.members;
  if (!classMembers || classMembers.length === 0) {
    return;
  }
  const classMethods = classMembers.filter(m => ts.isMethodDeclaration(m));
  if (classMethods.length === 0) {
    return;
  }
  const hasHostData = classMethods.some(m => isMethod(m, 'hostData'));
  cmpMeta.hasAttributeChangedCallbackFn = classMethods.some(m => isMethod(m, 'attributeChangedCallback'));
  cmpMeta.hasConnectedCallbackFn = classMethods.some(m => isMethod(m, 'connectedCallback'));
  cmpMeta.hasDisconnectedCallbackFn = classMethods.some(m => isMethod(m, 'disconnectedCallback'));
  cmpMeta.hasComponentWillLoadFn = classMethods.some(m => isMethod(m, 'componentWillLoad'));
  cmpMeta.hasComponentWillUpdateFn = classMethods.some(m => isMethod(m, 'componentWillUpdate'));
  cmpMeta.hasComponentWillRenderFn = classMethods.some(m => isMethod(m, 'componentWillRender'));
  cmpMeta.hasComponentDidRenderFn = classMethods.some(m => isMethod(m, 'componentDidRender'));
  cmpMeta.hasComponentDidLoadFn = classMethods.some(m => isMethod(m, 'componentDidLoad'));
  cmpMeta.hasComponentShouldUpdateFn = classMethods.some(m => isMethod(m, 'componentShouldUpdate'));
  cmpMeta.hasComponentDidUpdateFn = classMethods.some(m => isMethod(m, 'componentDidUpdate'));
  cmpMeta.hasComponentDidUnloadFn = classMethods.some(m => isMethod(m, 'componentDidUnload'));
  cmpMeta.hasLifecycle = cmpMeta.hasComponentWillLoadFn || cmpMeta.hasComponentDidLoadFn || cmpMeta.hasComponentWillUpdateFn || cmpMeta.hasComponentDidUpdateFn;
  cmpMeta.hasRenderFn = classMethods.some(m => isMethod(m, 'render')) || hasHostData;
  cmpMeta.hasVdomRender = cmpMeta.hasVdomRender || hasHostData;
};

// MODULE: compiler/transformers/static-to-meta/element-ref.js
const parseStaticElementRef = (staticMembers) => {
  const parsedElementRef = getStaticValue(staticMembers, 'elementRef');
  if (typeof parsedElementRef === 'string') {
    return parsedElementRef;
  }
  return null;
};

// MODULE: compiler/transformers/static-to-meta/encapsulation.js
const parseStaticEncapsulation = (staticMembers) => {
  let encapsulation = getStaticValue(staticMembers, 'encapsulation');
  if (typeof encapsulation === 'string') {
    encapsulation = encapsulation.toLowerCase().trim();
    if (encapsulation === 'shadow' || encapsulation === 'scoped') {
      return encapsulation;
    }
  }
  return 'none';
};
const parseStaticShadowDelegatesFocus = (encapsulation, staticMembers) => {
  if (encapsulation === 'shadow') {
    const delegatesFocus = getStaticValue(staticMembers, 'delegatesFocus');
    return !!delegatesFocus;
  }
  return null;
};

// MODULE: compiler/transformers/static-to-meta/events.js
const parseStaticEvents = (staticMembers) => {
  const parsedEvents = getStaticValue(staticMembers, 'events');
  if (!parsedEvents || parsedEvents.length === 0) {
    return [];
  }
  return parsedEvents.map(parsedEvent => {
    return {
      name: parsedEvent.name,
      method: parsedEvent.method,
      bubbles: parsedEvent.bubbles,
      cancelable: parsedEvent.cancelable,
      composed: parsedEvent.composed,
      docs: parsedEvent.docs,
      complexType: parsedEvent.complexType,
      internal: isInternal(parsedEvent.docs),
    };
  });
};

// MODULE: compiler/transformers/static-to-meta/props.js
const parseStaticProps = (staticMembers) => {
  const parsedProps = getStaticValue(staticMembers, 'properties');
  if (!parsedProps) {
    return [];
  }
  const propNames = Object.keys(parsedProps);
  if (propNames.length === 0) {
    return [];
  }
  return propNames.map(propName => {
    const val = parsedProps[propName];
    return {
      name: propName,
      type: val.type,
      attribute: val.attribute ? val.attribute.toLowerCase() : undefined,
      reflect: typeof val.reflect === 'boolean' ? val.reflect : typeof val.reflect === 'boolean' ? val.reflect : false,
      mutable: !!val.mutable,
      required: !!val.required,
      optional: !!val.optional,
      defaultValue: val.defaultValue,
      complexType: val.complexType,
      docs: val.docs,
      internal: isInternal(val.docs),
    };
  });
};

// MODULE: compiler/transformers/static-to-meta/states.js
const parseStaticStates = (staticMembers) => {
  const parsedStates = getStaticValue(staticMembers, 'states');
  if (!parsedStates) {
    return [];
  }
  const stateNames = Object.keys(parsedStates);
  if (stateNames.length === 0) {
    return [];
  }
  return stateNames.map(stateName => {
    return {
      name: stateName,
    };
  });
};

// MODULE: compiler/transformers/static-to-meta/watchers.js
const parseStaticWatchers = (staticMembers) => {
  const parsedWatchers = getStaticValue(staticMembers, 'watchers');
  if (!parsedWatchers || parsedWatchers.length === 0) {
    return [];
  }
  return parsedWatchers.map(parsedWatch => {
    return {
      propName: parsedWatch.propName,
      methodName: parsedWatch.methodName,
    };
  });
};

// MODULE: compiler/style/normalize-styles.js
const normalizeStyles = (tagName, componentFilePath, styles) => {
  styles.forEach(style => {
    if (style.modeName === DEFAULT_STYLE_MODE) {
      style.styleId = tagName.toUpperCase();
    }
    else {
      style.styleId = `${tagName.toUpperCase()}#${style.modeName}`;
    }
    if (Array.isArray(style.externalStyles)) {
      style.externalStyles.forEach(externalStyle => {
        normalizeExternalStyle(componentFilePath, externalStyle);
      });
    }
  });
};
const normalizeExternalStyle = (componentFilePath, externalStyle) => {
  if (typeof externalStyle.originalComponentPath !== 'string' || externalStyle.originalComponentPath.trim().length === 0) {
    return;
  }
  // get the absolute path of the directory which the component is sitting in
  const componentDir = dirname(componentFilePath);
  if (isAbsolute(externalStyle.originalComponentPath)) {
    // this path is absolute already!
    // add to our list of style absolute paths
    externalStyle.absolutePath = normalizePath(externalStyle.originalComponentPath);
    // if this is an absolute path already, let's convert it to be relative
    externalStyle.relativePath = normalizePath(relative(componentDir, externalStyle.originalComponentPath));
  }
  else {
    // this path is relative to the component
    // add to our list of style relative paths
    externalStyle.relativePath = normalizePath(externalStyle.originalComponentPath);
    // create the absolute path to the style file
    externalStyle.absolutePath = normalizePath(join(componentDir, externalStyle.originalComponentPath));
  }
};

// MODULE: compiler/transformers/static-to-meta/styles.js
const parseStaticStyles = (compilerCtx, tagName, componentFilePath, isCollectionDependency, staticMembers) => {
  const styles = [];
  const styleUrlsProp = isCollectionDependency ? 'styleUrls' : 'originalStyleUrls';
  const parsedStyleUrls = getStaticValue(staticMembers, styleUrlsProp);
  let parsedStyle = getStaticValue(staticMembers, 'styles');
  if (parsedStyle) {
    if (typeof parsedStyle === 'string') {
      // styles: 'div { padding: 10px }'
      parsedStyle = parsedStyle.trim();
      if (parsedStyle.length > 0) {
        styles.push({
          modeName: DEFAULT_STYLE_MODE,
          styleId: null,
          styleStr: parsedStyle,
          styleIdentifier: null,
          compiledStyleText: null,
          compiledStyleTextScoped: null,
          compiledStyleTextScopedCommented: null,
          externalStyles: [],
        });
        compilerCtx.styleModeNames.add(DEFAULT_STYLE_MODE);
      }
    }
    else if (parsedStyle.__identifier) {
      styles.push(parseStyleIdentifier(parsedStyle, DEFAULT_STYLE_MODE));
      compilerCtx.styleModeNames.add(DEFAULT_STYLE_MODE);
    }
    else if (typeof parsedStyle === 'object') {
      Object.keys(parsedStyle).forEach(modeName => {
        const parsedStyleMode = parsedStyle[modeName];
        if (typeof parsedStyleMode === 'string') {
          styles.push({
            modeName: modeName,
            styleId: null,
            styleStr: parsedStyleMode,
            styleIdentifier: null,
            compiledStyleText: null,
            compiledStyleTextScoped: null,
            compiledStyleTextScopedCommented: null,
            externalStyles: []
          });
        }
        else {
          styles.push(parseStyleIdentifier(parsedStyleMode, modeName));
        }
        compilerCtx.styleModeNames.add(modeName);
      });
    }
  }
  if (parsedStyleUrls && typeof parsedStyleUrls === 'object') {
    Object.keys(parsedStyleUrls).forEach(modeName => {
      const externalStyles = [];
      const styleObj = parsedStyleUrls[modeName];
      styleObj.forEach(styleUrl => {
        if (typeof styleUrl === 'string' && styleUrl.trim().length > 0) {
          externalStyles.push({
            absolutePath: null,
            relativePath: null,
            originalComponentPath: styleUrl.trim(),
          });
        }
      });
      if (externalStyles.length > 0) {
        const style = {
          modeName: modeName,
          styleId: null,
          styleStr: null,
          styleIdentifier: null,
          compiledStyleText: null,
          compiledStyleTextScoped: null,
          compiledStyleTextScopedCommented: null,
          externalStyles: externalStyles,
        };
        styles.push(style);
        compilerCtx.styleModeNames.add(modeName);
      }
    });
  }
  normalizeStyles(tagName, componentFilePath, styles);
  return sortBy(styles, s => s.modeName);
};
const parseStyleIdentifier = (parsedStyle, modeName) => {
  const style = {
    modeName: modeName,
    styleId: null,
    styleStr: null,
    styleIdentifier: parsedStyle.__escapedText,
    compiledStyleText: null,
    compiledStyleTextScoped: null,
    compiledStyleTextScopedCommented: null,
    externalStyles: [],
  };
  return style;
};

// MODULE: compiler/transformers/static-to-meta/string-literal.js
const parseStringLiteral = (m, node) => {
  if (typeof node.text === 'string' && node.text.includes('</')) {
    if (node.text.includes('<slot')) {
      m.htmlTagNames.push('slot');
    }
    if (node.text.includes('<svg')) {
      m.htmlTagNames.push('svg');
    }
  }
};

// MODULE: compiler/transformers/static-to-meta/component.js
const parseStaticComponentMeta = (compilerCtx, typeChecker, cmpNode, moduleFile, nodeMap, transformOpts) => {
  if (cmpNode.members == null) {
    return cmpNode;
  }
  const staticMembers = cmpNode.members.filter(isStaticGetter);
  const tagName = getComponentTagName(staticMembers);
  if (tagName == null) {
    return cmpNode;
  }
  const symbol = typeChecker ? typeChecker.getSymbolAtLocation(cmpNode.name) : undefined;
  const docs = serializeSymbol(typeChecker, symbol);
  const isCollectionDependency = moduleFile.isCollectionDependency;
  const encapsulation = parseStaticEncapsulation(staticMembers);
  const cmp = {
    isLegacy: false,
    tagName: tagName,
    excludeFromCollection: moduleFile.excludeFromCollection,
    isCollectionDependency,
    componentClassName: cmpNode.name ? cmpNode.name.text : '',
    elementRef: parseStaticElementRef(staticMembers),
    encapsulation,
    shadowDelegatesFocus: parseStaticShadowDelegatesFocus(encapsulation, staticMembers),
    properties: parseStaticProps(staticMembers),
    virtualProperties: parseVirtualProps(docs),
    states: parseStaticStates(staticMembers),
    methods: parseStaticMethods(staticMembers),
    listeners: parseStaticListeners(staticMembers),
    events: parseStaticEvents(staticMembers),
    watchers: parseStaticWatchers(staticMembers),
    styles: parseStaticStyles(compilerCtx, tagName, moduleFile.sourceFilePath, isCollectionDependency, staticMembers),
    legacyConnect: getStaticValue(staticMembers, 'connectProps') || [],
    legacyContext: getStaticValue(staticMembers, 'contextProps') || [],
    internal: isInternal(docs),
    assetsDirs: parseAssetsDirs(staticMembers, moduleFile.jsFilePath),
    styleDocs: [],
    docs,
    jsFilePath: moduleFile.jsFilePath,
    sourceFilePath: moduleFile.sourceFilePath,
    hasAttributeChangedCallbackFn: false,
    hasComponentWillLoadFn: false,
    hasComponentDidLoadFn: false,
    hasComponentShouldUpdateFn: false,
    hasComponentWillUpdateFn: false,
    hasComponentDidUpdateFn: false,
    hasComponentWillRenderFn: false,
    hasComponentDidRenderFn: false,
    hasComponentDidUnloadFn: false,
    hasConnectedCallbackFn: false,
    hasDisconnectedCallbackFn: false,
    hasElement: false,
    hasEvent: false,
    hasLifecycle: false,
    hasListener: false,
    hasListenerTarget: false,
    hasListenerTargetWindow: false,
    hasListenerTargetDocument: false,
    hasListenerTargetBody: false,
    hasListenerTargetParent: false,
    hasMember: false,
    hasMethod: false,
    hasMode: false,
    hasAttribute: false,
    hasProp: false,
    hasPropNumber: false,
    hasPropBoolean: false,
    hasPropString: false,
    hasPropMutable: false,
    hasReflect: false,
    hasRenderFn: false,
    hasState: false,
    hasStyle: false,
    hasVdomAttribute: false,
    hasVdomXlink: false,
    hasVdomClass: false,
    hasVdomFunctional: false,
    hasVdomKey: false,
    hasVdomListener: false,
    hasVdomPropOrAttr: false,
    hasVdomRef: false,
    hasVdomRender: false,
    hasVdomStyle: false,
    hasVdomText: false,
    hasWatchCallback: false,
    isPlain: false,
    htmlAttrNames: [],
    htmlTagNames: [],
    isUpdateable: false,
    potentialCmpRefs: [],
  };
  const visitComponentChildNode = (node) => {
    if (ts.isCallExpression(node)) {
      parseCallExpression(cmp, node);
    }
    else if (ts.isStringLiteral(node)) {
      parseStringLiteral(cmp, node);
    }
    node.forEachChild(visitComponentChildNode);
  };
  visitComponentChildNode(cmpNode);
  parseClassMethods(cmpNode, cmp);
  cmp.legacyConnect.forEach(({ connect }) => {
    cmp.htmlTagNames.push(connect);
    if (connect.includes('-')) {
      cmp.potentialCmpRefs.push(connect);
    }
  });
  cmp.htmlAttrNames = unique(cmp.htmlAttrNames);
  cmp.htmlTagNames = unique(cmp.htmlTagNames);
  cmp.potentialCmpRefs = unique(cmp.potentialCmpRefs);
  setComponentBuildConditionals(cmp);
  if (transformOpts && transformOpts.componentMetadata === 'compilerstatic') {
    cmpNode = addComponentMetaStatic(cmpNode, cmp);
  }
  // add to module map
  moduleFile.cmps.push(cmp);
  // add to node map
  nodeMap.set(cmpNode, cmp);
  return cmpNode;
};
const parseVirtualProps = (docs) => {
  return docs.tags
    .filter(({ name }) => name === 'virtualProp')
    .map(parseVirtualProp)
    .filter(prop => !!prop);
};
const parseVirtualProp = (tag) => {
  const results = /^\s*(?:\{([^}]+)\}\s+)?(\w+)\s+-\s+(.*)$/.exec(tag.text);
  if (!results) {
    return undefined;
  }
  const [, type, name, docs] = results;
  return {
    type: type == null ? 'any' : type.trim(),
    name: name.trim(),
    docs: docs.trim(),
  };
};
const parseAssetsDirs = (staticMembers, componentFilePath) => {
  const dirs = getStaticValue(staticMembers, 'assetsDirs') || [];
  const componentDir = normalizePath(dirname(componentFilePath));
  return dirs.map(dir => {
    // get the relative path from the component file to the assets directory
    dir = normalizePath(dir.trim());
    let absolutePath = dir;
    let cmpRelativePath = dir;
    if (isAbsolute(dir)) {
      // if this is an absolute path already, let's convert it to be relative
      cmpRelativePath = relative(componentDir, dir);
    }
    else {
      // create the absolute path to the asset dir
      absolutePath = join(componentDir, dir);
    }
    return {
      absolutePath,
      cmpRelativePath,
      originalComponentPath: dir,
    };
  });
};

// MODULE: compiler/transformers/static-to-meta/parse-static.js
const updateModule = (config, compilerCtx, buildCtx, tsSourceFile, sourceFileText, emitFilePath, typeChecker, collection) => {
  const sourceFilePath = normalizePath(tsSourceFile.fileName);
  const prevModuleFile = getModule(compilerCtx, sourceFilePath);
  if (prevModuleFile && prevModuleFile.staticSourceFileText === sourceFileText) {
    return prevModuleFile;
  }
  const srcDirPath = dirname(sourceFilePath);
  const emitFileName = basename(emitFilePath);
  emitFilePath = normalizePath(join(srcDirPath, emitFileName));
  const moduleFile = createModule(tsSourceFile, sourceFileText, emitFilePath);
  const moduleFileKey = normalizePath(moduleFile.sourceFilePath);
  compilerCtx.moduleMap.set(moduleFileKey, moduleFile);
  compilerCtx.changedModules.add(moduleFile.sourceFilePath);
  const visitNode = (node) => {
    if (ts.isClassDeclaration(node)) {
      parseStaticComponentMeta(compilerCtx, typeChecker, node, moduleFile, compilerCtx.nodeMap);
      return;
    }
    else if (ts.isImportDeclaration(node)) {
      parseImport(config, compilerCtx, buildCtx, moduleFile, srcDirPath, node);
      return;
    }
    else if (ts.isCallExpression(node)) {
      parseCallExpression(moduleFile, node);
    }
    else if (ts.isStringLiteral(node)) {
      parseStringLiteral(moduleFile, node);
    }
    node.forEachChild(visitNode);
  };
  if (collection != null) {
    moduleFile.isCollectionDependency = true;
    moduleFile.collectionName = collection.collectionName;
    collection.moduleFiles.push(moduleFile);
  }
  visitNode(tsSourceFile);
  // TODO: workaround around const enums
  // find better way
  if (moduleFile.cmps.length > 0) {
    moduleFile.staticSourceFile = ts.createSourceFile(sourceFilePath, sourceFileText, tsSourceFile.languageVersion, true, ts.ScriptKind.JS);
  }
  return moduleFile;
};

// MODULE: compiler/transformers/collections/parse-collection-components.js
const parseCollectionComponents = (config, compilerCtx, buildCtx, collectionDir, collectionManifest, collection) => {
  parseComponentsDeprecated(config, compilerCtx, collection, collectionDir, collectionManifest);
  if (collectionManifest.entries) {
    collectionManifest.entries.forEach(entryPath => {
      const componentPath = join(collectionDir, entryPath);
      transpileCollectionModule(config, compilerCtx, buildCtx, collection, componentPath);
    });
  }
};
const transpileCollectionModule = (config, compilerCtx, buildCtx, collection, inputFileName) => {
  const sourceText = compilerCtx.fs.readFileSync(inputFileName);
  const sourceFile = ts.createSourceFile(inputFileName, sourceText, ts.ScriptTarget.ES2017, true, ts.ScriptKind.JS);
  return updateModule(config, compilerCtx, buildCtx, sourceFile, sourceText, inputFileName, undefined, collection);
};

// MODULE: compiler/transformers/collections/parse-collection-manifest.js
const parseCollectionManifest = (config, compilerCtx, buildCtx, collectionName, collectionDir, collectionJsonStr) => {
  const collectionManifest = JSON.parse(collectionJsonStr);
  const compilerVersion = collectionManifest.compiler || {};
  const collection = {
    collectionName: collectionName,
    moduleId: collectionName,
    moduleFiles: [],
    dependencies: parseCollectionDependencies(collectionManifest),
    compiler: {
      name: compilerVersion.name || '',
      version: compilerVersion.version || '',
      typescriptVersion: compilerVersion.typescriptVersion || '',
    },
    bundles: parseBundles(collectionManifest),
  };
  parseGlobal(config, compilerCtx, buildCtx, collectionDir, collectionManifest, collection);
  parseCollectionComponents(config, compilerCtx, buildCtx, collectionDir, collectionManifest, collection);
  return collection;
};
const parseCollectionDependencies = (collectionManifest) => {
  return (collectionManifest.collections || []).map(c => c.name);
};
const parseGlobal = (config, compilerCtx, buildCtx, collectionDir, collectionManifest, collection) => {
  if (typeof collectionManifest.global !== 'string') {
    return;
  }
  const sourceFilePath = normalizePath(join(collectionDir, collectionManifest.global));
  const globalModule = transpileCollectionModule(config, compilerCtx, buildCtx, collection, sourceFilePath);
  collection.global = globalModule;
};
const parseBundles = (collectionManifest) => {
  if (invalidArrayData$1(collectionManifest.bundles)) {
    return [];
  }
  return collectionManifest.bundles.map(b => {
    return {
      components: b.components.slice().sort(),
    };
  });
};
const invalidArrayData$1 = (arr) => {
  return !arr || !Array.isArray(arr) || arr.length === 0;
};

// MODULE: compiler/transformers/collections/parse-collection-module.js
const parseCollection = (config, compilerCtx, buildCtx, moduleId, pkgJsonFilePath, pkgData) => {
  // note this MUST be synchronous because this is used during transpile
  const collectionName = pkgData.name;
  let collection = compilerCtx.collections.find(c => c.collectionName === collectionName);
  if (collection != null) {
    // we've already cached the collection, no need for another resolve/readFile/parse
    // thought being that /node_modules/ isn't changing between watch builds
    return collection;
  }
  // get the root directory of the dependency
  const collectionPackageRootDir = dirname(pkgJsonFilePath);
  // figure out the full path to the collection collection file
  const collectionFilePath = join(collectionPackageRootDir, pkgData.collection);
  const relPath = relative(config.rootDir, collectionFilePath);
  config.logger.debug(`load collection: ${collectionName}, ${relPath}`);
  // we haven't cached the collection yet, let's read this file
  // sync on purpose :(
  const collectionJsonStr = compilerCtx.fs.readFileSync(collectionFilePath);
  if (!collectionJsonStr) {
    return null;
  }
  // get the directory where the collection collection file is sitting
  const collectionDir = normalizePath(dirname(collectionFilePath));
  // parse the json string into our collection data
  collection = parseCollectionManifest(config, compilerCtx, buildCtx, collectionName, collectionDir, collectionJsonStr);
  collection.moduleId = moduleId;
  if (pkgData.module && pkgData.module !== pkgData.main) {
    collection.hasExports = true;
  }
  // remember the source of this collection node_module
  collection.moduleDir = collectionPackageRootDir;
  // cache it for later yo
  compilerCtx.collections.push(collection);
  return collection;
};

// MODULE: compiler/transformers/collections/add-external-import.js
const addExternalImport = (config, compilerCtx, buildCtx, moduleFile, containingFile, moduleId) => {
  if (!moduleFile.externalImports.includes(moduleId)) {
    moduleFile.externalImports.push(moduleId);
    moduleFile.externalImports.sort();
  }
  if (compilerCtx.resolvedCollections.has(moduleId)) {
    // we've already handled this collection moduleId before
    return;
  }
  let pkgJsonFilePath = tsResolveModuleNamePackageJsonPath(config, compilerCtx, moduleId, containingFile);
  // cache that we've already parsed this
  compilerCtx.resolvedCollections.add(moduleId);
  if (pkgJsonFilePath == null) {
    return;
  }
  const realPkgJsonFilePath = config.sys.realpathSync(pkgJsonFilePath);
  if (realPkgJsonFilePath) {
    pkgJsonFilePath = realPkgJsonFilePath;
  }
  if (pkgJsonFilePath === config.packageJsonFilePath) {
    // same package silly!
    return;
  }
  // open up and parse the package.json
  // sync on purpose :(
  const pkgJsonStr = compilerCtx.fs.readFileSync(pkgJsonFilePath);
  if (pkgJsonStr == null) {
    return;
  }
  const parsedPkgJson = parsePackageJson(pkgJsonStr, pkgJsonFilePath);
  if (parsedPkgJson.diagnostic) {
    buildCtx.diagnostics.push(parsedPkgJson.diagnostic);
    return;
  }
  if (!isString(parsedPkgJson.data.collection) || !parsedPkgJson.data.collection.endsWith('.json')) {
    // this import is not a stencil collection
    return;
  }
  if (!isString(parsedPkgJson.data.types) || !parsedPkgJson.data.types.endsWith('.d.ts')) {
    // this import should have types
    return;
  }
  // this import is a stencil collection
  // let's parse it and gather all the module data about it
  // internally it'll cached collection data if we've already done this
  const collection = parseCollection(config, compilerCtx, buildCtx, moduleId, parsedPkgJson.filePath, parsedPkgJson.data);
  if (!collection) {
    return;
  }
  // check if we already added this collection to the build context
  const alreadyHasCollection = buildCtx.collections.some(c => {
    return c.collectionName === collection.collectionName;
  });
  if (alreadyHasCollection) {
    // we already have this collection in our build context
    return;
  }
  // let's add the collection to the build context
  buildCtx.collections.push(collection);
  if (Array.isArray(collection.dependencies)) {
    // this collection has more collections
    // let's keep digging down and discover all of them
    collection.dependencies.forEach(dependencyModuleId => {
      const resolveFromDir = dirname(pkgJsonFilePath);
      addExternalImport(config, compilerCtx, buildCtx, moduleFile, resolveFromDir, dependencyModuleId);
    });
  }
};

// MODULE: compiler/transformers/static-to-meta/import.js
const parseImport = (config, compilerCtx, buildCtx, moduleFile, dirPath, importNode) => {
  if (importNode.moduleSpecifier && ts.isStringLiteral(importNode.moduleSpecifier)) {
    let importPath = importNode.moduleSpecifier.text;
    if (!moduleFile.originalImports.includes(importPath)) {
      moduleFile.originalImports.push(importPath);
    }
    if (isAbsolute(importPath)) {
      // absolute import
      importPath = normalizePath(importPath);
      moduleFile.localImports.push(importPath);
    }
    else if (importPath.startsWith('.')) {
      // relative import
      importPath = normalizePath(resolve(dirPath, importPath));
      moduleFile.localImports.push(importPath);
    }
    else {
      // node resolve side effect import
      addExternalImport(config, compilerCtx, buildCtx, moduleFile, moduleFile.sourceFilePath, importPath);
    }
  }
};

// MODULE: compiler/transformers/static-to-meta/visitor.js
const convertStaticToMeta = (config, compilerCtx, buildCtx, typeChecker, collection, transformOpts) => {
  return transformCtx => {
    let dirPath;
    let moduleFile;
    const visitNode = (node) => {
      if (ts.isClassDeclaration(node)) {
        return parseStaticComponentMeta(compilerCtx, typeChecker, node, moduleFile, compilerCtx.nodeMap, transformOpts);
      }
      else if (ts.isImportDeclaration(node)) {
        parseImport(config, compilerCtx, buildCtx, moduleFile, dirPath, node);
      }
      else if (ts.isCallExpression(node)) {
        parseCallExpression(moduleFile, node);
      }
      else if (ts.isStringLiteral(node)) {
        parseStringLiteral(moduleFile, node);
      }
      return ts.visitEachChild(node, visitNode, transformCtx);
    };
    return tsSourceFile => {
      dirPath = dirname(tsSourceFile.fileName);
      moduleFile = getModuleLegacy(config, compilerCtx, tsSourceFile.fileName);
      resetModuleLegacy(moduleFile);
      if (collection != null) {
        moduleFile.isCollectionDependency = true;
        moduleFile.collectionName = collection.collectionName;
        collection.moduleFiles.push(moduleFile);
      }
      else {
        moduleFile.isCollectionDependency = false;
        moduleFile.collectionName = null;
      }
      return visitNode(tsSourceFile);
    };
  };
};

// MODULE: compiler/transformers/add-imports.js
const addImports = (transformOpts, tsSourceFile, importFnNames, importPath) => {
  if (importFnNames.length === 0) {
    return tsSourceFile;
  }
  if (transformOpts.module === 'cjs') {
    // CommonJS require()
    return addCjsRequires(tsSourceFile, importFnNames, importPath);
  }
  // ESM Imports
  return addEsmImports(tsSourceFile, importFnNames, importPath);
};
const addEsmImports = (tsSourceFile, importFnNames, importPath) => {
  // ESM Imports
  // import { importNames } from 'importPath';
  const importSpecifiers = importFnNames.map(importKey => {
    const splt = importKey.split(' as ');
    let importAs = importKey;
    let importFnName = importKey;
    if (splt.length > 1) {
      importAs = splt[1];
      importFnName = splt[0];
    }
    return ts.createImportSpecifier(typeof importFnName === 'string' && importFnName !== importAs ? ts.createIdentifier(importFnName) : undefined, ts.createIdentifier(importAs));
  });
  const statements = tsSourceFile.statements.slice();
  const newImport = ts.createImportDeclaration(undefined, undefined, ts.createImportClause(undefined, ts.createNamedImports(importSpecifiers)), ts.createLiteral(importPath));
  statements.unshift(newImport);
  return ts.updateSourceFileNode(tsSourceFile, statements);
};
const addCjsRequires = (tsSourceFile, importFnNames, importPath) => {
  // CommonJS require()
  // const { a, b, c } = require(importPath);
  const importBinding = ts.createObjectBindingPattern(importFnNames.map(importKey => {
    const splt = importKey.split(' as ');
    let importAs = importKey;
    let importFnName = importKey;
    if (splt.length > 1) {
      importAs = splt[1];
      importFnName = splt[0];
    }
    return ts.createBindingElement(undefined, importFnName, importAs);
  }));
  const requireStatement = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(importBinding, undefined, ts.createCall(ts.createIdentifier('require'), [], [ts.createLiteral(importPath)]))], ts.NodeFlags.Const));
  const statements = tsSourceFile.statements.slice();
  statements.splice(2, 0, requireStatement);
  return ts.updateSourceFileNode(tsSourceFile, statements);
};

// MODULE: compiler/transformers/add-component-meta-proxy.js
const addModuleMetadataProxies = (tsSourceFile, moduleFile) => {
  const statements = tsSourceFile.statements.slice();
  addCoreRuntimeApi(moduleFile, RUNTIME_APIS.proxyCustomElement);
  statements.push(...moduleFile.cmps.map(addComponentMetadataProxy));
  return ts.updateSourceFileNode(tsSourceFile, statements);
};
const addComponentMetadataProxy = (compilerMeta) => {
  const compactMeta = formatComponentRuntimeMeta(compilerMeta, true);
  const liternalCmpClassName = ts.createIdentifier(compilerMeta.componentClassName);
  const liternalMeta = convertValueToLiteral(compactMeta);
  return ts.createStatement(ts.createCall(ts.createIdentifier(PROXY_CUSTOM_ELEMENT), [], [liternalCmpClassName, liternalMeta]));
};

// MODULE: compiler/transformers/define-custom-element.js
const defineCustomElement = (tsSourceFile, moduleFile, transformOpts) => {
  let statements = tsSourceFile.statements.slice();
  statements.push(...moduleFile.cmps.map(cmp => {
    return addDefineCustomElement(moduleFile, cmp);
  }));
  if (transformOpts.module === 'cjs') {
    // remove commonjs exports keyword from component classes
    statements = removeComponentCjsExport(statements, moduleFile);
  }
  return ts.updateSourceFileNode(tsSourceFile, statements);
};
const addDefineCustomElement = (moduleFile, compilerMeta) => {
  if (compilerMeta.isPlain) {
    // add customElements.define('cmp-a', CmpClass);
    return ts.createStatement(ts.createCall(ts.createPropertyAccess(ts.createIdentifier('customElements'), ts.createIdentifier('define')), [], [ts.createLiteral(compilerMeta.tagName), ts.createIdentifier(compilerMeta.componentClassName)]));
  }
  addCoreRuntimeApi(moduleFile, RUNTIME_APIS.defineCustomElement);
  const compactMeta = formatComponentRuntimeMeta(compilerMeta, true);
  const liternalCmpClassName = ts.createIdentifier(compilerMeta.componentClassName);
  const liternalMeta = convertValueToLiteral(compactMeta);
  return ts.createStatement(ts.createCall(ts.createIdentifier(DEFINE_CUSTOM_ELEMENT), [], [liternalCmpClassName, liternalMeta]));
};
const removeComponentCjsExport = (statements, moduleFile) => {
  const cmpClassNames = new Set(moduleFile.cmps.map(cmp => cmp.componentClassName));
  return statements.filter(s => {
    if (s.kind === ts.SyntaxKind.ExpressionStatement) {
      const exp = s.expression;
      if (exp && exp.kind === ts.SyntaxKind.BinaryExpression) {
        const left = exp.left;
        if (left && left.kind === ts.SyntaxKind.PropertyAccessExpression) {
          if (left.expression && left.expression.kind === ts.SyntaxKind.Identifier) {
            const leftText = left.expression;
            if (leftText.text === 'exports') {
              const right = exp.right;
              if (right && cmpClassNames.has(right.text)) {
                return false;
              }
            }
          }
        }
      }
    }
    return true;
  });
};

// MODULE: compiler/transformers/component-native/native-connected-callback.js
const addNativeConnectedCallback = (classMembers, cmp) => {
  // function call to stencil's exported connectedCallback(elm, plt)
  // TODO: fast path
  if (cmp.isPlain && cmp.hasRenderFn) {
    const fnCall = ts.createExpressionStatement(ts.createAssignment(ts.createPropertyAccess(ts.createThis(), 'textContent'), ts.createCall(ts.createPropertyAccess(ts.createThis(), 'render'), undefined, undefined)));
    const connectedCallback = classMembers.find(classMember => {
      return ts.isMethodDeclaration(classMember) && classMember.name.escapedText === 'connectedCallback';
    });
    const prependBody = [fnCall];
    if (connectedCallback != null) {
      // class already has a connectedCallback(), so update it
      connectedCallback.body = ts.updateBlock(connectedCallback.body, [...prependBody, ...connectedCallback.body.statements]);
    }
    else {
      // class doesn't have a connectedCallback(), so add it
      const callbackMethod = ts.createMethod(undefined, undefined, undefined, 'connectedCallback', undefined, undefined, undefined, undefined, ts.createBlock(prependBody, true));
      classMembers.push(callbackMethod);
    }
  }
};

// MODULE: compiler/transformers/component-native/native-element-getter.js
const addNativeElementGetter = (classMembers, cmp) => {
  // @Element() element;
  // is transformed into:
  // get element() { return this; }
  if (cmp.elementRef) {
    classMembers.push(ts.createGetAccessor(undefined, undefined, cmp.elementRef, [], undefined, ts.createBlock([ts.createReturn(ts.createThis())])));
  }
};

// MODULE: compiler/transformers/component-native/native-static-style.js
const addNativeStaticStyle = (classMembers, cmp) => {
  if (Array.isArray(cmp.styles) && cmp.styles.length > 0) {
    if (cmp.styles.length > 1 || (cmp.styles.length === 1 && cmp.styles[0].modeName !== DEFAULT_STYLE_MODE)) {
      // multiple style modes
      addMultipleModeStyleGetter(classMembers, cmp, cmp.styles);
    }
    else {
      // single style
      addSingleStyleGetter(classMembers, cmp, cmp.styles[0]);
    }
  }
};
const addMultipleModeStyleGetter = (classMembers, cmp, styles) => {
  const styleModes = [];
  styles.forEach(style => {
    if (typeof style.styleStr === 'string') {
      // inline the style string
      // static get style() { return { "ios": "string" }; }
      const styleLiteral = createStyleLiteral(cmp, style);
      const propStr = ts.createPropertyAssignment(style.modeName, styleLiteral);
      styleModes.push(propStr);
    }
    else if (typeof style.styleIdentifier === 'string') {
      // direct import already written in the source code
      // import myTagIosStyle from './import-path.css';
      // static get style() { return { "ios": myTagIosStyle }; }
      const styleIdentifier = ts.createIdentifier(style.styleIdentifier);
      const propIdentifier = ts.createPropertyAssignment(style.modeName, styleIdentifier);
      styleModes.push(propIdentifier);
    }
    else if (Array.isArray(style.externalStyles) && style.externalStyles.length > 0) {
      // import generated from @Component() styleUrls option
      // import myTagIosStyle from './import-path.css';
      // static get style() { return { "ios": myTagIosStyle }; }
      const styleUrlIdentifier = createStyleIdentifierFromUrl(cmp, style);
      const propUrlIdentifier = ts.createPropertyAssignment(style.modeName, styleUrlIdentifier);
      styleModes.push(propUrlIdentifier);
    }
  });
  const styleObj = ts.createObjectLiteral(styleModes, true);
  classMembers.push(createStaticGetter('style', styleObj));
};
const addSingleStyleGetter = (classMembers, cmp, style) => {
  if (typeof style.styleStr === 'string') {
    // inline the style string
    // static get style() { return "string"; }
    const styleLiteral = createStyleLiteral(cmp, style);
    classMembers.push(createStaticGetter('style', styleLiteral));
  }
  else if (typeof style.styleIdentifier === 'string') {
    // direct import already written in the source code
    // import myTagStyle from './import-path.css';
    // static get style() { return myTagStyle; }
    const styleIdentifier = ts.createIdentifier(style.styleIdentifier);
    classMembers.push(createStaticGetter('style', styleIdentifier));
  }
  else if (Array.isArray(style.externalStyles) && style.externalStyles.length > 0) {
    // import generated from @Component() styleUrls option
    // import myTagStyle from './import-path.css';
    // static get style() { return myTagStyle; }
    const styleUrlIdentifier = createStyleIdentifierFromUrl(cmp, style);
    classMembers.push(createStaticGetter('style', styleUrlIdentifier));
  }
};
const createStyleLiteral = (cmp, style) => {
  if (cmp.encapsulation === 'scoped') {
    // scope the css first
    const scopeId = getScopeId(cmp.tagName, style.modeName);
    return ts.createStringLiteral(scopeCss(style.styleStr, scopeId, false));
  }
  return ts.createStringLiteral(style.styleStr);
};
const createStyleIdentifierFromUrl = (cmp, style) => {
  style.styleIdentifier = dashToPascalCase(cmp.tagName);
  style.styleIdentifier = style.styleIdentifier.charAt(0).toLowerCase() + style.styleIdentifier.substring(1);
  if (style.modeName !== DEFAULT_STYLE_MODE) {
    style.styleIdentifier += dashToPascalCase(style.modeName);
  }
  style.styleIdentifier += 'Style';
  style.externalStyles = [style.externalStyles[0]];
  return ts.createIdentifier(style.styleIdentifier);
};

// MODULE: compiler/transformers/watcher-meta-transform.js
const addWatchers = (classMembers, cmp) => {
  if (cmp.watchers.length > 0) {
    const watcherObj = {};
    cmp.watchers.forEach(({ propName, methodName }) => {
      watcherObj[propName] = watcherObj[propName] || [];
      watcherObj[propName].push(methodName);
    });
    classMembers.push(createStaticGetter('watchers', convertValueToLiteral(watcherObj)));
  }
};

// MODULE: compiler/transformers/remove-static-meta-properties.js
const removeStaticMetaProperties = (classNode) => {
  if (classNode.members == null) {
    return [];
  }
  return classNode.members.filter(classMember => {
    if (classMember.modifiers) {
      if (classMember.modifiers.some(m => m.kind === ts.SyntaxKind.StaticKeyword)) {
        const memberName = classMember.name.escapedText;
        if (REMOVE_STATIC_GETTERS.has(memberName)) {
          return false;
        }
      }
    }
    return true;
  });
};
const REMOVE_STATIC_GETTERS = new Set([
  'is',
  'properties',
  'encapsulation',
  'elementRef',
  'events',
  'listeners',
  'methods',
  'states',
  'originalStyleUrls',
  'styleMode',
  'style',
  'styles',
  'styleUrl',
  'watchers',
  'styleUrls',
  'contextProps',
  'connectProps',
]);

// MODULE: compiler/transformers/host-data-transform.js
const transformHostData = (classElements, moduleFile) => {
  const hasHostData = classElements.some(e => ts.isMethodDeclaration(e) && e.name.escapedText === 'hostData');
  if (hasHostData) {
    const renderIndex = classElements.findIndex(e => ts.isMethodDeclaration(e) && e.name.escapedText === 'render');
    if (renderIndex >= 0) {
      const renderMethod = classElements[renderIndex];
      classElements[renderIndex] = ts.updateMethod(renderMethod, renderMethod.decorators, renderMethod.modifiers, renderMethod.asteriskToken, ts.createIdentifier(INTERNAL_RENDER), renderMethod.questionToken, renderMethod.typeParameters, renderMethod.parameters, renderMethod.type, renderMethod.body);
    }
    classElements.push(syntheticRender(moduleFile, renderIndex >= 0));
  }
};
const syntheticRender = (moduleFile, hasRender) => {
  addCoreRuntimeApi(moduleFile, RUNTIME_APIS.Host);
  addCoreRuntimeApi(moduleFile, RUNTIME_APIS.h);
  const hArguments = [
    // __stencil_Host
    ts.createIdentifier(HOST),
    // this.hostData()
    ts.createCall(ts.createPropertyAccess(ts.createThis(), 'hostData'), undefined, undefined),
  ];
  if (hasRender) {
    hArguments.push(
    // this.render()
    ts.createCall(ts.createPropertyAccess(ts.createThis(), INTERNAL_RENDER), undefined, undefined));
  }
  /**
   * render() {
   *   return h(arguments);
   * }
   */
  return ts.createMethod(undefined, undefined, undefined, 'render', undefined, undefined, undefined, undefined, ts.createBlock([ts.createReturn(ts.createCall(ts.createIdentifier(H), undefined, hArguments))]));
};
const INTERNAL_RENDER = '__stencil_render';

// MODULE: compiler/transformers/update-component-class.js
const updateComponentClass = (transformOpts, classNode, heritageClauses, members) => {
  if (transformOpts.module === 'cjs') {
    // CommonJS, leave component class as is
    let classModifiers = Array.isArray(classNode.modifiers) ? classNode.modifiers.slice() : [];
    if (transformOpts.componentExport === 'customelement') {
      // remove export from class
      classModifiers = classModifiers.filter(m => {
        return m.kind !== ts.SyntaxKind.ExportKeyword;
      });
    }
    return ts.updateClassDeclaration(classNode, classNode.decorators, classModifiers, classNode.name, classNode.typeParameters, heritageClauses, members);
  }
  // ESM with export
  return createConstClass(transformOpts, classNode, heritageClauses, members);
};
const createConstClass = (transformOpts, classNode, heritageClauses, members) => {
  const className = classNode.name;
  const classModifiers = (Array.isArray(classNode.modifiers) ? classNode.modifiers : []).filter(m => {
    // remove the export
    return m.kind !== ts.SyntaxKind.ExportKeyword;
  });
  const constModifiers = [];
  if (transformOpts.componentExport !== 'customelement') {
    constModifiers.push(ts.createModifier(ts.SyntaxKind.ExportKeyword));
  }
  return ts.createVariableStatement(constModifiers, ts.createVariableDeclarationList([ts.createVariableDeclaration(className, undefined, ts.createClassExpression(classModifiers, undefined, classNode.typeParameters, heritageClauses, members))], ts.NodeFlags.Const));
};

// MODULE: compiler/transformers/create-event.js
const addCreateEvents = (moduleFile, cmp) => {
  return cmp.events.map(ev => {
    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.createEvent);
    return ts.createStatement(ts.createAssignment(ts.createPropertyAccess(ts.createThis(), ts.createIdentifier(ev.method)), ts.createCall(ts.createIdentifier(CREATE_EVENT), undefined, [ts.createThis(), ts.createLiteral(ev.name), ts.createLiteral(computeFlags(ev))])));
  });
};
const computeFlags = (eventMeta) => {
  let flags = 0;
  if (eventMeta.bubbles) {
    flags |= 4 /* Bubbles */;
  }
  if (eventMeta.composed) {
    flags |= 2 /* Composed */;
  }
  if (eventMeta.cancelable) {
    flags |= 1 /* Cancellable */;
  }
  return flags;
};

// MODULE: compiler/transformers/legacy-props.js
const addLegacyProps = (moduleFile, cmp) => {
  if (cmp.legacyConnect.length > 0) {
    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.getConnect);
  }
  if (cmp.legacyContext.length > 0) {
    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.getContext);
  }
  return [...cmp.legacyConnect.map(c => getStatement(c.name, GET_CONNECT, c.connect)), ...cmp.legacyContext.map(c => getStatement(c.name, GET_CONTEXT, c.context))];
};
const getStatement = (propName, method, arg) => {
  return ts.createExpressionStatement(ts.createAssignment(ts.createPropertyAccess(ts.createThis(), propName), ts.createCall(ts.createIdentifier(method), undefined, [ts.createThis(), ts.createLiteral(arg)])));
};

// MODULE: compiler/transformers/component-native/native-constructor.js
const updateNativeConstructor = (classMembers, moduleFile, cmp, ensureSuper) => {
  if (cmp.isPlain) {
    return;
  }
  const cstrMethodIndex = classMembers.findIndex(m => m.kind === ts.SyntaxKind.Constructor);
  if (cstrMethodIndex >= 0) {
    // add to the existing constructor()
    const cstrMethod = classMembers[cstrMethodIndex];
    let statements = [...nativeInit(moduleFile, cmp), ...cstrMethod.body.statements, ...addCreateEvents(moduleFile, cmp), ...addLegacyProps(moduleFile, cmp)];
    if (ensureSuper) {
      const hasSuper = cstrMethod.body.statements.some(s => s.kind === ts.SyntaxKind.SuperKeyword);
      if (!hasSuper) {
        statements = [createNativeConstructorSuper(), ...statements];
      }
    }
    classMembers[cstrMethodIndex] = ts.updateConstructor(cstrMethod, cstrMethod.decorators, cstrMethod.modifiers, cstrMethod.parameters, ts.updateBlock(cstrMethod.body, statements));
  }
  else {
    // create a constructor()
    let statements = [...nativeInit(moduleFile, cmp), ...addCreateEvents(moduleFile, cmp), ...addLegacyProps(moduleFile, cmp)];
    if (ensureSuper) {
      statements = [createNativeConstructorSuper(), ...statements];
    }
    const cstrMethod = ts.createConstructor(undefined, undefined, undefined, ts.createBlock(statements, true));
    classMembers.unshift(cstrMethod);
  }
};
const nativeInit = (moduleFile, cmp) => {
  const initStatements = [nativeRegisterHostStatement()];
  if (cmp.encapsulation === 'shadow') {
    initStatements.push(nativeAttachShadowStatement(moduleFile));
  }
  return initStatements;
};
const nativeRegisterHostStatement = () => {
  return ts.createStatement(ts.createCall(ts.createPropertyAccess(ts.createThis(), ts.createIdentifier('__registerHost')), undefined, undefined));
};
const nativeAttachShadowStatement = (moduleFile) => {
  addCoreRuntimeApi(moduleFile, RUNTIME_APIS.attachShadow);
  return ts.createStatement(ts.createCall(ts.createIdentifier(ATTACH_SHADOW), undefined, [ts.createThis()]));
};
const createNativeConstructorSuper = () => {
  return ts.createExpressionStatement(ts.createCall(ts.createIdentifier('super'), undefined, undefined));
};

// MODULE: compiler/transformers/component-native/native-component.js
const updateNativeComponentClass = (transformOpts, classNode, moduleFile, cmp) => {
  const heritageClauses = updateNativeHostComponentHeritageClauses(classNode, moduleFile);
  const members = updateNativeHostComponentMembers(transformOpts, classNode, moduleFile, cmp);
  return updateComponentClass(transformOpts, classNode, heritageClauses, members);
};
const updateNativeHostComponentHeritageClauses = (classNode, moduleFile) => {
  if (classNode.heritageClauses != null && classNode.heritageClauses.length > 0) {
    return classNode.heritageClauses;
  }
  if (moduleFile.cmps.length > 1) {
    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.HTMLElement);
  }
  const heritageClause = ts.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [ts.createExpressionWithTypeArguments([], ts.createIdentifier(HTML_ELEMENT))]);
  return [heritageClause];
};
const updateNativeHostComponentMembers = (transformOpts, classNode, moduleFile, cmp) => {
  const classMembers = removeStaticMetaProperties(classNode);
  updateNativeConstructor(classMembers, moduleFile, cmp, true);
  addNativeConnectedCallback(classMembers, cmp);
  addNativeElementGetter(classMembers, cmp);
  addWatchers(classMembers, cmp);
  if (transformOpts.style === 'static') {
    addNativeStaticStyle(classMembers, cmp);
  }
  transformHostData(classMembers, moduleFile);
  return classMembers;
};

// MODULE: compiler/transformers/style-imports.js
const updateStyleImports = (transformOpts, tsSourceFile, moduleFile) => {
  // add style imports built from @Component() styleUrl option
  if (transformOpts.module === 'cjs') {
    return updateCjsStyleRequires(tsSourceFile, moduleFile);
  }
  return updateEsmStyleImports(tsSourceFile, moduleFile);
};
const updateEsmStyleImports = (tsSourceFile, moduleFile) => {
  const styleImports = [];
  let statements = tsSourceFile.statements.slice();
  let updateSourceFile = false;
  moduleFile.cmps.forEach(cmp => {
    cmp.styles.forEach(style => {
      if (typeof style.styleIdentifier === 'string') {
        updateSourceFile = true;
        if (style.externalStyles.length > 0) {
          // add style imports built from @Component() styleUrl option
          styleImports.push(createEsmStyleImport(tsSourceFile, cmp, style));
        }
        else {
          // update existing esm import of a style identifier
          statements = updateEsmStyleImportPath(tsSourceFile, statements, cmp, style);
        }
      }
    });
  });
  if (updateSourceFile) {
    let lastImportIndex = -1;
    for (let i = 0; i < statements.length; i++) {
      if (ts.isImportDeclaration(statements[i])) {
        lastImportIndex = i;
      }
    }
    statements.splice(lastImportIndex + 1, 0, ...styleImports);
    return ts.updateSourceFileNode(tsSourceFile, statements);
  }
  return tsSourceFile;
};
const updateEsmStyleImportPath = (tsSourceFile, statements, cmp, style) => {
  for (let i = 0; i < statements.length; i++) {
    const n = statements[i];
    if (ts.isImportDeclaration(n) && n.importClause && n.moduleSpecifier && ts.isStringLiteral(n.moduleSpecifier)) {
      if (n.importClause.name && n.importClause.name.escapedText === style.styleIdentifier) {
        const orgImportPath = n.moduleSpecifier.text;
        const importPath = getStyleImportPath(tsSourceFile, cmp, style, orgImportPath);
        statements[i] = ts.updateImportDeclaration(n, n.decorators, n.modifiers, n.importClause, ts.createStringLiteral(importPath));
        break;
      }
    }
  }
  return statements;
};
const createEsmStyleImport = (tsSourceFile, cmp, style) => {
  const importName = ts.createIdentifier(style.styleIdentifier);
  const importPath = getStyleImportPath(tsSourceFile, cmp, style, style.externalStyles[0].absolutePath);
  return ts.createImportDeclaration(undefined, undefined, ts.createImportClause(importName, undefined), ts.createLiteral(importPath));
};
const updateCjsStyleRequires = (tsSourceFile, moduleFile) => {
  const styleRequires = [];
  moduleFile.cmps.forEach(cmp => {
    cmp.styles.forEach(style => {
      if (typeof style.styleIdentifier === 'string' && style.externalStyles.length > 0) {
        // add style imports built from @Component() styleUrl option
        styleRequires.push(createCjsStyleRequire(tsSourceFile, cmp, style));
      }
    });
  });
  if (styleRequires.length > 0) {
    return ts.updateSourceFileNode(tsSourceFile, [...styleRequires, ...tsSourceFile.statements]);
  }
  return tsSourceFile;
};
const createCjsStyleRequire = (tsSourceFile, cmp, style) => {
  const importName = ts.createIdentifier(style.styleIdentifier);
  const importPath = getStyleImportPath(tsSourceFile, cmp, style, style.externalStyles[0].absolutePath);
  return ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(importName, undefined, ts.createCall(ts.createIdentifier('require'), [], [ts.createLiteral(importPath)]))], ts.NodeFlags.Const));
};
const getStyleImportPath = (tsSourceFile, cmp, style, importPath) => {
  const importData = {
    importeePath: importPath,
    importerPath: tsSourceFile.fileName,
    tag: cmp.tagName,
    encapsulation: cmp.encapsulation,
    mode: style.modeName,
  };
  return serializeImportPath(importData);
};

// MODULE: compiler/transformers/component-native/tranform-to-native-component.js
const nativeComponentTransform = (compilerCtx, transformOpts) => {
  return transformCtx => {
    return tsSourceFile => {
      const moduleFile = getModuleFromSourceFile(compilerCtx, tsSourceFile);
      const visitNode = (node) => {
        if (ts.isClassDeclaration(node)) {
          const cmp = getComponentMeta(compilerCtx, tsSourceFile, node);
          if (cmp != null) {
            return updateNativeComponentClass(transformOpts, node, moduleFile, cmp);
          }
        }
        return ts.visitEachChild(node, visitNode, transformCtx);
      };
      tsSourceFile = ts.visitEachChild(tsSourceFile, visitNode, transformCtx);
      if (moduleFile.cmps.length > 0) {
        if (transformOpts.componentExport === 'customelement') {
          // define custom element, will have no export
          tsSourceFile = defineCustomElement(tsSourceFile, moduleFile, transformOpts);
        }
        else if (transformOpts.proxy === 'defineproperty') {
          // exporting as a module, but also add the component proxy fn
          tsSourceFile = addModuleMetadataProxies(tsSourceFile, moduleFile);
        }
        tsSourceFile = updateStyleImports(transformOpts, tsSourceFile, moduleFile);
      }
      if (moduleFile.isLegacy) {
        addLegacyApis(moduleFile);
      }
      tsSourceFile = addImports(transformOpts, tsSourceFile, moduleFile.coreRuntimeApis, transformOpts.coreImportPath);
      return tsSourceFile;
    };
  };
};

// MODULE: compiler/transformers/component-lazy/lazy-element-getter.js
const addLazyElementGetter = (classMembers, moduleFile, cmp) => {
  // @Element() element;
  // is transformed into:
  // get element() { return __stencil_getElement(this); }
  if (cmp.elementRef) {
    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.getElement);
    classMembers.push(ts.createGetAccessor(undefined, undefined, cmp.elementRef, [], undefined, ts.createBlock([ts.createReturn(ts.createCall(ts.createIdentifier(GET_ELEMENT), undefined, [ts.createThis()]))])));
  }
};

// MODULE: compiler/transformers/add-static-style.js
/**
 * Adds static "style" getter within the class
 * const MyComponent = class {
 *   static get style() { return "styles"; }
 * }
 */
const addStaticStyleGetterWithinClass = (classMembers, cmp) => {
  const styleLiteral = getStyleLiteral(cmp);
  if (styleLiteral) {
    classMembers.push(createStaticGetter('style', styleLiteral));
  }
};
/**
 * Adds static "style" property to the class variable.
 * const MyComponent = class {}
 * MyComponent.style = "styles";
 */
const addStaticStylePropertyToClass = (styleStatements, cmp) => {
  const styleLiteral = getStyleLiteral(cmp);
  if (styleLiteral) {
    const statement = ts.createStatement(ts.createAssignment(ts.createPropertyAccess(ts.createIdentifier(cmp.componentClassName), 'style'), styleLiteral));
    styleStatements.push(statement);
  }
};
const getStyleLiteral = (cmp) => {
  if (Array.isArray(cmp.styles) && cmp.styles.length > 0) {
    if (cmp.styles.length > 1 || (cmp.styles.length === 1 && cmp.styles[0].modeName !== DEFAULT_STYLE_MODE)) {
      // multiple style modes
      return getMultipleModeStyle(cmp, cmp.styles);
    }
    else {
      // single style
      return getSingleStyle(cmp, cmp.styles[0]);
    }
  }
  return null;
};
const getMultipleModeStyle = (cmp, styles) => {
  const styleModes = [];
  styles.forEach(style => {
    if (typeof style.styleStr === 'string') {
      // inline the style string
      // static get style() { return { ios: "string" }; }
      const styleLiteral = createStyleLiteral$1(cmp, style);
      const propStr = createPropertyAssignment(style.modeName, styleLiteral);
      styleModes.push(propStr);
    }
    else if (typeof style.styleIdentifier === 'string') {
      // direct import already written in the source code
      // import myTagIosStyle from './import-path.css';
      // static get style() { return { ios: myTagIosStyle }; }
      const styleIdentifier = ts.createIdentifier(style.styleIdentifier);
      const propIdentifier = createPropertyAssignment(style.modeName, styleIdentifier);
      styleModes.push(propIdentifier);
    }
    else if (Array.isArray(style.externalStyles) && style.externalStyles.length > 0) {
      // import generated from @Component() styleUrls option
      // import myTagIosStyle from './import-path.css';
      // static get style() { return { ios: myTagIosStyle }; }
      const styleUrlIdentifier = createStyleIdentifierFromUrl$1(cmp, style);
      const propUrlIdentifier = createPropertyAssignment(style.modeName, styleUrlIdentifier);
      styleModes.push(propUrlIdentifier);
    }
  });
  return ts.createObjectLiteral(styleModes, true);
};
const createPropertyAssignment = (mode, initializer) => {
  const node = ts.createPropertyAssignment(mode, initializer);
  ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, `STENCIL:MODE:${mode}`);
  return node;
};
const getSingleStyle = (cmp, style) => {
  if (typeof style.styleStr === 'string') {
    // inline the style string
    // static get style() { return "string"; }
    return createStyleLiteral$1(cmp, style);
  }
  if (typeof style.styleIdentifier === 'string') {
    // direct import already written in the source code
    // import myTagStyle from './import-path.css';
    // static get style() { return myTagStyle; }
    return ts.createIdentifier(style.styleIdentifier);
  }
  if (Array.isArray(style.externalStyles) && style.externalStyles.length > 0) {
    // import generated from @Component() styleUrls option
    // import myTagStyle from './import-path.css';
    // static get style() { return myTagStyle; }
    return createStyleIdentifierFromUrl$1(cmp, style);
  }
  return null;
};
const createStyleLiteral$1 = (cmp, style) => {
  if (cmp.encapsulation === 'scoped') {
    // scope the css first
    const scopeId = getScopeId(cmp.tagName, style.modeName);
    return ts.createStringLiteral(scopeCss(style.styleStr, scopeId, false));
  }
  return ts.createStringLiteral(style.styleStr);
};
const createStyleIdentifierFromUrl$1 = (cmp, style) => {
  style.styleIdentifier = dashToPascalCase(cmp.tagName);
  style.styleIdentifier = style.styleIdentifier.charAt(0).toLowerCase() + style.styleIdentifier.substring(1);
  if (style.modeName !== DEFAULT_STYLE_MODE) {
    style.styleIdentifier += dashToPascalCase(style.modeName);
  }
  style.styleIdentifier += 'Style';
  style.externalStyles = [style.externalStyles[0]];
  return ts.createIdentifier(style.styleIdentifier);
};

// MODULE: compiler/transformers/component-lazy/lazy-constructor.js
const updateLazyComponentConstructor = (classMembers, moduleFile, cmp) => {
  const cstrMethodArgs = [ts.createParameter(undefined, undefined, undefined, ts.createIdentifier(HOST_REF_ARG))];
  const cstrMethodIndex = classMembers.findIndex(m => m.kind === ts.SyntaxKind.Constructor);
  if (cstrMethodIndex >= 0) {
    // add to the existing constructor()
    const cstrMethod = classMembers[cstrMethodIndex];
    const body = ts.updateBlock(cstrMethod.body, [
      registerInstanceStatement(moduleFile),
      ...cstrMethod.body.statements,
      ...addCreateEvents(moduleFile, cmp),
      ...addLegacyProps(moduleFile, cmp),
    ]);
    classMembers[cstrMethodIndex] = ts.updateConstructor(cstrMethod, cstrMethod.decorators, cstrMethod.modifiers, cstrMethodArgs, body);
  }
  else {
    // create a constructor()
    const cstrMethod = ts.createConstructor(undefined, undefined, cstrMethodArgs, ts.createBlock([registerInstanceStatement(moduleFile), ...addCreateEvents(moduleFile, cmp), ...addLegacyProps(moduleFile, cmp)], true));
    classMembers.unshift(cstrMethod);
  }
};
const registerInstanceStatement = (moduleFile) => {
  addCoreRuntimeApi(moduleFile, RUNTIME_APIS.registerInstance);
  return ts.createStatement(ts.createCall(ts.createIdentifier(REGISTER_INSTANCE), undefined, [ts.createThis(), ts.createIdentifier(HOST_REF_ARG)]));
};
const HOST_REF_ARG = 'hostRef';

// MODULE: compiler/transformers/component-lazy/lazy-component.js
const updateLazyComponentClass = (transformOpts, styleStatements, classNode, moduleFile, cmp) => {
  const members = updateLazyComponentMembers(transformOpts, styleStatements, classNode, moduleFile, cmp);
  return updateComponentClass(transformOpts, classNode, classNode.heritageClauses, members);
};
const updateLazyComponentMembers = (transformOpts, styleStatements, classNode, moduleFile, cmp) => {
  const classMembers = removeStaticMetaProperties(classNode);
  updateLazyComponentConstructor(classMembers, moduleFile, cmp);
  addLazyElementGetter(classMembers, moduleFile, cmp);
  addWatchers(classMembers, cmp);
  transformHostData(classMembers, moduleFile);
  if (transformOpts.style === 'static') {
    addStaticStylePropertyToClass(styleStatements, cmp);
  }
  return classMembers;
};

// MODULE: compiler/transformers/component-lazy/transform-lazy-component.js
const lazyComponentTransform = (compilerCtx, transformOpts) => {
  return transformCtx => {
    return tsSourceFile => {
      const styleStatements = [];
      const moduleFile = getModuleFromSourceFile(compilerCtx, tsSourceFile);
      const visitNode = (node) => {
        if (ts.isClassDeclaration(node)) {
          const cmp = getComponentMeta(compilerCtx, tsSourceFile, node);
          if (cmp != null) {
            return updateLazyComponentClass(transformOpts, styleStatements, node, moduleFile, cmp);
          }
        }
        return ts.visitEachChild(node, visitNode, transformCtx);
      };
      tsSourceFile = ts.visitEachChild(tsSourceFile, visitNode, transformCtx);
      if (moduleFile.cmps.length > 0) {
        tsSourceFile = updateStyleImports(transformOpts, tsSourceFile, moduleFile);
      }
      if (moduleFile.isLegacy) {
        addLegacyApis(moduleFile);
      }
      tsSourceFile = addImports(transformOpts, tsSourceFile, moduleFile.coreRuntimeApis, transformOpts.coreImportPath);
      if (styleStatements.length > 0) {
        tsSourceFile = ts.updateSourceFileNode(tsSourceFile, [...tsSourceFile.statements, ...styleStatements]);
      }
      return tsSourceFile;
    };
  };
};

// MODULE: testing/testing-logger.js
class TestingLogger {
  constructor() {
    this.colors = false;
    this.enable = false;
    this.buildLogFilePath = null;
  }
  info(...msg) {
    if (this.enable) {
      console.log.apply(console, msg);
    }
  }
  warn(...msg) {
    if (this.enable) {
      console.warn.apply(console, msg);
    }
  }
  error(...msg) {
    if (this.enable) {
      console.error.apply(console, msg);
    }
  }
  debug(...msg) {
    if (this.enable) {
      console.log.apply(console, msg);
    }
  }
  color(_msg, _color) {
    /* */
  }
  red(msg) {
    return msg;
  }
  green(msg) {
    return msg;
  }
  yellow(msg) {
    return msg;
  }
  blue(msg) {
    return msg;
  }
  magenta(msg) {
    return msg;
  }
  cyan(msg) {
    return msg;
  }
  gray(msg) {
    return msg;
  }
  bold(msg) {
    return msg;
  }
  dim(msg) {
    return msg;
  }
  bgRed(msg) {
    return msg;
  }
  createTimeSpan(_startMsg, _debug = false) {
    return {
      duration() {
        return 0;
      },
      finish() {
        return 0;
      },
    };
  }
  printDiagnostics(_diagnostics) {
    /* */
  }
  writeLogs(_) {
    /**/
  }
}

// MODULE: compiler/transformers/update-stencil-core-import.js
const updateStencilCoreImports = (updatedCoreImportPath) => {
  return () => {
    return tsSourceFile => {
      let madeChanges = false;
      const newStatements = [];
      tsSourceFile.statements.forEach(s => {
        if (ts.isImportDeclaration(s)) {
          if (s.moduleSpecifier != null && ts.isStringLiteral(s.moduleSpecifier)) {
            if (s.moduleSpecifier.text === STENCIL_CORE_ID) {
              if (s.importClause && s.importClause.namedBindings && s.importClause.namedBindings.kind === ts.SyntaxKind.NamedImports) {
                const origImports = s.importClause.namedBindings.elements;
                const keepImports = origImports.map(e => e.getText()).filter(name => KEEP_IMPORTS.has(name));
                if (keepImports.length > 0) {
                  const newImport = ts.updateImportDeclaration(s, undefined, undefined, ts.createImportClause(undefined, ts.createNamedImports(keepImports.map(name => ts.createImportSpecifier(undefined, ts.createIdentifier(name))))), ts.createStringLiteral(updatedCoreImportPath));
                  newStatements.push(newImport);
                }
              }
              madeChanges = true;
              return;
            }
          }
        }
        newStatements.push(s);
      });
      if (madeChanges) {
        return ts.updateSourceFileNode(tsSourceFile, newStatements, tsSourceFile.isDeclarationFile, tsSourceFile.referencedFiles, tsSourceFile.typeReferenceDirectives, tsSourceFile.hasNoDefaultLib, tsSourceFile.libReferenceDirectives);
      }
      return tsSourceFile;
    };
  };
};
const KEEP_IMPORTS = new Set([
  'h',
  'setMode',
  'getMode',
  'Build',
  'Host',
  'getAssetPath',
  'writeTask',
  'readTask',
  'getElement',
  'forceUpdate',
  'getRenderingRef',
  'forceModeUpdate',
]);

// MODULE: compiler/transpile/transpile-module.js
/**
 * Stand-alone compiling of a single string
 */
const transpileModule = (config, input, transformOpts) => {
  if (!config.logger) {
    config = Object.assign({ logger: new TestingLogger() }, config);
  }
  const compilerCtx = new CompilerContext();
  const buildCtx = new BuildContext(config, compilerCtx);
  const tsCompilerOptions = Object.assign({}, config.tsCompilerOptions);
  let sourceFilePath = transformOpts.file;
  if (isString(sourceFilePath)) {
    sourceFilePath = normalizePath(sourceFilePath);
  }
  else {
    sourceFilePath = tsCompilerOptions.jsx ? `module.tsx` : `module.ts`;
  }
  const results = {
    sourceFilePath: sourceFilePath,
    code: null,
    map: null,
    diagnostics: [],
    moduleFile: null,
    build: {},
  };
  if (transformOpts.module === 'cjs') {
    tsCompilerOptions.module = ts.ModuleKind.CommonJS;
  }
  else {
    tsCompilerOptions.module = ts.ModuleKind.ESNext;
  }
  tsCompilerOptions.target = getScriptTargetKind(transformOpts);
  if ((sourceFilePath.endsWith('.tsx') || sourceFilePath.endsWith('.jsx')) && tsCompilerOptions.jsx == null) {
    // ensure we're setup for JSX in typescript
    tsCompilerOptions.jsx = ts.JsxEmit.React;
  }
  if (tsCompilerOptions.jsx != null && !isString(tsCompilerOptions.jsxFactory)) {
    tsCompilerOptions.jsxFactory = 'h';
  }
  if (tsCompilerOptions.paths && !isString(tsCompilerOptions.baseUrl)) {
    tsCompilerOptions.baseUrl = '.';
  }
  const sourceFile = ts.createSourceFile(sourceFilePath, input, tsCompilerOptions.target);
  // Create a compilerHost object to allow the compiler to read and write files
  const compilerHost = {
    getSourceFile: fileName => {
      return normalizePath(fileName) === normalizePath(sourceFilePath) ? sourceFile : undefined;
    },
    writeFile: (name, text) => {
      if (name.endsWith('.js.map')) {
        results.map = text;
      }
      else if (name.endsWith('.js')) {
        results.code = text;
      }
    },
    getDefaultLibFileName: () => `lib.d.ts`,
    useCaseSensitiveFileNames: () => false,
    getCanonicalFileName: fileName => fileName,
    getCurrentDirectory: () => transformOpts.currentDirectory || '',
    getNewLine: () => ts.sys.newLine,
    fileExists: fileName => normalizePath(fileName) === normalizePath(sourceFilePath),
    readFile: () => '',
    directoryExists: () => true,
    getDirectories: () => [],
  };
  const program = ts.createProgram([sourceFilePath], tsCompilerOptions, compilerHost);
  const typeChecker = program.getTypeChecker();
  const after = [convertStaticToMeta(config, compilerCtx, buildCtx, typeChecker, null, transformOpts)];
  if (transformOpts.componentExport === 'customelement' || transformOpts.componentExport === 'module') {
    after.push(nativeComponentTransform(compilerCtx, transformOpts));
  }
  else {
    after.push(lazyComponentTransform(compilerCtx, transformOpts));
  }
  program.emit(undefined, undefined, undefined, false, {
    before: [convertDecoratorsToStatic(config, buildCtx.diagnostics, typeChecker), updateStencilCoreImports(transformOpts.coreImportPath)],
    after,
  });
  const tsDiagnostics = [...program.getSyntacticDiagnostics()];
  if (config.validateTypes) {
    tsDiagnostics.push(...program.getOptionsDiagnostics());
  }
  buildCtx.diagnostics.push(...loadTypeScriptDiagnostics(tsDiagnostics));
  results.diagnostics.push(...buildCtx.diagnostics);
  results.moduleFile = compilerCtx.moduleMap.get(results.sourceFilePath);
  return results;
};
const getScriptTargetKind = (transformOpts) => {
  switch (transformOpts.target) {
    case 'esnext': {
      return ts.ScriptTarget.ESNext;
    }
    case 'es2020': {
      return ts.ScriptTarget.ES2020;
    }
    case 'es2019': {
      return ts.ScriptTarget.ES2019;
    }
    case 'es2018': {
      return ts.ScriptTarget.ES2018;
    }
    case 'es2017': {
      return ts.ScriptTarget.ES2017;
    }
    case 'es2016': {
      return ts.ScriptTarget.ES2016;
    }
    case 'es2015': {
      return ts.ScriptTarget.ES2015;
    }
    case 'es5': {
      return ts.ScriptTarget.ES5;
    }
    default: {
      return ts.ScriptTarget.Latest;
    }
  }
};

// MODULE: compiler/compile-module.js
const compile$1 = async (code, opts = {}) => {
  const { importData, results } = getCompileResults(code, opts);
  try {
    if (shouldTranspileCode(results.inputFileExtension)) {
      const { config, compileOpts, transformOpts } = getCompileModuleConfig(opts);
      await patchTypescript(config, results.diagnostics, null);
      compileModule(config, compileOpts, transformOpts, results);
    }
    else if (results.inputFileExtension === 'd.ts') {
      results.code = '';
    }
    else if (results.inputFileExtension === 'css') {
      const transformInput = getCompileCssConfig(opts, importData, results);
      await compileCss(transformInput, results);
    }
    else if (results.inputFileExtension === 'json') {
      compileJson(results);
    }
  }
  catch (e) {
    catchError(results.diagnostics, e);
  }
  return results;
};
const compileSync = (code, opts = {}) => {
  const { importData, results } = getCompileResults(code, opts);
  try {
    if (shouldTranspileCode(results.inputFileExtension)) {
      const { config, compileOpts, transformOpts } = getCompileModuleConfig(opts);
      patchTypescriptSync(config, results.diagnostics, null);
      compileModule(config, compileOpts, transformOpts, results);
    }
    else if (results.inputFileExtension === 'd.ts') {
      results.code = '';
    }
    else if (results.inputFileExtension === 'css') {
      const transformInput = getCompileCssConfig(opts, importData, results);
      compileCssSync(transformInput, results);
    }
    else if (results.inputFileExtension === 'json') {
      compileJson(results);
    }
  }
  catch (e) {
    catchError(results.diagnostics, e);
  }
  return results;
};
const compileModule = (config, compileOpts, transformOpts, results) => {
  const transpileResults = transpileModule(config, results.code, transformOpts);
  results.diagnostics.push(...transpileResults.diagnostics);
  if (typeof transpileResults.code === 'string') {
    results.code = transpileResults.code;
    results.map = transpileResults.map;
    if (compileOpts.sourceMap === 'inline') {
      try {
        const mapObject = JSON.parse(transpileResults.map);
        mapObject.file = compileOpts.file;
        mapObject.sources = [compileOpts.file];
        delete mapObject.sourceRoot;
        const mapBase64 = Buffer.from(JSON.stringify(mapObject), 'utf8').toString('base64');
        const sourceMapInlined = `data:application/json;charset=utf-8;base64,` + mapBase64;
        const sourceMapComment = results.code.lastIndexOf('//#');
        results.code = results.code.slice(0, sourceMapComment) + '//# sourceMappingURL=' + sourceMapInlined;
      }
      catch (e) {
        console.error(e);
      }
    }
  }
  if (isString(transpileResults.sourceFilePath)) {
    results.inputFilePath = transpileResults.sourceFilePath;
  }
  const moduleFile = transpileResults.moduleFile;
  if (moduleFile) {
    results.outputFilePath = moduleFile.jsFilePath;
    moduleFile.cmps.forEach(cmp => {
      results.data.push(getPublicCompilerMeta(cmp));
    });
    moduleFile.originalImports.forEach(originalImport => {
      results.imports.push({
        path: originalImport,
      });
    });
  }
};
const compileCss = async (transformInput, results) => {
  const cssResults = await transformCssToEsm(transformInput);
  results.code = cssResults.output;
  results.map = cssResults.map;
  results.imports = cssResults.imports.map(p => ({ path: p.importPath }));
  results.diagnostics.push(...cssResults.diagnostics);
};
const compileCssSync = (transformInput, results) => {
  const cssResults = transformCssToEsmSync(transformInput);
  results.code = cssResults.output;
  results.map = cssResults.map;
  results.imports = cssResults.imports.map(p => ({ path: p.importPath }));
  results.diagnostics.push(...cssResults.diagnostics);
};
const compileJson = (results) => {
  results.code = index.dataToEsm(JSON.parse(results.code), {
    preferConst: true,
    compact: false,
    indent: '  ',
  });
  results.map = { mappings: '' };
};
const shouldTranspileCode = (ext) => ext === 'tsx' || ext === 'ts' || ext === 'jsx' || ext === 'mjs';

// MODULE: sys/node/worker/worker-child.js
const initNodeWorkerThread = (prcs, msgHandler) => {
  const sendHandle = (err) => {
    if (err && err.code === 'ERR_IPC_CHANNEL_CLOSED') {
      prcs.exit(0);
    }
  };
  const errorHandler = (stencilMsgId, err) => {
    const errMsgBackToMain = {
      stencilId: stencilMsgId,
      stencilRtnValue: null,
      stencilRtnError: 'Error',
    };
    if (isString(err)) {
      errMsgBackToMain.stencilRtnError += ': ' + err;
    }
    else if (err) {
      if (err.stack) {
        errMsgBackToMain.stencilRtnError += ': ' + err.stack;
      }
      else if (err.message) {
        errMsgBackToMain.stencilRtnError += ':' + err.message;
      }
    }
    prcs.send(errMsgBackToMain, sendHandle);
  };
  prcs.on('message', async (msgToWorker) => {
    // message from the main thread
    if (msgToWorker && isNumber(msgToWorker.stencilId)) {
      try {
        // run the handler to get the data
        const msgFromWorker = {
          stencilId: msgToWorker.stencilId,
          stencilRtnValue: await msgHandler(msgToWorker),
          stencilRtnError: null,
        };
        // send response data from the worker to the main thread
        prcs.send(msgFromWorker, sendHandle);
      }
      catch (e) {
        // error occurred while running the task
        errorHandler(msgToWorker.stencilId, e);
      }
    }
  });
  prcs.on(`unhandledRejection`, (e) => {
    errorHandler(-1, e);
  });
};

// MODULE: compiler/sys/worker/web-worker-thread.js
const initWebWorkerThread = (selfWorker, msgHandler) => {
  let isQueued = false;
  const tick = Promise.resolve();
  const msgsFromWorkerQueue = [];
  const drainMsgQueueFromWorkerToMain = () => {
    isQueued = false;
    selfWorker.postMessage(msgsFromWorkerQueue);
    msgsFromWorkerQueue.length = 0;
  };
  const queueMsgFromWorkerToMain = (msgFromWorkerToMain) => {
    msgsFromWorkerQueue.push(msgFromWorkerToMain);
    if (!isQueued) {
      isQueued = true;
      tick.then(drainMsgQueueFromWorkerToMain);
    }
  };
  const error = (stencilMsgId, err) => {
    const errMsgFromWorkerToMain = {
      stencilId: stencilMsgId,
      stencilRtnValue: null,
      stencilRtnError: 'Error',
    };
    if (isString(err)) {
      errMsgFromWorkerToMain.stencilRtnError += ': ' + err;
    }
    else if (err) {
      if (err.stack) {
        errMsgFromWorkerToMain.stencilRtnError += ': ' + err.stack;
      }
      else if (err.message) {
        errMsgFromWorkerToMain.stencilRtnError += ': ' + err.message;
      }
    }
    queueMsgFromWorkerToMain(errMsgFromWorkerToMain);
  };
  const receiveMsgFromMainToWorker = async (msgToWorker) => {
    if (msgToWorker && isNumber(msgToWorker.stencilId)) {
      try {
        // run the handler to get the data
        const msgFromWorkerToMain = {
          stencilId: msgToWorker.stencilId,
          stencilRtnValue: await msgHandler(msgToWorker),
          stencilRtnError: null,
        };
        queueMsgFromWorkerToMain(msgFromWorkerToMain);
      }
      catch (e) {
        // error occurred while running the task
        error(msgToWorker.stencilId, e);
      }
    }
  };
  selfWorker.onmessage = ev => {
    // message from the main thread
    const msgsFromMainToWorker = ev.data;
    if (Array.isArray(msgsFromMainToWorker)) {
      for (const msgFromMainToWorker of msgsFromMainToWorker) {
        receiveMsgFromMainToWorker(msgFromMainToWorker);
      }
    }
  };
  selfWorker.onerror = e => {
    // uncaught error occurred on the worker thread
    error(-1, e);
  };
};

// MODULE: compiler/transpile/transpile-to-es5.js
const transpileToEs5 = async (input, inlineHelpers) => {
  const diagnostics = [];
  const ts = await loadTypescript(null, diagnostics, null);
  const results = {
    sourceFilePath: null,
    code: input,
    map: null,
    diagnostics: diagnostics,
    moduleFile: null,
    build: {},
  };
  if (hasError(diagnostics)) {
    return results;
  }
  const transpileOpts = {
    compilerOptions: {
      sourceMap: false,
      allowJs: true,
      declaration: false,
      target: ts.ScriptTarget.ES5,
      module: ts.ModuleKind.ESNext,
      removeComments: false,
      isolatedModules: true,
      skipLibCheck: true,
      noEmitHelpers: !inlineHelpers,
      importHelpers: !inlineHelpers,
    },
  };
  const tsResults = ts.transpileModule(input, transpileOpts);
  results.diagnostics.push(...loadTypeScriptDiagnostics(tsResults.diagnostics));
  results.code = tsResults.outputText;
  return results;
};

// MODULE: ../node_modules/source-map/lib/base64.js
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
var encode$2 = function (number) {
  if (0 <= number && number < intToCharMap.length) {
  return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
var decode = function (charCode) {
  var bigA = 65;   // 'A'
  var bigZ = 90;   // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;   // '0'
  var nine = 57;   // '9'

  var plus = 43;   // '+'
  var slash = 47;  // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
  return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
  return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
  return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
  return 62;
  }

  // 63: /
  if (charCode == slash) {
  return 63;
  }

  // Invalid base64 digit.
  return -1;
};

var base64 = {
	encode: encode$2,
	decode: decode
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/base64.js?commonjs-proxy

// MODULE: ../node_modules/source-map/lib/base64-vlq.js

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *  notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *  copyright notice, this list of conditions and the following
 *  disclaimer in the documentation and/or other materials provided
 *  with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *  contributors may be used to endorse or promote products derived
 *  from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |  Sign
//   |  |
//   V  V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
  ? ((-aValue) << 1) + 1
  : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
  ? -shifted
  : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
var encode$3 = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
  digit = vlq & VLQ_BASE_MASK;
  vlq >>>= VLQ_BASE_SHIFT;
  if (vlq > 0) {
    // There are still more digits in this value, so we must make sure the
    // continuation bit is marked.
    digit |= VLQ_CONTINUATION_BIT;
  }
  encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
  if (aIndex >= strLen) {
    throw new Error("Expected more digits in base 64 VLQ value.");
  }

  digit = base64.decode(aStr.charCodeAt(aIndex++));
  if (digit === -1) {
    throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
  }

  continuation = !!(digit & VLQ_CONTINUATION_BIT);
  digit &= VLQ_BASE_MASK;
  result = result + (digit << shift);
  shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

var base64Vlq = {
	encode: encode$3,
	decode: decode$1
};

// MODULE: ../node_modules/source-map/lib/util.js

var util$3 = createCommonjsModule(function (module, exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
  return aArgs[aName];
  } else if (arguments.length === 3) {
  return aDefaultValue;
  } else {
  throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
  return null;
  }
  return {
  scheme: match[1],
  auth: match[2],
  host: match[3],
  port: match[4],
  path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
  url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
  url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
  url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
  url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
  url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
  if (!url.path) {
    return aPath;
  }
  path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
  part = parts[i];
  if (part === '.') {
    parts.splice(i, 1);
  } else if (part === '..') {
    up++;
  } else if (up > 0) {
    if (part === '') {
    // The first part is blank if the path is absolute. Trying to go
    // above the root is a no-op. Therefore we can remove all '..' parts
    // directly after the root.
    parts.splice(i + 1, up);
    up = 0;
    } else {
    parts.splice(i, 2);
    up--;
    }
  }
  }
  path = parts.join('/');

  if (path === '') {
  path = isAbsolute ? '/' : '.';
  }

  if (url) {
  url.path = path;
  return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
  aRoot = ".";
  }
  if (aPath === "") {
  aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
  aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
  if (aRootUrl) {
    aPathUrl.scheme = aRootUrl.scheme;
  }
  return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
  return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
  aRootUrl.host = aPath;
  return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
  ? aPath
  : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
  aRootUrl.path = joined;
  return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
  aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
  var index = aRoot.lastIndexOf("/");
  if (index < 0) {
    return aPath;
  }

  // If the only part of the root that is left is the scheme (i.e. http://,
  // file:///, etc.), one or more slashes (/), or simply nothing at all, we
  // have exhausted all components, so the path is not relative to the root.
  aRoot = aRoot.slice(0, index);
  if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
    return aPath;
  }

  ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
  return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
  return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
  return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
  return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
    s.charCodeAt(length - 2) !== 95  /* '_' */ ||
    s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
    s.charCodeAt(length - 4) !== 116 /* 't' */ ||
    s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
    s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
    s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
    s.charCodeAt(length - 8) !== 95  /* '_' */ ||
    s.charCodeAt(length - 9) !== 95  /* '_' */) {
  return false;
  }

  for (var i = length - 10; i >= 0; i--) {
  if (s.charCodeAt(i) !== 36 /* '$' */) {
    return false;
  }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
  return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
  return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
  return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
  return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
  return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
  return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
  return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
  return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
  return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
  return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
  return 0;
  }

  if (aStr1 === null) {
  return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
  return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
  return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
  return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
  return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
  return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
  return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
  return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
  // This follows what Chrome does.
  if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
    sourceRoot += '/';
  }
  // The spec says:
  //   Line 4: An optional source root, useful for relocating source
  //   files on a server or removing repeated values in the
  //   “sources” entry.  This value is prepended to the individual
  //   entries in the “source” field.
  sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //  new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
  var parsed = urlParse(sourceMapURL);
  if (!parsed) {
    throw new Error("sourceMapURL could not be parsed");
  }
  if (parsed.path) {
    // Strip the last path component, but keep the "/".
    var index = parsed.path.lastIndexOf('/');
    if (index >= 0) {
    parsed.path = parsed.path.substring(0, index + 1);
    }
  }
  sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
});
var util_1 = util$3.getArg;
var util_2 = util$3.urlParse;
var util_3 = util$3.urlGenerate;
var util_4 = util$3.normalize;
var util_5 = util$3.join;
var util_6 = util$3.isAbsolute;
var util_7 = util$3.relative;
var util_8 = util$3.toSetString;
var util_9 = util$3.fromSetString;
var util_10 = util$3.compareByOriginalPositions;
var util_11 = util$3.compareByGeneratedPositionsDeflated;
var util_12 = util$3.compareByGeneratedPositionsInflated;
var util_13 = util$3.parseSourceMapInput;
var util_14 = util$3.computeSourceURL;

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/util.js?commonjs-proxy

// MODULE: ../node_modules/source-map/lib/array-set.js

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */


var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
  set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util$3.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
  this._array.push(aStr);
  }
  if (!isDuplicate) {
  if (hasNativeMap) {
    this._set.set(aStr, idx);
  } else {
    this._set[sStr] = idx;
  }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
  return this._set.has(aStr);
  } else {
  var sStr = util$3.toSetString(aStr);
  return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
  var idx = this._set.get(aStr);
  if (idx >= 0) {
    return idx;
  }
  } else {
  var sStr = util$3.toSetString(aStr);
  if (has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
  return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

var ArraySet_1 = ArraySet;

var arraySet = {
	ArraySet: ArraySet_1
};

// MODULE: ../node_modules/source-map/lib/mapping-list.js

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */



/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
     util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
  this._last = aMapping;
  this._array.push(aMapping);
  } else {
  this._sorted = false;
  this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
  this._array.sort(util$3.compareByGeneratedPositionsInflated);
  this._sorted = true;
  }
  return this._array;
};

var MappingList_1 = MappingList;

var mappingList = {
	MappingList: MappingList_1
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/base64-vlq.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/array-set.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/mapping-list.js?commonjs-proxy

// MODULE: ../node_modules/source-map/lib/source-map-generator.js

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */



var ArraySet$1 = arraySet.ArraySet;
var MappingList$1 = mappingList.MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
  aArgs = {};
  }
  this._file = util$3.getArg(aArgs, 'file', null);
  this._sourceRoot = util$3.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util$3.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet$1();
  this._names = new ArraySet$1();
  this._mappings = new MappingList$1();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
    generated: {
      line: mapping.generatedLine,
      column: mapping.generatedColumn
    }
    };

    if (mapping.source != null) {
    newMapping.source = mapping.source;
    if (sourceRoot != null) {
      newMapping.source = util$3.relative(sourceRoot, newMapping.source);
    }

    newMapping.original = {
      line: mapping.originalLine,
      column: mapping.originalColumn
    };

    if (mapping.name != null) {
      newMapping.name = mapping.name;
    }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
    sourceRelative = util$3.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
    generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
    generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
  var generated = util$3.getArg(aArgs, 'generated');
  var original = util$3.getArg(aArgs, 'original', null);
  var source = util$3.getArg(aArgs, 'source', null);
  var name = util$3.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
    this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);
    if (!this._names.has(name)) {
    this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = util$3.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
    this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[util$3.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util$3.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
    this._sourcesContents = null;
    }
  }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *    If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *    to be applied. If relative, it is relative to the SourceMapConsumer.
 *    This parameter is needed when the two source maps aren't in the same
 *    directory, and the source map to be applied contains relative source
 *    paths. If so, those relative source paths need to be rewritten
 *    relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  // If aSourceFile is omitted, we will use the file property of the SourceMap
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
    throw new Error(
      'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
      'or the source map\'s "file" property. Both were omitted.'
    );
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  // Make "sourceFile" relative if an absolute Url is passed.
  if (sourceRoot != null) {
    sourceFile = util$3.relative(sourceRoot, sourceFile);
  }
  // Applying the SourceMap can add and remove items from the sources and
  // the names array.
  var newSources = new ArraySet$1();
  var newNames = new ArraySet$1();

  // Find mappings for the "sourceFile"
  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
    // Check if it can be mapped by the source map, then update the mapping.
    var original = aSourceMapConsumer.originalPositionFor({
      line: mapping.originalLine,
      column: mapping.originalColumn
    });
    if (original.source != null) {
      // Copy mapping
      mapping.source = original.source;
      if (aSourceMapPath != null) {
      mapping.source = util$3.join(aSourceMapPath, mapping.source);
      }
      if (sourceRoot != null) {
      mapping.source = util$3.relative(sourceRoot, mapping.source);
      }
      mapping.originalLine = original.line;
      mapping.originalColumn = original.column;
      if (original.name != null) {
      mapping.name = original.name;
      }
    }
    }

    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
    newSources.add(source);
    }

    var name = mapping.name;
    if (name != null && !newNames.has(name)) {
    newNames.add(name);
    }

  }, this);
  this._sources = newSources;
  this._names = newNames;

  // Copy sourcesContents of applied map.
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
    if (aSourceMapPath != null) {
      sourceFile = util$3.join(aSourceMapPath, sourceFile);
    }
    if (sourceRoot != null) {
      sourceFile = util$3.relative(sourceRoot, sourceFile);
    }
    this.setSourceContent(sourceFile, content);
    }
  }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *    token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                        aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error(
      'original.line and original.column are not numbers -- you probably meant to omit ' +
      'the original mapping entirely and only map the generated position. If so, pass ' +
      'null for the original mapping instead of an object with empty or null values.'
    );
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
    && aGenerated.line > 0 && aGenerated.column >= 0
    && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  }
  else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
       && aOriginal && 'line' in aOriginal && 'column' in aOriginal
       && aGenerated.line > 0 && aGenerated.column >= 0
       && aOriginal.line > 0 && aOriginal.column >= 0
       && aSource) {
    // Cases 2 and 3.
    return;
  }
  else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
    generated: aGenerated,
    source: aSource,
    original: aOriginal,
    name: aName
    }));
  }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();
  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
    previousGeneratedColumn = 0;
    while (mapping.generatedLine !== previousGeneratedLine) {
      next += ';';
      previousGeneratedLine++;
    }
    }
    else {
    if (i > 0) {
      if (!util$3.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
      continue;
      }
      next += ',';
    }
    }

    next += base64Vlq.encode(mapping.generatedColumn
                 - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
    sourceIdx = this._sources.indexOf(mapping.source);
    next += base64Vlq.encode(sourceIdx - previousSource);
    previousSource = sourceIdx;

    // lines are stored 0-based in SourceMap spec version 3
    next += base64Vlq.encode(mapping.originalLine - 1
                   - previousOriginalLine);
    previousOriginalLine = mapping.originalLine - 1;

    next += base64Vlq.encode(mapping.originalColumn
                   - previousOriginalColumn);
    previousOriginalColumn = mapping.originalColumn;

    if (mapping.name != null) {
      nameIdx = this._names.indexOf(mapping.name);
      next += base64Vlq.encode(nameIdx - previousName);
      previousName = nameIdx;
    }
    }

    result += next;
  }

  return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
    return null;
    }
    if (aSourceRoot != null) {
    source = util$3.relative(aSourceRoot, source);
    }
    var key = util$3.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
    ? this._sourcesContents[key]
    : null;
  }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
  };

var SourceMapGenerator_1 = SourceMapGenerator;

var sourceMapGenerator = {
	SourceMapGenerator: SourceMapGenerator_1
};

// MODULE: ../node_modules/source-map/lib/binary-search.js

var binarySearch = createCommonjsModule(function (module, exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *   'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *   closest element that is smaller than or greater than the one we are
 *   searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //    the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //    element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
  // Found the element we are looking for.
  return mid;
  }
  else if (cmp > 0) {
  // Our needle is greater than aHaystack[mid].
  if (aHigh - mid > 1) {
    // The element is in the upper half.
    return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
  }

  // The exact needle element was not found in this haystack. Determine if
  // we are in termination case (3) or (2) and return the appropriate thing.
  if (aBias == exports.LEAST_UPPER_BOUND) {
    return aHigh < aHaystack.length ? aHigh : -1;
  } else {
    return mid;
  }
  }
  else {
  // Our needle is less than aHaystack[mid].
  if (mid - aLow > 1) {
    // The element is in the lower half.
    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
  }

  // we are in termination case (3) or (2) and return the appropriate thing.
  if (aBias == exports.LEAST_UPPER_BOUND) {
    return mid;
  } else {
    return aLow < 0 ? -1 : aLow;
  }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *   array and returns -1, 0, or 1 depending on whether the needle is less
 *   than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *   'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *   closest element that is smaller than or greater than the one we are
 *   searching for, respectively, if the exact element cannot be found.
 *   Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
  return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
  return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
  if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
    break;
  }
  --index;
  }

  return index;
};
});
var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
var binarySearch_3 = binarySearch.search;

// MODULE: ../node_modules/source-map/lib/quick-sort.js
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *    The array.
 * @param {Number} x
 *    The index of the first item.
 * @param {Number} y
 *    The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *    The lower bound on the range.
 * @param {Number} high
 *    The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *    An array to sort.
 * @param {function} comparator
 *    Function to use to compare two items.
 * @param {Number} p
 *    Start index of the array
 * @param {Number} r
 *    End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
  // (1) Partitioning.
  //
  // The partitioning chooses a pivot between `p` and `r` and moves all
  // elements that are less than or equal to the pivot to the before it, and
  // all the elements that are greater than it after it. The effect is that
  // once partition is done, the pivot is in the exact place it will be when
  // the array is put in sorted order, and it will not need to be moved
  // again. This runs in O(n) time.

  // Always choose a random pivot so that an input array which is reverse
  // sorted does not cause O(n^2) running time.
  var pivotIndex = randomIntInRange(p, r);
  var i = p - 1;

  swap(ary, pivotIndex, r);
  var pivot = ary[r];

  // Immediately after `j` is incremented in this loop, the following hold
  // true:
  //
  //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
  //
  //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
  for (var j = p; j < r; j++) {
    if (comparator(ary[j], pivot) <= 0) {
    i += 1;
    swap(ary, i, j);
    }
  }

  swap(ary, i + 1, j);
  var q = i + 1;

  // (2) Recurse on each half.

  doQuickSort(ary, comparator, p, q - 1);
  doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *    An array to sort.
 * @param {function} comparator
 *    Function to use to compare two items.
 */
var quickSort_1 = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

var quickSort = {
	quickSort: quickSort_1
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/binary-search.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/quick-sort.js?commonjs-proxy

// MODULE: ../node_modules/source-map/lib/source-map-consumer.js

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */



var ArraySet$2 = arraySet.ArraySet;

var quickSort$1 = quickSort.quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
  sourceMap = util$3.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
  ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
  : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//   {
//     generatedLine: The line number in the generated code,
//     generatedColumn: The column number in the generated code,
//     source: The path to the original source file that generated this
//         chunk of code,
//     originalLine: The line number in the original source that
//           corresponds to this chunk of generated code,
//     originalColumn: The column number in the original source that
//             corresponds to this chunk of generated code,
//     name: The name of the original symbol which generated this chunk of
//       code.
//   }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
  if (!this.__generatedMappings) {
    this._parseMappings(this._mappings, this.sourceRoot);
  }

  return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
  if (!this.__originalMappings) {
    this._parseMappings(this._mappings, this.sourceRoot);
  }

  return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *    The function that is called with each mapping.
 * @param Object aContext
 *    Optional. If specified, this object will be the value of `this` every
 *    time that `aCallback` is called.
 * @param aOrder
 *    Either `SourceMapConsumer.GENERATED_ORDER` or
 *    `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *    iterate over the mappings sorted by the generated file's line/column
 *    order or the original's source/line/column order, respectively. Defaults to
 *    `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

  var mappings;
  switch (order) {
  case SourceMapConsumer.GENERATED_ORDER:
    mappings = this._generatedMappings;
    break;
  case SourceMapConsumer.ORIGINAL_ORDER:
    mappings = this._originalMappings;
    break;
  default:
    throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util$3.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
    source: source,
    generatedLine: mapping.generatedLine,
    generatedColumn: mapping.generatedColumn,
    originalLine: mapping.originalLine,
    originalColumn: mapping.originalColumn,
    name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *  The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *  line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *  The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util$3.getArg(aArgs, 'line');

  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.
  var needle = {
    source: util$3.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util$3.getArg(aArgs, 'column', 0)
  };

  needle.source = this._findSourceIndex(needle.source);
  if (needle.source < 0) {
    return [];
  }

  var mappings = [];

  var index = this._findMapping(needle,
                  this._originalMappings,
                  "originalLine",
                  "originalColumn",
                  util$3.compareByOriginalPositions,
                  binarySearch.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
    var originalLine = mapping.originalLine;

    // Iterate until either we run out of mappings, or we run into
    // a mapping for a different line than the one we found. Since
    // mappings are sorted, this is guaranteed to find all mappings for
    // the line we found.
    while (mapping && mapping.originalLine === originalLine) {
      mappings.push({
      line: util$3.getArg(mapping, 'generatedLine', null),
      column: util$3.getArg(mapping, 'generatedColumn', null),
      lastColumn: util$3.getArg(mapping, 'lastGeneratedColumn', null)
      });

      mapping = this._originalMappings[++index];
    }
    } else {
    var originalColumn = mapping.originalColumn;

    // Iterate until either we run out of mappings, or we run into
    // a mapping for a different line than the one we were searching for.
    // Since mappings are sorted, this is guaranteed to find all mappings for
    // the line we are searching for.
    while (mapping &&
         mapping.originalLine === line &&
         mapping.originalColumn == originalColumn) {
      mappings.push({
      line: util$3.getArg(mapping, 'generatedLine', null),
      column: util$3.getArg(mapping, 'generatedColumn', null),
      lastColumn: util$3.getArg(mapping, 'lastGeneratedColumn', null)
      });

      mapping = this._originalMappings[++index];
    }
    }
  }

  return mappings;
  };

var SourceMapConsumer_1 = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *   {
 *     version : 3,
 *     file: "out.js",
 *     sourceRoot : "",
 *     sources: ["foo.js", "bar.js"],
 *     names: ["src", "maps", "are", "fun"],
 *     mappings: "AA,AB;;ABCDE;"
 *   }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
  sourceMap = util$3.parseSourceMapInput(aSourceMap);
  }

  var version = util$3.getArg(sourceMap, 'version');
  var sources = util$3.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util$3.getArg(sourceMap, 'names', []);
  var sourceRoot = util$3.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util$3.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util$3.getArg(sourceMap, 'mappings');
  var file = util$3.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
  throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
  sourceRoot = util$3.normalize(sourceRoot);
  }

  sources = sources
  .map(String)
  // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util$3.normalize)
  // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util$3.isAbsolute(sourceRoot) && util$3.isAbsolute(source)
    ? util$3.relative(sourceRoot, source)
    : source;
  });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet$2.fromArray(names.map(String), true);
  this._sources = ArraySet$2.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
  return util$3.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
  relativeSource = util$3.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
  return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
  if (this._absoluteSources[i] == aSource) {
    return i;
  }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *    The source map that will be consumed.
 * @param String aSourceMapURL
 *    The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);

  var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                              smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util$3.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  });

  // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping;
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
    destMapping.source = sources.indexOf(srcMapping.source);
    destMapping.originalLine = srcMapping.originalLine;
    destMapping.originalColumn = srcMapping.originalColumn;

    if (srcMapping.name) {
      destMapping.name = names.indexOf(srcMapping.name);
    }

    destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort$1(smc.__originalMappings, util$3.compareByOriginalPositions);

  return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
  return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
    generatedLine++;
    index++;
    previousGeneratedColumn = 0;
    }
    else if (aStr.charAt(index) === ',') {
    index++;
    }
    else {
    mapping = new Mapping();
    mapping.generatedLine = generatedLine;

    // Because each offset is encoded relative to the previous one,
    // many segments often have the same encoding. We can exploit this
    // fact by caching the parsed variable length fields of each segment,
    // allowing us to avoid a second parse if we encounter the same
    // segment again.
    for (end = index; end < length; end++) {
      if (this._charIsMappingSeparator(aStr, end)) {
      break;
      }
    }
    str = aStr.slice(index, end);

    segment = cachedSegments[str];
    if (segment) {
      index += str.length;
    } else {
      segment = [];
      while (index < end) {
      base64Vlq.decode(aStr, index, temp);
      value = temp.value;
      index = temp.rest;
      segment.push(value);
      }

      if (segment.length === 2) {
      throw new Error('Found a source, but no line and column');
      }

      if (segment.length === 3) {
      throw new Error('Found a source and line, but no column');
      }

      cachedSegments[str] = segment;
    }

    // Generated column.
    mapping.generatedColumn = previousGeneratedColumn + segment[0];
    previousGeneratedColumn = mapping.generatedColumn;

    if (segment.length > 1) {
      // Original source.
      mapping.source = previousSource + segment[1];
      previousSource += segment[1];

      // Original line.
      mapping.originalLine = previousOriginalLine + segment[2];
      previousOriginalLine = mapping.originalLine;
      // Lines are stored 0-based
      mapping.originalLine += 1;

      // Original column.
      mapping.originalColumn = previousOriginalColumn + segment[3];
      previousOriginalColumn = mapping.originalColumn;

      if (segment.length > 4) {
      // Original name.
      mapping.name = previousName + segment[4];
      previousName += segment[4];
      }
    }

    generatedMappings.push(mapping);
    if (typeof mapping.originalLine === 'number') {
      originalMappings.push(mapping);
    }
    }
  }

  quickSort$1(generatedMappings, util$3.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;

  quickSort$1(originalMappings, util$3.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                     aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.

  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got '
              + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got '
              + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];

    // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).
    if (index + 1 < this._generatedMappings.length) {
    var nextMapping = this._generatedMappings[index + 1];

    if (mapping.generatedLine === nextMapping.generatedLine) {
      mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
      continue;
    }
    }

    // The last mapping for each line spans the entire line.
    mapping.lastGeneratedColumn = Infinity;
  }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *   is 1-based.
 *   - column: The column number in the generated source.  The column
 *   number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *   'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *   closest element that is smaller than or greater than the one we are
 *   searching for, respectively, if the exact element cannot be found.
 *   Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *   line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *   column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util$3.getArg(aArgs, 'line'),
    generatedColumn: util$3.getArg(aArgs, 'column')
  };

  var index = this._findMapping(
    needle,
    this._generatedMappings,
    "generatedLine",
    "generatedColumn",
    util$3.compareByGeneratedPositionsDeflated,
    util$3.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
  );

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
    var source = util$3.getArg(mapping, 'source', null);
    if (source !== null) {
      source = this._sources.at(source);
      source = util$3.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
    }
    var name = util$3.getArg(mapping, 'name', null);
    if (name !== null) {
      name = this._names.at(name);
    }
    return {
      source: source,
      line: util$3.getArg(mapping, 'originalLine', null),
      column: util$3.getArg(mapping, 'originalColumn', null),
      name: name
    };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() &&
    !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  var index = this._findSourceIndex(aSource);
  if (index >= 0) {
    return this.sourcesContent[index];
  }

  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util$3.relative(this.sourceRoot, relativeSource);
  }

  var url;
  if (this.sourceRoot != null
    && (url = util$3.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
    if (url.scheme == "file"
      && this._sources.has(fileUriAbsPath)) {
    return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
    }

    if ((!url.path || url.path == "/")
      && this._sources.has("/" + relativeSource)) {
    return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  }

  // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.
  if (nullOnMissing) {
    return null;
  }
  else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *   is 1-based.
 *   - column: The column number in the original source.  The column
 *   number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *   'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *   closest element that is smaller than or greater than the one we are
 *   searching for, respectively, if the exact element cannot be found.
 *   Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *   line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *   The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util$3.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);
  if (source < 0) {
    return {
    line: null,
    column: null,
    lastColumn: null
    };
  }

  var needle = {
    source: source,
    originalLine: util$3.getArg(aArgs, 'line'),
    originalColumn: util$3.getArg(aArgs, 'column')
  };

  var index = this._findMapping(
    needle,
    this._originalMappings,
    "originalLine",
    "originalColumn",
    util$3.compareByOriginalPositions,
    util$3.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
  );

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
    return {
      line: util$3.getArg(mapping, 'generatedLine', null),
      column: util$3.getArg(mapping, 'generatedColumn', null),
      lastColumn: util$3.getArg(mapping, 'lastGeneratedColumn', null)
    };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
  };

var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *     begins to apply, defined as an object with a "line" and "column"
 *     field.
 *   - map: A source map definition. This source map could also be indexed,
 *     but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *  version : 3,
 *  file: "app.js",
 *  sections: [{
 *    offset: {line:100, column:10},
 *    map: {
 *    version : 3,
 *    file: "section.js",
 *    sources: ["foo.js", "bar.js"],
 *    names: ["src", "maps", "are", "fun"],
 *    mappings: "AAAA,E;;ABCDE;"
 *    }
 *  }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
  sourceMap = util$3.parseSourceMapInput(aSourceMap);
  }

  var version = util$3.getArg(sourceMap, 'version');
  var sections = util$3.getArg(sourceMap, 'sections');

  if (version != this._version) {
  throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet$2();
  this._names = new ArraySet$2();

  var lastOffset = {
  line: -1,
  column: 0
  };
  this._sections = sections.map(function (s) {
  if (s.url) {
    // The url field will require support for asynchronicity.
    // See https://github.com/mozilla/source-map/issues/16
    throw new Error('Support for url field in sections not implemented.');
  }
  var offset = util$3.getArg(s, 'offset');
  var offsetLine = util$3.getArg(offset, 'line');
  var offsetColumn = util$3.getArg(offset, 'column');

  if (offsetLine < lastOffset.line ||
    (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
    throw new Error('Section offsets must be ordered and non-overlapping.');
  }
  lastOffset = offset;

  return {
    generatedOffset: {
    // The offset fields are 0-based, but we use 1-based indices when
    // encoding/decoding from VLQ.
    generatedLine: offsetLine + 1,
    generatedColumn: offsetColumn + 1
    },
    consumer: new SourceMapConsumer(util$3.getArg(s, 'map'), aSourceMapURL)
  }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
  var sources = [];
  for (var i = 0; i < this._sections.length; i++) {
    for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
    sources.push(this._sections[i].consumer.sources[j]);
    }
  }
  return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *   is 1-based.
 *   - column: The column number in the generated source.  The column
 *   number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *   line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *   column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util$3.getArg(aArgs, 'line'),
    generatedColumn: util$3.getArg(aArgs, 'column')
  };

  // Find the section containing the generated position we're trying to map
  // to an original position.
  var sectionIndex = binarySearch.search(needle, this._sections,
    function(needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }

    return (needle.generatedColumn -
        section.generatedOffset.generatedColumn);
    });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
    source: null,
    line: null,
    column: null,
    name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine -
    (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn -
    (section.generatedOffset.generatedLine === needle.generatedLine
     ? section.generatedOffset.generatedColumn - 1
     : 0),
    bias: aArgs.bias
  });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    var content = section.consumer.sourceContentFor(aSource, true);
    if (content) {
    return content;
    }
  }
  if (nullOnMissing) {
    return null;
  }
  else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *   is 1-based.
 *   - column: The column number in the original source.  The column
 *   number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *   line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *   The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    // Only consider this section if the requested source is in the list of
    // sources of the consumer.
    if (section.consumer._findSourceIndex(util$3.getArg(aArgs, 'source')) === -1) {
    continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
    var ret = {
      line: generatedPosition.line +
      (section.generatedOffset.generatedLine - 1),
      column: generatedPosition.column +
      (section.generatedOffset.generatedLine === generatedPosition.line
       ? section.generatedOffset.generatedColumn - 1
       : 0)
    };
    return ret;
    }
  }

  return {
    line: null,
    column: null
  };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0; j < sectionMappings.length; j++) {
    var mapping = sectionMappings[j];

    var source = section.consumer._sources.at(mapping.source);
    source = util$3.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
    this._sources.add(source);
    source = this._sources.indexOf(source);

    var name = null;
    if (mapping.name) {
      name = section.consumer._names.at(mapping.name);
      this._names.add(name);
      name = this._names.indexOf(name);
    }

    // The mappings coming from the consumer for the section have
    // generated positions relative to the start of the section, so we
    // need to offset them to be relative to the start of the concatenated
    // generated file.
    var adjustedMapping = {
      source: source,
      generatedLine: mapping.generatedLine +
      (section.generatedOffset.generatedLine - 1),
      generatedColumn: mapping.generatedColumn +
      (section.generatedOffset.generatedLine === mapping.generatedLine
      ? section.generatedOffset.generatedColumn - 1
      : 0),
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: name
    };

    this.__generatedMappings.push(adjustedMapping);
    if (typeof adjustedMapping.originalLine === 'number') {
      this.__originalMappings.push(adjustedMapping);
    }
    }
  }

  quickSort$1(this.__generatedMappings, util$3.compareByGeneratedPositionsDeflated);
  quickSort$1(this.__originalMappings, util$3.compareByOriginalPositions);
  };

var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

var sourceMapConsumer = {
	SourceMapConsumer: SourceMapConsumer_1,
	BasicSourceMapConsumer: BasicSourceMapConsumer_1,
	IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/source-map-generator.js?commonjs-proxy

// MODULE: ../node_modules/source-map/lib/source-node.js

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;


// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *    generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *    SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode();

  // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.
  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;
  var shiftNextLine = function() {
    var lineContents = getNextLine();
    // The last line of a file might not have a newline.
    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
    return remainingLinesIndex < remainingLines.length ?
      remainingLines[remainingLinesIndex++] : undefined;
    }
  };

  // We need to remember the position of "remainingLines"
  var lastGeneratedLine = 1, lastGeneratedColumn = 0;

  // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.
  var lastMapping = null;

  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
    // We add the code from "lastMapping" to "mapping":
    // First check if there is a new line in between.
    if (lastGeneratedLine < mapping.generatedLine) {
      // Associate first line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
      lastGeneratedLine++;
      lastGeneratedColumn = 0;
      // The remaining code is added without mapping
    } else {
      // There is no new line in between.
      // Associate the code between "lastGeneratedColumn" and
      // "mapping.generatedColumn" with "lastMapping"
      var nextLine = remainingLines[remainingLinesIndex] || '';
      var code = nextLine.substr(0, mapping.generatedColumn -
                    lastGeneratedColumn);
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                        lastGeneratedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
      addMappingWithCode(lastMapping, code);
      // No more remaining code, continue
      lastMapping = mapping;
      return;
    }
    }
    // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.
    while (lastGeneratedLine < mapping.generatedLine) {
    node.add(shiftNextLine());
    lastGeneratedLine++;
    }
    if (lastGeneratedColumn < mapping.generatedColumn) {
    var nextLine = remainingLines[remainingLinesIndex] || '';
    node.add(nextLine.substr(0, mapping.generatedColumn));
    remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
    lastGeneratedColumn = mapping.generatedColumn;
    }
    lastMapping = mapping;
  }, this);
  // We have processed all mappings.
  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
    // Associate the remaining code in the current line with "lastMapping"
    addMappingWithCode(lastMapping, shiftNextLine());
    }
    // and add the remaining lines without any mapping
    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  }

  // Copy sourcesContent into SourceNode
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
    if (aRelativePath != null) {
      sourceFile = util$3.join(aRelativePath, sourceFile);
    }
    node.setSourceContent(sourceFile, content);
    }
  });

  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
    node.add(code);
    } else {
    var source = aRelativePath
      ? util$3.join(aRelativePath, mapping.source)
      : mapping.source;
    node.add(new SourceNode(mapping.originalLine,
                mapping.originalColumn,
                source,
                code,
                mapping.name));
    }
  }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *    SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
  aChunk.forEach(function (chunk) {
    this.add(chunk);
  }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
  if (aChunk) {
    this.children.push(aChunk);
  }
  }
  else {
  throw new TypeError(
    "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
  );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *    SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
  for (var i = aChunk.length-1; i >= 0; i--) {
    this.prepend(aChunk[i]);
  }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
  this.children.unshift(aChunk);
  }
  else {
  throw new TypeError(
    "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
  );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
  chunk = this.children[i];
  if (chunk[isSourceNode]) {
    chunk.walk(aFn);
  }
  else {
    if (chunk !== '') {
    aFn(chunk, { source: this.source,
           line: this.line,
           column: this.column,
           name: this.name });
    }
  }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
  newChildren = [];
  for (i = 0; i < len-1; i++) {
    newChildren.push(this.children[i]);
    newChildren.push(aSep);
  }
  newChildren.push(this.children[i]);
  this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
  lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
  this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
  this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util$3.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
    this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);
  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util$3.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
  str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
  code: "",
  line: 1,
  column: 0
  };
  var map = new SourceMapGenerator$1(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
  generated.code += chunk;
  if (original.source !== null
    && original.line !== null
    && original.column !== null) {
    if(lastOriginalSource !== original.source
     || lastOriginalLine !== original.line
     || lastOriginalColumn !== original.column
     || lastOriginalName !== original.name) {
    map.addMapping({
      source: original.source,
      original: {
      line: original.line,
      column: original.column
      },
      generated: {
      line: generated.line,
      column: generated.column
      },
      name: original.name
    });
    }
    lastOriginalSource = original.source;
    lastOriginalLine = original.line;
    lastOriginalColumn = original.column;
    lastOriginalName = original.name;
    sourceMappingActive = true;
  } else if (sourceMappingActive) {
    map.addMapping({
    generated: {
      line: generated.line,
      column: generated.column
    }
    });
    lastOriginalSource = null;
    sourceMappingActive = false;
  }
  for (var idx = 0, length = chunk.length; idx < length; idx++) {
    if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
    generated.line++;
    generated.column = 0;
    // Mappings end at eol
    if (idx + 1 === length) {
      lastOriginalSource = null;
      sourceMappingActive = false;
    } else if (sourceMappingActive) {
      map.addMapping({
      source: original.source,
      original: {
        line: original.line,
        column: original.column
      },
      generated: {
        line: generated.line,
        column: generated.column
      },
      name: original.name
      });
    }
    } else {
    generated.column++;
    }
  }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
  map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

var SourceNode_1 = SourceNode;

var sourceNode = {
	SourceNode: SourceNode_1
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/source-map-consumer.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/lib/source-node.js?commonjs-proxy

// MODULE: ../node_modules/source-map/source-map.js

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
var SourceNode$1 = sourceNode.SourceNode;

var sourceMap = {
	SourceMapGenerator: SourceMapGenerator$2,
	SourceMapConsumer: SourceMapConsumer$1,
	SourceNode: SourceNode$1
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/source-map/source-map.js?commonjs-proxy

// MODULE: ../node_modules/terser/dist/bundle.min.js

var bundle_min = createCommonjsModule(function (module, exports) {
!function(e,t){t(exports,sourceMap);}(commonjsGlobal,(function(e,t){function n(e){return e.split("")}function i(e,t){return t.includes(e)}t=t&&t.hasOwnProperty("default")?t.default:t;class o extends Error{constructor(e,t){super(),this.name="DefaultsError",this.message=e,this.defs=t;}}function r(e,t,n){!0===e&&(e={});const i=e||{};if(n)for(const e in i)if(D(i,e)&&!D(t,e))throw new o("`"+e+"` is not a supported option",t);for(const n in t)if(D(t,n))if(e&&D(e,n))if("ecma"===n){let t=0|e[n];t>5&&t<2015&&(t+=2009),i[n]=t;}else i[n]=e&&D(e,n)?e[n]:t[n];else i[n]=t[n];return i}function a(){}function s(){return !1}function u(){return !0}function c(){return this}function l(){return null}var f=function(){function e(e,r,a){var s,u=[],c=[];function l(){var l=r(e[s],s),f=l instanceof o;return f&&(l=l.v),l instanceof n?(l=l.v)instanceof i?c.push.apply(c,a?l.v.slice().reverse():l.v):c.push(l):l!==t&&(l instanceof i?u.push.apply(u,a?l.v.slice().reverse():l.v):u.push(l)),f}if(Array.isArray(e))if(a){for(s=e.length;--s>=0&&!l(););u.reverse(),c.reverse();}else for(s=0;s<e.length&&!l();++s);else for(s in e)if(D(e,s)&&l())break;return c.concat(u)}e.at_top=function(e){return new n(e)},e.splice=function(e){return new i(e)},e.last=function(e){return new o(e)};var t=e.skip={};function n(e){this.v=e;}function i(e){this.v=e;}function o(e){this.v=e;}return e}();function p(e,t,n){return n||(n={}),t&&(n.start||(n.start=t.start),n.end||(n.end=t.end)),new e(n)}function _(e,t){e.includes(t)||e.push(t);}function d(e,t){return e.replace(/{(.+?)}/g,(function(e,n){return t&&t[n]}))}function m(e,t){for(var n=e.length;--n>=0;)e[n]===t&&e.splice(n,1);}function h(e,t){if(e.length<2)return e.slice();return function e(n){if(n.length<=1)return n;var i=Math.floor(n.length/2),o=n.slice(0,i),r=n.slice(i);return function(e,n){for(var i=[],o=0,r=0,a=0;o<e.length&&r<n.length;)t(e[o],n[r])<=0?i[a++]=e[o++]:i[a++]=n[r++];return o<e.length&&i.push.apply(i,e.slice(o)),r<n.length&&i.push.apply(i,n.slice(r)),i}(o=e(o),r=e(r))}(e)}function E(e){return Array.isArray(e)||(e=e.split(" ")),new Set(e)}function g(e,t,n){e.has(t)?e.get(t).push(n):e.set(t,[n]);}function D(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function S(e,t){return !0===e||e instanceof RegExp&&e.test(t)}var v={"\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"};function A(e){return e.replace(/[\n\r\u2028\u2029]/g,(function(t,n){return ("\\"==e[n-1]&&("\\"!=e[n-2]||/(?:^|[^\\])(?:\\{2})*$/.test(e.slice(0,n-1)))?"":"\\")+v[t]}))}function T(e,t){return e._annotations&t}function y(e,t){e._annotations|=t;}var b="break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with",C="false null true",O="enum implements import interface package private protected public static super this "+C+" "+b,F="return new delete throw else case yield await";b=E(b),O=E(O),F=E(F),C=E(C);var M=E(n("+-*&%=<>!?|~^")),R=/[0-9a-f]/i,w=/^0x[0-9a-f]+$/i,x=/^0[0-7]+$/,N=/^0o[0-7]+$/i,k=/^0b[01]+$/i,I=/^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i,L=/^(0[xob])?[0-9a-f]+n$/i,V=E(["in","instanceof","typeof","new","void","delete","++","--","+","-","!","~","&","|","^","*","**","/","%",">>","<<",">>>","<",">","<=",">=","==","===","!=","!==","?","=","+=","-=","/=","*=","**=","%=",">>=","<<=",">>>=","|=","^=","&=","&&","||"]),P=E(n("  \n\r\t\f\v​           \u2028\u2029  　\ufeff")),B=E(n("\n\r\u2028\u2029")),K=E(n(";]),:")),U=E(n("[{(,;:")),G=E(n("[]{}(),;:")),H={ID_Start:/[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,ID_Continue:/[0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/};function X(e,t){if(z(e.charCodeAt(t))){if(W(e.charCodeAt(t+1)))return e.charAt(t)+e.charAt(t+1)}else if(W(e.charCodeAt(t))&&z(e.charCodeAt(t-1)))return e.charAt(t-1)+e.charAt(t);return e.charAt(t)}function z(e){return e>=55296&&e<=56319}function W(e){return e>=56320&&e<=57343}function Y(e){return e>=48&&e<=57}function q(e){var t=e.charCodeAt(0);return H.ID_Start.test(e)||36==t||95==t}function $(e){var t=e.charCodeAt(0);return H.ID_Continue.test(e)||36==t||95==t||8204==t||8205==t}function j(e){return /^[a-z_$][a-z0-9_$]*$/i.test(e)}function Z(e,t=!0){if(!t&&e.includes("e"))return NaN;if(w.test(e))return parseInt(e.substr(2),16);if(x.test(e))return parseInt(e.substr(1),8);if(N.test(e))return parseInt(e.substr(2),8);if(k.test(e))return parseInt(e.substr(2),2);if(I.test(e))return parseFloat(e);var n=parseFloat(e);return n==e?n:void 0}class J extends Error{constructor(e,t,n,i,o){super(),this.name="SyntaxError",this.message=e,this.filename=t,this.line=n,this.col=i,this.pos=o;}}function Q(e,t,n,i,o){throw new J(e,t,n,i,o)}function ee(e,t,n){return e.type==t&&(null==n||e.value==n)}var te={};function ne(e,t,n,i){var o={text:e,filename:t,pos:0,tokpos:0,line:1,tokline:0,col:0,tokcol:0,newline_before:!1,regex_allowed:!1,brace_counter:0,template_braces:[],comments_before:[],directives:{},directive_stack:[]};function r(){return X(o.text,o.pos)}function a(e,t){var n=X(o.text,o.pos++);if(e&&!n)throw te;return B.has(n)?(o.newline_before=o.newline_before||!t,++o.line,o.col=0,"\r"==n&&"\n"==r()&&(++o.pos,n="\n")):(n.length>1&&(++o.pos,++o.col),++o.col),n}function s(e){for(;e--;)a();}function u(e){return o.text.substr(o.pos,e.length)==e}function c(e,t){var n=o.text.indexOf(e,o.pos);if(t&&-1==n)throw te;return n}function l(){o.tokline=o.line,o.tokcol=o.col,o.tokpos=o.pos;}var f=!1,p=null;function _(n,i,r){o.regex_allowed="operator"==n&&!oe.has(i)||"keyword"==n&&F.has(i)||"punc"==n&&U.has(i)||"arrow"==n,"punc"==n&&"."==i?f=!0:r||(f=!1);var a={type:n,value:i,line:o.tokline,col:o.tokcol,pos:o.tokpos,endline:o.line,endcol:o.col,endpos:o.pos,nlb:o.newline_before,file:t};return /^(?:num|string|regexp)$/i.test(n)&&(a.raw=e.substring(a.pos,a.endpos)),r||(a.comments_before=o.comments_before,a.comments_after=o.comments_before=[]),o.newline_before=!1,a=new le(a),r||(p=a),a}function d(){for(;P.has(r());)a();}function m(e){Q(e,t,o.tokline,o.tokcol,o.tokpos);}function h(e){var t=!1,n=!1,i=!1,o="."==e,s=!1,u=function(e){for(var t,n="",i=0;(t=r())&&e(t,i++);)n+=a();return n}((function(r,a){if(s)return !1;switch(r.charCodeAt(0)){case 98:case 66:return i=!0;case 111:case 79:case 120:case 88:return !i&&(i=!0);case 101:case 69:return !!i||!t&&(t=n=!0);case 45:return n||0==a&&!e;case 43:return n;case n=!1,46:return !(o||i||t)&&(o=!0)}return "n"===r?(s=!0,!0):R.test(r)}));if(e&&(u=e+u),x.test(u)&&K.has_directive("use strict")&&m("Legacy octal literals are not allowed in strict mode"),u.endsWith("n")){const e=u.slice(0,-1),t=Z(e,!1);if(!o&&L.test(u)&&!isNaN(t))return _("big_int",e);m("Invalid or unexpected token");}var c=Z(u);if(!isNaN(c))return _("num",c);m("Invalid syntax: "+u);}function E(e){return e>="0"&&e<="7"}function g(e,t,n){var i,s=a(!0,e);switch(s.charCodeAt(0)){case 110:return "\n";case 114:return "\r";case 116:return "\t";case 98:return "\b";case 118:return "\v";case 102:return "\f";case 120:return String.fromCharCode(D(2,t));case 117:if("{"==r()){for(a(!0),"}"===r()&&m("Expecting hex-character between {}");"0"==r();)a(!0);var u,l=c("}",!0)-o.pos;return (l>6||(u=D(l,t))>1114111)&&m("Unicode reference out of bounds"),a(!0),(i=u)>65535?(i-=65536,String.fromCharCode(55296+(i>>10))+String.fromCharCode(i%1024+56320)):String.fromCharCode(i)}return String.fromCharCode(D(4,t));case 10:return "";case 13:if("\n"==r())return a(!0,e),""}if(E(s)){if(n&&t){"0"===s&&!E(r())||m("Octal escape sequences are not allowed in template strings");}return function(e,t){var n=r();n>="0"&&n<="7"&&(e+=a(!0))[0]<="3"&&(n=r())>="0"&&n<="7"&&(e+=a(!0));if("0"===e)return "\0";e.length>0&&K.has_directive("use strict")&&t&&m("Legacy octal escape sequences are not allowed in strict mode");return String.fromCharCode(parseInt(e,8))}(s,t)}return s}function D(e,t){for(var n=0;e>0;--e){if(!t&&isNaN(parseInt(r(),16)))return parseInt(n,16)||"";var i=a(!0);isNaN(parseInt(i,16))&&m("Invalid hex-character pattern in string"),n+=i;}return parseInt(n,16)}var S=I("Unterminated string constant",(function(){for(var e=a(),t="";;){var n=a(!0,!0);if("\\"==n)n=g(!0,!0);else if("\r"==n||"\n"==n)m("Unterminated string constant");else if(n==e)break;t+=n;}var i=_("string",t);return i.quote=e,i})),v=I("Unterminated template",(function(e){e&&o.template_braces.push(o.brace_counter);var t,n,i="",s="";for(a(!0,!0);"`"!=(t=a(!0,!0));){if("\r"==t)"\n"==r()&&++o.pos,t="\n";else if("$"==t&&"{"==r())return a(!0,!0),o.brace_counter++,(n=_(e?"template_head":"template_substitution",i)).raw=s,n;if(s+=t,"\\"==t){var u=o.pos;t=g(!0,!(p&&("name"===p.type||"punc"===p.type&&(")"===p.value||"]"===p.value))),!0),s+=o.text.substr(u,o.pos-u);}i+=t;}return o.template_braces.pop(),(n=_(e?"template_head":"template_substitution",i)).raw=s,n.end=!0,n}));function A(e){var t,n=o.regex_allowed,i=function(){for(var e=o.text,t=o.pos,n=o.text.length;t<n;++t){var i=e[t];if(B.has(i))return t}return -1}();return -1==i?(t=o.text.substr(o.pos),o.pos=o.text.length):(t=o.text.substring(o.pos,i),o.pos=i),o.col=o.tokcol+(o.pos-o.tokpos),o.comments_before.push(_(e,t,!0)),o.regex_allowed=n,K}var T=I("Unterminated multiline comment",(function(){var e=o.regex_allowed,t=c("*/",!0),n=o.text.substring(o.pos,t).replace(/\r\n|\r|\u2028|\u2029/g,"\n");return s(function(e){for(var t=0,n=0;n<e.length;n++)z(e.charCodeAt(n))&&W(e.charCodeAt(n+1))&&(t++,n++);return e.length-t}(n)+2),o.comments_before.push(_("comment2",n,!0)),o.newline_before=o.newline_before||n.includes("\n"),o.regex_allowed=e,K})),y=I("Unterminated identifier name",(function(){var e,t,n=!1,i=function(){return n=!0,a(),"u"!==r()&&m("Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}"),g(!1,!0)};if("\\"===(e=r()))q(e=i())||m("First identifier char is an invalid identifier char");else{if(!q(e))return "";a();}for(;null!=(t=r());){if("\\"===(t=r()))$(t=i())||m("Invalid escaped identifier char");else{if(!$(t))break;a();}e+=t;}return O.has(e)&&n&&m("Escaped characters are not allowed in keywords"),e})),w=I("Unterminated regular expression",(function(e){for(var t,n=!1,i=!1;t=a(!0);)if(B.has(t))m("Unexpected line terminator");else if(n)e+="\\"+t,n=!1;else if("["==t)i=!0,e+=t;else if("]"==t&&i)i=!1,e+=t;else{if("/"==t&&!i)break;"\\"==t?n=!0:e+=t;}return _("regexp",{source:e,flags:y()})}));function N(e){return _("operator",function e(t){if(!r())return t;var n=t+r();return V.has(n)?(a(),e(n)):t}(e||a()))}function k(){switch(a(),r()){case"/":return a(),A("comment1");case"*":return a(),T()}return o.regex_allowed?w(""):N("/")}function I(e,t){return function(n){try{return t(n)}catch(t){if(t!==te)throw t;m(e);}}}function K(e){if(null!=e)return w(e);for(i&&0==o.pos&&u("#!")&&(l(),s(2),A("comment5"));;){if(d(),l(),n){if(u("\x3c!--")){s(4),A("comment3");continue}if(u("--\x3e")&&o.newline_before){s(3),A("comment4");continue}}var t=r();if(!t)return _("eof");var c=t.charCodeAt(0);switch(c){case 34:case 39:return S();case 46:return a(),Y(r().charCodeAt(0))?h("."):"."===r()?(a(),a(),_("expand","...")):_("punc",".");case 47:var p=k();if(p===K)continue;return p;case 61:return a(),">"===r()?(a(),_("arrow","=>")):N("=");case 96:return v(!0);case 123:o.brace_counter++;break;case 125:if(o.brace_counter--,o.template_braces.length>0&&o.template_braces[o.template_braces.length-1]===o.brace_counter)return v(!1)}if(Y(c))return h();if(G.has(t))return _("punc",a());if(M.has(t))return N();if(92==c||q(t))return E=void 0,E=y(),f?_("name",E):C.has(E)?_("atom",E):b.has(E)?V.has(E)?_("operator",E):_("keyword",E):_("name",E);break}var E;m("Unexpected character '"+t+"'");}return K.next=a,K.peek=r,K.context=function(e){return e&&(o=e),o},K.add_directive=function(e){o.directive_stack[o.directive_stack.length-1].push(e),void 0===o.directives[e]?o.directives[e]=1:o.directives[e]++;},K.push_directives_stack=function(){o.directive_stack.push([]);},K.pop_directives_stack=function(){for(var e=o.directive_stack[o.directive_stack.length-1],t=0;t<e.length;t++)o.directives[e[t]]--;o.directive_stack.pop();},K.has_directive=function(e){return o.directives[e]>0},K}var ie=E(["typeof","void","delete","--","++","!","~","-","+"]),oe=E(["--","++"]),re=E(["=","+=","-=","/=","*=","**=","%=",">>=","<<=",">>>=","|=","^=","&="]),ae=function(e,t){for(var n=0;n<e.length;++n)for(var i=e[n],o=0;o<i.length;++o)t[i[o]]=n+1;return t}([["||"],["&&"],["|"],["^"],["&"],["==","===","!=","!=="],["<",">","<=",">=","in","instanceof"],[">>","<<",">>>"],["+","-"],["*","/","%"],["**"]],{}),se=E(["atom","num","big_int","string","regexp","name"]);function ue(e,t){const n=new Map;t=r(t,{bare_returns:!1,ecma:2017,expression:!1,filename:null,html5_comments:!0,module:!1,shebang:!0,strict:!1,toplevel:null},!0);var i={input:"string"==typeof e?ne(e,t.filename,t.html5_comments,t.shebang):e,token:null,prev:null,peeked:null,in_function:0,in_async:-1,in_generator:-1,in_directives:!0,in_loop:0,labels:[]};function o(e,t){return ee(i.token,e,t)}function a(){return i.peeked||(i.peeked=i.input())}function s(){return i.prev=i.token,i.peeked||a(),i.token=i.peeked,i.peeked=null,i.in_directives=i.in_directives&&("string"==i.token.type||o("punc",";")),i.token}function u(){return i.prev}function c(e,t,n,o){var r=i.input.context();Q(e,r.filename,null!=t?t:r.tokline,null!=n?n:r.tokcol,null!=o?o:r.tokpos);}function l(e,t){c(t,e.line,e.col);}function f(e){null==e&&(e=i.token),l(e,"Unexpected token: "+e.type+" ("+e.value+")");}function p(e,t){if(o(e,t))return s();l(i.token,"Unexpected token "+i.token.type+" «"+i.token.value+"», expected "+e+" «"+t+"»");}function _(e){return p("punc",e)}function d(e){return e.nlb||!e.comments_before.every(e=>!e.nlb)}function m(){return !t.strict&&(o("eof")||o("punc","}")||d(i.token))}function h(){return i.in_generator===i.in_function}function E(){return i.in_async===i.in_function}function g(e){o("punc",";")?s():e||m()||f();}function D(){_("(");var e=et(!0);return _(")"),e}function S(e){return function(...t){const n=i.token,o=e(...t);return o.start=n,o.end=u(),o}}function v(){(o("operator","/")||o("operator","/="))&&(i.peeked=null,i.token=i.input(i.token.value.substr(1)));}i.token=s();var A=S((function(e,n,r){switch(v(),i.token.type){case"string":if(i.in_directives){var h=a();!i.token.raw.includes("\\")&&(ee(h,"punc",";")||ee(h,"punc","}")||d(h)||ee(h,"eof"))?i.input.add_directive(i.token.value):i.in_directives=!1;}var S=i.in_directives,y=T();return S&&y.body instanceof ln?new de(y.body):y;case"template_head":case"num":case"big_int":case"regexp":case"operator":case"atom":return T();case"name":if("async"==i.token.value&&ee(a(),"keyword","function"))return s(),s(),n&&c("functions are not allowed as the body of a loop"),F(Pe,!1,!0,e);if("import"==i.token.value&&!ee(a(),"punc","(")){s();var C=function(){var e,t,n=u();o("name")&&(e=le(Qt));o("punc",",")&&s();((t=J(!0))||e)&&p("name","from");var r=i.token;"string"!==r.type&&f();return s(),new pt({start:n,imported_name:e,imported_names:t,module_name:new ln({start:r,value:r.value,quote:r.quote,end:r}),end:i.token})}();return g(),C}return ee(a(),"punc",":")?function(){var e=le(tn);"await"===e.name&&E()&&l(i.prev,"await cannot be used as label inside async function");i.labels.some(t=>t.name===e.name)&&c("Label "+e.name+" defined twice");_(":"),i.labels.push(e);var t=A();i.labels.pop(),t instanceof Te||e.references.forEach((function(t){t instanceof $e&&(t=t.label.start,c("Continue label `"+e.name+"` refers to non-IterationStatement.",t.line,t.col,t.pos));}));return new Ae({body:t,label:e})}():T();case"punc":switch(i.token.value){case"{":return new De({start:i.token,body:N(),end:u()});case"[":case"(":return T();case";":return i.in_directives=!1,s(),new Se;default:f();}case"keyword":switch(i.token.value){case"break":return s(),b(qe);case"continue":return s(),b($e);case"debugger":return s(),g(),new _e;case"do":s();var O=St(A);p("keyword","while");var M=D();return g(!0),new be({body:O,condition:M});case"while":return s(),new Ce({condition:D(),body:St((function(){return A(!1,!0)}))});case"for":return s(),function(){var e="`for await` invalid in this context",t=i.token;"name"==t.type&&"await"==t.value?(E()||l(t,e),s()):t=!1;_("(");var n=null;if(o("punc",";"))t&&l(t,e);else{n=o("keyword","var")?(s(),L(!0)):o("keyword","let")?(s(),V(!0)):o("keyword","const")?(s(),P(!0)):et(!0,!0);var r=o("operator","in"),a=o("name","of");if(t&&!a&&l(t,e),r||a)return n instanceof at?n.definitions.length>1&&l(n.start,"Only one variable declaration allowed in for..in loop"):He(n)||(n=Xe(n))instanceof Be||l(n.start,"Invalid left-hand side in for..in loop"),s(),r?function(e){var t=et(!0);return _(")"),new Fe({init:e,object:t,body:St((function(){return A(!1,!0)}))})}(n):function(e,t){var n=e instanceof at?e.definitions[0].name:null,i=et(!0);return _(")"),new Me({await:t,init:e,name:n,object:i,body:St((function(){return A(!1,!0)}))})}(n,!!t)}return function(e){_(";");var t=o("punc",";")?null:et(!0);_(";");var n=o("punc",")")?null:et(!0);return _(")"),new Oe({init:e,condition:t,step:n,body:St((function(){return A(!1,!0)}))})}(n)}();case"class":return s(),n&&c("classes are not allowed as the body of a loop"),r&&c("classes are not allowed as the body of an if"),q(Lt);case"function":return s(),n&&c("functions are not allowed as the body of a loop"),F(Pe,!1,!1,e);case"if":return s(),function(){var e=D(),t=A(!1,!1,!0),n=null;o("keyword","else")&&(s(),n=A(!1,!1,!0));return new Je({condition:e,body:t,alternative:n})}();case"return":0!=i.in_function||t.bare_returns||c("'return' outside of function"),s();var w=null;return o("punc",";")?s():m()||(w=et(!0),g()),new ze({value:w});case"switch":return s(),new Qe({expression:D(),body:St(k)});case"throw":s(),d(i.token)&&c("Illegal newline after 'throw'");w=et(!0);return g(),new We({value:w});case"try":return s(),function(){var e=N(),t=null,n=null;if(o("keyword","catch")){var r=i.token;if(s(),o("punc","{"))var a=null;else{_("(");a=R(void 0,Jt);_(")");}t=new ot({start:r,argname:a,body:N(),end:u()});}if(o("keyword","finally")){r=i.token;s(),n=new rt({start:r,body:N(),end:u()});}t||n||c("Missing catch/finally blocks");return new it({body:e,bcatch:t,bfinally:n})}();case"var":s();C=L();return g(),C;case"let":s();C=V();return g(),C;case"const":s();C=P();return g(),C;case"with":return i.input.has_directive("use strict")&&c("Strict mode may not include a with statement"),s(),new Re({expression:D(),body:A()});case"export":if(!ee(a(),"punc","(")){s();C=function(){var e,t,n,r,c,l=i.token;if(o("keyword","default"))e=!0,s();else if(t=J(!1)){if(o("name","from")){s();var p=i.token;return "string"!==p.type&&f(),s(),new _t({start:l,is_default:e,exported_names:t,module_name:new ln({start:p,value:p.value,quote:p.quote,end:p}),end:u()})}return new _t({start:l,is_default:e,exported_names:t,end:u()})}o("punc","{")||e&&(o("keyword","class")||o("keyword","function"))&&ee(a(),"punc")?(r=et(!1),g()):(n=A(e))instanceof at&&e?f(n.start):n instanceof at||n instanceof ke||n instanceof Lt?c=n:n instanceof me?r=n.body:f(n.start);return new _t({start:l,is_default:e,exported_value:r,exported_definition:c,end:u()})}();return o("punc",";")&&g(),C}}}f();}));function T(e){return new me({body:(e=et(!0),g(),e)})}function b(e){var t,n=null;m()||(n=le(an,!0)),null!=n?((t=i.labels.find(e=>e.name===n.name))||c("Undefined label "+n.name),n.thedef=t):0==i.in_loop&&c(e.TYPE+" not inside a loop or switch"),g();var o=new e({label:n});return t&&t.references.push(o),o}var C=function(e,t,n){d(i.token)&&c("Unexpected newline before arrow (=>)"),p("arrow","=>");var r=x(o("punc","{"),!1,n),a=r instanceof Array&&r.length?r[r.length-1].end:r instanceof Array?e:r.end;return new Ve({start:e,end:a,async:n,argnames:t,body:r})},F=function(e,t,n,i){var r=e===Pe,a=o("operator","*");a&&s();var c=o("name")?le(r?Wt:$t):null;r&&!c&&(i?e=Le:f()),!c||e===Ie||c instanceof Kt||f(u());var l=[],p=x(!0,a||t,n,c,l);return new e({start:l.start,end:p.end,is_generator:a,async:n,name:c,argnames:l,body:p})};function M(e,t){var n=new Set,i=!1,o=!1,r=!1,a=!!t,s={add_parameter:function(t){if(n.has(t.value))!1===i&&(i=t),s.check_strict();else if(n.add(t.value),e)switch(t.value){case"arguments":case"eval":case"yield":a&&l(t,"Unexpected "+t.value+" identifier as parameter inside strict mode");break;default:O.has(t.value)&&f();}},mark_default_assignment:function(e){!1===o&&(o=e);},mark_spread:function(e){!1===r&&(r=e);},mark_strict_mode:function(){a=!0;},is_strict:function(){return !1!==o||!1!==r||a},check_strict:function(){s.is_strict()&&!1!==i&&l(i,"Parameter "+i.value+" was used already");}};return s}function R(e,t){var n,r=!1;return void 0===e&&(e=M(!0,i.input.has_directive("use strict"))),o("expand","...")&&(r=i.token,e.mark_spread(i.token),s()),n=w(e,t),o("operator","=")&&!1===r&&(e.mark_default_assignment(i.token),s(),n=new Ct({start:n.start,left:n,operator:"=",right:et(!1),end:i.token})),!1!==r&&(o("punc",")")||f(),n=new Ne({start:r,expression:n,end:r})),e.check_strict(),n}function w(e,t){var n,r=[],l=!0,p=!1,d=i.token;if(void 0===e&&(e=M(!1,i.input.has_directive("use strict"))),t=void 0===t?zt:t,o("punc","[")){for(s();!o("punc","]");){if(l?l=!1:_(","),o("expand","...")&&(p=!0,n=i.token,e.mark_spread(i.token),s()),o("punc"))switch(i.token.value){case",":r.push(new gn({start:i.token,end:i.token}));continue;case"]":break;case"[":case"{":r.push(w(e,t));break;default:f();}else o("name")?(e.add_parameter(i.token),r.push(le(t))):c("Invalid function parameter");o("operator","=")&&!1===p&&(e.mark_default_assignment(i.token),s(),r[r.length-1]=new Ct({start:r[r.length-1].start,left:r[r.length-1],operator:"=",right:et(!1),end:i.token})),p&&(o("punc","]")||c("Rest element must be last element"),r[r.length-1]=new Ne({start:n,expression:r[r.length-1],end:n}));}return _("]"),e.check_strict(),new Be({start:d,names:r,is_array:!0,end:u()})}if(o("punc","{")){for(s();!o("punc","}");){if(l?l=!1:_(","),o("expand","...")&&(p=!0,n=i.token,e.mark_spread(i.token),s()),o("name")&&(ee(a(),"punc")||ee(a(),"operator"))&&[",","}","="].includes(a().value)){e.add_parameter(i.token);var m=u(),h=le(t);p?r.push(new Ne({start:n,expression:h,end:h.end})):r.push(new Rt({start:m,key:h.name,value:h,end:h.end}));}else{if(o("punc","}"))continue;var E=i.token,g=te();null===g?f(u()):"name"!==u().type||o("punc",":")?(_(":"),r.push(new Rt({start:E,quote:E.quote,key:g,value:w(e,t),end:u()}))):r.push(new Rt({start:u(),key:g,value:new t({start:u(),name:g,end:u()}),end:u()}));}p?o("punc","}")||c("Rest element must be last element"):o("operator","=")&&(e.mark_default_assignment(i.token),s(),r[r.length-1].value=new Ct({start:r[r.length-1].value.start,left:r[r.length-1].value,operator:"=",right:et(!1),end:i.token}));}return _("}"),e.check_strict(),new Be({start:d,names:r,is_array:!1,end:u()})}if(o("name"))return e.add_parameter(i.token),le(t);c("Invalid function parameter");}function x(e,n,r,a,u){var c=i.in_loop,l=i.labels,p=i.in_generator,d=i.in_async;if(++i.in_function,n&&(i.in_generator=i.in_function),r&&(i.in_async=i.in_function),u&&function(e){var n=M(!0,i.input.has_directive("use strict"));for(_("(");!o("punc",")");){var r=R(n);if(e.push(r),o("punc",")")||(_(","),o("punc",")")&&t.ecma<2017&&f()),r instanceof Ne)break}s();}(u),e&&(i.in_directives=!0),i.in_loop=0,i.labels=[],e){i.input.push_directives_stack();var m=N();a&&ce(a),u&&u.forEach(ce),i.input.pop_directives_stack();}else m=[new ze({start:i.token,value:et(!1),end:i.token})];return --i.in_function,i.in_loop=c,i.labels=l,i.in_generator=p,i.in_async=d,m}function N(){_("{");for(var e=[];!o("punc","}");)o("eof")&&f(),e.push(A());return s(),e}function k(){_("{");for(var e,t=[],n=null,r=null;!o("punc","}");)o("eof")&&f(),o("keyword","case")?(r&&(r.end=u()),n=[],r=new nt({start:(e=i.token,s(),e),expression:et(!0),body:n}),t.push(r),_(":")):o("keyword","default")?(r&&(r.end=u()),n=[],r=new tt({start:(e=i.token,s(),_(":"),e),body:n}),t.push(r)):(n||f(),n.push(A()));return r&&(r.end=u()),s(),t}function I(e,t){for(var n,r=[];;){var a="var"===t?Ut:"const"===t?Ht:"let"===t?Xt:null;if(o("punc","{")||o("punc","[")?n=new lt({start:i.token,name:w(void 0,a),value:o("operator","=")?(p("operator","="),et(!1,e)):null,end:u()}):"import"==(n=new lt({start:i.token,name:le(a),value:o("operator","=")?(s(),et(!1,e)):e||"const"!==t?null:c("Missing initializer in const declaration"),end:u()})).name.name&&c("Unexpected token: import"),r.push(n),!o("punc",","))break;s();}return r}var L=function(e){return new st({start:u(),definitions:I(e,"var"),end:u()})},V=function(e){return new ut({start:u(),definitions:I(e,"let"),end:u()})},P=function(e){return new ct({start:u(),definitions:I(e,"const"),end:u()})};function B(){var e,t=i.token;switch(t.type){case"name":e=ue(nn);break;case"num":e=new fn({start:t,end:t,value:t.value});break;case"big_int":e=new pn({start:t,end:t,value:t.value});break;case"string":e=new ln({start:t,end:t,value:t.value,quote:t.quote});break;case"regexp":e=new _n({start:t,end:t,value:t.value});break;case"atom":switch(t.value){case"false":e=new vn({start:t,end:t});break;case"true":e=new An({start:t,end:t});break;case"null":e=new mn({start:t,end:t});}}return s(),e}function U(e,t,n,i){var o=function(e,t){return t?new Ct({start:e.start,left:e,operator:"=",right:t,end:t.end}):e};return e instanceof Ft?o(new Be({start:e.start,end:e.end,is_array:!1,names:e.properties.map(U)}),i):e instanceof Rt?(e.value=U(e.value,0,[e.key]),o(e,i)):e instanceof gn?e:e instanceof Be?(e.names=e.names.map(U),o(e,i)):e instanceof nn?o(new zt({name:e.name,start:e.start,end:e.end}),i):e instanceof Ne?(e.expression=U(e.expression),o(e,i)):e instanceof Ot?o(new Be({start:e.start,end:e.end,is_array:!0,names:e.elements.map(U)}),i):e instanceof bt?o(U(e.left,void 0,void 0,e.right),i):e instanceof Ct?(e.left=U(e.left,0,[e.left]),e):void c("Invalid function parameter",e.start.line,e.start.col)}var G=function(e,r){if(o("operator","new"))return function(e){var n=i.token;if(p("operator","new"),o("punc","."))return s(),p("name","target"),he(new Bt({start:n,end:u()}),e);var r,a=G(!1);o("punc","(")?(s(),r=X(")",t.ecma>=2017)):r=[];var c=new mt({start:n,expression:a,args:r,end:u()});return pe(c),he(c,e)}(e);var c,l=i.token,d=o("name","async")&&"["!=(c=a()).value&&"arrow"!=c.type&&B();if(o("punc")){switch(i.token.value){case"(":if(d&&!e)break;var m=function(e,n){var r,a,c,l=[];for(_("(");!o("punc",")");)r&&f(r),o("expand","...")?(r=i.token,n&&(a=i.token),s(),l.push(new Ne({start:u(),expression:et(),end:i.token}))):l.push(et()),o("punc",")")||(_(","),o("punc",")")&&(t.ecma<2017&&f(),c=u(),n&&(a=c)));return _(")"),e&&o("arrow","=>")?r&&c&&f(c):a&&f(a),l}(r,!d);if(r&&o("arrow","=>"))return C(l,m.map(U),!!d);var h=d?new dt({expression:d,args:m}):1==m.length?m[0]:new ht({expressions:m});if(h.start){const e=l.comments_before.length;if(n.set(l,e),h.start.comments_before.unshift(...l.comments_before),l.comments_before=h.start.comments_before,0==e&&l.comments_before.length>0){var E=l.comments_before[0];E.nlb||(E.nlb=l.nlb,l.nlb=!1);}l.comments_after=h.start.comments_after;}h.start=l;var g=u();return h.end&&(g.comments_before=h.end.comments_before,h.end.comments_after.push(...g.comments_after),g.comments_after=h.end.comments_after),h.end=g,h instanceof dt&&pe(h),he(h,e);case"[":return he(z(),e);case"{":return he(Y(),e)}d||f();}if(r&&o("name")&&ee(a(),"arrow")){var D=new zt({name:i.token.value,start:l,end:l});return s(),C(l,[D],!!d)}if(o("keyword","function")){s();var S=F(Le,!1,!!d);return S.start=l,S.end=u(),he(S,e)}if(d)return he(d,e);if(o("keyword","class")){s();var v=q(Vt);return v.start=l,v.end=u(),he(v,e)}return o("template_head")?he(H(),e):se.has(i.token.type)?he(B(),e):void f()};function H(){var e=[],t=i.token;for(e.push(new Ge({start:i.token,raw:i.token.raw,value:i.token.value,end:i.token}));!i.token.end;)s(),v(),e.push(et(!0)),ee("template_substitution")||f(),e.push(new Ge({start:i.token,raw:i.token.raw,value:i.token.value,end:i.token}));return s(),new Ue({start:t,segments:e,end:i.token})}function X(e,t,n){for(var r=!0,a=[];!o("punc",e)&&(r?r=!1:_(","),!t||!o("punc",e));)o("punc",",")&&n?a.push(new gn({start:i.token,end:i.token})):o("expand","...")?(s(),a.push(new Ne({start:u(),expression:et(),end:i.token}))):a.push(et(!1));return s(),a}var z=S((function(){return _("["),new Ot({elements:X("]",!t.strict,!0)})})),W=S((e,t)=>F(Ie,e,t)),Y=S((function(){var e=i.token,n=!0,r=[];for(_("{");!o("punc","}")&&(n?n=!1:_(","),t.strict||!o("punc","}"));)if("expand"!=(e=i.token).type){var a,c=te();if(o("punc",":"))null===c?f(u()):(s(),a=et(!1));else{var l=$(c,e);if(l){r.push(l);continue}a=new nn({start:u(),name:c,end:u()});}o("operator","=")&&(s(),a=new bt({start:e,left:a,operator:"=",right:et(!1),end:u()})),r.push(new Rt({start:e,quote:e.quote,key:c instanceof fe?c:""+c,value:a,end:u()}));}else s(),r.push(new Ne({start:e,expression:et(!1),end:u()}));return s(),new Ft({properties:r})}));function q(e){var t,n,r,a,c=[];for(i.input.push_directives_stack(),i.input.add_directive("use strict"),"name"==i.token.type&&"extends"!=i.token.value&&(r=le(e===Lt?jt:Zt)),e!==Lt||r||f(),"extends"==i.token.value&&(s(),a=et(!0)),_("{");o("punc",";");)s();for(;!o("punc","}");)for(t=i.token,(n=$(te(),t,!0))||f(),c.push(n);o("punc",";");)s();return i.input.pop_directives_stack(),s(),new e({start:t,name:r,extends:a,properties:c,end:u()})}function $(e,t,n){var r=function(e,t){return "string"==typeof e||"number"==typeof e?new Yt({start:t,name:""+e,end:u()}):(null===e&&f(),e)};var a=!1,c=!1,l=!1,p=t;if(n&&"static"===e&&!o("punc","(")&&(c=!0,p=i.token,e=te()),"async"!==e||o("punc","(")||o("punc",",")||o("punc","}")||o("operator","=")||(a=!0,p=i.token,e=te()),null===e&&(l=!0,p=i.token,null===(e=te())&&f()),o("punc","("))return e=r(e,t),new Nt({start:t,static:c,is_generator:l,async:a,key:e,quote:e instanceof Yt?p.quote:void 0,value:W(l,a),end:u()});const _=i.token;if("get"==e){if(!o("punc")||o("punc","["))return e=r(te(),t),new xt({start:t,static:c,key:e,quote:e instanceof Yt?_.quote:void 0,value:W(),end:u()})}else if("set"==e&&(!o("punc")||o("punc","[")))return e=r(te(),t),new wt({start:t,static:c,key:e,quote:e instanceof Yt?_.quote:void 0,value:W(),end:u()});if(n){const n=(e=>"string"==typeof e||"number"==typeof e?new qt({start:p,end:p,name:""+e}):(null===e&&f(),e))(e),i=n instanceof qt?p.quote:void 0;if(o("operator","="))return s(),new It({start:t,static:c,quote:i,key:n,value:et(!1),end:u()});if(o("name")||o("punc",";")||o("punc","}"))return new It({start:t,static:c,quote:i,key:n,end:u()})}}function j(e){function t(e){return new e({name:te(),start:u(),end:u()})}var n,r,a=e?en:rn,c=e?Qt:on,l=i.token;return e?n=t(a):r=t(c),o("name","as")?(s(),e?r=t(c):n=t(a)):e?r=new c(n):n=new a(r),new ft({start:l,foreign_name:n,name:r,end:u()})}function Z(e,t){var n,o=e?en:rn,r=e?Qt:on,a=i.token,s=u();return t=t||new r({name:"*",start:a,end:s}),n=new o({name:"*",start:a,end:s}),new ft({start:a,foreign_name:n,name:t,end:s})}function J(e){var t;if(o("punc","{")){for(s(),t=[];!o("punc","}");)t.push(j(e)),o("punc",",")&&s();s();}else if(o("operator","*")){var n;s(),e&&o("name","as")&&(s(),n=le(e?Qt:rn)),t=[Z(e,n)];}return t}function te(){var e=i.token;switch(e.type){case"punc":if("["===e.value){s();var t=et(!1);return _("]"),t}f(e);case"operator":if("*"===e.value)return s(),null;["delete","in","instanceof","new","typeof","void"].includes(e.value)||f(e);case"name":"yield"==e.value&&(h()?l(e,"Yield cannot be used as identifier inside generators"):ee(a(),"punc",":")||ee(a(),"punc","(")||!i.input.has_directive("use strict")||l(e,"Unexpected yield identifier inside strict mode"));case"string":case"num":case"big_int":case"keyword":case"atom":return s(),e.value;default:f(e);}}function ue(e){var t=i.token.value;return new("this"==t?sn:"super"==t?un:e)({name:String(t),start:i.token,end:i.token})}function ce(e){var t=e.name;h()&&"yield"==t&&l(e.start,"Yield cannot be used as identifier inside generators"),i.input.has_directive("use strict")&&("yield"==t&&l(e.start,"Unexpected yield identifier inside strict mode"),e instanceof Kt&&("arguments"==t||"eval"==t)&&l(e.start,"Unexpected "+t+" in strict mode"));}function le(e,t){if(!o("name"))return t||c("Name expected"),null;var n=ue(e);return ce(n),s(),n}function pe(e){var t=e.start,i=t.comments_before;const o=n.get(t);for(var r=null!=o?o:i.length;--r>=0;){var a=i[r];if(/[@#]__/.test(a.value)){if(/[@#]__PURE__/.test(a.value)){y(e,Fn);break}if(/[@#]__INLINE__/.test(a.value)){y(e,Mn);break}if(/[@#]__NOINLINE__/.test(a.value)){y(e,Rn);break}}}}var he=function(e,t){var n,r=e.start;if(o("punc","."))return s(),he(new gt({start:r,expression:e,property:(n=i.token,"name"!=n.type&&f(),s(),n.value),end:u()}),t);if(o("punc","[")){s();var a=et(!0);return _("]"),he(new Dt({start:r,expression:e,property:a,end:u()}),t)}if(t&&o("punc","(")){s();var c=new dt({start:r,expression:e,args:Ee(),end:u()});return pe(c),he(c,!0)}return o("template_head")?he(new Ke({start:r,prefix:e,template_string:H(),end:u()}),t):e};function Ee(){for(var e=[];!o("punc",")");)o("expand","...")?(s(),e.push(new Ne({start:u(),expression:et(!1),end:u()}))):e.push(et(!1)),o("punc",")")||(_(","),o("punc",")")&&t.ecma<2017&&f());return s(),e}var ge=function(e,t){var n=i.token;if("name"==n.type&&"await"==n.value){if(E())return s(),E()||c("Unexpected await expression outside async function",i.prev.line,i.prev.col,i.prev.pos),new je({start:u(),end:i.token,expression:ge(!0)});i.input.has_directive("use strict")&&l(i.token,"Unexpected await identifier inside strict mode");}if(o("operator")&&ie.has(n.value)){s(),v();var r=ve(vt,n,ge(e));return r.start=n,r.end=u(),r}for(var a=G(e,t);o("operator")&&oe.has(i.token.value)&&!d(i.token);)a instanceof Ve&&f(),(a=ve(At,i.token,a)).start=n,a.end=i.token,s();return a};function ve(e,t,n){var o=t.value;switch(o){case"++":case"--":He(n)||c("Invalid use of "+o+" operator",t.line,t.col,t.pos);break;case"delete":n instanceof nn&&i.input.has_directive("use strict")&&c("Calling delete on expression not allowed in strict mode",n.start.line,n.start.col,n.start.pos);}return new e({operator:o,expression:n})}var ye=function(e,t,n){var r=o("operator")?i.token.value:null;"in"==r&&n&&(r=null),"**"==r&&e instanceof vt&&!ee(e.start,"punc","(")&&"--"!==e.operator&&"++"!==e.operator&&f(e.start);var a=null!=r?ae[r]:null;if(null!=a&&(a>t||"**"===r&&t===a)){s();var u=ye(ge(!0),a,n);return ye(new Tt({start:e.start,left:e,operator:r,right:u,end:u.end}),t,n)}return e};var we=function(e){var t=i.token,n=function(e){return ye(ge(!0,!0),0,e)}(e);if(o("operator","?")){s();var r=et(!1);return _(":"),new yt({start:t,condition:n,consequent:r,alternative:et(!1,e),end:u()})}return n};function He(e){return e instanceof Et||e instanceof nn}function Xe(e){if(e instanceof Ft)e=new Be({start:e.start,names:e.properties.map(Xe),is_array:!1,end:e.end});else if(e instanceof Ot){for(var t=[],n=0;n<e.elements.length;n++)e.elements[n]instanceof Ne&&(n+1!==e.elements.length&&l(e.elements[n].start,"Spread must the be last element in destructuring array"),e.elements[n].expression=Xe(e.elements[n].expression)),t.push(Xe(e.elements[n]));e=new Be({start:e.start,names:t,is_array:!0,end:e.end});}else e instanceof Mt?e.value=Xe(e.value):e instanceof bt&&(e=new Ct({start:e.start,left:e.left,operator:"=",right:e.right,end:e.end}));return e}var Ye=function(e){v();var t=i.token;if("name"==t.type&&"yield"==t.value){if(h())return s(),function(){h()||c("Unexpected yield expression outside generator function",i.prev.line,i.prev.col,i.prev.pos);var e=i.token,t=!1,n=!0;return m()||o("punc")&&K.has(i.token.value)?n=!1:o("operator","*")&&(t=!0,s()),new Ze({start:e,is_star:t,expression:n?et():null,end:u()})}();i.input.has_directive("use strict")&&l(i.token,"Unexpected yield identifier inside strict mode");}var n=we(e),r=i.token.value;if(o("operator")&&re.has(r)){if(He(n)||(n=Xe(n))instanceof Be)return s(),new bt({start:t,left:n,operator:r,right:Ye(e),end:u()});c("Invalid assignment");}return n},et=function(e,t){for(var n=i.token,r=[];r.push(Ye(t)),e&&o("punc",",");)s(),e=!0;return 1==r.length?r[0]:new ht({start:n,expressions:r,end:a()})};function St(e){++i.in_loop;var t=e();return --i.in_loop,t}return t.expression?et(!0):function(){var e=i.token,n=[];for(i.input.push_directives_stack(),t.module&&i.input.add_directive("use strict");!o("eof");)n.push(A());i.input.pop_directives_stack();var r=u(),a=t.toplevel;return a?(a.body=a.body.concat(n),a.end=r):a=new xe({start:e,body:n,end:r}),a}()}function ce(e,t,n,i=fe){var o=t=t?t.split(/\s+/):[];i&&i.PROPS&&(t=t.concat(i.PROPS));for(var r="return function AST_"+e+"(props){ if (props) { ",a=t.length;--a>=0;)r+="this."+t[a]+" = props."+t[a]+";";const s=i&&Object.create(i.prototype);(s&&s.initialize||n&&n.initialize)&&(r+="this.initialize();"),r+="}",r+="this.flags = 0;",r+="}";var u=new Function(r)();if(s&&(u.prototype=s,u.BASE=i),i&&i.SUBCLASSES.push(u),u.prototype.CTOR=u,u.prototype.constructor=u,u.PROPS=t||null,u.SELF_PROPS=o,u.SUBCLASSES=[],e&&(u.prototype.TYPE=u.TYPE=e),n)for(a in n)D(n,a)&&("$"===a[0]?u[a.substr(1)]=n[a]:u.prototype[a]=n[a]);return u.DEFMETHOD=function(e,t){this.prototype[e]=t;},u}var le=ce("Token","type value line col pos endline endcol endpos nlb comments_before comments_after file raw quote end",{},null),fe=ce("Node","start end",{_clone:function(e){if(e){var t=this.clone();return t.transform(new On((function(e){if(e!==t)return e.clone(!0)})))}return new this.CTOR(this)},clone:function(e){return this._clone(e)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},_walk:function(e){return e._visit(this)},walk:function(e){return this._walk(e)},_children_backwards:()=>{}},null);fe.warn_function=null,fe.warn=function(e,t){fe.warn_function&&fe.warn_function(d(e,t));};var pe=ce("Statement",null,{$documentation:"Base class of all statements"}),_e=ce("Debugger",null,{$documentation:"Represents a debugger statement"},pe),de=ce("Directive","value quote",{$documentation:'Represents a directive, like "use strict";',$propdoc:{value:"[string] The value of this directive as a plain string (it's not an AST_String!)",quote:"[string] the original quote character"}},pe),me=ce("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_walk:function(e){return e._visit(this,(function(){this.body._walk(e);}))},_children_backwards(e){e(this.body);}},pe);function he(e,t){const n=e.body;for(var i=0,o=n.length;i<o;i++)n[i]._walk(t);}function Ee(e){var t=this._clone(e);return this.block_scope&&(t.block_scope=this.block_scope.clone()),t}var ge=ce("Block","body block_scope",{$documentation:"A body of statements (usually braced)",$propdoc:{body:"[AST_Statement*] an array of statements",block_scope:"[AST_Scope] the block scope"},_walk:function(e){return e._visit(this,(function(){he(this,e);}))},_children_backwards(e){let t=this.body.length;for(;t--;)e(this.body[t]);},clone:Ee},pe),De=ce("BlockStatement",null,{$documentation:"A block statement"},ge),Se=ce("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)"},pe),ve=ce("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"}},pe),Ae=ce("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_walk:function(e){return e._visit(this,(function(){this.label._walk(e),this.body._walk(e);}))},_children_backwards(e){e(this.body),e(this.label);},clone:function(e){var t=this._clone(e);if(e){var n=t.label,i=this.label;t.walk(new Cn((function(e){e instanceof Ye&&e.label&&e.label.thedef===i&&(e.label.thedef=n,n.references.push(e));})));}return t}},ve),Te=ce("IterationStatement","block_scope",{$documentation:"Internal class.  All loops inherit from it.",$propdoc:{block_scope:"[AST_Scope] the block scope for this iteration statement."},clone:Ee},ve),ye=ce("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"}},Te),be=ce("Do",null,{$documentation:"A `do` statement",_walk:function(e){return e._visit(this,(function(){this.body._walk(e),this.condition._walk(e);}))},_children_backwards(e){e(this.condition),e(this.body);}},ye),Ce=ce("While",null,{$documentation:"A `while` statement",_walk:function(e){return e._visit(this,(function(){this.condition._walk(e),this.body._walk(e);}))},_children_backwards(e){e(this.body),e(this.condition);}},ye),Oe=ce("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_walk:function(e){return e._visit(this,(function(){this.init&&this.init._walk(e),this.condition&&this.condition._walk(e),this.step&&this.step._walk(e),this.body._walk(e);}))},_children_backwards(e){e(this.body),this.step&&e(this.step),this.condition&&e(this.condition),this.init&&e(this.init);}},Te),Fe=ce("ForIn","init object",{$documentation:"A `for ... in` statement",$propdoc:{init:"[AST_Node] the `for/in` initialization code",object:"[AST_Node] the object that we're looping through"},_walk:function(e){return e._visit(this,(function(){this.init._walk(e),this.object._walk(e),this.body._walk(e);}))},_children_backwards(e){e(this.body),this.object&&e(this.object),this.init&&e(this.init);}},Te),Me=ce("ForOf","await",{$documentation:"A `for ... of` statement"},Fe),Re=ce("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_walk:function(e){return e._visit(this,(function(){this.expression._walk(e),this.body._walk(e);}))},_children_backwards(e){e(this.body),e(this.expression);}},ve),we=ce("Scope","variables functions uses_with uses_eval parent_scope enclosed cname _var_name_cache",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{variables:"[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope",functions:"[Map/S] like `variables`, but only lists function declarations",uses_with:"[boolean/S] tells whether this scope uses the `with` statement",uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",parent_scope:"[AST_Scope?/S] link to the parent scope",enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",cname:"[integer/S] current index for mangling variables (used internally by the mangler)"},get_defun_scope:function(){for(var e=this;e.is_block_scope();)e=e.parent_scope;return e},clone:function(e){var t=this._clone(e);return this.variables&&(t.variables=new Map(this.variables)),this.functions&&(t.functions=new Map(this.functions)),this.enclosed&&(t.enclosed=this.enclosed.slice()),this._block_scope&&(t._block_scope=this._block_scope),t},pinned:function(){return this.uses_eval||this.uses_with}},ge),xe=ce("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Map/S] a map of name -> SymbolDef for all undeclared names"},wrap_commonjs:function(e){var t=this.body,n="(function(exports){'$ORIG';})(typeof "+e+"=='undefined'?("+e+"={}):"+e+");";return n=(n=ue(n)).transform(new On((function(e){if(e instanceof de&&"$ORIG"==e.value)return f.splice(t)})))},wrap_enclose:function(e){"string"!=typeof e&&(e="");var t=e.indexOf(":");t<0&&(t=e.length);var n=this.body;return ue(["(function(",e.slice(0,t),'){"$ORIG"})(',e.slice(t+1),")"].join("")).transform(new On((function(e){if(e instanceof de&&"$ORIG"==e.value)return f.splice(n)})))}},we),Ne=ce("Expansion","expression",{$documentation:"An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list",$propdoc:{expression:"[AST_Node] the thing to be expanded"},_walk:function(e){return e._visit(this,(function(){this.expression.walk(e);}))},_children_backwards(e){e(this.expression);}}),ke=ce("Lambda","name argnames uses_arguments is_generator async",{$documentation:"Base class for functions",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this function",argnames:"[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments",uses_arguments:"[boolean/S] tells whether this function accesses the arguments array",is_generator:"[boolean] is this a generator method",async:"[boolean] is this method async"},args_as_names:function(){for(var e=[],t=0;t<this.argnames.length;t++)this.argnames[t]instanceof Be?e.push(...this.argnames[t].all_symbols()):e.push(this.argnames[t]);return e},_walk:function(e){return e._visit(this,(function(){this.name&&this.name._walk(e);for(var t=this.argnames,n=0,i=t.length;n<i;n++)t[n]._walk(e);he(this,e);}))},_children_backwards(e){let t=this.body.length;for(;t--;)e(this.body[t]);for(t=this.argnames.length;t--;)e(this.argnames[t]);this.name&&e(this.name);}},we),Ie=ce("Accessor",null,{$documentation:"A setter/getter function.  The `name` property is always null."},ke),Le=ce("Function",null,{$documentation:"A function expression"},ke),Ve=ce("Arrow",null,{$documentation:"An ES6 Arrow function ((a) => b)"},ke),Pe=ce("Defun",null,{$documentation:"A function definition"},ke),Be=ce("Destructuring","names is_array",{$documentation:"A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",$propdoc:{names:"[AST_Node*] Array of properties or elements",is_array:"[Boolean] Whether the destructuring represents an object or array"},_walk:function(e){return e._visit(this,(function(){this.names.forEach((function(t){t._walk(e);}));}))},_children_backwards(e){let t=this.names.length;for(;t--;)e(this.names[t]);},all_symbols:function(){var e=[];return this.walk(new Cn((function(t){t instanceof Pt&&e.push(t);}))),e}}),Ke=ce("PrefixedTemplateString","template_string prefix",{$documentation:"A templatestring with a prefix, such as String.raw`foobarbaz`",$propdoc:{template_string:"[AST_TemplateString] The template string",prefix:"[AST_SymbolRef|AST_PropAccess] The prefix, which can be a symbol such as `foo` or a dotted expression such as `String.raw`."},_walk:function(e){return e._visit(this,(function(){this.prefix._walk(e),this.template_string._walk(e);}))},_children_backwards(e){e(this.template_string),e(this.prefix);}}),Ue=ce("TemplateString","segments",{$documentation:"A template string literal",$propdoc:{segments:"[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment."},_walk:function(e){return e._visit(this,(function(){this.segments.forEach((function(t){t._walk(e);}));}))},_children_backwards(e){let t=this.segments.length;for(;t--;)e(this.segments[t]);}}),Ge=ce("TemplateSegment","value raw",{$documentation:"A segment of a template string literal",$propdoc:{value:"Content of the segment",raw:"Raw content of the segment"}}),He=ce("Jump",null,{$documentation:"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"},pe),Xe=ce("Exit","value",{$documentation:"Base class for “exits” (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_walk:function(e){return e._visit(this,this.value&&function(){this.value._walk(e);})},_children_backwards(e){this.value&&e(this.value);}},He),ze=ce("Return",null,{$documentation:"A `return` statement"},Xe),We=ce("Throw",null,{$documentation:"A `throw` statement"},Xe),Ye=ce("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_walk:function(e){return e._visit(this,this.label&&function(){this.label._walk(e);})},_children_backwards(e){this.label&&e(this.label);}},He),qe=ce("Break",null,{$documentation:"A `break` statement"},Ye),$e=ce("Continue",null,{$documentation:"A `continue` statement"},Ye),je=ce("Await","expression",{$documentation:"An `await` statement",$propdoc:{expression:"[AST_Node] the mandatory expression being awaited"},_walk:function(e){return e._visit(this,(function(){this.expression._walk(e);}))},_children_backwards(e){e(this.expression);}}),Ze=ce("Yield","expression is_star",{$documentation:"A `yield` statement",$propdoc:{expression:"[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false",is_star:"[Boolean] Whether this is a yield or yield* statement"},_walk:function(e){return e._visit(this,this.expression&&function(){this.expression._walk(e);})},_children_backwards(e){this.expression&&e(this.expression);}}),Je=ce("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_walk:function(e){return e._visit(this,(function(){this.condition._walk(e),this.body._walk(e),this.alternative&&this.alternative._walk(e);}))},_children_backwards(e){this.alternative&&e(this.alternative),e(this.body),e(this.condition);}},ve),Qe=ce("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` “discriminant”"},_walk:function(e){return e._visit(this,(function(){this.expression._walk(e),he(this,e);}))},_children_backwards(e){let t=this.body.length;for(;t--;)e(this.body[t]);e(this.expression);}},ge),et=ce("SwitchBranch",null,{$documentation:"Base class for `switch` branches"},ge),tt=ce("Default",null,{$documentation:"A `default` switch branch"},et),nt=ce("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_walk:function(e){return e._visit(this,(function(){this.expression._walk(e),he(this,e);}))},_children_backwards(e){let t=this.body.length;for(;t--;)e(this.body[t]);e(this.expression);}},et),it=ce("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_walk:function(e){return e._visit(this,(function(){he(this,e),this.bcatch&&this.bcatch._walk(e),this.bfinally&&this.bfinally._walk(e);}))},_children_backwards(e){this.bfinally&&e(this.bfinally),this.bcatch&&e(this.bcatch);let t=this.body.length;for(;t--;)e(this.body[t]);}},ge),ot=ce("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"},_walk:function(e){return e._visit(this,(function(){this.argname&&this.argname._walk(e),he(this,e);}))},_children_backwards(e){let t=this.body.length;for(;t--;)e(this.body[t]);this.argname&&e(this.argname);}},ge),rt=ce("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},ge),at=ce("Definitions","definitions",{$documentation:"Base class for `var` or `const` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_walk:function(e){return e._visit(this,(function(){for(var t=this.definitions,n=0,i=t.length;n<i;n++)t[n]._walk(e);}))},_children_backwards(e){let t=this.definitions.length;for(;t--;)e(this.definitions[t]);}},pe),st=ce("Var",null,{$documentation:"A `var` statement"},at),ut=ce("Let",null,{$documentation:"A `let` statement"},at),ct=ce("Const",null,{$documentation:"A `const` statement"},at),lt=ce("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_walk:function(e){return e._visit(this,(function(){this.name._walk(e),this.value&&this.value._walk(e);}))},_children_backwards(e){this.value&&e(this.value),e(this.name);}}),ft=ce("NameMapping","foreign_name name",{$documentation:"The part of the export/import statement that declare names from a module.",$propdoc:{foreign_name:"[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",name:"[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."},_walk:function(e){return e._visit(this,(function(){this.foreign_name._walk(e),this.name._walk(e);}))},_children_backwards(e){e(this.name),e(this.foreign_name);}}),pt=ce("Import","imported_name imported_names module_name",{$documentation:"An `import` statement",$propdoc:{imported_name:"[AST_SymbolImport] The name of the variable holding the module's default export.",imported_names:"[AST_NameMapping*] The names of non-default imported variables",module_name:"[AST_String] String literal describing where this module came from"},_walk:function(e){return e._visit(this,(function(){this.imported_name&&this.imported_name._walk(e),this.imported_names&&this.imported_names.forEach((function(t){t._walk(e);})),this.module_name._walk(e);}))},_children_backwards(e){if(e(this.module_name),this.imported_names){let t=this.imported_names.length;for(;t--;)e(this.imported_names[t]);}this.imported_name&&e(this.imported_name);}}),_t=ce("Export","exported_definition exported_value is_default exported_names module_name",{$documentation:"An `export` statement",$propdoc:{exported_definition:"[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",exported_value:"[AST_Node?] An exported value",exported_names:"[AST_NameMapping*?] List of exported names",module_name:"[AST_String?] Name of the file to load exports from",is_default:"[Boolean] Whether this is the default exported value of this module"},_walk:function(e){return e._visit(this,(function(){this.exported_definition&&this.exported_definition._walk(e),this.exported_value&&this.exported_value._walk(e),this.exported_names&&this.exported_names.forEach((function(t){t._walk(e);})),this.module_name&&this.module_name._walk(e);}))},_children_backwards(e){if(this.module_name&&e(this.module_name),this.exported_names){let t=this.exported_names.length;for(;t--;)e(this.exported_names[t]);}this.exported_value&&e(this.exported_value),this.exported_definition&&e(this.exported_definition);}},pe),dt=ce("Call","expression args _annotations",{$documentation:"A function call expression",$propdoc:{expression:"[AST_Node] expression to invoke as function",args:"[AST_Node*] array of arguments",_annotations:"[number] bitfield containing information about the call"},initialize(){null==this._annotations&&(this._annotations=0);},_walk(e){return e._visit(this,(function(){for(var t=this.args,n=0,i=t.length;n<i;n++)t[n]._walk(e);this.expression._walk(e);}))},_children_backwards(e){let t=this.args.length;for(;t--;)e(this.args[t]);e(this.expression);}}),mt=ce("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties"},dt),ht=ce("Sequence","expressions",{$documentation:"A sequence expression (comma-separated expressions)",$propdoc:{expressions:"[AST_Node*] array of expressions (at least two)"},_walk:function(e){return e._visit(this,(function(){this.expressions.forEach((function(t){t._walk(e);}));}))},_children_backwards(e){let t=this.expressions.length;for(;t--;)e(this.expressions[t]);}}),Et=ce("PropAccess","expression property",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the “container” expression",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"}}),gt=ce("Dot","quote",{$documentation:"A dotted property access expression",$propdoc:{quote:"[string] the original quote character when transformed from AST_Sub"},_walk:function(e){return e._visit(this,(function(){this.expression._walk(e);}))},_children_backwards(e){e(this.expression);}},Et),Dt=ce("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',_walk:function(e){return e._visit(this,(function(){this.expression._walk(e),this.property._walk(e);}))},_children_backwards(e){e(this.property),e(this.expression);}},Et),St=ce("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_walk:function(e){return e._visit(this,(function(){this.expression._walk(e);}))},_children_backwards(e){e(this.expression);}}),vt=ce("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},St),At=ce("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},St),Tt=ce("Binary","operator left right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_walk:function(e){return e._visit(this,(function(){this.left._walk(e),this.right._walk(e);}))},_children_backwards(e){e(this.right),e(this.left);}}),yt=ce("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_walk:function(e){return e._visit(this,(function(){this.condition._walk(e),this.consequent._walk(e),this.alternative._walk(e);}))},_children_backwards(e){e(this.alternative),e(this.consequent),e(this.condition);}}),bt=ce("Assign",null,{$documentation:"An assignment expression — `a = b + 5`"},Tt),Ct=ce("DefaultAssign",null,{$documentation:"A default assignment expression like in `(a = 3) => a`"},Tt),Ot=ce("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_walk:function(e){return e._visit(this,(function(){for(var t=this.elements,n=0,i=t.length;n<i;n++)t[n]._walk(e);}))},_children_backwards(e){let t=this.elements.length;for(;t--;)e(this.elements[t]);}}),Ft=ce("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[AST_ObjectProperty*] array of properties"},_walk:function(e){return e._visit(this,(function(){for(var t=this.properties,n=0,i=t.length;n<i;n++)t[n]._walk(e);}))},_children_backwards(e){let t=this.properties.length;for(;t--;)e(this.properties[t]);}}),Mt=ce("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.",value:"[AST_Node] property value.  For getters and setters this is an AST_Accessor."},_walk:function(e){return e._visit(this,(function(){this.key instanceof fe&&this.key._walk(e),this.value._walk(e);}))},_children_backwards(e){e(this.value),this.key instanceof fe&&e(this.key);}}),Rt=ce("ObjectKeyVal","quote",{$documentation:"A key: value object property",$propdoc:{quote:"[string] the original quote character"},computed_key(){return this.key instanceof fe}},Mt),wt=ce("ObjectSetter","quote static",{$propdoc:{quote:"[string|undefined] the original quote character, if any",static:"[boolean] whether this is a static setter (classes only)"},$documentation:"An object setter property",computed_key(){return !(this.key instanceof Yt)}},Mt),xt=ce("ObjectGetter","quote static",{$propdoc:{quote:"[string|undefined] the original quote character, if any",static:"[boolean] whether this is a static getter (classes only)"},$documentation:"An object getter property",computed_key(){return !(this.key instanceof Yt)}},Mt),Nt=ce("ConciseMethod","quote static is_generator async",{$propdoc:{quote:"[string|undefined] the original quote character, if any",static:"[boolean] is this method static (classes only)",is_generator:"[boolean] is this a generator method",async:"[boolean] is this method async"},$documentation:"An ES6 concise method inside an object or class",computed_key(){return !(this.key instanceof Yt)}},Mt),kt=ce("Class","name extends properties",{$propdoc:{name:"[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",extends:"[AST_Node]? optional parent class",properties:"[AST_ObjectProperty*] array of properties"},$documentation:"An ES6 class",_walk:function(e){return e._visit(this,(function(){this.name&&this.name._walk(e),this.extends&&this.extends._walk(e),this.properties.forEach(t=>t._walk(e));}))},_children_backwards(e){let t=this.properties.length;for(;t--;)e(this.properties[t]);this.extends&&e(this.extends),this.name&&e(this.name);}},we),It=ce("ClassProperty","static quote",{$documentation:"A class property",$propdoc:{static:"[boolean] whether this is a static key",quote:"[string] which quote is being used"},_walk:function(e){return e._visit(this,(function(){this.key instanceof fe&&this.key._walk(e),this.value instanceof fe&&this.value._walk(e);}))},_children_backwards(e){this.value instanceof fe&&e(this.value),this.key instanceof fe&&e(this.key);},computed_key(){return !(this.key instanceof qt)}},Mt),Lt=ce("DefClass",null,{$documentation:"A class definition"},kt),Vt=ce("ClassExpression",null,{$documentation:"A class expression."},kt),Pt=ce("Symbol","scope name thedef",{$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},$documentation:"Base class for all symbols"}),Bt=ce("NewTarget",null,{$documentation:"A reference to new.target"}),Kt=ce("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)"},Pt),Ut=ce("SymbolVar",null,{$documentation:"Symbol defining a variable"},Kt),Gt=ce("SymbolBlockDeclaration",null,{$documentation:"Base class for block-scoped declaration symbols"},Kt),Ht=ce("SymbolConst",null,{$documentation:"A constant declaration"},Gt),Xt=ce("SymbolLet",null,{$documentation:"A block-scoped `let` declaration"},Gt),zt=ce("SymbolFunarg",null,{$documentation:"Symbol naming a function argument"},Ut),Wt=ce("SymbolDefun",null,{$documentation:"Symbol defining a function"},Kt),Yt=ce("SymbolMethod",null,{$documentation:"Symbol in an object defining a method"},Pt),qt=ce("SymbolClassProperty",null,{$documentation:"Symbol for a class property"},Pt),$t=ce("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},Kt),jt=ce("SymbolDefClass",null,{$documentation:"Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class."},Gt),Zt=ce("SymbolClass",null,{$documentation:"Symbol naming a class's name. Lexically scoped to the class."},Kt),Jt=ce("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},Gt),Qt=ce("SymbolImport",null,{$documentation:"Symbol referring to an imported name"},Gt),en=ce("SymbolImportForeign",null,{$documentation:"A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes"},Pt),tn=ce("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this;}},Pt),nn=ce("SymbolRef",null,{$documentation:"Reference to some symbol (not definition/declaration)"},Pt),on=ce("SymbolExport",null,{$documentation:"Symbol referring to a name to export"},nn),rn=ce("SymbolExportForeign",null,{$documentation:"A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes"},Pt),an=ce("LabelRef",null,{$documentation:"Reference to a label symbol"},Pt),sn=ce("This",null,{$documentation:"The `this` symbol"},Pt),un=ce("Super",null,{$documentation:"The `super` symbol"},sn),cn=ce("Constant",null,{$documentation:"Base class for all constants",getValue:function(){return this.value}}),ln=ce("String","value quote",{$documentation:"A string literal",$propdoc:{value:"[string] the contents of this string",quote:"[string] the original quote character"}},cn),fn=ce("Number","value literal",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value",literal:"[string] numeric value as string (optional)"}},cn),pn=ce("BigInt","value",{$documentation:"A big int literal",$propdoc:{value:"[string] big int value"}},cn),_n=ce("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"}},cn),dn=ce("Atom",null,{$documentation:"Base class for atoms"},cn),mn=ce("Null",null,{$documentation:"The `null` atom",value:null},dn),hn=ce("NaN",null,{$documentation:"The impossible value",value:NaN},dn),En=ce("Undefined",null,{$documentation:"The `undefined` value",value:void 0},dn),gn=ce("Hole",null,{$documentation:"A hole in an array",value:void 0},dn),Dn=ce("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},dn),Sn=ce("Boolean",null,{$documentation:"Base class for booleans"},dn),vn=ce("False",null,{$documentation:"The `false` atom",value:!1},Sn),An=ce("True",null,{$documentation:"The `true` atom",value:!0},Sn);function Tn(e,t,n=[e]){const i=n.push.bind(n);for(;n.length;){const e=n.pop(),o=t(e,n);if(o){if(o===bn)return !0}else e._children_backwards(i);}return !1}function yn(e,t,n){const i=[e],o=i.push.bind(i),r=n?n.slice():[],a=[];let s;const u={parent:(e=0)=>-1===e?s:n&&e>=r.length?(e-=r.length,n[n.length-(e+1)]):r[r.length-(1+e)]};for(;i.length;){for(s=i.pop();a.length&&i.length==a[a.length-1];)r.pop(),a.pop();const e=t(s,u);if(e){if(e===bn)return !0;continue}const n=i.length;s._children_backwards(o),i.length>n&&(r.push(s),a.push(n-1));}return !1}const bn=Symbol("abort walk");class Cn{constructor(e){this.visit=e,this.stack=[],this.directives=Object.create(null);}_visit(e,t){this.push(e);var n=this.visit(e,t?function(){t.call(e);}:a);return !n&&t&&t.call(e),this.pop(),n}parent(e){return this.stack[this.stack.length-2-(e||0)]}push(e){e instanceof ke?this.directives=Object.create(this.directives):e instanceof de&&!this.directives[e.value]?this.directives[e.value]=e:e instanceof kt&&(this.directives=Object.create(this.directives),this.directives["use strict"]||(this.directives["use strict"]=e)),this.stack.push(e);}pop(){var e=this.stack.pop();(e instanceof ke||e instanceof kt)&&(this.directives=Object.getPrototypeOf(this.directives));}self(){return this.stack[this.stack.length-1]}find_parent(e){for(var t=this.stack,n=t.length;--n>=0;){var i=t[n];if(i instanceof e)return i}}has_directive(e){var t=this.directives[e];if(t)return t;var n=this.stack[this.stack.length-1];if(n instanceof we&&n.body)for(var i=0;i<n.body.length;++i){var o=n.body[i];if(!(o instanceof de))break;if(o.value==e)return o}}loopcontrol_target(e){var t=this.stack;if(e.label)for(var n=t.length;--n>=0;){if((i=t[n])instanceof Ae&&i.label.name==e.label.name)return i.body}else for(n=t.length;--n>=0;){var i;if((i=t[n])instanceof Te||e instanceof qe&&i instanceof Qe)return i}}}class On extends Cn{constructor(e,t){super(),this.before=e,this.after=t;}}const Fn=1,Mn=2,Rn=4;var wn=Object.freeze({__proto__:null,AST_Accessor:Ie,AST_Array:Ot,AST_Arrow:Ve,AST_Assign:bt,AST_Atom:dn,AST_Await:je,AST_BigInt:pn,AST_Binary:Tt,AST_Block:ge,AST_BlockStatement:De,AST_Boolean:Sn,AST_Break:qe,AST_Call:dt,AST_Case:nt,AST_Catch:ot,AST_Class:kt,AST_ClassExpression:Vt,AST_ClassProperty:It,AST_ConciseMethod:Nt,AST_Conditional:yt,AST_Const:ct,AST_Constant:cn,AST_Continue:$e,AST_Debugger:_e,AST_Default:tt,AST_DefaultAssign:Ct,AST_DefClass:Lt,AST_Definitions:at,AST_Defun:Pe,AST_Destructuring:Be,AST_Directive:de,AST_Do:be,AST_Dot:gt,AST_DWLoop:ye,AST_EmptyStatement:Se,AST_Exit:Xe,AST_Expansion:Ne,AST_Export:_t,AST_False:vn,AST_Finally:rt,AST_For:Oe,AST_ForIn:Fe,AST_ForOf:Me,AST_Function:Le,AST_Hole:gn,AST_If:Je,AST_Import:pt,AST_Infinity:Dn,AST_IterationStatement:Te,AST_Jump:He,AST_Label:tn,AST_LabeledStatement:Ae,AST_LabelRef:an,AST_Lambda:ke,AST_Let:ut,AST_LoopControl:Ye,AST_NameMapping:ft,AST_NaN:hn,AST_New:mt,AST_NewTarget:Bt,AST_Node:fe,AST_Null:mn,AST_Number:fn,AST_Object:Ft,AST_ObjectGetter:xt,AST_ObjectKeyVal:Rt,AST_ObjectProperty:Mt,AST_ObjectSetter:wt,AST_PrefixedTemplateString:Ke,AST_PropAccess:Et,AST_RegExp:_n,AST_Return:ze,AST_Scope:we,AST_Sequence:ht,AST_SimpleStatement:me,AST_Statement:pe,AST_StatementWithBody:ve,AST_String:ln,AST_Sub:Dt,AST_Super:un,AST_Switch:Qe,AST_SwitchBranch:et,AST_Symbol:Pt,AST_SymbolBlockDeclaration:Gt,AST_SymbolCatch:Jt,AST_SymbolClass:Zt,AST_SymbolClassProperty:qt,AST_SymbolConst:Ht,AST_SymbolDeclaration:Kt,AST_SymbolDefClass:jt,AST_SymbolDefun:Wt,AST_SymbolExport:on,AST_SymbolExportForeign:rn,AST_SymbolFunarg:zt,AST_SymbolImport:Qt,AST_SymbolImportForeign:en,AST_SymbolLambda:$t,AST_SymbolLet:Xt,AST_SymbolMethod:Yt,AST_SymbolRef:nn,AST_SymbolVar:Ut,AST_TemplateSegment:Ge,AST_TemplateString:Ue,AST_This:sn,AST_Throw:We,AST_Token:le,AST_Toplevel:xe,AST_True:An,AST_Try:it,AST_Unary:St,AST_UnaryPostfix:At,AST_UnaryPrefix:vt,AST_Undefined:En,AST_Var:st,AST_VarDef:lt,AST_While:Ce,AST_With:Re,AST_Yield:Ze,TreeTransformer:On,TreeWalker:Cn,walk:Tn,walk_abort:bn,walk_body:he,walk_parent:yn,_INLINE:Mn,_NOINLINE:Rn,_PURE:Fn});function xn(e,t){e.DEFMETHOD("transform",(function(e,n){let i=void 0;if(e.push(this),e.before&&(i=e.before(this,t,n)),void 0===i&&(i=this,t(i,e),e.after)){const t=e.after(i,n);void 0!==t&&(i=t);}return e.pop(),i}));}function Nn(e,t){return f(e,(function(e){return e.transform(t,!0)}))}function kn(e){let t=e.parent(-1);for(let n,i=0;n=e.parent(i);i++){if(n instanceof pe&&n.body===t)return !0;if(!(n instanceof ht&&n.expressions[0]===t||"Call"===n.TYPE&&n.expression===t||n instanceof Ke&&n.prefix===t||n instanceof gt&&n.expression===t||n instanceof Dt&&n.expression===t||n instanceof yt&&n.condition===t||n instanceof Tt&&n.left===t||n instanceof At&&n.expression===t))return !1;t=n;}}xn(fe,a),xn(Ae,(function(e,t){e.label=e.label.transform(t),e.body=e.body.transform(t);})),xn(me,(function(e,t){e.body=e.body.transform(t);})),xn(ge,(function(e,t){e.body=Nn(e.body,t);})),xn(be,(function(e,t){e.body=e.body.transform(t),e.condition=e.condition.transform(t);})),xn(Ce,(function(e,t){e.condition=e.condition.transform(t),e.body=e.body.transform(t);})),xn(Oe,(function(e,t){e.init&&(e.init=e.init.transform(t)),e.condition&&(e.condition=e.condition.transform(t)),e.step&&(e.step=e.step.transform(t)),e.body=e.body.transform(t);})),xn(Fe,(function(e,t){e.init=e.init.transform(t),e.object=e.object.transform(t),e.body=e.body.transform(t);})),xn(Re,(function(e,t){e.expression=e.expression.transform(t),e.body=e.body.transform(t);})),xn(Xe,(function(e,t){e.value&&(e.value=e.value.transform(t));})),xn(Ye,(function(e,t){e.label&&(e.label=e.label.transform(t));})),xn(Je,(function(e,t){e.condition=e.condition.transform(t),e.body=e.body.transform(t),e.alternative&&(e.alternative=e.alternative.transform(t));})),xn(Qe,(function(e,t){e.expression=e.expression.transform(t),e.body=Nn(e.body,t);})),xn(nt,(function(e,t){e.expression=e.expression.transform(t),e.body=Nn(e.body,t);})),xn(it,(function(e,t){e.body=Nn(e.body,t),e.bcatch&&(e.bcatch=e.bcatch.transform(t)),e.bfinally&&(e.bfinally=e.bfinally.transform(t));})),xn(ot,(function(e,t){e.argname&&(e.argname=e.argname.transform(t)),e.body=Nn(e.body,t);})),xn(at,(function(e,t){e.definitions=Nn(e.definitions,t);})),xn(lt,(function(e,t){e.name=e.name.transform(t),e.value&&(e.value=e.value.transform(t));})),xn(Be,(function(e,t){e.names=Nn(e.names,t);})),xn(ke,(function(e,t){e.name&&(e.name=e.name.transform(t)),e.argnames=Nn(e.argnames,t),e.body instanceof fe?e.body=e.body.transform(t):e.body=Nn(e.body,t);})),xn(dt,(function(e,t){e.expression=e.expression.transform(t),e.args=Nn(e.args,t);})),xn(ht,(function(e,t){const n=Nn(e.expressions,t);e.expressions=n.length?n:[new fn({value:0})];})),xn(gt,(function(e,t){e.expression=e.expression.transform(t);})),xn(Dt,(function(e,t){e.expression=e.expression.transform(t),e.property=e.property.transform(t);})),xn(Ze,(function(e,t){e.expression&&(e.expression=e.expression.transform(t));})),xn(je,(function(e,t){e.expression=e.expression.transform(t);})),xn(St,(function(e,t){e.expression=e.expression.transform(t);})),xn(Tt,(function(e,t){e.left=e.left.transform(t),e.right=e.right.transform(t);})),xn(yt,(function(e,t){e.condition=e.condition.transform(t),e.consequent=e.consequent.transform(t),e.alternative=e.alternative.transform(t);})),xn(Ot,(function(e,t){e.elements=Nn(e.elements,t);})),xn(Ft,(function(e,t){e.properties=Nn(e.properties,t);})),xn(Mt,(function(e,t){e.key instanceof fe&&(e.key=e.key.transform(t)),e.value&&(e.value=e.value.transform(t));})),xn(kt,(function(e,t){e.name&&(e.name=e.name.transform(t)),e.extends&&(e.extends=e.extends.transform(t)),e.properties=Nn(e.properties,t);})),xn(Ne,(function(e,t){e.expression=e.expression.transform(t);})),xn(ft,(function(e,t){e.foreign_name=e.foreign_name.transform(t),e.name=e.name.transform(t);})),xn(pt,(function(e,t){e.imported_name&&(e.imported_name=e.imported_name.transform(t)),e.imported_names&&Nn(e.imported_names,t),e.module_name=e.module_name.transform(t);})),xn(_t,(function(e,t){e.exported_definition&&(e.exported_definition=e.exported_definition.transform(t)),e.exported_value&&(e.exported_value=e.exported_value.transform(t)),e.exported_names&&Nn(e.exported_names,t),e.module_name&&(e.module_name=e.module_name.transform(t));})),xn(Ue,(function(e,t){e.segments=Nn(e.segments,t);})),xn(Ke,(function(e,t){e.prefix=e.prefix.transform(t),e.template_string=e.template_string.transform(t);}));const In=/^$|[;{][\s\n]*$/,Ln=/[@#]__(PURE|INLINE|NOINLINE)__/g;function Vn(e){return ("comment2"===e.type||"comment1"===e.type)&&/@preserve|@lic|@cc_on|^\**!/i.test(e.value)}function Pn(e){var t=!e;void 0===(e=r(e,{ascii_only:!1,beautify:!1,braces:!1,comments:"some",ecma:5,ie8:!1,indent_level:4,indent_start:0,inline_script:!0,keep_numbers:!1,keep_quoted_props:!1,max_line_len:!1,preamble:null,preserve_annotations:!1,quote_keys:!1,quote_style:0,safari10:!1,semicolons:!0,shebang:!0,shorthand:void 0,source_map:null,webkit:!1,width:80,wrap_iife:!1,wrap_func_args:!0},!0)).shorthand&&(e.shorthand=e.ecma>5);var n=s;if(e.comments){let t=e.comments;if("string"==typeof e.comments&&/^\/.*\/[a-zA-Z]*$/.test(e.comments)){var i=e.comments.lastIndexOf("/");t=new RegExp(e.comments.substr(1,i-1),e.comments.substr(i+1));}n=t instanceof RegExp?function(e){return "comment5"!=e.type&&t.test(e.value)}:"function"==typeof t?function(e){return "comment5"!=e.type&&t(this,e)}:"some"===t?Vn:u;}var o=0,c=0,l=1,f=0,p="";let _=new Set;var d=e.ascii_only?function(t,n){return e.ecma>=2015&&(t=t.replace(/[\ud800-\udbff][\udc00-\udfff]/g,(function(e){return "\\u{"+function(e,t){return z(e.charCodeAt(t))?65536+(e.charCodeAt(t)-55296<<10)+e.charCodeAt(t+1)-56320:e.charCodeAt(t)}(e,0).toString(16)+"}"}))),t.replace(/[\u0000-\u001f\u007f-\uffff]/g,(function(e){var t=e.charCodeAt(0).toString(16);if(t.length<=2&&!n){for(;t.length<2;)t="0"+t;return "\\x"+t}for(;t.length<4;)t="0"+t;return "\\u"+t}))}:function(e){for(var t="",n=0,i=e.length;n<i;n++)z(e.charCodeAt(n))&&!W(e.charCodeAt(n+1))||W(e.charCodeAt(n))&&!z(e.charCodeAt(n-1))?t+="\\u"+e.charCodeAt(n).toString(16):t+=e[n];return t};function m(t,n){var i=function(t,n){var i=0,o=0;function r(){return "'"+t.replace(/\x27/g,"\\'")+"'"}function a(){return '"'+t.replace(/\x22/g,'\\"')+'"'}if(t=t.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,(function(n,r){switch(n){case'"':return ++i,'"';case"'":return ++o,"'";case"\\":return "\\\\";case"\n":return "\\n";case"\r":return "\\r";case"\t":return "\\t";case"\b":return "\\b";case"\f":return "\\f";case"\v":return e.ie8?"\\x0B":"\\v";case"\u2028":return "\\u2028";case"\u2029":return "\\u2029";case"\ufeff":return "\\ufeff";case"\0":return /[0-9]/.test(X(t,r+1))?"\\x00":"\\0"}return n})),t=d(t),"`"===n)return "`"+t.replace(/`/g,"\\`")+"`";switch(e.quote_style){case 1:return r();case 2:return a();case 3:return "'"==n?r():a();default:return i>o?r():a()}}(t,n);return e.inline_script&&(i=(i=(i=i.replace(/<\x2f(script)([>\/\t\n\f\r ])/gi,"<\\/$1$2")).replace(/\x3c!--/g,"\\x3c!--")).replace(/--\x3e/g,"--\\x3e")),i}var h,g,D=!1,S=!1,v=!1,A=0,T=!1,y=!1,b=-1,C="",O=e.source_map&&[],F=O?function(){O.forEach((function(t){try{e.source_map.add(t.token.file,t.line,t.col,t.token.line,t.token.col,t.name||"name"!=t.token.type?t.name:t.token.value);}catch(e){null!=t.token.file&&fe.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]",{file:t.token.file,line:t.token.line,col:t.token.col,cline:t.line,ccol:t.col,name:t.name||""});}})),O=[];}:a,M=e.max_line_len?function(){if(c>e.max_line_len){if(A){var t=p.slice(0,A),n=p.slice(A);if(O){var i=n.length-c;O.forEach((function(e){e.line++,e.col+=i;}));}p=t+"\n"+n,l++,f++,c=n.length;}c>e.max_line_len&&fe.warn("Output exceeds {max_line_len} characters",e);}A&&(A=0,F());}:a,R=E("( [ + * / - , . `");function w(t){var n=X(t=String(t),0);T&&n&&(T=!1,"\n"!==n&&(w("\n"),N())),y&&n&&(y=!1,/[\s;})]/.test(n)||x()),b=-1;var i=C.charAt(C.length-1);v&&(v=!1,(":"!==i||"}"!==n)&&(n&&";}".includes(n)||";"===i)||(e.semicolons||R.has(n)?(p+=";",c++,f++):(M(),c>0&&(p+="\n",f++,l++,c=0),/^\s+$/.test(t)&&(v=!0)),e.beautify||(S=!1))),S&&(($(i)&&($(n)||"\\"==n)||"/"==n&&n==i||("+"==n||"-"==n)&&n==C)&&(p+=" ",c++,f++),S=!1),h&&(O.push({token:h,name:g,line:l,col:c}),h=!1,A||F()),p+=t,D="("==t[t.length-1],f+=t.length;var o=t.split(/\r?\n/),r=o.length-1;l+=r,c+=o[0].length,r>0&&(M(),c=o[r].length),C=t;}var x=e.beautify?function(){w(" ");}:function(){S=!0;},N=e.beautify?function(t){var n;e.beautify&&w((n=t?.5:0," ".repeat(e.indent_start+o-n*e.indent_level)));}:a,k=e.beautify?function(e,t){!0===e&&(e=P());var n=o;o=e;var i=t();return o=n,i}:function(e,t){return t()},I=e.beautify?function(){if(b<0)return w("\n");"\n"!=p[b]&&(p=p.slice(0,b)+"\n"+p.slice(b),f++,l++),b++;}:e.max_line_len?function(){M(),A=p.length;}:a,L=e.beautify?function(){w(";");}:function(){v=!0;};function V(){v=!1,w(";");}function P(){return o+e.indent_level}function B(){return A&&M(),p}function K(){let e=p.length-1;for(;e>=0;){const t=p.charCodeAt(e);if(10===t)return !0;if(32!==t)return !1;e--;}return !0}function U(t){return e.preserve_annotations||(t=t.replace(Ln," ")),/^\s*$/.test(t)?"":t.replace(/(<\s*\/\s*)(script)/i,"<\\/$2")}var G=[];return {get:B,toString:B,indent:N,in_directive:!1,use_asm:null,active_scope:null,indentation:function(){return o},current_width:function(){return c-o},should_break:function(){return e.width&&this.current_width()>=e.width},has_parens:function(){return D},newline:I,print:w,star:function(){w("*");},space:x,comma:function(){w(","),x();},colon:function(){w(":"),x();},last:function(){return C},semicolon:L,force_semicolon:V,to_utf8:d,print_name:function(e){w(function(e){return e=e.toString(),e=d(e,!0)}(e));},print_string:function(e,t,n){var i=m(e,t);!0!==n||i.includes("\\")||(In.test(p)||V(),V()),w(i);},print_template_string_chars:function(e){var t=m(e,"`").replace(/\${/g,"\\${");return w(t.substr(1,t.length-2))},encode_string:m,next_indent:P,with_indent:k,with_block:function(e){var t;return w("{"),I(),k(P(),(function(){t=e();})),N(),w("}"),t},with_parens:function(e){w("(");var t=e();return w(")"),t},with_square:function(e){w("[");var t=e();return w("]"),t},add_mapping:O?function(e,t){h=e,g=t;}:a,option:function(t){return e[t]},printed_comments:_,prepend_comments:t?a:function(t){var i=t.start;if(!i)return;var o=this.printed_comments;const r=t instanceof Xe&&t.value;if(i.comments_before&&o.has(i.comments_before)){if(!r)return;i.comments_before=[];}var a=i.comments_before;if(a||(a=i.comments_before=[]),o.add(a),r){var s=new Cn((function(e){var t=s.parent();if(!(t instanceof Xe||t instanceof Tt&&t.left===e||"Call"==t.TYPE&&t.expression===e||t instanceof yt&&t.condition===e||t instanceof gt&&t.expression===e||t instanceof ht&&t.expressions[0]===e||t instanceof Dt&&t.expression===e||t instanceof At))return !0;if(e.start){var n=e.start.comments_before;n&&!o.has(n)&&(o.add(n),a=a.concat(n));}}));s.push(t),t.value.walk(s);}if(0==f){a.length>0&&e.shebang&&"comment5"===a[0].type&&!o.has(a[0])&&(w("#!"+a.shift().value+"\n"),N());var u=e.preamble;u&&w(u.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g,"\n"));}if(0!=(a=a.filter(n,t).filter(e=>!o.has(e))).length){var c=K();a.forEach((function(e,t){if(o.add(e),c||(e.nlb?(w("\n"),N(),c=!0):t>0&&x()),/comment[134]/.test(e.type))(n=U(e.value))&&(w("//"+n+"\n"),N()),c=!0;else if("comment2"==e.type){var n;(n=U(e.value))&&w("/*"+n+"*/"),c=!1;}})),c||(i.nlb?(w("\n"),N()):x());}},append_comments:t||n===s?a:function(e,t){var i=e.end;if(i){var o=this.printed_comments,r=i[t?"comments_before":"comments_after"];if(r&&!o.has(r)&&(e instanceof pe||r.every(e=>!/comment[134]/.test(e.type)))){o.add(r);var a=p.length;r.filter(n,e).forEach((function(e,n){if(!o.has(e))if(o.add(e),y=!1,T?(w("\n"),N(),T=!1):e.nlb&&(n>0||!K())?(w("\n"),N()):(n>0||!t)&&x(),/comment[134]/.test(e.type)){const t=U(e.value);t&&w("//"+t),T=!0;}else if("comment2"==e.type){const t=U(e.value);t&&w("/*"+t+"*/"),y=!0;}})),p.length>a&&(b=a);}}},line:function(){return l},col:function(){return c},pos:function(){return f},push_node:function(e){G.push(e);},pop_node:function(){return G.pop()},parent:function(e){return G[G.length-2-(e||0)]}}}!function(){function e(e,t){e.DEFMETHOD("_codegen",t);}function t(e,n){Array.isArray(e)?e.forEach((function(e){t(e,n);})):e.DEFMETHOD("needs_parens",n);}function n(e,t,n,i){var o=e.length-1;n.in_directive=i,e.forEach((function(e,i){!0!==n.in_directive||e instanceof de||e instanceof Se||e instanceof me&&e.body instanceof ln||(n.in_directive=!1),e instanceof Se||(n.indent(),e.print(n),i==o&&t||(n.newline(),t&&n.newline())),!0===n.in_directive&&e instanceof me&&e.body instanceof ln&&(n.in_directive=!1);})),n.in_directive=!1;}function i(e,t){t.print("{"),t.with_indent(t.next_indent(),(function(){t.append_comments(e,!0);})),t.print("}");}function o(e,t,o){e.body.length>0?t.with_block((function(){n(e.body,!1,t,o);})):i(e,t);}function r(e,t,n){var i=!1;n&&(i=Tn(e,e=>e instanceof we||(e instanceof Tt&&"in"==e.operator?bn:void 0))),e.print(t,i);}function u(e,t,n){return n.option("quote_keys")?n.print_string(e):""+ +e==e&&e>=0?n.option("keep_numbers")?n.print(e):n.print(p(e)):(O.has(e)?!n.option("ie8"):j(e))?t&&n.option("keep_quoted_props")?n.print_string(e,t):n.print_name(e):n.print_string(e,t)}fe.DEFMETHOD("print",(function(e,t){var n=this,i=n._codegen;function o(){e.prepend_comments(n),n.add_source_map(e),i(n,e),e.append_comments(n);}n instanceof we?e.active_scope=n:!e.use_asm&&n instanceof de&&"use asm"==n.value&&(e.use_asm=e.active_scope),e.push_node(n),t||n.needs_parens(e)?e.with_parens(o):o(),e.pop_node(),n===e.use_asm&&(e.use_asm=null);})),fe.DEFMETHOD("_print",fe.prototype.print),fe.DEFMETHOD("print_to_string",(function(e){var t=Pn(e);return this.print(t),t.get()})),t(fe,s),t(Le,(function(e){if(!e.has_parens()&&kn(e))return !0;var t;if(e.option("webkit")&&((t=e.parent())instanceof Et&&t.expression===this))return !0;if(e.option("wrap_iife")&&((t=e.parent())instanceof dt&&t.expression===this))return !0;if(e.option("wrap_func_args")&&((t=e.parent())instanceof dt&&t.args.includes(this)))return !0;return !1})),t(Ve,(function(e){var t=e.parent();return t instanceof Et&&t.expression===this})),t(Ft,(function(e){return !e.has_parens()&&kn(e)})),t(Vt,kn),t(St,(function(e){var t=e.parent();return t instanceof Et&&t.expression===this||t instanceof dt&&t.expression===this||t instanceof Tt&&"**"===t.operator&&this instanceof vt&&t.left===this&&"++"!==this.operator&&"--"!==this.operator})),t(je,(function(e){var t=e.parent();return t instanceof Et&&t.expression===this||t instanceof dt&&t.expression===this||e.option("safari10")&&t instanceof vt})),t(ht,(function(e){var t=e.parent();return t instanceof dt||t instanceof St||t instanceof Tt||t instanceof lt||t instanceof Et||t instanceof Ot||t instanceof Mt||t instanceof yt||t instanceof Ve||t instanceof Ct||t instanceof Ne||t instanceof Me&&this===t.object||t instanceof Ze||t instanceof _t})),t(Tt,(function(e){var t=e.parent();if(t instanceof dt&&t.expression===this)return !0;if(t instanceof St)return !0;if(t instanceof Et&&t.expression===this)return !0;if(t instanceof Tt){var n=t.operator,i=ae[n],o=this.operator,r=ae[o];if(i>r||i==r&&(this===t.right||"**"==n))return !0}})),t(Ze,(function(e){var t=e.parent();return t instanceof Tt&&"="!==t.operator||(t instanceof dt&&t.expression===this||(t instanceof yt&&t.condition===this||(t instanceof St||(t instanceof Et&&t.expression===this||void 0))))})),t(Et,(function(e){var t=e.parent();if(t instanceof mt&&t.expression===this)return Tn(this,e=>e instanceof we||(e instanceof dt?bn:void 0))})),t(dt,(function(e){var t,n=e.parent();return !!(n instanceof mt&&n.expression===this||n instanceof _t&&n.is_default&&this.expression instanceof Le)||this.expression instanceof Le&&n instanceof Et&&n.expression===this&&(t=e.parent(1))instanceof bt&&t.left===n})),t(mt,(function(e){var t=e.parent();if(0===this.args.length&&(t instanceof Et||t instanceof dt&&t.expression===this))return !0})),t(fn,(function(e){var t=e.parent();if(t instanceof Et&&t.expression===this){var n=this.getValue();if(n<0||/^0/.test(p(n)))return !0}})),t(pn,(function(e){var t=e.parent();if(t instanceof Et&&t.expression===this&&this.getValue().startsWith("-"))return !0})),t([bt,yt],(function(e){var t=e.parent();return t instanceof St||(t instanceof Tt&&!(t instanceof bt)||(t instanceof dt&&t.expression===this||(t instanceof yt&&t.condition===this||(t instanceof Et&&t.expression===this||(this instanceof bt&&this.left instanceof Be&&!1===this.left.is_array||void 0)))))})),e(de,(function(e,t){t.print_string(e.value,e.quote),t.semicolon();})),e(Ne,(function(e,t){t.print("..."),e.expression.print(t);})),e(Be,(function(e,t){t.print(e.is_array?"[":"{");var n=e.names.length;e.names.forEach((function(e,i){i>0&&t.comma(),e.print(t),i==n-1&&e instanceof gn&&t.comma();})),t.print(e.is_array?"]":"}");})),e(_e,(function(e,t){t.print("debugger"),t.semicolon();})),ve.DEFMETHOD("_do_print_body",(function(e){f(this.body,e);})),e(pe,(function(e,t){e.body.print(t),t.semicolon();})),e(xe,(function(e,t){n(e.body,!0,t,!0),t.print("");})),e(Ae,(function(e,t){e.label.print(t),t.colon(),e.body.print(t);})),e(me,(function(e,t){e.body.print(t),t.semicolon();})),e(De,(function(e,t){o(e,t);})),e(Se,(function(e,t){t.semicolon();})),e(be,(function(e,t){t.print("do"),t.space(),_(e.body,t),t.space(),t.print("while"),t.space(),t.with_parens((function(){e.condition.print(t);})),t.semicolon();})),e(Ce,(function(e,t){t.print("while"),t.space(),t.with_parens((function(){e.condition.print(t);})),t.space(),e._do_print_body(t);})),e(Oe,(function(e,t){t.print("for"),t.space(),t.with_parens((function(){e.init?(e.init instanceof at?e.init.print(t):r(e.init,t,!0),t.print(";"),t.space()):t.print(";"),e.condition?(e.condition.print(t),t.print(";"),t.space()):t.print(";"),e.step&&e.step.print(t);})),t.space(),e._do_print_body(t);})),e(Fe,(function(e,t){t.print("for"),e.await&&(t.space(),t.print("await")),t.space(),t.with_parens((function(){e.init.print(t),t.space(),t.print(e instanceof Me?"of":"in"),t.space(),e.object.print(t);})),t.space(),e._do_print_body(t);})),e(Re,(function(e,t){t.print("with"),t.space(),t.with_parens((function(){e.expression.print(t);})),t.space(),e._do_print_body(t);})),ke.DEFMETHOD("_do_print",(function(e,t){var n=this;t||(n.async&&(e.print("async"),e.space()),e.print("function"),n.is_generator&&e.star(),n.name&&e.space()),n.name instanceof Pt?n.name.print(e):t&&n.name instanceof fe&&e.with_square((function(){n.name.print(e);})),e.with_parens((function(){n.argnames.forEach((function(t,n){n&&e.comma(),t.print(e);}));})),e.space(),o(n,e,!0);})),e(ke,(function(e,t){e._do_print(t);})),e(Ke,(function(e,t){var n=e.prefix,i=n instanceof ke||n instanceof Tt||n instanceof yt||n instanceof ht||n instanceof St||n instanceof gt&&n.expression instanceof Ft;i&&t.print("("),e.prefix.print(t),i&&t.print(")"),e.template_string.print(t);})),e(Ue,(function(e,t){var n=t.parent()instanceof Ke;t.print("`");for(var i=0;i<e.segments.length;i++)e.segments[i]instanceof Ge?n?t.print(e.segments[i].raw):t.print_template_string_chars(e.segments[i].value):(t.print("${"),e.segments[i].print(t),t.print("}"));t.print("`");})),Ve.DEFMETHOD("_do_print",(function(e){var t=this,n=e.parent(),i=n instanceof Tt&&!(n instanceof bt)||n instanceof St||n instanceof dt&&t===n.expression;i&&e.print("("),t.async&&(e.print("async"),e.space()),1===t.argnames.length&&t.argnames[0]instanceof Pt?t.argnames[0].print(e):e.with_parens((function(){t.argnames.forEach((function(t,n){n&&e.comma(),t.print(e);}));})),e.space(),e.print("=>"),e.space();const r=t.body[0];if(1===t.body.length&&r instanceof ze){const t=r.value;t?!function e(t){return t instanceof Ft||(t instanceof ht?e(t.expressions[0]):"Call"===t.TYPE?e(t.expression):t instanceof Ke?e(t.prefix):t instanceof gt||t instanceof Dt?e(t.expression):t instanceof yt?e(t.condition):t instanceof Tt?e(t.left):t instanceof At&&e(t.expression))}(t)?t.print(e):(e.print("("),t.print(e),e.print(")")):e.print("{}");}else o(t,e);i&&e.print(")");})),Xe.DEFMETHOD("_do_print",(function(e,t){if(e.print(t),this.value){e.space();const t=this.value.start.comments_before;t&&t.length&&!e.printed_comments.has(t)?(e.print("("),this.value.print(e),e.print(")")):this.value.print(e);}e.semicolon();})),e(ze,(function(e,t){e._do_print(t,"return");})),e(We,(function(e,t){e._do_print(t,"throw");})),e(Ze,(function(e,t){var n=e.is_star?"*":"";t.print("yield"+n),e.expression&&(t.space(),e.expression.print(t));})),e(je,(function(e,t){t.print("await"),t.space();var n=e.expression,i=!(n instanceof dt||n instanceof nn||n instanceof Et||n instanceof St||n instanceof cn);i&&t.print("("),e.expression.print(t),i&&t.print(")");})),Ye.DEFMETHOD("_do_print",(function(e,t){e.print(t),this.label&&(e.space(),this.label.print(e)),e.semicolon();})),e(qe,(function(e,t){e._do_print(t,"break");})),e($e,(function(e,t){e._do_print(t,"continue");})),e(Je,(function(e,t){t.print("if"),t.space(),t.with_parens((function(){e.condition.print(t);})),t.space(),e.alternative?(!function(e,t){var n=e.body;if(t.option("braces")||t.option("ie8")&&n instanceof be)return _(n,t);if(!n)return t.force_semicolon();for(;;)if(n instanceof Je){if(!n.alternative)return void _(e.body,t);n=n.alternative;}else{if(!(n instanceof ve))break;n=n.body;}f(e.body,t);}(e,t),t.space(),t.print("else"),t.space(),e.alternative instanceof Je?e.alternative.print(t):f(e.alternative,t)):e._do_print_body(t);})),e(Qe,(function(e,t){t.print("switch"),t.space(),t.with_parens((function(){e.expression.print(t);})),t.space();var n=e.body.length-1;n<0?i(e,t):t.with_block((function(){e.body.forEach((function(e,i){t.indent(!0),e.print(t),i<n&&e.body.length>0&&t.newline();}));}));})),et.DEFMETHOD("_do_print_body",(function(e){e.newline(),this.body.forEach((function(t){e.indent(),t.print(e),e.newline();}));})),e(tt,(function(e,t){t.print("default:"),e._do_print_body(t);})),e(nt,(function(e,t){t.print("case"),t.space(),e.expression.print(t),t.print(":"),e._do_print_body(t);})),e(it,(function(e,t){t.print("try"),t.space(),o(e,t),e.bcatch&&(t.space(),e.bcatch.print(t)),e.bfinally&&(t.space(),e.bfinally.print(t));})),e(ot,(function(e,t){t.print("catch"),e.argname&&(t.space(),t.with_parens((function(){e.argname.print(t);}))),t.space(),o(e,t);})),e(rt,(function(e,t){t.print("finally"),t.space(),o(e,t);})),at.DEFMETHOD("_do_print",(function(e,t){e.print(t),e.space(),this.definitions.forEach((function(t,n){n&&e.comma(),t.print(e);}));var n=e.parent();(!(n instanceof Oe||n instanceof Fe)||n&&n.init!==this)&&e.semicolon();})),e(ut,(function(e,t){e._do_print(t,"let");})),e(st,(function(e,t){e._do_print(t,"var");})),e(ct,(function(e,t){e._do_print(t,"const");})),e(pt,(function(e,t){t.print("import"),t.space(),e.imported_name&&e.imported_name.print(t),e.imported_name&&e.imported_names&&(t.print(","),t.space()),e.imported_names&&(1===e.imported_names.length&&"*"===e.imported_names[0].foreign_name.name?e.imported_names[0].print(t):(t.print("{"),e.imported_names.forEach((function(n,i){t.space(),n.print(t),i<e.imported_names.length-1&&t.print(",");})),t.space(),t.print("}"))),(e.imported_name||e.imported_names)&&(t.space(),t.print("from"),t.space()),e.module_name.print(t),t.semicolon();})),e(ft,(function(e,t){var n=t.parent()instanceof pt,i=e.name.definition();(i&&i.mangled_name||e.name.name)!==e.foreign_name.name?(n?t.print(e.foreign_name.name):e.name.print(t),t.space(),t.print("as"),t.space(),n?e.name.print(t):t.print(e.foreign_name.name)):e.name.print(t);})),e(_t,(function(e,t){if(t.print("export"),t.space(),e.is_default&&(t.print("default"),t.space()),e.exported_names)1===e.exported_names.length&&"*"===e.exported_names[0].name.name?e.exported_names[0].print(t):(t.print("{"),e.exported_names.forEach((function(n,i){t.space(),n.print(t),i<e.exported_names.length-1&&t.print(",");})),t.space(),t.print("}"));else if(e.exported_value)e.exported_value.print(t);else if(e.exported_definition&&(e.exported_definition.print(t),e.exported_definition instanceof at))return;e.module_name&&(t.space(),t.print("from"),t.space(),e.module_name.print(t)),(e.exported_value&&!(e.exported_value instanceof Pe||e.exported_value instanceof Le||e.exported_value instanceof kt)||e.module_name||e.exported_names)&&t.semicolon();})),e(lt,(function(e,t){if(e.name.print(t),e.value){t.space(),t.print("="),t.space();var n=t.parent(1),i=n instanceof Oe||n instanceof Fe;r(e.value,t,i);}})),e(dt,(function(e,t){e.expression.print(t),e instanceof mt&&0===e.args.length||((e.expression instanceof dt||e.expression instanceof ke)&&t.add_mapping(e.start),t.with_parens((function(){e.args.forEach((function(e,n){n&&t.comma(),e.print(t);}));})));})),e(mt,(function(e,t){t.print("new"),t.space(),dt.prototype._codegen(e,t);})),ht.DEFMETHOD("_do_print",(function(e){this.expressions.forEach((function(t,n){n>0&&(e.comma(),e.should_break()&&(e.newline(),e.indent())),t.print(e);}));})),e(ht,(function(e,t){e._do_print(t);})),e(gt,(function(e,t){var n=e.expression;n.print(t);var i=e.property;t.option("ie8")&&O.has(i)?(t.print("["),t.add_mapping(e.end),t.print_string(i),t.print("]")):(n instanceof fn&&n.getValue()>=0&&(/[xa-f.)]/i.test(t.last())||t.print(".")),t.print("."),t.add_mapping(e.end),t.print_name(i));})),e(Dt,(function(e,t){e.expression.print(t),t.print("["),e.property.print(t),t.print("]");})),e(vt,(function(e,t){var n=e.operator;t.print(n),(/^[a-z]/i.test(n)||/[+-]$/.test(n)&&e.expression instanceof vt&&/^[+-]/.test(e.expression.operator))&&t.space(),e.expression.print(t);})),e(At,(function(e,t){e.expression.print(t),t.print(e.operator);})),e(Tt,(function(e,t){var n=e.operator;e.left.print(t),">"==n[0]&&e.left instanceof At&&"--"==e.left.operator?t.print(" "):t.space(),t.print(n),("<"==n||"<<"==n)&&e.right instanceof vt&&"!"==e.right.operator&&e.right.expression instanceof vt&&"--"==e.right.expression.operator?t.print(" "):t.space(),e.right.print(t);})),e(yt,(function(e,t){e.condition.print(t),t.space(),t.print("?"),t.space(),e.consequent.print(t),t.space(),t.colon(),e.alternative.print(t);})),e(Ot,(function(e,t){t.with_square((function(){var n=e.elements,i=n.length;i>0&&t.space(),n.forEach((function(e,n){n&&t.comma(),e.print(t),n===i-1&&e instanceof gn&&t.comma();})),i>0&&t.space();}));})),e(Ft,(function(e,t){e.properties.length>0?t.with_block((function(){e.properties.forEach((function(e,n){n&&(t.print(","),t.newline()),t.indent(),e.print(t);})),t.newline();})):i(e,t);})),e(kt,(function(e,t){if(t.print("class"),t.space(),e.name&&(e.name.print(t),t.space()),e.extends){var n=!(e.extends instanceof nn||e.extends instanceof Et||e.extends instanceof Vt||e.extends instanceof Le);t.print("extends"),n?t.print("("):t.space(),e.extends.print(t),n?t.print(")"):t.space();}e.properties.length>0?t.with_block((function(){e.properties.forEach((function(e,n){n&&t.newline(),t.indent(),e.print(t);})),t.newline();})):t.print("{}");})),e(Bt,(function(e,t){t.print("new.target");})),e(Rt,(function(e,t){function n(e){var t=e.definition();return t?t.mangled_name||t.name:e.name}var i=t.option("shorthand");i&&e.value instanceof Pt&&j(e.key)&&n(e.value)===e.key&&!O.has(e.key)?u(e.key,e.quote,t):i&&e.value instanceof Ct&&e.value.left instanceof Pt&&j(e.key)&&n(e.value.left)===e.key?(u(e.key,e.quote,t),t.space(),t.print("="),t.space(),e.value.right.print(t)):(e.key instanceof fe?t.with_square((function(){e.key.print(t);})):u(e.key,e.quote,t),t.colon(),e.value.print(t));})),e(It,(e,t)=>{e.static&&(t.print("static"),t.space()),e.key instanceof qt?u(e.key.name,e.quote,t):(t.print("["),e.key.print(t),t.print("]")),e.value&&(t.print("="),e.value.print(t)),t.semicolon();}),Mt.DEFMETHOD("_print_getter_setter",(function(e,t){var n=this;n.static&&(t.print("static"),t.space()),e&&(t.print(e),t.space()),n.key instanceof Yt?u(n.key.name,n.quote,t):t.with_square((function(){n.key.print(t);})),n.value._do_print(t,!0);})),e(wt,(function(e,t){e._print_getter_setter("set",t);})),e(xt,(function(e,t){e._print_getter_setter("get",t);})),e(Nt,(function(e,t){var n;e.is_generator&&e.async?n="async*":e.is_generator?n="*":e.async&&(n="async"),e._print_getter_setter(n,t);})),Pt.DEFMETHOD("_do_print",(function(e){var t=this.definition();e.print_name(t?t.mangled_name||t.name:this.name);})),e(Pt,(function(e,t){e._do_print(t);})),e(gn,a),e(sn,(function(e,t){t.print("this");})),e(un,(function(e,t){t.print("super");})),e(cn,(function(e,t){t.print(e.getValue());})),e(ln,(function(e,t){t.print_string(e.getValue(),e.quote,t.in_directive);})),e(fn,(function(e,t){(t.option("keep_numbers")||t.use_asm)&&e.start&&null!=e.start.raw?t.print(e.start.raw):t.print(p(e.getValue()));})),e(pn,(function(e,t){t.print(e.getValue()+"n");}));const c=/(<\s*\/\s*script)/i,l=(e,t)=>t.replace("/","\\/");function f(e,t){t.option("braces")?_(e,t):!e||e instanceof Se?t.force_semicolon():e.print(t);}function p(e){var t,n,i,o=e.toString(10).replace(/^0\./,".").replace("e+","e"),r=[o];return Math.floor(e)===e&&(e<0?r.push("-0x"+(-e).toString(16).toLowerCase()):r.push("0x"+e.toString(16).toLowerCase())),(t=/^\.0+/.exec(o))?(n=t[0].length,i=o.slice(n),r.push(i+"e-"+(i.length+n-1))):(t=/0+$/.exec(o))?(n=t[0].length,r.push(o.slice(0,-n)+"e"+n)):(t=/^(\d)\.(\d+)e(-?\d+)$/.exec(o))&&r.push(t[1]+t[2]+"e"+(t[3]-t[2].length)),function(e){for(var t=e[0],n=t.length,i=1;i<e.length;++i)e[i].length<n&&(n=(t=e[i]).length);return t}(r)}function _(e,t){!e||e instanceof Se?t.print("{}"):e instanceof De?e.print(t):t.with_block((function(){t.indent(),e.print(t),t.newline();}));}function d(e,t){e.forEach((function(e){e.DEFMETHOD("add_source_map",t);}));}e(_n,(function(e,t){let{source:n,flags:i}=e.getValue();n=A(n),i=i?function(e){const t=new Set(e.split(""));let n="";for(const e of "gimuy")t.has(e)&&(n+=e,t.delete(e));return t.size&&t.forEach(e=>{n+=e;}),n}(i):"",n=n.replace(c,l),t.print(t.to_utf8(`/${n}/${i}`));const o=t.parent();o instanceof Tt&&/^\w/.test(o.operator)&&o.left===e&&t.print(" ");})),d([fe,Ae,xe],a),d([Ot,De,ot,kt,cn,_e,at,de,rt,He,ke,mt,Ft,ve,Pt,Qe,et,Ue,Ge,it],(function(e){e.add_mapping(this.start);})),d([xt,wt],(function(e){e.add_mapping(this.start,this.key.name);})),d([Mt],(function(e){e.add_mapping(this.start,this.key);}));}();const Bn=(e,t)=>e.TYPE===t.TYPE&&e.shallow_cmp(t),Kn=e=>{const t=Object.keys(e).map(t=>{if("eq"===e[t])return `this.${t} === other.${t}`;if("exist"===e[t])return `(this.${t} == null ? other.${t} == null : this.${t} === other.${t})`;throw new Error(`mkshallow: Unexpected instruction: ${e[t]}`)}).join(" && ");return new Function("other","return "+t)},Un=()=>!0;fe.prototype.shallow_cmp=function(){throw new Error("did not find a shallow_cmp function for "+this.constructor.name)},_e.prototype.shallow_cmp=Un,de.prototype.shallow_cmp=Kn({value:"eq"}),me.prototype.shallow_cmp=Un,ge.prototype.shallow_cmp=Un,Se.prototype.shallow_cmp=Un,Ae.prototype.shallow_cmp=Kn({"label.name":"eq"}),be.prototype.shallow_cmp=Un,Ce.prototype.shallow_cmp=Un,Oe.prototype.shallow_cmp=Kn({init:"exist",condition:"exist",step:"exist"}),Fe.prototype.shallow_cmp=Un,Me.prototype.shallow_cmp=Un,Re.prototype.shallow_cmp=Un,xe.prototype.shallow_cmp=Un,Ne.prototype.shallow_cmp=Un,ke.prototype.shallow_cmp=Kn({is_generator:"eq",async:"eq"}),Be.prototype.shallow_cmp=Kn({is_array:"eq"}),Ke.prototype.shallow_cmp=Un,Ue.prototype.shallow_cmp=Un,Ge.prototype.shallow_cmp=Kn({value:"eq"}),He.prototype.shallow_cmp=Un,Ye.prototype.shallow_cmp=Un,je.prototype.shallow_cmp=Un,Ze.prototype.shallow_cmp=Kn({is_star:"eq"}),Je.prototype.shallow_cmp=Kn({alternative:"exist"}),Qe.prototype.shallow_cmp=Un,et.prototype.shallow_cmp=Un,it.prototype.shallow_cmp=Kn({bcatch:"exist",bfinally:"exist"}),ot.prototype.shallow_cmp=Kn({argname:"exist"}),rt.prototype.shallow_cmp=Un,at.prototype.shallow_cmp=Un,lt.prototype.shallow_cmp=Kn({value:"exist"}),ft.prototype.shallow_cmp=Un,pt.prototype.shallow_cmp=Kn({imported_name:"exist",imported_names:"exist"}),_t.prototype.shallow_cmp=Kn({exported_definition:"exist",exported_value:"exist",exported_names:"exist",module_name:"eq",is_default:"eq"}),dt.prototype.shallow_cmp=Un,ht.prototype.shallow_cmp=Un,Et.prototype.shallow_cmp=Un,gt.prototype.shallow_cmp=Kn({property:"eq"}),St.prototype.shallow_cmp=Kn({operator:"eq"}),Tt.prototype.shallow_cmp=Kn({operator:"eq"}),yt.prototype.shallow_cmp=Un,Ot.prototype.shallow_cmp=Un,Ft.prototype.shallow_cmp=Un,Mt.prototype.shallow_cmp=Un,Rt.prototype.shallow_cmp=Kn({key:"eq"}),wt.prototype.shallow_cmp=Kn({static:"eq"}),xt.prototype.shallow_cmp=Kn({static:"eq"}),Nt.prototype.shallow_cmp=Kn({static:"eq",is_generator:"eq",async:"eq"}),kt.prototype.shallow_cmp=Kn({name:"exist",extends:"exist"}),It.prototype.shallow_cmp=Kn({static:"eq"}),Pt.prototype.shallow_cmp=Kn({name:"eq"}),Bt.prototype.shallow_cmp=Un,sn.prototype.shallow_cmp=Un,un.prototype.shallow_cmp=Un,ln.prototype.shallow_cmp=Kn({value:"eq"}),fn.prototype.shallow_cmp=Kn({value:"eq"}),pn.prototype.shallow_cmp=Kn({value:"eq"}),_n.prototype.shallow_cmp=function(e){return this.value.flags===e.value.flags&&this.value.source===e.value.source},dn.prototype.shallow_cmp=Un;let Gn=null,Hn=null;class Xn{constructor(e,t,n){this.name=t.name,this.orig=[t],this.init=n,this.eliminated=0,this.assignments=0,this.scope=e,this.replaced=0,this.global=!1,this.export=0,this.mangled_name=null,this.undeclared=!1,this.id=Xn.next_id++,this.chained=!1,this.direct_access=!1,this.escaped=0,this.recursive_refs=0,this.references=[],this.should_replace=void 0,this.single_use=!1,this.fixed=!1,Object.seal(this);}fixed_value(){return !this.fixed||this.fixed instanceof fe?this.fixed:this.fixed()}unmangleable(e){return e||(e={}),!!(Gn&&Gn.has(this.id)&&S(e.keep_fnames,this.orig[0].name))||(this.global&&!e.toplevel||1&this.export||this.undeclared||!e.eval&&this.scope.pinned()||(this.orig[0]instanceof $t||this.orig[0]instanceof Wt)&&S(e.keep_fnames,this.orig[0].name)||this.orig[0]instanceof Yt||(this.orig[0]instanceof Zt||this.orig[0]instanceof jt)&&S(e.keep_classnames,this.orig[0].name))}mangle(e){const t=e.cache&&e.cache.props;if(this.global&&t&&t.has(this.name))this.mangled_name=t.get(this.name);else if(!this.mangled_name&&!this.unmangleable(e)){var n=this.scope,i=this.orig[0];e.ie8&&i instanceof $t&&(n=n.parent_scope);const o=zn(this);this.mangled_name=o?o.mangled_name||o.name:n.next_mangled(e,this),this.global&&t&&t.set(this.name,this.mangled_name);}}}function zn(e){if(e.orig[0]instanceof Jt&&e.scope.is_block_scope())return e.scope.get_defun_scope().variables.get(e.name)}function Wn(e,t){var n=e.enclosed;e:for(;;){var i=Yn(++e.cname);if(!O.has(i)&&!(t.reserved.has(i)||Hn&&Hn.has(i))){for(let e=n.length;--e>=0;){const o=n[e];if(i==(o.mangled_name||o.unmangleable(t)&&o.name))continue e}return i}}}Xn.next_id=1,xe.DEFMETHOD("figure_out_scope",(function(e){e=r(e,{cache:null,ie8:!1,safari10:!1});var t=this.parent_scope=null,n=new Map,i=null,o=null,a=[],s=new Cn((r,c)=>{if(r.is_block_scope()){const n=t;r.block_scope=t=new we(r),t._block_scope=!0;const i=r instanceof ot?n.parent_scope:n;if(t.init_scope_vars(i),t.uses_with=n.uses_with,t.uses_eval=n.uses_eval,e.safari10&&(r instanceof Oe||r instanceof Fe)&&a.push(t),r instanceof Qe){const e=t;t=n,r.expression.walk(s),t=e;for(let e=0;e<r.body.length;e++)r.body[e].walk(s);}else c();return t=n,!0}if(r instanceof Be){const e=o;return o=r,c(),o=e,!0}if(r instanceof we){r.init_scope_vars(t);var l=t,f=i,p=n;return i=t=r,n=new Map,c(),t=l,i=f,n=p,!0}if(r instanceof Ae){var _=r.label;if(n.has(_.name))throw new Error(d("Label {name} defined twice",_));return n.set(_.name,_),c(),n.delete(_.name),!0}if(r instanceof Re)for(var m=t;m;m=m.parent_scope)m.uses_with=!0;else{if(r instanceof Pt&&(r.scope=t),r instanceof tn&&(r.thedef=r,r.references=[]),r instanceof $t)i.def_function(r,"arguments"==r.name?void 0:i);else if(r instanceof Wt)u((r.scope=i.parent_scope.get_defun_scope()).def_function(r,i),1);else if(r instanceof Zt)u(i.def_variable(r,i),1);else if(r instanceof Qt)t.def_variable(r);else if(r instanceof jt)u((r.scope=i.parent_scope).def_function(r,i),1);else if(r instanceof Ut||r instanceof Xt||r instanceof Ht||r instanceof Jt){if((h=r instanceof Gt?t.def_variable(r,null):i.def_variable(r,"SymbolVar"==r.TYPE?null:void 0)).orig.every(e=>e===r||(r instanceof Gt?e instanceof $t:!(e instanceof Xt||e instanceof Ht)))||Q(`"${r.name}" is redeclared`,r.start.file,r.start.line,r.start.col,r.start.pos),r instanceof zt||u(h,2),i!==t){r.mark_enclosed();var h=t.find_variable(r);r.thedef!==h&&(r.thedef=h,r.reference());}}else if(r instanceof an){var E=n.get(r.name);if(!E)throw new Error(d("Undefined label {name} [{line},{col}]",{name:r.name,line:r.start.line,col:r.start.col}));r.thedef=E;}t instanceof xe||!(r instanceof _t||r instanceof pt)||Q(`"${r.TYPE}" statement may only appear at the top level`,r.start.file,r.start.line,r.start.col,r.start.pos);}});function u(e,t){if(o){var n=0;do{t++;}while(s.parent(n++)!==o)}var i=s.parent(t);if(e.export=i instanceof _t?1:0){var r=i.exported_definition;(r instanceof Pe||r instanceof Lt)&&i.is_default&&(e.export=2);}}this.walk(s),this.globals=new Map;s=new Cn(e=>{if(e instanceof Ye&&e.label)return e.label.thedef.references.push(e),!0;if(e instanceof nn){var t,n=e.name;if("eval"==n&&s.parent()instanceof dt)for(var i=e.scope;i&&!i.uses_eval;i=i.parent_scope)i.uses_eval=!0;return s.parent()instanceof ft&&s.parent(1).module_name||!(t=e.scope.find_variable(n))?(t=this.def_global(e),e instanceof on&&(t.export=1)):t.scope instanceof ke&&"arguments"==n&&(t.scope.uses_arguments=!0),e.thedef=t,e.reference(),!e.scope.is_block_scope()||t.orig[0]instanceof Gt||(e.scope=e.scope.get_defun_scope()),!0}var o;if(e instanceof Jt&&(o=zn(e.definition())))for(i=e.scope;i&&(_(i.enclosed,o),i!==o.scope);)i=i.parent_scope;});if(this.walk(s),(e.ie8||e.safari10)&&Tn(this,e=>{if(e instanceof Jt){var t=e.name,n=e.thedef.references,i=e.scope.get_defun_scope(),o=i.find_variable(t)||this.globals.get(t)||i.def_variable(e);return n.forEach((function(e){e.thedef=o,e.reference();})),e.thedef=o,e.reference(),!0}}),e.safari10)for(const e of a)e.parent_scope.variables.forEach((function(t){_(e.enclosed,t);}));})),xe.DEFMETHOD("def_global",(function(e){var t=this.globals,n=e.name;if(t.has(n))return t.get(n);var i=new Xn(this,e);return i.undeclared=!0,i.global=!0,t.set(n,i),i})),we.DEFMETHOD("init_scope_vars",(function(e){this.variables=new Map,this.functions=new Map,this.uses_with=!1,this.uses_eval=!1,this.parent_scope=e,this.enclosed=[],this.cname=-1,this._var_name_cache=null;})),we.DEFMETHOD("var_names",(function e(){var t=this._var_name_cache;return t||(this._var_name_cache=t=new Set(this.parent_scope?e.call(this.parent_scope):null),this._added_var_names&&this._added_var_names.forEach(e=>{t.add(e);}),this.enclosed.forEach((function(e){t.add(e.name);})),this.variables.forEach((function(e,n){t.add(n);}))),t})),we.DEFMETHOD("add_var_name",(function(e){this._added_var_names||(this._added_var_names=new Set),this._added_var_names.add(e),this._var_name_cache||this.var_names(),this._var_name_cache.add(e);})),we.DEFMETHOD("add_child_scope",(function(e){if(e.parent_scope===this)return;e.parent_scope=this,e._var_name_cache=null,e._added_var_names&&e._added_var_names.forEach(t=>e.add_var_name(t));const t=new Set(e.enclosed),n=(()=>{const e=[];let t=this;do{e.push(t);}while(t=t.parent_scope);return e.reverse(),e})(),i=[];for(const e of n){i.forEach(t=>_(e.enclosed,t));for(const n of e.variables.values())t.has(n)&&(_(i,n),_(e.enclosed,n));}})),fe.DEFMETHOD("is_block_scope",s),kt.DEFMETHOD("is_block_scope",s),ke.DEFMETHOD("is_block_scope",s),xe.DEFMETHOD("is_block_scope",s),et.DEFMETHOD("is_block_scope",s),ge.DEFMETHOD("is_block_scope",u),we.DEFMETHOD("is_block_scope",(function(){return this._block_scope||!1})),Te.DEFMETHOD("is_block_scope",u),ke.DEFMETHOD("init_scope_vars",(function(){we.prototype.init_scope_vars.apply(this,arguments),this.uses_arguments=!1,this.def_variable(new zt({name:"arguments",start:this.start,end:this.end}));})),Ve.DEFMETHOD("init_scope_vars",(function(){we.prototype.init_scope_vars.apply(this,arguments),this.uses_arguments=!1;})),Pt.DEFMETHOD("mark_enclosed",(function(){for(var e=this.definition(),t=this.scope;t&&(_(t.enclosed,e),t!==e.scope);)t=t.parent_scope;})),Pt.DEFMETHOD("reference",(function(){this.definition().references.push(this),this.mark_enclosed();})),we.DEFMETHOD("find_variable",(function(e){return e instanceof Pt&&(e=e.name),this.variables.get(e)||this.parent_scope&&this.parent_scope.find_variable(e)})),we.DEFMETHOD("def_function",(function(e,t){var n=this.def_variable(e,t);return (!n.init||n.init instanceof Pe)&&(n.init=t),this.functions.set(e.name,n),n})),we.DEFMETHOD("def_variable",(function(e,t){var n=this.variables.get(e.name);return n?(n.orig.push(e),n.init&&(n.scope!==e.scope||n.init instanceof Le)&&(n.init=t)):(n=new Xn(this,e,t),this.variables.set(e.name,n),n.global=!this.parent_scope),e.thedef=n})),we.DEFMETHOD("next_mangled",(function(e){return Wn(this,e)})),xe.DEFMETHOD("next_mangled",(function(e){let t;const n=this.mangled_names;do{t=Wn(this,e);}while(n.has(t));return t})),Le.DEFMETHOD("next_mangled",(function(e,t){for(var n=t.orig[0]instanceof zt&&this.name&&this.name.definition(),i=n?n.mangled_name||n.name:null;;){var o=Wn(this,e);if(!i||i!=o)return o}})),Pt.DEFMETHOD("unmangleable",(function(e){var t=this.definition();return !t||t.unmangleable(e)})),tn.DEFMETHOD("unmangleable",s),Pt.DEFMETHOD("unreferenced",(function(){return !this.definition().references.length&&!this.scope.pinned()})),Pt.DEFMETHOD("definition",(function(){return this.thedef})),Pt.DEFMETHOD("global",(function(){return this.thedef.global})),xe.DEFMETHOD("_default_mangler_options",(function(e){return (e=r(e,{eval:!1,ie8:!1,keep_classnames:!1,keep_fnames:!1,module:!1,reserved:[],toplevel:!1})).module&&(e.toplevel=!0),Array.isArray(e.reserved)||e.reserved instanceof Set||(e.reserved=[]),e.reserved=new Set(e.reserved),e.reserved.add("arguments"),e})),xe.DEFMETHOD("mangle_names",(function(e){e=this._default_mangler_options(e);var t=-1,n=[];e.keep_fnames&&(Gn=new Set);const i=this.mangled_names=new Set;e.cache&&(this.globals.forEach(r),e.cache.props&&e.cache.props.forEach((function(e){i.add(e);})));var o=new Cn((function(i,o){if(i instanceof Ae){var a=t;return o(),t=a,!0}if(i instanceof we)i.variables.forEach(r);else if(i.is_block_scope())i.block_scope.variables.forEach(r);else if(Gn&&i instanceof lt&&i.value instanceof ke&&!i.value.name&&S(e.keep_fnames,i.name.name))Gn.add(i.name.definition().id);else{if(i instanceof tn){let e;do{e=Yn(++t);}while(O.has(e));return i.mangled_name=e,!0}!e.ie8&&!e.safari10&&i instanceof Jt&&n.push(i.definition());}}));function r(t){!(e.reserved.has(t.name)||1&t.export)&&n.push(t);}this.walk(o),(e.keep_fnames||e.keep_classnames)&&(Hn=new Set,n.forEach(t=>{t.name.length<6&&t.unmangleable(e)&&Hn.add(t.name);})),n.forEach(t=>{t.mangle(e);}),Gn=null,Hn=null;})),xe.DEFMETHOD("find_colliding_names",(function(e){const t=e.cache&&e.cache.props,n=new Set;return e.reserved.forEach(i),this.globals.forEach(o),this.walk(new Cn((function(e){e instanceof we&&e.variables.forEach(o),e instanceof Jt&&o(e.definition());}))),n;function i(e){n.add(e);}function o(n){var o=n.name;if(n.global&&t&&t.has(o))o=t.get(o);else if(!n.unmangleable(e))return;i(o);}})),xe.DEFMETHOD("expand_names",(function(e){Yn.reset(),Yn.sort(),e=this._default_mangler_options(e);var t=this.find_colliding_names(e),n=0;function i(i){if(i.global&&e.cache)return;if(i.unmangleable(e))return;if(e.reserved.has(i.name))return;const o=zn(i),r=i.name=o?o.name:function(){var e;do{e=Yn(n++);}while(t.has(e)||O.has(e));return e}();i.orig.forEach((function(e){e.name=r;})),i.references.forEach((function(e){e.name=r;}));}this.globals.forEach(i),this.walk(new Cn((function(e){e instanceof we&&e.variables.forEach(i),e instanceof Jt&&i(e.definition());})));})),fe.DEFMETHOD("tail_node",c),ht.DEFMETHOD("tail_node",(function(){return this.expressions[this.expressions.length-1]})),xe.DEFMETHOD("compute_char_frequency",(function(e){e=this._default_mangler_options(e);try{fe.prototype.print=function(t,n){this._print(t,n),this instanceof Pt&&!this.unmangleable(e)?Yn.consider(this.name,-1):e.properties&&(this instanceof gt?Yn.consider(this.property,-1):this instanceof Dt&&function e(t){t instanceof ln?Yn.consider(t.value,-1):t instanceof yt?(e(t.consequent),e(t.alternative)):t instanceof ht&&e(t.tail_node());}(this.property));},Yn.consider(this.print_to_string(),1);}finally{fe.prototype.print=fe.prototype._print;}Yn.sort();}));const Yn=(()=>{const e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_".split(""),t="0123456789".split("");let n,i;function o(){i=new Map,e.forEach((function(e){i.set(e,0);})),t.forEach((function(e){i.set(e,0);}));}function r(e,t){return i.get(t)-i.get(e)}function a(e){var t="",i=54;e++;do{e--,t+=n[e%i],e=Math.floor(e/i),i=64;}while(e>0);return t}return a.consider=function(e,t){for(var n=e.length;--n>=0;)i.set(e[n],i.get(e[n])+t);},a.sort=function(){n=h(e,r).concat(h(t,r));},a.reset=o,o(),a})();function qn(){const e={};return Object.keys($n({0:0})).forEach(t=>{const n=$n({[t]:{0:0}});n&&(e[t]=n);}),e}function $n(e){var t=Eo("",e);return t.error&&t.error.defs}let jn=void 0;fe.prototype.size=function(e,t){jn=qn.mangle;let n=0;return yn(this,(e,t)=>{n+=e._size(t);},t||e&&e.stack),jn=void 0,n},fe.prototype._size=()=>0,_e.prototype._size=()=>8,de.prototype._size=function(){return 2+this.value.length};const Zn=e=>e.length&&e.length-1;ge.prototype._size=function(){return 2+Zn(this.body)},xe.prototype._size=function(){return Zn(this.body)},Se.prototype._size=()=>1,Ae.prototype._size=()=>2,be.prototype._size=()=>9,Ce.prototype._size=()=>7,Oe.prototype._size=()=>8,Fe.prototype._size=()=>8,Re.prototype._size=()=>6,Ne.prototype._size=()=>3;const Jn=e=>(e.is_generator?1:0)+(e.async?6:0);Ie.prototype._size=function(){return Jn(this)+4+Zn(this.argnames)+Zn(this.body)},Le.prototype._size=function(e){return 2*!!kn(e)+Jn(this)+12+Zn(this.argnames)+Zn(this.body)},Pe.prototype._size=function(){return Jn(this)+13+Zn(this.argnames)+Zn(this.body)},Ve.prototype._size=function(){let e=2+Zn(this.argnames);return 1===this.argnames.length&&this.argnames[0]instanceof Pt||(e+=2),Jn(this)+e+Array.isArray(this.body)?Zn(this.body):this.body._size()},Be.prototype._size=()=>2,Ue.prototype._size=function(){return 2+3*Math.floor(this.segments.length/2)},Ge.prototype._size=function(){return this.value.length},ze.prototype._size=function(){return this.value?7:6},We.prototype._size=()=>6,qe.prototype._size=function(){return this.label?6:5},$e.prototype._size=function(){return this.label?9:8},Je.prototype._size=()=>4,Qe.prototype._size=function(){return 8+Zn(this.body)},nt.prototype._size=function(){return 5+Zn(this.body)},tt.prototype._size=function(){return 8+Zn(this.body)},it.prototype._size=function(){return 3+Zn(this.body)},ot.prototype._size=function(){let e=7+Zn(this.body);return this.argname&&(e+=2),e},rt.prototype._size=function(){return 7+Zn(this.body)};const Qn=(e,t)=>e+Zn(t.definitions);st.prototype._size=function(){return Qn(4,this)},ut.prototype._size=function(){return Qn(4,this)},ct.prototype._size=function(){return Qn(6,this)},lt.prototype._size=function(){return this.value?1:0},ft.prototype._size=function(){return this.name?4:0},pt.prototype._size=function(){let e=6;return this.imported_name&&(e+=1),(this.imported_name||this.imported_names)&&(e+=5),this.imported_names&&(e+=2+Zn(this.imported_names)),e},_t.prototype._size=function(){let e=7+(this.is_default?8:0);return this.exported_value&&(e+=this.exported_value._size()),this.exported_names&&(e+=2+Zn(this.exported_names)),this.module_name&&(e+=5),e},dt.prototype._size=function(){return 2+Zn(this.args)},mt.prototype._size=function(){return 6+Zn(this.args)},ht.prototype._size=function(){return Zn(this.expressions)},gt.prototype._size=function(){return this.property.length+1},Dt.prototype._size=()=>2,St.prototype._size=function(){return "typeof"===this.operator?7:"void"===this.operator?5:this.operator.length},Tt.prototype._size=function(e){if("in"===this.operator)return 4;let t=this.operator.length;return ("+"===this.operator||"-"===this.operator)&&this.right instanceof St&&this.right.operator===this.operator&&(t+=1),this.needs_parens(e)&&(t+=2),t},yt.prototype._size=()=>3,Ot.prototype._size=function(){return 2+Zn(this.elements)},Ft.prototype._size=function(e){let t=2;return kn(e)&&(t+=2),t+Zn(this.properties)};const ei=e=>"string"==typeof e?e.length:0;Rt.prototype._size=function(){return ei(this.key)+1};const ti=e=>e?7:0;xt.prototype._size=function(){return 5+ti(this.static)+ei(this.key)},wt.prototype._size=function(){return 5+ti(this.static)+ei(this.key)},Nt.prototype._size=function(){return ti(this.static)+ei(this.key)+Jn(this)},kt.prototype._size=function(){return (this.name?8:7)+(this.extends?8:0)},It.prototype._size=function(){return ti(this.static)+("string"==typeof this.key?this.key.length+2:0)+(this.value?1:0)},Pt.prototype._size=function(){return !jn||this.definition().unmangleable(jn)?this.name.length:2},qt.prototype._size=function(){return this.name.length},nn.prototype._size=function(){const{name:e,thedef:t}=this;return t&&t.global?e.length:"arguments"===e?9:2},Bt.prototype._size=()=>10,en.prototype._size=function(){return this.name.length},rn.prototype._size=function(){return this.name.length},sn.prototype._size=()=>4,un.prototype._size=()=>5,ln.prototype._size=function(){return this.value.length+2},fn.prototype._size=function(){const{value:e}=this;return 0===e?1:e>0&&Math.floor(e)===e?Math.floor(Math.log10(e)+1):e.toString().length},pn.prototype._size=function(){return this.value.length},_n.prototype._size=function(){return this.value.toString().length},mn.prototype._size=()=>4,hn.prototype._size=()=>3,En.prototype._size=()=>6,gn.prototype._size=()=>0,Dn.prototype._size=()=>8,An.prototype._size=()=>4,vn.prototype._size=()=>5,je.prototype._size=()=>6,Ze.prototype._size=()=>6;const ni=(e,t)=>e.flags&t,ii=(e,t)=>{e.flags|=t;},oi=(e,t)=>{e.flags&=~t;};class ri extends Cn{constructor(e,t){super(),void 0===e.defaults||e.defaults||(t=!0),this.options=r(e,{arguments:!1,arrows:!t,booleans:!t,booleans_as_integers:!1,collapse_vars:!t,comparisons:!t,computed_props:!t,conditionals:!t,dead_code:!t,defaults:!0,directives:!t,drop_console:!1,drop_debugger:!t,ecma:5,evaluate:!t,expression:!1,global_defs:!1,hoist_funs:!1,hoist_props:!t,hoist_vars:!1,ie8:!1,if_return:!t,inline:!t,join_vars:!t,keep_classnames:!1,keep_fargs:!0,keep_fnames:!1,keep_infinity:!1,loops:!t,module:!1,negate_iife:!t,passes:1,properties:!t,pure_getters:!t&&"strict",pure_funcs:null,reduce_funcs:null,reduce_vars:!t,sequences:!t,side_effects:!t,switches:!t,top_retain:null,toplevel:!(!e||!e.top_retain),typeofs:!t,unsafe:!1,unsafe_arrows:!1,unsafe_comps:!1,unsafe_Function:!1,unsafe_math:!1,unsafe_symbols:!1,unsafe_methods:!1,unsafe_proto:!1,unsafe_regexp:!1,unsafe_undefined:!1,unused:!t,warnings:!1},!0);var n=this.options.global_defs;if("object"==typeof n)for(var i in n)"@"===i[0]&&D(n,i)&&(n[i.slice(1)]=ue(n[i],{expression:!0}));!0===this.options.inline&&(this.options.inline=3);var o=this.options.pure_funcs;this.pure_funcs="function"==typeof o?o:o?function(e){return !o.includes(e.expression.print_to_string())}:u;var a=this.options.top_retain;a instanceof RegExp?this.top_retain=function(e){return a.test(e.name)}:"function"==typeof a?this.top_retain=a:a&&("string"==typeof a&&(a=a.split(/,/)),this.top_retain=function(e){return a.includes(e.name)}),this.options.module&&(this.directives["use strict"]=!0,this.options.toplevel=!0);var s=this.options.toplevel;this.toplevel="string"==typeof s?{funcs:/funcs/.test(s),vars:/vars/.test(s)}:{funcs:s,vars:s};var c=this.options.sequences;this.sequences_limit=1==c?800:0|c,this.warnings_produced={},this.evaluated_regexps=new Map;}option(e){return this.options[e]}exposed(e){if(e.export)return !0;if(e.global)for(var t=0,n=e.orig.length;t<n;t++)if(!this.toplevel[e.orig[t]instanceof Wt?"funcs":"vars"])return !0;return !1}in_boolean_context(){if(!this.option("booleans"))return !1;for(var e,t=this.self(),n=0;e=this.parent(n);n++){if(e instanceof me||e instanceof yt&&e.condition===t||e instanceof ye&&e.condition===t||e instanceof Oe&&e.condition===t||e instanceof Je&&e.condition===t||e instanceof vt&&"!"==e.operator&&e.expression===t)return !0;if(!(e instanceof Tt&&("&&"==e.operator||"||"==e.operator)||e instanceof yt||e.tail_node()===t))return !1;t=e;}}compress(e){e=e.resolve_defines(this),this.option("expression")&&e.process_expression(!0);for(var t=+this.options.passes||1,n=1/0,i=!1,o={ie8:this.option("ie8")},r=0;r<t;r++)if(e.figure_out_scope(o),0===r&&this.option("drop_console")&&(e=e.drop_console()),(r>0||this.option("reduce_vars"))&&e.reset_opt_flags(this),e=e.transform(this),t>1){let t=0;if(Tn(e,()=>{t++;}),this.info("pass "+r+": last_count: "+n+", count: "+t),t<n)n=t,i=!1;else{if(i)break;i=!0;}}return this.option("expression")&&e.process_expression(!1),e}info(...e){"verbose"==this.options.warnings&&fe.warn(...e);}warn(e,t){if(this.options.warnings){var n=d(e,t);n in this.warnings_produced||(this.warnings_produced[n]=!0,fe.warn.apply(fe,arguments));}}clear_warnings(){this.warnings_produced={};}before(e,t){if(ni(e,256))return e;var n=!1;e instanceof we&&(e=(e=e.hoist_properties(this)).hoist_declarations(this),n=!0),t(e,this),t(e,this);var i=e.optimize(this);return n&&i instanceof we&&(i.drop_unused(this),t(i,this)),i===e&&ii(i,256),i}}function ai(e,t){e.DEFMETHOD("optimize",(function(e){if(ni(this,512))return this;if(e.has_directive("use asm"))return this;var n=t(this,e);return ii(n,512),n}));}function si(e,t){if(!((t=Ri(t))instanceof fe)){var n;if(e instanceof Ot){var i=e.elements;if("length"==t)return mi(i.length,e);"number"==typeof t&&t in i&&(n=i[t]);}else if(e instanceof Ft){t=""+t;for(var o=e.properties,r=o.length;--r>=0;){if(!(o[r]instanceof Rt))return;n||o[r].key!==t||(n=o[r].value);}}return n instanceof nn&&n.fixed_value()||n}}function ui(e,t,n,i,o,r){var a=t.parent(o),s=ki(n,a);if(s)return s;if(!r&&a instanceof dt&&a.expression===n&&!(i instanceof Ve)&&!(i instanceof kt)&&!a.is_expr_pure(e)&&(!(i instanceof Le)||!(a instanceof mt)&&i.contains_this()))return !0;if(a instanceof Ot)return ui(e,t,a,a,o+1);if(a instanceof Rt&&n===a.value){var u=t.parent(o+1);return ui(e,t,u,u,o+2)}if(a instanceof Et&&a.expression===n){var c=si(i,a.property);return !r&&ui(e,t,a,c,o+1)}}function ci(e){return e instanceof Ve||e instanceof Le}function li(e){if(e instanceof sn)return !0;if(e instanceof nn)return e.definition().orig[0]instanceof $t;if(e instanceof Et){if((e=e.expression)instanceof nn){if(e.is_immutable())return !1;e=e.fixed_value();}return !e||!(e instanceof _n)&&(e instanceof cn||li(e))}return !1}function fi(e,t){if(!(e instanceof nn))return !1;for(var n=e.definition().orig,i=n.length;--i>=0;)if(n[i]instanceof t)return !0}function pi(e,t){for(let n=0;;n++){const i=e.parent(n);if(i instanceof xe)return t?i:void 0;if(i instanceof ke)return i;if(i.block_scope)return i.block_scope}}function _i(e,t){for(var n,i=0;(n=e.parent(i++))&&!(n instanceof we);)if(n instanceof ot&&n.argname){n=n.argname.definition().scope;break}return n.find_variable(t)}function di(e,t){if(1==t.length)return t[0];if(0==t.length)throw new Error("trying to create a sequence with length zero!");return p(ht,e,{expressions:t.reduce(Ei,[])})}function mi(e,t){switch(typeof e){case"string":return p(ln,t,{value:e});case"number":return isNaN(e)?p(hn,t):isFinite(e)?1/e<0?p(vt,t,{operator:"-",expression:p(fn,t,{value:-e})}):p(fn,t,{value:e}):e<0?p(vt,t,{operator:"-",expression:p(Dn,t)}):p(Dn,t);case"boolean":return p(e?An:vn,t);case"undefined":return p(En,t);default:if(null===e)return p(mn,t,{value:null});if(e instanceof RegExp)return p(_n,t,{value:{source:A(e.source),flags:e.flags}});throw new Error(d("Can't handle constant of type: {type}",{type:typeof e}))}}function hi(e,t,n){return e instanceof vt&&"delete"==e.operator||e instanceof dt&&e.expression===t&&(n instanceof Et||n instanceof nn&&"eval"==n.name)?di(t,[p(fn,t,{value:0}),n]):n}function Ei(e,t){return t instanceof ht?e.push(...t.expressions):e.push(t),e}function gi(e){if(null===e)return [];if(e instanceof De)return e.body;if(e instanceof Se)return [];if(e instanceof pe)return [e];throw new Error("Can't convert thing to statement array")}function Di(e){return null===e||(e instanceof Se||e instanceof De&&0==e.body.length)}function Si(e){return !(e instanceof Lt||e instanceof Pe||e instanceof ut||e instanceof ct||e instanceof _t||e instanceof pt)}function vi(e){return e instanceof Te&&e.body instanceof De?e.body:e}function Ai(e){return "Call"==e.TYPE&&(e.expression instanceof Le||Ai(e.expression))}function Ti(e){return e instanceof nn&&e.definition().undeclared}ai(fe,(function(e){return e})),xe.DEFMETHOD("drop_console",(function(){return this.transform(new On((function(e){if("Call"==e.TYPE){var t=e.expression;if(t instanceof Et){for(var n=t.expression;n.expression;)n=n.expression;if(Ti(n)&&"console"==n.name)return p(En,e)}}})))})),fe.DEFMETHOD("equivalent_to",(function(e){return ((e,t)=>{if(!Bn(e,t))return !1;const n=[e],i=[t],o=n.push.bind(n),r=i.push.bind(i);for(;n.length&&i.length;){const e=n.pop(),t=i.pop();if(!Bn(e,t))return !1;e._children_backwards(o),t._children_backwards(r);}return 0==n.length&&0==i.length})(this,e)})),we.DEFMETHOD("process_expression",(function(e,t){var n=this,i=new On((function(o){if(e&&o instanceof me)return p(ze,o,{value:o.body});if(!e&&o instanceof ze){if(t){var r=o.value&&o.value.drop_side_effect_free(t,!0);return r?p(me,o,{body:r}):p(Se,o)}return p(me,o,{body:o.value||p(vt,o,{operator:"void",expression:p(fn,o,{value:0})})})}if(o instanceof kt||o instanceof ke&&o!==n)return o;if(o instanceof ge){var a=o.body.length-1;a>=0&&(o.body[a]=o.body[a].transform(i));}else o instanceof Je?(o.body=o.body.transform(i),o.alternative&&(o.alternative=o.alternative.transform(i))):o instanceof Re&&(o.body=o.body.transform(i));return o}));n.transform(i);})),function(e){function t(e,t){t.assignments=0,t.chained=!1,t.direct_access=!1,t.escaped=0,t.recursive_refs=0,t.references=[],t.should_replace=void 0,t.single_use=void 0,t.scope.pinned()?t.fixed=!1:t.orig[0]instanceof Ht||!e.exposed(t)?t.fixed=t.init:t.fixed=!1;}function n(e,n,i){i.variables.forEach((function(i){t(n,i),null===i.fixed?(e.defs_to_safe_ids.set(i.id,e.safe_ids),s(e,i,!0)):i.fixed&&(e.loop_ids.set(i.id,e.in_loop),s(e,i,!0));}));}function i(e,n){n.block_scope&&n.block_scope.variables.forEach(n=>{t(e,n);});}function o(e){e.safe_ids=Object.create(e.safe_ids);}function r(e){e.safe_ids=Object.getPrototypeOf(e.safe_ids);}function s(e,t,n){e.safe_ids[t.id]=n;}function u(e,t){if("m"==t.single_use)return !1;if(e.safe_ids[t.id]){if(null==t.fixed){var n=t.orig[0];if(n instanceof zt||"arguments"==n.name)return !1;t.fixed=p(En,n);}return !0}return t.fixed instanceof Pe}function c(e,t,n,i){if(void 0===t.fixed)return !0;let o;return null===t.fixed&&(o=e.defs_to_safe_ids.get(t.id))?(o[t.id]=!1,e.defs_to_safe_ids.delete(t.id),!0):!!D(e.safe_ids,t.id)&&(!!u(e,t)&&(!1!==t.fixed&&(!(null!=t.fixed&&(!i||t.references.length>t.assignments))&&(t.fixed instanceof Pe?i instanceof fe&&t.fixed.parent_scope===n:t.orig.every(e=>!(e instanceof Ht||e instanceof Wt||e instanceof $t))))))}function l(e,t,n,i,o,r,a){var s=e.parent(r);if(o){if(o.is_constant())return;if(o instanceof Vt)return}if(s instanceof bt&&"="==s.operator&&i===s.right||s instanceof dt&&(i!==s.expression||s instanceof mt)||s instanceof Xe&&i===s.value&&i.scope!==t.scope||s instanceof lt&&i===s.value||s instanceof Ze&&i===s.value&&i.scope!==t.scope)return !(a>1)||o&&o.is_constant_expression(n)||(a=1),void((!t.escaped||t.escaped>a)&&(t.escaped=a));if(s instanceof Ot||s instanceof je||s instanceof Tt&&xi.has(s.operator)||s instanceof yt&&i!==s.condition||s instanceof Ne||s instanceof ht&&i===s.tail_node())l(e,t,n,s,s,r+1,a);else if(s instanceof Rt&&i===s.value){var u=e.parent(r+1);l(e,t,n,u,u,r+2,a);}else if(s instanceof Et&&i===s.expression&&(l(e,t,n,s,o=si(o,s.property),r+1,a+1),o))return;r>0||s instanceof ht&&i!==s.tail_node()||s instanceof me||(t.direct_access=!0);}e(fe,a);const f=e=>Tn(e,e=>{if(e instanceof Pt){var t=e.definition();t&&(e instanceof nn&&t.references.push(e),t.fixed=!1);}});e(Ie,(function(e,t,i){return o(e),n(e,i,this),t(),r(e),!0})),e(bt,(function(e,t,n){var i=this;if(i.left instanceof Be)f(i.left);else{var o=i.left;if(o instanceof nn){var r=o.definition(),a=c(e,r,o.scope,i.right);if(r.assignments++,a){var u=r.fixed;if(u||"="==i.operator){var _="="==i.operator,d=_?i.right:i;if(!ui(n,e,i,d,0))return r.references.push(o),_||(r.chained=!0),r.fixed=_?function(){return i.right}:function(){return p(Tt,i,{operator:i.operator.slice(0,-1),left:u instanceof fe?u:u(),right:i.right})},s(e,r,!1),i.right.walk(e),s(e,r,!0),l(e,r,o.scope,i,d,0,1),!0}}}}})),e(Tt,(function(e){if(xi.has(this.operator))return this.left.walk(e),o(e),this.right.walk(e),r(e),!0})),e(ge,(function(e,t,n){i(n,this);})),e(nt,(function(e){return o(e),this.expression.walk(e),r(e),o(e),he(this,e),r(e),!0})),e(kt,(function(e,t){return oi(this,16),o(e),t(),r(e),!0})),e(yt,(function(e){return this.condition.walk(e),o(e),this.consequent.walk(e),r(e),o(e),this.alternative.walk(e),r(e),!0})),e(tt,(function(e,t){return o(e),t(),r(e),!0})),e(ke,(function(e,t,i){return oi(this,16),o(e),n(e,i,this),this.uses_arguments?(t(),void r(e)):(!this.name&&(a=e.parent())instanceof dt&&a.expression===this&&!a.args.some(e=>e instanceof Ne)&&this.argnames.every(e=>e instanceof Pt)&&this.argnames.forEach((t,n)=>{if(t.definition){var i=t.definition();i.orig.length>1||(void 0!==i.fixed||this.uses_arguments&&!e.has_directive("use strict")?i.fixed=!1:(i.fixed=function(){return a.args[n]||p(En,a)},e.loop_ids.set(i.id,e.in_loop),s(e,i,!0)));}}),t(),r(e),!0);var a;})),e(be,(function(e,t,n){i(n,this);const a=e.in_loop;return e.in_loop=this,o(e),this.body.walk(e),qi(this)&&(r(e),o(e)),this.condition.walk(e),r(e),e.in_loop=a,!0})),e(Oe,(function(e,t,n){i(n,this),this.init&&this.init.walk(e);const a=e.in_loop;return e.in_loop=this,o(e),this.condition&&this.condition.walk(e),this.body.walk(e),this.step&&(qi(this)&&(r(e),o(e)),this.step.walk(e)),r(e),e.in_loop=a,!0})),e(Fe,(function(e,t,n){i(n,this),f(this.init),this.object.walk(e);const a=e.in_loop;return e.in_loop=this,o(e),this.body.walk(e),r(e),e.in_loop=a,!0})),e(Je,(function(e){return this.condition.walk(e),o(e),this.body.walk(e),r(e),this.alternative&&(o(e),this.alternative.walk(e),r(e)),!0})),e(Ae,(function(e){return o(e),this.body.walk(e),r(e),!0})),e(Jt,(function(){this.definition().fixed=!1;})),e(nn,(function(e,t,n){var i,o,r=this.definition();r.references.push(this),1==r.references.length&&!r.fixed&&r.orig[0]instanceof Wt&&e.loop_ids.set(r.id,e.in_loop),void 0!==r.fixed&&u(e,r)?r.fixed&&((i=this.fixed_value())instanceof ke&&Zi(e,r)?r.recursive_refs++:i&&!n.exposed(r)&&function(e,t,n){return t.option("unused")&&!n.scope.pinned()&&n.references.length-n.recursive_refs==1&&e.loop_ids.get(n.id)===e.in_loop}(e,n,r)?r.single_use=i instanceof ke&&!i.pinned()||i instanceof kt||r.scope===this.scope&&i.is_constant_expression():r.single_use=!1,ui(n,e,this,i,0,!!(o=i)&&(o.is_constant()||o instanceof ke||o instanceof sn))&&(r.single_use?r.single_use="m":r.fixed=!1)):r.fixed=!1,l(e,r,this.scope,this,i,0,1);})),e(xe,(function(e,i,o){this.globals.forEach((function(e){t(o,e);})),n(e,o,this);})),e(it,(function(e,t,n){return i(n,this),o(e),he(this,e),r(e),this.bcatch&&(o(e),this.bcatch.walk(e),r(e)),this.bfinally&&this.bfinally.walk(e),!0})),e(St,(function(e){var t=this;if("++"===t.operator||"--"===t.operator){var n=t.expression;if(n instanceof nn){var i=n.definition(),o=c(e,i,n.scope,!0);if(i.assignments++,o){var r=i.fixed;if(r)return i.references.push(n),i.chained=!0,i.fixed=function(){return p(Tt,t,{operator:t.operator.slice(0,-1),left:p(vt,t,{operator:"+",expression:r instanceof fe?r:r()}),right:p(fn,t,{value:1})})},s(e,i,!0),!0}}}})),e(lt,(function(e,t){var n=this;if(n.name instanceof Be)f(n.name);else{var i=n.name.definition();if(n.value){if(c(e,i,n.name.scope,n.value))return i.fixed=function(){return n.value},e.loop_ids.set(i.id,e.in_loop),s(e,i,!1),t(),s(e,i,!0),!0;i.fixed=!1;}}})),e(Ce,(function(e,t,n){i(n,this);const a=e.in_loop;return e.in_loop=this,o(e),t(),r(e),e.in_loop=a,!0}));}((function(e,t){e.DEFMETHOD("reduce_vars",t);})),xe.DEFMETHOD("reset_opt_flags",(function(e){const t=this,n=e.option("reduce_vars"),i=new Cn((function(o,r){if(oi(o,1792),n)return e.top_retain&&o instanceof Pe&&i.parent()===t&&ii(o,1024),o.reduce_vars(i,r,e)}));i.safe_ids=Object.create(null),i.in_loop=null,i.loop_ids=new Map,i.defs_to_safe_ids=new Map,t.walk(i);})),Pt.DEFMETHOD("fixed_value",(function(){var e=this.thedef.fixed;return !e||e instanceof fe?e:e()})),nn.DEFMETHOD("is_immutable",(function(){var e=this.definition().orig;return 1==e.length&&e[0]instanceof $t}));var yi=E("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError");nn.DEFMETHOD("is_declared",(function(e){return !this.definition().undeclared||e.option("unsafe")&&yi.has(this.name)}));var bi,Ci=E("Infinity NaN undefined");function Oi(e){return e instanceof Dn||e instanceof hn||e instanceof En}function Fi(e,t){var n,o,r=t.find_parent(we).get_defun_scope();!function(){var e=t.self(),i=0;do{if(e instanceof ot||e instanceof rt)i++;else if(e instanceof Te)n=!0;else{if(e instanceof we){r=e;break}e instanceof it&&(o=!0);}}while(e=t.parent(i++))}();var a,s=10;do{a=!1,c(e),t.option("dead_code")&&_(e,t),t.option("if_return")&&l(e,t),t.sequences_limit>0&&(h(e,t),g(e,t)),t.option("join_vars")&&S(e),t.option("collapse_vars")&&u(e,t);}while(a&&s-- >0);function u(e,t){if(r.pinned())return e;for(var s,u=[],c=e.length,l=new On((function(e){if(M)return e;if(!F)return e!==d[m]?e:++m<d.length?I(e):(F=!0,(g=function e(t,n,i){var o=l.parent(n);if(o instanceof bt)return i&&!(o.left instanceof Et||v.has(o.left.name))?e(o,n+1,i):t;if(o instanceof Tt)return !i||xi.has(o.operator)&&o.left!==t?t:e(o,n+1,i);if(o instanceof dt)return t;if(o instanceof nt)return t;if(o instanceof yt)return i&&o.condition===t?e(o,n+1,i):t;if(o instanceof at)return e(o,n+1,!0);if(o instanceof Xe)return i?e(o,n+1,i):t;if(o instanceof Je)return i&&o.condition===t?e(o,n+1,i):t;if(o instanceof Te)return t;if(o instanceof ht)return e(o,n+1,o.tail_node()!==t);if(o instanceof me)return e(o,n+1,!0);return o instanceof Qe||o instanceof lt?t:null}(e,0))===e&&(M=!0),e);var n,i=l.parent();if(e instanceof bt&&"="!=e.operator&&S.equivalent_to(e.left)||e instanceof je||e instanceof dt&&S instanceof Et&&S.equivalent_to(e.expression)||e instanceof _e||e instanceof Be||e instanceof Ne&&e.expression instanceof Pt&&e.expression.definition().references.length>1||e instanceof Te&&!(e instanceof Oe)||e instanceof Ye||e instanceof it||e instanceof Re||e instanceof Ze||e instanceof _t||i instanceof Oe&&e!==i.init||!b&&e instanceof nn&&!e.is_declared(t)&&!Hi.has(e)||e instanceof nn&&i instanceof dt&&T(i,Rn))return M=!0,e;if(D||A&&b||!(i instanceof Tt&&xi.has(i.operator)&&i.left!==e||i instanceof yt&&i.condition!==e||i instanceof Je&&i.condition!==e)||(D=i),w&&!(e instanceof Kt)&&S.equivalent_to(e)){if(D)return M=!0,e;if(ki(e,i))return E&&R++,e;if(R++,E&&h instanceof lt)return e;if(a=M=!0,t.info("Collapsing {name} [{file}:{line},{col}]",{name:e.print_to_string(),file:e.start.file,line:e.start.line,col:e.start.col}),h instanceof At)return p(vt,h,h);if(h instanceof lt){var s=h.name.definition(),u=h.value;return s.references.length-s.replaced!=1||t.exposed(s)?p(bt,h,{operator:"=",left:p(nn,h.name,h.name),right:u}):(s.replaced++,O&&Oi(u)?u.transform(t):hi(i,e,u))}return oi(h,32),h}return (e instanceof dt||e instanceof Xe&&(y||S instanceof Et||W(S))||e instanceof Et&&(y||e.expression.may_throw_on_access(t))||e instanceof nn&&(v.get(e.name)||y&&W(e))||e instanceof lt&&e.value&&(v.has(e.name.name)||y&&W(e.name))||(n=ki(e.left,e))&&(n instanceof Et||v.has(n.name))||C&&(o?e.has_side_effects(t):function e(t,n){if(t instanceof bt)return e(t.left,!0);if(t instanceof St)return e(t.expression,!0);if(t instanceof lt)return t.value&&e(t.value);if(n){if(t instanceof gt)return e(t.expression,!0);if(t instanceof Dt)return e(t.expression,!0);if(t instanceof nn)return t.definition().scope!==r}return !1}(e)))&&(g=e,e instanceof we&&(M=!0)),I(e)}),(function(e){M||(g===e&&(M=!0),D===e&&(D=null));})),_=new On((function(e){if(M)return e;if(!F){if(e!==d[m])return e;if(++m<d.length)return;return F=!0,e}return e instanceof nn&&e.name==k.name?(--R||(M=!0),ki(e,_.parent())?e:(k.replaced++,E.replaced--,h.value)):e instanceof tt||e instanceof we?e:void 0}));--c>=0;){0==c&&t.option("unused")&&V();var d=[];for(P(e[c]);u.length>0;){d=u.pop();var m=0,h=d[d.length-1],E=null,g=null,D=null,S=B(h);if(S&&!li(S)&&!S.has_side_effects(t)){var v=U(h),A=H(S);S instanceof nn&&v.set(S.name,!1);var y=X(h),b=z(),C=h.may_throw(t),O=h.name instanceof zt,F=O,M=!1,R=0,w=!s||!F;if(!w){for(var x=t.self().argnames.lastIndexOf(h.name)+1;!M&&x<s.length;x++)s[x].transform(l);w=!0;}for(var N=c;!M&&N<e.length;N++)e[N].transform(l);if(E){var k=h.name.definition();if(M&&k.references.length-k.replaced>R)R=!1;else{M=!1,m=0,F=O;for(N=c;!M&&N<e.length;N++)e[N].transform(_);E.single_use=!1;}}R&&!G(h)&&e.splice(c,1);}}}function I(e){if(e instanceof ke)return e;if(e instanceof kt){e.extends&&(e.extends=e.extends.transform(l));for(const t of e.properties)t.computed_key()&&(t.key=t.key.transform(l)),t.static&&t.value&&(t.value=t.value.transform(l));return e}if(e instanceof Qe){e.expression=e.expression.transform(l);for(var t=0,n=e.body.length;!M&&t<n;t++){var i=e.body[t];if(i instanceof nt){if(!F){if(i!==d[m])continue;m++;}if(i.expression=i.expression.transform(l),!b)break}}return M=!0,e}}function L(e,t,n){var i=!1,o=!(e instanceof Ve);return t.walk(new Cn((function(t,a){if(i)return !0;if(t instanceof nn&&(e.variables.has(t.name)||function(e,t){if(e.global)return !1;let n=e.scope;for(;n&&n!==t;){if(n.variables.has(e.name))return !0;n=n.parent_scope;}return !1}(t.definition(),e))){var s=t.definition().scope;if(s!==r)for(;s=s.parent_scope;)if(s===r)return !0;return i=!0}if((n||o)&&t instanceof sn)return i=!0;if(t instanceof we&&!(t instanceof Ve)){var u=o;return o=!1,a(),o=u,!0}}))),i}function V(){var e,n=t.self();if(ci(n)&&!n.name&&!n.uses_arguments&&!n.pinned()&&(e=t.parent())instanceof dt&&e.expression===n&&e.args.every(e=>!(e instanceof Ne))){var o=t.has_directive("use strict");o&&!i(o,n.body)&&(o=!1);var r=n.argnames.length;s=e.args.slice(r);for(var a=new Set,c=r;--c>=0;){var l=n.argnames[c],f=e.args[c];const i=l.definition&&l.definition();if(!(i&&i.orig.length>1)&&(s.unshift(p(lt,l,{name:l,value:f})),!a.has(l.name)))if(a.add(l.name),l instanceof Ne){var _=e.args.slice(c);_.every(e=>!L(n,e,o))&&u.unshift([p(lt,l,{name:l.expression,value:p(Ot,e,{elements:_})})]);}else f?(f instanceof ke&&f.pinned()||L(n,f,o))&&(f=null):f=p(En,l).transform(t),f&&u.unshift([p(lt,l,{name:l,value:f})]);}}}function P(e){if(d.push(e),e instanceof bt)e.left.has_side_effects(t)||u.push(d.slice()),P(e.right);else if(e instanceof Tt)P(e.left),P(e.right);else if(e instanceof dt&&!T(e,Rn))P(e.expression),e.args.forEach(P);else if(e instanceof nt)P(e.expression);else if(e instanceof yt)P(e.condition),P(e.consequent),P(e.alternative);else if(!(e instanceof at)||!t.option("unused")&&e instanceof ct)e instanceof ye?(P(e.condition),e.body instanceof ge||P(e.body)):e instanceof Xe?e.value&&P(e.value):e instanceof Oe?(e.init&&P(e.init),e.condition&&P(e.condition),e.step&&P(e.step),e.body instanceof ge||P(e.body)):e instanceof Fe?(P(e.object),e.body instanceof ge||P(e.body)):e instanceof Je?(P(e.condition),e.body instanceof ge||P(e.body),!e.alternative||e.alternative instanceof ge||P(e.alternative)):e instanceof ht?e.expressions.forEach(P):e instanceof me?P(e.body):e instanceof Qe?(P(e.expression),e.body.forEach(P)):e instanceof St?"++"!=e.operator&&"--"!=e.operator||u.push(d.slice()):e instanceof lt&&e.value&&(u.push(d.slice()),P(e.value));else{var n=e.definitions.length,i=n-200;for(i<0&&(i=0);i<n;i++)P(e.definitions[i]);}d.pop();}function B(e){if(!(e instanceof lt&&e.name instanceof Kt)){const t=e[e instanceof bt?"left":"expression"];return !fi(t,Ht)&&!fi(t,Xt)&&t}var n=e.name.definition();if(i(e.name,n.orig)){var o=n.references.length-n.replaced;if(o)return n.orig.length-n.eliminated>1&&!(e.name instanceof zt)||(o>1?function(e){var t=e.value;if(t instanceof nn&&"arguments"!=t.name){var n=t.definition();if(!n.undeclared)return E=n}}(e):!t.exposed(n))?p(nn,e.name,e.name):void 0}}function K(e){return e[e instanceof bt?"right":"value"]}function U(e){var n=new Map;if(e instanceof St)return n;var i=new Cn((function(e){for(var o=e;o instanceof Et;)o=o.expression;(o instanceof nn||o instanceof sn)&&n.set(o.name,n.get(o.name)||ui(t,i,e,e,0));}));return K(e).walk(i),n}function G(n){if(n.name instanceof zt){var i=t.parent(),o=t.self().argnames,r=o.indexOf(n.name);if(r<0)i.args.length=Math.min(i.args.length,o.length-1);else{var a=i.args;a[r]&&(a[r]=p(fn,a[r],{value:0}));}return !0}var s=!1;return e[c].transform(new On((function(e,t,i){return s?e:e===n||e.body===n?(s=!0,e instanceof lt?(e.value=null,e):i?f.skip:null):void 0}),(function(e){if(e instanceof ht)switch(e.expressions.length){case 0:return null;case 1:return e.expressions[0]}})))}function H(e){for(;e instanceof Et;)e=e.expression;return e instanceof nn&&e.definition().scope===r&&!(n&&(v.has(e.name)||h instanceof St||h instanceof bt&&"="!=h.operator))}function X(e){return e instanceof St?Ni.has(e.operator):K(e).has_side_effects(t)}function z(){if(y)return !1;if(E)return !0;if(S instanceof nn){var e=S.definition();if(e.references.length-e.replaced==(h instanceof lt?1:2))return !0}return !1}function W(e){if(!e.definition)return !0;var t=e.definition();return !(1==t.orig.length&&t.orig[0]instanceof Wt)&&(t.scope.get_defun_scope()!==r||!t.references.every(e=>{var t=e.scope.get_defun_scope();return "Scope"==t.TYPE&&(t=t.parent_scope),t===r}))}}function c(e){for(var t=[],n=0;n<e.length;){var i=e[n];i instanceof De&&i.body.every(Si)?(a=!0,c(i.body),e.splice(n,1,...i.body),n+=i.body.length):i instanceof Se?(a=!0,e.splice(n,1)):i instanceof de?t.indexOf(i.value)<0?(n++,t.push(i.value)):(a=!0,e.splice(n,1)):n++;}}function l(e,t){for(var n=t.self(),i=function(e){for(var t=0,n=e.length;--n>=0;){var i=e[n];if(i instanceof Je&&i.body instanceof ze&&++t>1)return !0}return !1}(e),o=n instanceof ke,r=e.length;--r>=0;){var s=e[r],u=S(r),c=e[u];if(o&&!c&&s instanceof ze){if(!s.value){a=!0,e.splice(r,1);continue}if(s.value instanceof vt&&"void"==s.value.operator){a=!0,e[r]=p(me,s,{body:s.value.expression});continue}}if(s instanceof Je){var l;if(E(l=Xi(s.body))){l.label&&m(l.label.thedef.references,l),a=!0,(s=s.clone()).condition=s.condition.negate(t);var f=D(s.body,l);s.body=p(De,s,{body:gi(s.alternative).concat(g())}),s.alternative=p(De,s,{body:f}),e[r]=s.transform(t);continue}if(E(l=Xi(s.alternative))){l.label&&m(l.label.thedef.references,l),a=!0,(s=s.clone()).body=p(De,s.body,{body:gi(s.body).concat(g())});f=D(s.alternative,l);s.alternative=p(De,s.alternative,{body:f}),e[r]=s.transform(t);continue}}if(s instanceof Je&&s.body instanceof ze){var _=s.body.value;if(!_&&!s.alternative&&(o&&!c||c instanceof ze&&!c.value)){a=!0,e[r]=p(me,s.condition,{body:s.condition});continue}if(_&&!s.alternative&&c instanceof ze&&c.value){a=!0,(s=s.clone()).alternative=c,e[r]=s.transform(t),e.splice(u,1);continue}if(_&&!s.alternative&&(!c&&o&&i||c instanceof ze)){a=!0,(s=s.clone()).alternative=c||p(ze,s,{value:null}),e[r]=s.transform(t),c&&e.splice(u,1);continue}var h=e[v(r)];if(t.option("sequences")&&o&&!s.alternative&&h instanceof Je&&h.body instanceof ze&&S(u)==e.length&&c instanceof me){a=!0,(s=s.clone()).alternative=p(De,c,{body:[c,p(ze,c,{value:null})]}),e[r]=s.transform(t),e.splice(u,1);continue}}}function E(i){if(!i)return !1;for(var a=r+1,s=e.length;a<s;a++){var u=e[a];if(u instanceof ct||u instanceof ut)return !1}var c=i instanceof Ye?t.loopcontrol_target(i):null;return i instanceof ze&&o&&function(e){return !e||e instanceof vt&&"void"==e.operator}(i.value)||i instanceof $e&&n===vi(c)||i instanceof qe&&c instanceof De&&n===c}function g(){var t=e.slice(r+1);return e.length=r+1,t.filter((function(t){return !(t instanceof Pe)||(e.push(t),!1)}))}function D(e,t){var n=gi(e).slice(0,-1);return t.value&&n.push(p(me,t.value,{body:t.value.expression})),n}function S(t){for(var n=t+1,i=e.length;n<i;n++){var o=e[n];if(!(o instanceof st&&d(o)))break}return n}function v(t){for(var n=t;--n>=0;){var i=e[n];if(!(i instanceof st&&d(i)))break}return n}}function _(e,t){for(var n,i=t.self(),o=0,r=0,s=e.length;o<s;o++){var u=e[o];if(u instanceof Ye){var c=t.loopcontrol_target(u);u instanceof qe&&!(c instanceof Te)&&vi(c)===i||u instanceof $e&&vi(c)===i?u.label&&m(u.label.thedef.references,u):e[r++]=u;}else e[r++]=u;if(Xi(u)){n=e.slice(o+1);break}}e.length=r,a=r!=s,n&&n.forEach((function(n){Mi(t,n,e);}));}function d(e){return e.definitions.every(e=>!e.value)}function h(e,t){if(!(e.length<2)){for(var n=[],i=0,o=0,r=e.length;o<r;o++){var s=e[o];if(s instanceof me){n.length>=t.sequences_limit&&c();var u=s.body;n.length>0&&(u=u.drop_side_effect_free(t)),u&&Ei(n,u);}else s instanceof at&&d(s)||s instanceof Pe||c(),e[i++]=s;}c(),e.length=i,i!=r&&(a=!0);}function c(){if(n.length){var t=di(n[0],n);e[i++]=p(me,t,{body:t}),n=[];}}}function E(e,t){if(!(e instanceof De))return e;for(var n=null,i=0,o=e.body.length;i<o;i++){var r=e.body[i];if(r instanceof st&&d(r))t.push(r);else{if(n)return !1;n=r;}}return n}function g(e,t){function n(e){o--,a=!0;var n=i.body;return di(n,[n,e]).transform(t)}for(var i,o=0,r=0;r<e.length;r++){var s=e[r];if(i)if(s instanceof Xe)s.value=n(s.value||p(En,s).transform(t));else if(s instanceof Oe){if(!(s.init instanceof at)){Tn(i.body,e=>e instanceof we||(e instanceof Tt&&"in"===e.operator?bn:void 0))||(s.init?s.init=n(s.init):(s.init=i.body,o--,a=!0));}}else s instanceof Fe?s.init instanceof ct||s.init instanceof ut||(s.object=n(s.object)):s instanceof Je?s.condition=n(s.condition):(s instanceof Qe||s instanceof Re)&&(s.expression=n(s.expression));if(t.option("conditionals")&&s instanceof Je){var u=[],c=E(s.body,u),l=E(s.alternative,u);if(!1!==c&&!1!==l&&u.length>0){var f=u.length;u.push(p(Je,s,{condition:s.condition,body:c||p(Se,s.body),alternative:l})),u.unshift(o,1),[].splice.apply(e,u),r+=f,o+=f+1,i=null,a=!0;continue}}e[o++]=s,i=s instanceof me?s:null;}e.length=o;}function D(e,n){if(e instanceof at){var i,o=e.definitions[e.definitions.length-1];if(o.value instanceof Ft)if(n instanceof bt?i=[n]:n instanceof ht&&(i=n.expressions.slice()),i){var a=!1;do{var s=i[0];if(!(s instanceof bt))break;if("="!=s.operator)break;if(!(s.left instanceof Et))break;var u=s.left.expression;if(!(u instanceof nn))break;if(o.name.name!=u.name)break;if(!s.right.is_constant_expression(r))break;var c=s.left.property;if(c instanceof fe&&(c=c.evaluate(t)),c instanceof fe)break;c=""+c;var l=t.option("ecma")<2015&&t.has_directive("use strict")?function(e){return e.key!=c&&e.key&&e.key.name!=c}:function(e){return e.key&&e.key.name!=c};if(!o.value.properties.every(l))break;var f=o.value.properties.filter((function(e){return e.key===c}))[0];f?f.value=new ht({start:f.start,expressions:[f.value.clone(),s.right.clone()],end:f.end}):o.value.properties.push(p(Rt,s,{key:c,value:s.right})),i.shift(),a=!0;}while(i.length);return a&&i}}}function S(e){for(var t,n=0,i=-1,o=e.length;n<o;n++){var r=e[n],s=e[i];if(r instanceof at)s&&s.TYPE==r.TYPE?(s.definitions=s.definitions.concat(r.definitions),a=!0):t&&t.TYPE==r.TYPE&&d(r)?(t.definitions=t.definitions.concat(r.definitions),a=!0):(e[++i]=r,t=r);else if(r instanceof Xe)r.value=c(r.value);else if(r instanceof Oe){(u=D(s,r.init))?(a=!0,r.init=u.length?di(r.init,u):null,e[++i]=r):s instanceof st&&(!r.init||r.init.TYPE==s.TYPE)?(r.init&&(s.definitions=s.definitions.concat(r.init.definitions)),r.init=s,e[i]=r,a=!0):t&&r.init&&t.TYPE==r.init.TYPE&&d(r.init)?(t.definitions=t.definitions.concat(r.init.definitions),r.init=null,e[++i]=r,a=!0):e[++i]=r;}else if(r instanceof Fe)r.object=c(r.object);else if(r instanceof Je)r.condition=c(r.condition);else if(r instanceof me){var u;if(u=D(s,r.body)){if(a=!0,!u.length)continue;r.body=di(r.body,u);}e[++i]=r;}else r instanceof Qe||r instanceof Re?r.expression=c(r.expression):e[++i]=r;}function c(t){e[++i]=r;var n=D(s,t);return n?(a=!0,n.length?di(t,n):t instanceof ht?t.tail_node().left:t.left):t}e.length=i+1;}}function Mi(e,t,n){t instanceof Pe||e.warn("Dropping unreachable code [{file}:{line},{col}]",t.start),Tn(t,i=>i instanceof st?(e.warn("Declarations in unreachable code! [{file}:{line},{col}]",i.start),i.remove_initializers(),n.push(i),!0):i instanceof Pe&&(i===t||!e.has_directive("use strict"))?(n.push(i===t?i:p(st,i,{definitions:[p(lt,i,{name:p(Ut,i.name,i.name),value:null})]})),!0):i instanceof we||void 0);}function Ri(e){return e instanceof cn?e.getValue():e instanceof vt&&"void"==e.operator&&e.expression instanceof cn?void 0:e}function wi(e,t){return ni(e,8)||e instanceof En||e instanceof vt&&"void"==e.operator&&!e.expression.has_side_effects(t)}!function(e){function t(e){return /strict/.test(e.option("pure_getters"))}fe.DEFMETHOD("may_throw_on_access",(function(e){return !e.option("pure_getters")||this._dot_throw(e)})),e(fe,t),e(mn,u),e(En,u),e(cn,s),e(Ot,s),e(Ft,(function(e){if(!t(e))return !1;for(var n=this.properties.length;--n>=0;)if(this.properties[n]._dot_throw(e))return !0;return !1})),e(Mt,s),e(xt,u),e(Ne,(function(e){return this.expression._dot_throw(e)})),e(Le,s),e(Ve,s),e(At,s),e(vt,(function(){return "void"==this.operator})),e(Tt,(function(e){return ("&&"==this.operator||"||"==this.operator)&&(this.left._dot_throw(e)||this.right._dot_throw(e))})),e(bt,(function(e){return "="==this.operator&&this.right._dot_throw(e)})),e(yt,(function(e){return this.consequent._dot_throw(e)||this.alternative._dot_throw(e)})),e(gt,(function(e){return !!t(e)&&!(this.expression instanceof Le&&"prototype"==this.property)})),e(ht,(function(e){return this.tail_node()._dot_throw(e)})),e(nn,(function(e){if(ni(this,8))return !0;if(!t(e))return !1;if(Ti(this)&&this.is_declared(e))return !1;if(this.is_immutable())return !1;var n=this.fixed_value();return !n||n._dot_throw(e)}));}((function(e,t){e.DEFMETHOD("_dot_throw",t);})),function(e){const t=E("! delete"),n=E("in instanceof == != === !== < <= >= >");e(fe,s),e(vt,(function(){return t.has(this.operator)})),e(Tt,(function(){return n.has(this.operator)||xi.has(this.operator)&&this.left.is_boolean()&&this.right.is_boolean()})),e(yt,(function(){return this.consequent.is_boolean()&&this.alternative.is_boolean()})),e(bt,(function(){return "="==this.operator&&this.right.is_boolean()})),e(ht,(function(){return this.tail_node().is_boolean()})),e(An,u),e(vn,u);}((function(e,t){e.DEFMETHOD("is_boolean",t);})),function(e){e(fe,s),e(fn,u);var t=E("+ - ~ ++ --");e(St,(function(){return t.has(this.operator)}));var n=E("- * / % & | ^ << >> >>>");e(Tt,(function(e){return n.has(this.operator)||"+"==this.operator&&this.left.is_number(e)&&this.right.is_number(e)})),e(bt,(function(e){return n.has(this.operator.slice(0,-1))||"="==this.operator&&this.right.is_number(e)})),e(ht,(function(e){return this.tail_node().is_number(e)})),e(yt,(function(e){return this.consequent.is_number(e)&&this.alternative.is_number(e)}));}((function(e,t){e.DEFMETHOD("is_number",t);})),(bi=function(e,t){e.DEFMETHOD("is_string",t);})(fe,s),bi(ln,u),bi(Ue,(function(){return 1===this.segments.length})),bi(vt,(function(){return "typeof"==this.operator})),bi(Tt,(function(e){return "+"==this.operator&&(this.left.is_string(e)||this.right.is_string(e))})),bi(bt,(function(e){return ("="==this.operator||"+="==this.operator)&&this.right.is_string(e)})),bi(ht,(function(e){return this.tail_node().is_string(e)})),bi(yt,(function(e){return this.consequent.is_string(e)&&this.alternative.is_string(e)}));var xi=E("&& ||"),Ni=E("delete ++ --");function ki(e,t){return t instanceof St&&Ni.has(t.operator)?t.expression:t instanceof bt&&t.left===e?e:void 0}function Ii(e,t){return e.size()>t.size()?t:e}function Li(e,t){return Ii(p(me,e,{body:e}),p(me,t,{body:t})).body}function Vi(e,t,n){return (kn(e)?Li:Ii)(t,n)}function Pi(e){const t=new Map;for(var n of Object.keys(e))t.set(n,E(e[n]));return t}!function(e){function t(e,t){e.warn("global_defs "+t.print_to_string()+" redefined [{file}:{line},{col}]",t.start);}xe.DEFMETHOD("resolve_defines",(function(e){return e.option("global_defs")?(this.figure_out_scope({ie8:e.option("ie8")}),this.transform(new On((function(n){var i=n._find_defs(e,"");if(i){for(var o,r=0,a=n;(o=this.parent(r++))&&o instanceof Et&&o.expression===a;)a=o;if(!ki(a,o))return i;t(e,n);}})))):this})),e(fe,a),e(gt,(function(e,t){return this.expression._find_defs(e,"."+this.property+t)})),e(Kt,(function(e){this.global()&&D(e.option("global_defs"),this.name)&&t(e,this);})),e(nn,(function(e,t){if(this.global()){var n=e.option("global_defs"),i=this.name+t;return D(n,i)?function e(t,n){if(t instanceof fe)return p(t.CTOR,n,t);if(Array.isArray(t))return p(Ot,n,{elements:t.map((function(t){return e(t,n)}))});if(t&&"object"==typeof t){var i=[];for(var o in t)D(t,o)&&i.push(p(Rt,n,{key:o,value:e(t[o],n)}));return p(Ft,n,{properties:i})}return mi(t,n)}(n[i],this):void 0}}));}((function(e,t){e.DEFMETHOD("_find_defs",t);}));var Bi=["constructor","toString","valueOf"],Ki=Pi({Array:["indexOf","join","lastIndexOf","slice"].concat(Bi),Boolean:Bi,Function:Bi,Number:["toExponential","toFixed","toPrecision"].concat(Bi),Object:Bi,RegExp:["test"].concat(Bi),String:["charAt","charCodeAt","concat","indexOf","italics","lastIndexOf","match","replace","search","slice","split","substr","substring","toLowerCase","toUpperCase","trim"].concat(Bi)}),Ui=Pi({Array:["isArray"],Math:["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan","atan2","pow","max","min"],Number:["isFinite","isNaN"],Object:["create","getOwnPropertyDescriptor","getOwnPropertyNames","getPrototypeOf","isExtensible","isFrozen","isSealed","keys"],String:["fromCharCode"]});!function(e){fe.DEFMETHOD("evaluate",(function(e){if(!e.option("evaluate"))return this;var t=this._eval(e,1);return !t||t instanceof RegExp?t:"function"==typeof t||"object"==typeof t?this:t}));var t=E("! ~ - + void");fe.DEFMETHOD("is_constant",(function(){return this instanceof cn?!(this instanceof _n):this instanceof vt&&this.expression instanceof cn&&t.has(this.operator)})),e(pe,(function(){throw new Error(d("Cannot evaluate a statement [{file}:{line},{col}]",this.start))})),e(ke,c),e(kt,c),e(fe,c),e(cn,(function(){return this.getValue()})),e(pn,c),e(_n,(function(e){let t=e.evaluated_regexps.get(this);if(void 0===t){try{t=(0,eval)(this.print_to_string());}catch(e){t=null;}e.evaluated_regexps.set(this,t);}return t||this})),e(Ue,(function(){return 1!==this.segments.length?this:this.segments[0].value})),e(Le,(function(e){if(e.option("unsafe")){var t=function(){};return t.node=this,t.toString=function(){return this.node.print_to_string()},t}return this})),e(Ot,(function(e,t){if(e.option("unsafe")){for(var n=[],i=0,o=this.elements.length;i<o;i++){var r=this.elements[i],a=r._eval(e,t);if(r===a)return this;n.push(a);}return n}return this})),e(Ft,(function(e,t){if(e.option("unsafe")){for(var n={},i=0,o=this.properties.length;i<o;i++){var r=this.properties[i];if(r instanceof Ne)return this;var a=r.key;if(a instanceof Pt)a=a.name;else if(a instanceof fe&&(a=a._eval(e,t))===r.key)return this;if("function"==typeof Object.prototype[a])return this;if(!(r.value instanceof Le)&&(n[a]=r.value._eval(e,t),n[a]===r.value))return this}return n}return this}));var n=E("! typeof void");e(vt,(function(e,t){var i=this.expression;if(e.option("typeofs")&&"typeof"==this.operator&&(i instanceof ke||i instanceof nn&&i.fixed_value()instanceof ke))return "function";if(n.has(this.operator)||t++,(i=i._eval(e,t))===this.expression)return this;switch(this.operator){case"!":return !i;case"typeof":return i instanceof RegExp?this:typeof i;case"void":return;case"~":return ~i;case"-":return -i;case"+":return +i}return this}));var i=E("&& || === !==");e(Tt,(function(e,t){i.has(this.operator)||t++;var n=this.left._eval(e,t);if(n===this.left)return this;var o,r=this.right._eval(e,t);if(r===this.right)return this;switch(this.operator){case"&&":o=n&&r;break;case"||":o=n||r;break;case"|":o=n|r;break;case"&":o=n&r;break;case"^":o=n^r;break;case"+":o=n+r;break;case"*":o=n*r;break;case"**":o=Math.pow(n,r);break;case"/":o=n/r;break;case"%":o=n%r;break;case"-":o=n-r;break;case"<<":o=n<<r;break;case">>":o=n>>r;break;case">>>":o=n>>>r;break;case"==":o=n==r;break;case"===":o=n===r;break;case"!=":o=n!=r;break;case"!==":o=n!==r;break;case"<":o=n<r;break;case"<=":o=n<=r;break;case">":o=n>r;break;case">=":o=n>=r;break;default:return this}return isNaN(o)&&e.find_parent(Re)?this:o})),e(yt,(function(e,t){var n=this.condition._eval(e,t);if(n===this.condition)return this;var i=n?this.consequent:this.alternative,o=i._eval(e,t);return o===i?this:o})),e(nn,(function(e,t){var n,i=this.fixed_value();if(!i)return this;if(D(i,"_eval"))n=i._eval();else{if(this._eval=c,n=i._eval(e,t),delete this._eval,n===i)return this;i._eval=function(){return n};}if(n&&"object"==typeof n){var o=this.definition().escaped;if(o&&t>o)return this}return n}));var o={Array:Array,Math:Math,Number:Number,Object:Object,String:String},r=Pi({Math:["E","LN10","LN2","LOG2E","LOG10E","PI","SQRT1_2","SQRT2"],Number:["MAX_VALUE","MIN_VALUE","NaN","NEGATIVE_INFINITY","POSITIVE_INFINITY"]});e(Et,(function(e,t){if(e.option("unsafe")){var n=this.property;if(n instanceof fe&&(n=n._eval(e,t))===this.property)return this;var i,a=this.expression;if(Ti(a)){var s,u="hasOwnProperty"===a.name&&"call"===n&&(s=e.parent()&&e.parent().args)&&s&&s[0]&&s[0].evaluate(e);if(null==(u=u instanceof gt?u.expression:u)||u.thedef&&u.thedef.undeclared)return this.clone();var c=r.get(a.name);if(!c||!c.has(n))return this;i=o[a.name];}else{if(!(i=a._eval(e,t+1))||i===a||!D(i,n))return this;if("function"==typeof i)switch(n){case"name":return i.node.name?i.node.name.name:"";case"length":return i.node.argnames.length;default:return this}}return i[n]}return this})),e(dt,(function(e,t){var n=this.expression;if(e.option("unsafe")&&n instanceof Et){var i,r=n.property;if(r instanceof fe&&(r=r._eval(e,t))===n.property)return this;var a=n.expression;if(Ti(a)){var s="hasOwnProperty"===a.name&&"call"===r&&this.args[0]&&this.args[0].evaluate(e);if(null==(s=s instanceof gt?s.expression:s)||s.thedef&&s.thedef.undeclared)return this.clone();var u=Ui.get(a.name);if(!u||!u.has(r))return this;i=o[a.name];}else{if((i=a._eval(e,t+1))===a||!i)return this;var c=Ki.get(i.constructor.name);if(!c||!c.has(r))return this}for(var l=[],f=0,p=this.args.length;f<p;f++){var _=this.args[f],d=_._eval(e,t);if(_===d)return this;l.push(d);}try{return i[r].apply(i,l)}catch(t){e.warn("Error evaluating {code} [{file}:{line},{col}]",{code:this.print_to_string(),file:this.start.file,line:this.start.line,col:this.start.col});}}return this})),e(mt,c);}((function(e,t){e.DEFMETHOD("_eval",t);})),function(e){function t(e){return p(vt,e,{operator:"!",expression:e})}function n(e,n,i){var o=t(e);if(i){var r=p(me,n,{body:n});return Ii(o,r)===r?n:o}return Ii(o,n)}e(fe,(function(){return t(this)})),e(pe,(function(){throw new Error("Cannot negate a statement")})),e(Le,(function(){return t(this)})),e(Ve,(function(){return t(this)})),e(vt,(function(){return "!"==this.operator?this.expression:t(this)})),e(ht,(function(e){var t=this.expressions.slice();return t.push(t.pop().negate(e)),di(this,t)})),e(yt,(function(e,t){var i=this.clone();return i.consequent=i.consequent.negate(e),i.alternative=i.alternative.negate(e),n(this,i,t)})),e(Tt,(function(e,i){var o=this.clone(),r=this.operator;if(e.option("unsafe_comps"))switch(r){case"<=":return o.operator=">",o;case"<":return o.operator=">=",o;case">=":return o.operator="<",o;case">":return o.operator="<=",o}switch(r){case"==":return o.operator="!=",o;case"!=":return o.operator="==",o;case"===":return o.operator="!==",o;case"!==":return o.operator="===",o;case"&&":return o.operator="||",o.left=o.left.negate(e,i),o.right=o.right.negate(e),n(this,o,i);case"||":return o.operator="&&",o.left=o.left.negate(e,i),o.right=o.right.negate(e),n(this,o,i)}return t(this)}));}((function(e,t){e.DEFMETHOD("negate",(function(e,n){return t.call(this,e,n)}));}));var Gi=E("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");dt.DEFMETHOD("is_expr_pure",(function(e){if(e.option("unsafe")){var t=this.expression,n=this.args&&this.args[0]&&this.args[0].evaluate(e);if(t.expression&&"hasOwnProperty"===t.expression.name&&(null==n||n.thedef&&n.thedef.undeclared))return !1;if(Ti(t)&&Gi.has(t.name))return !0;let i;if(t instanceof gt&&Ti(t.expression)&&(i=Ui.get(t.expression.name))&&i.has(t.property))return !0}return !!T(this,Fn)||!e.pure_funcs(this)})),fe.DEFMETHOD("is_call_pure",s),gt.DEFMETHOD("is_call_pure",(function(e){if(!e.option("unsafe"))return;const t=this.expression;let n;return t instanceof Ot?n=Ki.get("Array"):t.is_boolean()?n=Ki.get("Boolean"):t.is_number(e)?n=Ki.get("Number"):t instanceof _n?n=Ki.get("RegExp"):t.is_string(e)?n=Ki.get("String"):this.may_throw_on_access(e)||(n=Ki.get("Object")),n&&n.has(this.property)}));const Hi=new Set(["Number","String","Array","Object","Function","Promise"]);function Xi(e){return e&&e.aborts()}!function(e){function t(e,t){for(var n=e.length;--n>=0;)if(e[n].has_side_effects(t))return !0;return !1}e(fe,u),e(Se,s),e(cn,s),e(sn,s),e(ge,(function(e){return t(this.body,e)})),e(dt,(function(e){return !(this.is_expr_pure(e)||this.expression.is_call_pure(e)&&!this.expression.has_side_effects(e))||t(this.args,e)})),e(Qe,(function(e){return this.expression.has_side_effects(e)||t(this.body,e)})),e(nt,(function(e){return this.expression.has_side_effects(e)||t(this.body,e)})),e(it,(function(e){return t(this.body,e)||this.bcatch&&this.bcatch.has_side_effects(e)||this.bfinally&&this.bfinally.has_side_effects(e)})),e(Je,(function(e){return this.condition.has_side_effects(e)||this.body&&this.body.has_side_effects(e)||this.alternative&&this.alternative.has_side_effects(e)})),e(Ae,(function(e){return this.body.has_side_effects(e)})),e(me,(function(e){return this.body.has_side_effects(e)})),e(ke,s),e(kt,(function(e){return !(!this.extends||!this.extends.has_side_effects(e))||t(this.properties,e)})),e(Tt,(function(e){return this.left.has_side_effects(e)||this.right.has_side_effects(e)})),e(bt,u),e(yt,(function(e){return this.condition.has_side_effects(e)||this.consequent.has_side_effects(e)||this.alternative.has_side_effects(e)})),e(St,(function(e){return Ni.has(this.operator)||this.expression.has_side_effects(e)})),e(nn,(function(e){return !this.is_declared(e)&&!Hi.has(this.name)})),e(qt,s),e(Kt,s),e(Ft,(function(e){return t(this.properties,e)})),e(Mt,(function(e){return this.computed_key()&&this.key.has_side_effects(e)||this.value.has_side_effects(e)})),e(It,(function(e){return this.computed_key()&&this.key.has_side_effects(e)||this.static&&this.value&&this.value.has_side_effects(e)})),e(Nt,(function(e){return this.computed_key()&&this.key.has_side_effects(e)})),e(xt,(function(e){return this.computed_key()&&this.key.has_side_effects(e)})),e(wt,(function(e){return this.computed_key()&&this.key.has_side_effects(e)})),e(Ot,(function(e){return t(this.elements,e)})),e(gt,(function(e){return this.expression.may_throw_on_access(e)||this.expression.has_side_effects(e)})),e(Dt,(function(e){return this.expression.may_throw_on_access(e)||this.expression.has_side_effects(e)||this.property.has_side_effects(e)})),e(ht,(function(e){return t(this.expressions,e)})),e(at,(function(e){return t(this.definitions,e)})),e(lt,(function(){return this.value})),e(Ge,s),e(Ue,(function(e){return t(this.segments,e)}));}((function(e,t){e.DEFMETHOD("has_side_effects",t);})),function(e){function t(e,t){for(var n=e.length;--n>=0;)if(e[n].may_throw(t))return !0;return !1}e(fe,u),e(cn,s),e(Se,s),e(ke,s),e(Kt,s),e(sn,s),e(kt,(function(e){return !(!this.extends||!this.extends.may_throw(e))||t(this.properties,e)})),e(Ot,(function(e){return t(this.elements,e)})),e(bt,(function(e){return !!this.right.may_throw(e)||!(!e.has_directive("use strict")&&"="==this.operator&&this.left instanceof nn)&&this.left.may_throw(e)})),e(Tt,(function(e){return this.left.may_throw(e)||this.right.may_throw(e)})),e(ge,(function(e){return t(this.body,e)})),e(dt,(function(e){return !!t(this.args,e)||!this.is_expr_pure(e)&&(!!this.expression.may_throw(e)||(!(this.expression instanceof ke)||t(this.expression.body,e)))})),e(nt,(function(e){return this.expression.may_throw(e)||t(this.body,e)})),e(yt,(function(e){return this.condition.may_throw(e)||this.consequent.may_throw(e)||this.alternative.may_throw(e)})),e(at,(function(e){return t(this.definitions,e)})),e(gt,(function(e){return this.expression.may_throw_on_access(e)||this.expression.may_throw(e)})),e(Je,(function(e){return this.condition.may_throw(e)||this.body&&this.body.may_throw(e)||this.alternative&&this.alternative.may_throw(e)})),e(Ae,(function(e){return this.body.may_throw(e)})),e(Ft,(function(e){return t(this.properties,e)})),e(Mt,(function(e){return this.value.may_throw(e)})),e(It,(function(e){return this.computed_key()&&this.key.may_throw(e)||this.static&&this.value&&this.value.may_throw(e)})),e(Nt,(function(e){return this.computed_key()&&this.key.may_throw(e)})),e(xt,(function(e){return this.computed_key()&&this.key.may_throw(e)})),e(wt,(function(e){return this.computed_key()&&this.key.may_throw(e)})),e(ze,(function(e){return this.value&&this.value.may_throw(e)})),e(ht,(function(e){return t(this.expressions,e)})),e(me,(function(e){return this.body.may_throw(e)})),e(Dt,(function(e){return this.expression.may_throw_on_access(e)||this.expression.may_throw(e)||this.property.may_throw(e)})),e(Qe,(function(e){return this.expression.may_throw(e)||t(this.body,e)})),e(nn,(function(e){return !this.is_declared(e)&&!Hi.has(this.name)})),e(qt,s),e(it,(function(e){return this.bcatch?this.bcatch.may_throw(e):t(this.body,e)||this.bfinally&&this.bfinally.may_throw(e)})),e(St,(function(e){return !("typeof"==this.operator&&this.expression instanceof nn)&&this.expression.may_throw(e)})),e(lt,(function(e){return !!this.value&&this.value.may_throw(e)}));}((function(e,t){e.DEFMETHOD("may_throw",t);})),function(e){function t(e){let t=!0;return Tn(this,n=>{if(n instanceof nn){if(ni(this,16))return t=!1,bn;var o=n.definition();if(i(o,this.enclosed)&&!this.variables.has(o.name)){if(e){var r=e.find_variable(n);if(o.undeclared?!r:r===o)return t="f",!0}return t=!1,bn}return !0}if(n instanceof sn&&this instanceof Ve)return t=!1,bn}),t}e(fe,s),e(cn,u),e(kt,(function(e){return !(this.extends&&!this.extends.is_constant_expression(e))&&t.call(this,e)})),e(ke,t),e(St,(function(){return this.expression.is_constant_expression()})),e(Tt,(function(){return this.left.is_constant_expression()&&this.right.is_constant_expression()})),e(Ot,(function(){return this.elements.every(e=>e.is_constant_expression())})),e(Ft,(function(){return this.properties.every(e=>e.is_constant_expression())})),e(Mt,(function(){return !(this.key instanceof fe)&&this.value.is_constant_expression()}));}((function(e,t){e.DEFMETHOD("is_constant_expression",t);})),function(e){function t(){for(var e=0;e<this.body.length;e++)if(Xi(this.body[e]))return this.body[e];return null}e(pe,l),e(He,c),e(pt,(function(){return null})),e(De,t),e(et,t),e(Je,(function(){return this.alternative&&Xi(this.body)&&Xi(this.alternative)&&this}));}((function(e,t){e.DEFMETHOD("aborts",t);}));var zi=new Set(["use asm","use strict"]);function Wi(e,t){return Fi(e.body,t),t.option("side_effects")&&1==e.body.length&&e.body[0]===t.has_directive("use strict")&&(e.body.length=0),e}ai(de,(function(e,t){return !t.option("directives")||zi.has(e.value)&&t.has_directive(e.value)===e?e:p(Se,e)})),ai(_e,(function(e,t){return t.option("drop_debugger")?p(Se,e):e})),ai(Ae,(function(e,t){return e.body instanceof qe&&t.loopcontrol_target(e.body)===e.body?p(Se,e):0==e.label.references.length?e.body:e})),ai(ge,(function(e,t){return Fi(e.body,t),e})),ai(De,(function(e,t){switch(Fi(e.body,t),e.body.length){case 1:if(!t.has_directive("use strict")&&t.parent()instanceof Je&&!((n=e.body[0])instanceof ct||n instanceof ut||n instanceof kt)||Si(e.body[0]))return e.body[0];break;case 0:return p(Se,e)}var n;return e})),ai(ke,Wi);const Yi=/keep_assign/;function qi(e,t){var n=!1,i=new Cn((function(t){return !!(n||t instanceof we)||(t instanceof Ye&&i.loopcontrol_target(t)===e?n=!0:void 0)}));return t instanceof Ae&&i.push(t),i.push(e),e.body.walk(i),n}function $i(e,t){return t.top_retain&&e instanceof Pe&&ni(e,1024)&&e.name&&t.top_retain(e.name)}we.DEFMETHOD("drop_unused",(function(e){if(!e.option("unused"))return;if(e.has_directive("use asm"))return;var t=this;if(t.pinned())return;var n=!(t instanceof xe)||e.toplevel.funcs,i=!(t instanceof xe)||e.toplevel.vars;const o=Yi.test(e.option("unused"))?s:function(e){return e instanceof bt&&(ni(e,32)||"="==e.operator)?e.left:e instanceof St&&ni(e,32)?e.expression:void 0};var r=new Map,a=new Map;t instanceof xe&&e.top_retain&&t.variables.forEach((function(t){e.top_retain(t)&&!r.has(t.id)&&r.set(t.id,t);}));var u=new Map,c=new Map,l=this,_=new Cn((function(o,s){if(o instanceof ke&&o.uses_arguments&&!_.has_directive("use strict")&&o.argnames.forEach((function(e){if(e instanceof Kt){var t=e.definition();r.has(t.id)||r.set(t.id,t);}})),o!==t){if(o instanceof Pe||o instanceof Lt){var f=o.name.definition();return (_.parent()instanceof _t||!n&&l===t)&&f.global&&!r.has(f.id)&&r.set(f.id,f),o instanceof Lt&&o.extends&&(o.extends.has_side_effects(e)||o.extends.may_throw(e))&&o.extends.walk(_),g(c,f.id,o),!0}if(o instanceof zt&&l===t&&g(u,o.definition().id,o),o instanceof at&&l===t){const t=_.parent()instanceof _t;return o.definitions.forEach((function(n){if(n.name instanceof Ut&&g(u,n.name.definition().id,n),!t&&i||Tn(n.name,e=>{if(e instanceof Kt){const n=e.definition();!t&&!n.global||r.has(n.id)||r.set(n.id,n);}}),n.value){if(n.name instanceof Be)n.walk(_);else{var o=n.name.definition();g(c,o.id,n.value),o.chained||n.name.fixed_value()!==n.value||a.set(o.id,n);}n.value.has_side_effects(e)&&n.value.walk(_);}})),!0}return h(o,s)}}));t.walk(_),_=new Cn(h),r.forEach((function(e){var t=c.get(e.id);t&&t.forEach((function(e){e.walk(_);}));}));var d=new On((function(s,c,_){var h=d.parent();if(i){const e=o(s);if(e instanceof nn){var E=e.definition(),g=r.has(E.id);if(s instanceof bt){if(!g||a.has(E.id)&&a.get(E.id)!==s)return hi(h,s,s.right.transform(d))}else if(!g)return _?f.skip:p(fn,s,{value:0})}}if(l===t){if(s.name&&(s instanceof Vt&&!S(e.option("keep_classnames"),(E=s.name.definition()).name)||s instanceof Le&&!S(e.option("keep_fnames"),(E=s.name.definition()).name))&&(!r.has(E.id)||E.orig.length>1)&&(s.name=null),s instanceof ke&&!(s instanceof Ie))for(var D=!e.option("keep_fargs"),v=s.argnames,A=v.length;--A>=0;){var T=v[A];T instanceof Ne&&(T=T.expression),T instanceof Ct&&(T=T.left),T instanceof Be||r.has(T.definition().id)?D=!1:(ii(T,1),D&&(v.pop(),e[T.unreferenced()?"warn":"info"]("Dropping unused function argument {name} [{file}:{line},{col}]",R(T))));}if((s instanceof Pe||s instanceof Lt)&&s!==t){const t=s.name.definition();if(!(t.global&&!n||r.has(t.id))){if(e[s.name.unreferenced()?"warn":"info"]("Dropping unused function {name} [{file}:{line},{col}]",R(s.name)),t.eliminated++,s instanceof Lt){const t=s.drop_side_effect_free(e);if(t)return p(me,s,{body:t})}return _?f.skip:p(Se,s)}}if(s instanceof at&&!(h instanceof Fe&&h.init===s)){var y=!(h instanceof xe||s instanceof st),b=[],C=[],O=[],F=[];switch(s.definitions.forEach((function(t){t.value&&(t.value=t.value.transform(d));var n=t.name instanceof Be,o=n?new Xn(null,{name:"<destructure>"}):t.name.definition();if(y&&o.global)return O.push(t);if(!i&&!y||n&&(t.name.names.length||t.name.is_array||1!=e.option("pure_getters"))||r.has(o.id)){if(t.value&&a.has(o.id)&&a.get(o.id)!==t&&(t.value=t.value.drop_side_effect_free(e)),t.name instanceof Ut){var c=u.get(o.id);if(c.length>1&&(!t.value||o.orig.indexOf(t.name)>o.eliminated)){if(e.warn("Dropping duplicated definition of variable {name} [{file}:{line},{col}]",R(t.name)),t.value){var l=p(nn,t.name,t.name);o.references.push(l);var f=p(bt,t,{operator:"=",left:l,right:t.value});a.get(o.id)===t&&a.set(o.id,f),F.push(f.transform(d));}return m(c,t),void o.eliminated++}}t.value?(F.length>0&&(O.length>0?(F.push(t.value),t.value=di(t.value,F)):b.push(p(me,s,{body:di(s,F)})),F=[]),O.push(t)):C.push(t);}else if(o.orig[0]instanceof Jt){(_=t.value&&t.value.drop_side_effect_free(e))&&F.push(_),t.value=null,C.push(t);}else{var _;(_=t.value&&t.value.drop_side_effect_free(e))?(n||e.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]",R(t.name)),F.push(_)):n||e[t.name.unreferenced()?"warn":"info"]("Dropping unused variable {name} [{file}:{line},{col}]",R(t.name)),o.eliminated++;}})),(C.length>0||O.length>0)&&(s.definitions=C.concat(O),b.push(s)),F.length>0&&b.push(p(me,s,{body:di(s,F)})),b.length){case 0:return _?f.skip:p(Se,s);case 1:return b[0];default:return _?f.splice(b):p(De,s,{body:b})}}if(s instanceof Oe)return c(s,this),s.init instanceof De&&(M=s.init,s.init=M.body.pop(),M.body.push(s)),s.init instanceof me?s.init=s.init.body:Di(s.init)&&(s.init=null),M?_?f.splice(M.body):M:s;if(s instanceof Ae&&s.body instanceof Oe){if(c(s,this),s.body instanceof De){var M=s.body;return s.body=M.body.pop(),M.body.push(s),_?f.splice(M.body):M}return s}if(s instanceof De)return c(s,this),_&&s.body.every(Si)?f.splice(s.body):s;if(s instanceof we){const e=l;return l=s,c(s,this),l=e,s}}function R(e){return {name:e.name,file:e.start.file,line:e.start.line,col:e.start.col}}}));function h(e,n){var i;const s=o(e);if(s instanceof nn&&!fi(e.left,Gt)&&t.variables.get(s.name)===(i=s.definition()))return e instanceof bt&&(e.right.walk(_),i.chained||e.left.fixed_value()!==e.right||a.set(i.id,e)),!0;if(e instanceof nn){if(i=e.definition(),!r.has(i.id)&&(r.set(i.id,i),i.orig[0]instanceof Jt)){const e=i.scope.is_block_scope()&&i.scope.get_defun_scope().variables.get(i.name);e&&r.set(e.id,e);}return !0}if(e instanceof we){var u=l;return l=e,n(),l=u,!0}}t.transform(d);})),we.DEFMETHOD("hoist_declarations",(function(e){var t=this;if(e.has_directive("use asm"))return t;if(!Array.isArray(t.body))return t;var n=e.option("hoist_funs"),i=e.option("hoist_vars");if(n||i){var o=[],r=[],a=new Map,s=0,u=0;Tn(t,e=>e instanceof we&&e!==t||(e instanceof st?(++u,!0):void 0)),i=i&&u>1;var c=new On((function(u){if(u!==t){if(u instanceof de)return o.push(u),p(Se,u);if(n&&u instanceof Pe&&!(c.parent()instanceof _t)&&c.parent()===t)return r.push(u),p(Se,u);if(i&&u instanceof st){u.definitions.forEach((function(e){e.name instanceof Be||(a.set(e.name.name,e),++s);}));var l=u.to_assignments(e),f=c.parent();if(f instanceof Fe&&f.init===u){if(null==l){var _=u.definitions[0].name;return p(nn,_,_)}return l}return f instanceof Oe&&f.init===u?l:l?p(me,u,{body:l}):p(Se,u)}if(u instanceof we)return u}}));if(t=t.transform(c),s>0){var l=[];const e=t instanceof ke,n=e?t.args_as_names():null;if(a.forEach((t,i)=>{e&&n.some(e=>e.name===t.name.name)?a.delete(i):((t=t.clone()).value=null,l.push(t),a.set(i,t));}),l.length>0){for(var f=0;f<t.body.length;){if(t.body[f]instanceof me){var _,d,h=t.body[f].body;if(h instanceof bt&&"="==h.operator&&(_=h.left)instanceof Pt&&a.has(_.name)){if((E=a.get(_.name)).value)break;E.value=h.right,m(l,E),l.push(E),t.body.splice(f,1);continue}if(h instanceof ht&&(d=h.expressions[0])instanceof bt&&"="==d.operator&&(_=d.left)instanceof Pt&&a.has(_.name)){var E;if((E=a.get(_.name)).value)break;E.value=d.right,m(l,E),l.push(E),t.body[f].body=di(h,h.expressions.slice(1));continue}}if(t.body[f]instanceof Se)t.body.splice(f,1);else{if(!(t.body[f]instanceof De))break;var g=[f,1].concat(t.body[f].body);t.body.splice.apply(t.body,g);}}l=p(st,t,{definitions:l}),r.push(l);}}t.body=o.concat(r,t.body);}return t})),we.DEFMETHOD("make_var_name",(function(e){for(var t=this.var_names(),n=e=e.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/gi,"_"),i=0;t.has(n);i++)n=e+"$"+i;return this.add_var_name(n),n})),we.DEFMETHOD("hoist_properties",(function(e){var t=this;if(!e.option("hoist_props")||e.has_directive("use asm"))return t;var n=t instanceof xe&&e.top_retain||s,i=new Map,o=new On((function(r,a){if(r instanceof at&&o.parent()instanceof _t)return r;if(r instanceof lt){const o=r.name;let u,c;if(o.scope===t&&1!=(u=o.definition()).escaped&&!u.assignments&&!u.direct_access&&!u.single_use&&!e.exposed(u)&&!n(u)&&(c=o.fixed_value())===r.value&&c instanceof Ft&&c.properties.every(e=>"string"==typeof e.key)){a(r,this);const e=new Map,t=[];return c.properties.forEach((function(n){t.push(p(lt,r,{name:s(o,n.key,e),value:n.value}));})),i.set(u.id,e),f.splice(t)}}else if(r instanceof Et&&r.expression instanceof nn){const e=i.get(r.expression.definition().id);if(e){const t=e.get(String(Ri(r.property))),n=p(nn,r,{name:t.name,scope:r.expression.scope,thedef:t});return n.reference({}),n}}function s(e,n,i){const o=p(e.CTOR,e,{name:t.make_var_name(e.name+"_"+n),scope:t}),r=t.def_variable(o);return i.set(String(n),r),t.enclosed.push(r),o}}));return t.transform(o)})),function(e){function t(e,t,n){var i=e.length;if(!i)return null;for(var o=[],r=!1,a=0;a<i;a++){var s=e[a].drop_side_effect_free(t,n);r|=s!==e[a],s&&(o.push(s),n=!1);}return r?o.length?o:null:e}e(fe,c),e(cn,l),e(sn,l),e(dt,(function(e,n){if(!this.is_expr_pure(e)){if(this.expression.is_call_pure(e)){var i=this.args.slice();return i.unshift(this.expression.expression),(i=t(i,e,n))&&di(this,i)}if(ci(this.expression)&&(!this.expression.name||!this.expression.name.definition().references.length)){var o=this.clone();return o.expression.process_expression(!1,e),o}return this}T(this,Fn)&&e.warn("Dropping __PURE__ call [{file}:{line},{col}]",this.start);var r=t(this.args,e,n);return r&&di(this,r)})),e(Ie,l),e(Le,l),e(Ve,l),e(kt,(function(e){const t=[],n=this.extends&&this.extends.drop_side_effect_free(e);n&&t.push(n);for(const n of this.properties){const i=n.drop_side_effect_free(e);i&&t.push(i);}return t.length?di(this,t):null})),e(Tt,(function(e,t){var n=this.right.drop_side_effect_free(e);if(!n)return this.left.drop_side_effect_free(e,t);if(xi.has(this.operator)){if(n===this.right)return this;var i=this.clone();return i.right=n,i}var o=this.left.drop_side_effect_free(e,t);return o?di(this,[o,n]):this.right.drop_side_effect_free(e,t)})),e(bt,(function(e){var t=this.left;if(t.has_side_effects(e)||e.has_directive("use strict")&&t instanceof Et&&t.expression.is_constant())return this;for(ii(this,32);t instanceof Et;)t=t.expression;return t.is_constant_expression(e.find_parent(we))?this.right.drop_side_effect_free(e):this})),e(yt,(function(e){var t=this.consequent.drop_side_effect_free(e),n=this.alternative.drop_side_effect_free(e);if(t===this.consequent&&n===this.alternative)return this;if(!t)return n?p(Tt,this,{operator:"||",left:this.condition,right:n}):this.condition.drop_side_effect_free(e);if(!n)return p(Tt,this,{operator:"&&",left:this.condition,right:t});var i=this.clone();return i.consequent=t,i.alternative=n,i})),e(St,(function(e,t){if(Ni.has(this.operator))return this.expression.has_side_effects(e)?oi(this,32):ii(this,32),this;if("typeof"==this.operator&&this.expression instanceof nn)return null;var n=this.expression.drop_side_effect_free(e,t);return t&&n&&Ai(n)?n===this.expression&&"!"==this.operator?this:n.negate(e,t):n})),e(nn,(function(e){return this.is_declared(e)||Hi.has(this.name)?null:this})),e(Ft,(function(e,n){var i=t(this.properties,e,n);return i&&di(this,i)})),e(Mt,(function(e,t){const n=this instanceof Rt&&this.key instanceof fe&&this.key.drop_side_effect_free(e,t),i=this.value.drop_side_effect_free(e,t);return n&&i?di(this,[n,i]):n||i})),e(It,(function(e){const t=this.computed_key()&&this.key.drop_side_effect_free(e),n=this.static&&this.value&&this.value.drop_side_effect_free(e);return t&&n?di(this,[t,n]):t||n||null})),e(Nt,(function(){return this.computed_key()?this.key:null})),e(xt,(function(){return this.computed_key()?this.key:null})),e(wt,(function(){return this.computed_key()?this.key:null})),e(Ot,(function(e,n){var i=t(this.elements,e,n);return i&&di(this,i)})),e(gt,(function(e,t){return this.expression.may_throw_on_access(e)?this:this.expression.drop_side_effect_free(e,t)})),e(Dt,(function(e,t){if(this.expression.may_throw_on_access(e))return this;var n=this.expression.drop_side_effect_free(e,t);if(!n)return this.property.drop_side_effect_free(e,t);var i=this.property.drop_side_effect_free(e);return i?di(this,[n,i]):n})),e(ht,(function(e){var t=this.tail_node(),n=t.drop_side_effect_free(e);if(n===t)return this;var i=this.expressions.slice(0,-1);return n&&i.push(n),i.length?di(this,i):p(fn,this,{value:0})})),e(Ne,(function(e,t){return this.expression.drop_side_effect_free(e,t)})),e(Ge,l),e(Ue,(function(e){var n=t(this.segments,e,kn);return n&&di(this,n)}));}((function(e,t){e.DEFMETHOD("drop_side_effect_free",t);})),ai(me,(function(e,t){if(t.option("side_effects")){var n=e.body,i=n.drop_side_effect_free(t,!0);if(!i)return t.warn("Dropping side-effect-free statement [{file}:{line},{col}]",e.start),p(Se,e);if(i!==n)return p(me,e,{body:i})}return e})),ai(Ce,(function(e,t){return t.option("loops")?p(Oe,e,e).optimize(t):e})),ai(be,(function(e,t){if(!t.option("loops"))return e;var n=e.condition.tail_node().evaluate(t);if(!(n instanceof fe)){if(n)return p(Oe,e,{body:p(De,e.body,{body:[e.body,p(me,e.condition,{body:e.condition})]})}).optimize(t);if(!qi(e,t.parent()))return p(De,e.body,{body:[e.body,p(me,e.condition,{body:e.condition})]}).optimize(t)}return e})),ai(Oe,(function(e,t){if(!t.option("loops"))return e;if(t.option("side_effects")&&e.init&&(e.init=e.init.drop_side_effect_free(t)),e.condition){var n=e.condition.evaluate(t);if(!(n instanceof fe))if(n)e.condition=null;else if(!t.option("dead_code")){var i=e.condition;e.condition=mi(n,e.condition),e.condition=Ii(e.condition.transform(t),i);}if(t.option("dead_code")&&(n instanceof fe&&(n=e.condition.tail_node().evaluate(t)),!n)){var o=[];return Mi(t,e.body,o),e.init instanceof pe?o.push(e.init):e.init&&o.push(p(me,e.init,{body:e.init})),o.push(p(me,e.condition,{body:e.condition})),p(De,e,{body:o}).optimize(t)}}return function e(t,n){var i=t.body instanceof De?t.body.body[0]:t.body;if(n.option("dead_code")&&r(i)){var o=[];return t.init instanceof pe?o.push(t.init):t.init&&o.push(p(me,t.init,{body:t.init})),t.condition&&o.push(p(me,t.condition,{body:t.condition})),Mi(n,t.body,o),p(De,t,{body:o})}return i instanceof Je&&(r(i.body)?(t.condition?t.condition=p(Tt,t.condition,{left:t.condition,operator:"&&",right:i.condition.negate(n)}):t.condition=i.condition.negate(n),a(i.alternative)):r(i.alternative)&&(t.condition?t.condition=p(Tt,t.condition,{left:t.condition,operator:"&&",right:i.condition}):t.condition=i.condition,a(i.body))),t;function r(e){return e instanceof qe&&n.loopcontrol_target(e)===n.self()}function a(i){i=gi(i),t.body instanceof De?(t.body=t.body.clone(),t.body.body=i.concat(t.body.body.slice(1)),t.body=t.body.transform(n)):t.body=p(De,t.body,{body:i}).transform(n),t=e(t,n);}}(e,t)})),ai(Je,(function(e,t){if(Di(e.alternative)&&(e.alternative=null),!t.option("conditionals"))return e;var n=e.condition.evaluate(t);if(!(t.option("dead_code")||n instanceof fe)){var i=e.condition;e.condition=mi(n,i),e.condition=Ii(e.condition.transform(t),i);}if(t.option("dead_code")){if(n instanceof fe&&(n=e.condition.tail_node().evaluate(t)),!n){t.warn("Condition always false [{file}:{line},{col}]",e.condition.start);var o=[];return Mi(t,e.body,o),o.push(p(me,e.condition,{body:e.condition})),e.alternative&&o.push(e.alternative),p(De,e,{body:o}).optimize(t)}if(!(n instanceof fe))return t.warn("Condition always true [{file}:{line},{col}]",e.condition.start),(o=[]).push(p(me,e.condition,{body:e.condition})),o.push(e.body),e.alternative&&Mi(t,e.alternative,o),p(De,e,{body:o}).optimize(t)}var r=e.condition.negate(t),a=e.condition.size(),s=r.size(),u=s<a;if(e.alternative&&u){u=!1,e.condition=r;var c=e.body;e.body=e.alternative||p(Se,e),e.alternative=c;}if(Di(e.body)&&Di(e.alternative))return p(me,e.condition,{body:e.condition.clone()}).optimize(t);if(e.body instanceof me&&e.alternative instanceof me)return p(me,e,{body:p(yt,e,{condition:e.condition,consequent:e.body.body,alternative:e.alternative.body})}).optimize(t);if(Di(e.alternative)&&e.body instanceof me)return a===s&&!u&&e.condition instanceof Tt&&"||"==e.condition.operator&&(u=!0),u?p(me,e,{body:p(Tt,e,{operator:"||",left:r,right:e.body.body})}).optimize(t):p(me,e,{body:p(Tt,e,{operator:"&&",left:e.condition,right:e.body.body})}).optimize(t);if(e.body instanceof Se&&e.alternative instanceof me)return p(me,e,{body:p(Tt,e,{operator:"||",left:e.condition,right:e.alternative.body})}).optimize(t);if(e.body instanceof Xe&&e.alternative instanceof Xe&&e.body.TYPE==e.alternative.TYPE)return p(e.body.CTOR,e,{value:p(yt,e,{condition:e.condition,consequent:e.body.value||p(En,e.body),alternative:e.alternative.value||p(En,e.alternative)}).transform(t)}).optimize(t);if(e.body instanceof Je&&!e.body.alternative&&!e.alternative&&(e=p(Je,e,{condition:p(Tt,e.condition,{operator:"&&",left:e.condition,right:e.body.condition}),body:e.body.body,alternative:null})),Xi(e.body)&&e.alternative){var l=e.alternative;return e.alternative=null,p(De,e,{body:[e,l]}).optimize(t)}if(Xi(e.alternative)){o=e.body;return e.body=e.alternative,e.condition=u?r:e.condition.negate(t),e.alternative=null,p(De,e,{body:[e,o]}).optimize(t)}return e})),ai(Qe,(function(e,t){if(!t.option("switches"))return e;var n,i=e.expression.evaluate(t);if(!(i instanceof fe)){var o=e.expression;e.expression=mi(i,o),e.expression=Ii(e.expression.transform(t),o);}if(!t.option("dead_code"))return e;i instanceof fe&&(i=e.expression.tail_node().evaluate(t));for(var r,a,s=[],u=[],c=0,l=e.body.length;c<l&&!a;c++){if((n=e.body[c])instanceof tt)r?D(n,u[u.length-1]):r=n;else if(!(i instanceof fe)){if(!((E=n.expression.evaluate(t))instanceof fe)&&E!==i){D(n,u[u.length-1]);continue}if(E instanceof fe&&(E=n.expression.tail_node().evaluate(t)),E===i&&(a=n,r)){var f=u.indexOf(r);u.splice(f,1),D(r,u[f-1]),r=null;}}if(Xi(n)){var _=u[u.length-1];Xi(_)&&_.body.length==n.body.length&&p(De,_,_).equivalent_to(p(De,n,n))&&(_.body=[]);}u.push(n);}for(;c<l;)D(e.body[c++],u[u.length-1]);for(u.length>0&&(u[0].body=s.concat(u[0].body)),e.body=u;n=u[u.length-1];){var d=n.body[n.body.length-1];if(d instanceof qe&&t.loopcontrol_target(d)===e&&n.body.pop(),n.body.length||n instanceof nt&&(r||n.expression.has_side_effects(t)))break;u.pop()===r&&(r=null);}if(0==u.length)return p(De,e,{body:s.concat(p(me,e.expression,{body:e.expression}))}).optimize(t);if(1==u.length&&(u[0]===a||u[0]===r)){var m=!1,h=new Cn((function(t){if(m||t instanceof ke||t instanceof me)return !0;t instanceof qe&&h.loopcontrol_target(t)===e&&(m=!0);}));if(e.walk(h),!m){var E,g=u[0].body.slice();return (E=u[0].expression)&&g.unshift(p(me,E,{body:E})),g.unshift(p(me,e.expression,{body:e.expression})),p(De,e,{body:g}).optimize(t)}}return e;function D(e,n){n&&!Xi(n)?n.body=n.body.concat(e.body):Mi(t,e,s);}})),ai(it,(function(e,t){if(Fi(e.body,t),e.bcatch&&e.bfinally&&e.bfinally.body.every(Di)&&(e.bfinally=null),t.option("dead_code")&&e.body.every(Di)){var n=[];return e.bcatch&&Mi(t,e.bcatch,n),e.bfinally&&n.push(...e.bfinally.body),p(De,e,{body:n}).optimize(t)}return e})),at.DEFMETHOD("remove_initializers",(function(){var e=[];this.definitions.forEach((function(t){t.name instanceof Kt?(t.value=null,e.push(t)):Tn(t.name,n=>{n instanceof Kt&&e.push(p(lt,t,{name:n,value:null}));});})),this.definitions=e;})),at.DEFMETHOD("to_assignments",(function(e){var t=e.option("reduce_vars"),n=this.definitions.reduce((function(e,n){if(!n.value||n.name instanceof Be){if(n.value){var i=p(lt,n,{name:n.name,value:n.value}),o=p(st,n,{definitions:[i]});e.push(o);}}else{var r=p(nn,n.name,n.name);e.push(p(bt,n,{operator:"=",left:r,right:n.value})),t&&(r.definition().fixed=!1);}return (n=n.name.definition()).eliminated++,n.replaced--,e}),[]);return 0==n.length?null:di(this,n)})),ai(at,(function(e){return 0==e.definitions.length?p(Se,e):e})),ai(pt,(function(e){return e})),ai(dt,(function(e,t){var n=e.expression,i=n;ro(e,t,e.args);var o=e.args.every(e=>!(e instanceof Ne));if(t.option("reduce_vars")&&i instanceof nn&&!T(e,Rn)){const e=i.fixed_value();$i(e,t)||(i=e);}var r=i instanceof ke;if(t.option("unused")&&o&&r&&!i.uses_arguments&&!i.pinned()){for(var a=0,s=0,u=0,c=e.args.length;u<c;u++){if(i.argnames[u]instanceof Ne){if(ni(i.argnames[u].expression,1))for(;u<c;){(D=e.args[u++].drop_side_effect_free(t))&&(e.args[a++]=D);}else for(;u<c;)e.args[a++]=e.args[u++];s=a;break}var l=u>=i.argnames.length;if(l||ni(i.argnames[u],1)){if(D=e.args[u].drop_side_effect_free(t))e.args[a++]=D;else if(!l){e.args[a++]=p(fn,e.args[u],{value:0});continue}}else e.args[a++]=e.args[u];s=a;}e.args.length=s;}if(t.option("unsafe"))if(Ti(n))switch(n.name){case"Array":if(1!=e.args.length)return p(Ot,e,{elements:e.args}).optimize(t);if(e.args[0]instanceof fn&&e.args[0].value<=11){const t=[];for(let n=0;n<e.args[0].value;n++)t.push(new gn);return new Ot({elements:t})}break;case"Object":if(0==e.args.length)return p(Ft,e,{properties:[]});break;case"String":if(0==e.args.length)return p(ln,e,{value:""});if(e.args.length<=1)return p(Tt,e,{left:e.args[0],operator:"+",right:p(ln,e,{value:""})}).optimize(t);break;case"Number":if(0==e.args.length)return p(fn,e,{value:0});if(1==e.args.length&&t.option("unsafe_math"))return p(vt,e,{expression:e.args[0],operator:"+"}).optimize(t);break;case"Symbol":1==e.args.length&&e.args[0]instanceof ln&&t.option("unsafe_symbols")&&(e.args.length=0);break;case"Boolean":if(0==e.args.length)return p(vn,e);if(1==e.args.length)return p(vt,e,{expression:p(vt,e,{expression:e.args[0],operator:"!"}),operator:"!"}).optimize(t);break;case"RegExp":var f=[];if(e.args.length>=1&&e.args.length<=2&&e.args.every(e=>{var n=e.evaluate(t);return f.push(n),e!==n})){let[n,i]=f;n=A(new RegExp(n).source);const o=p(_n,e,{value:{source:n,flags:i}});if(o._eval(t)!==o)return o;t.warn("Error converting {expr} [{file}:{line},{col}]",{expr:e.print_to_string(),file:e.start.file,line:e.start.line,col:e.start.col});}}else if(n instanceof gt)switch(n.property){case"toString":if(0==e.args.length&&!n.expression.may_throw_on_access(t))return p(Tt,e,{left:p(ln,e,{value:""}),operator:"+",right:n.expression}).optimize(t);break;case"join":if(n.expression instanceof Ot)e:{var _;if(!(e.args.length>0&&(_=e.args[0].evaluate(t))===e.args[0])){var d,m=[],h=[];for(u=0,c=n.expression.elements.length;u<c;u++){var E=n.expression.elements[u];if(E instanceof Ne)break e;var g=E.evaluate(t);g!==E?h.push(g):(h.length>0&&(m.push(p(ln,e,{value:h.join(_)})),h.length=0),m.push(E));}return h.length>0&&m.push(p(ln,e,{value:h.join(_)})),0==m.length?p(ln,e,{value:""}):1==m.length?m[0].is_string(t)?m[0]:p(Tt,m[0],{operator:"+",left:p(ln,e,{value:""}),right:m[0]}):""==_?(d=m[0].is_string(t)||m[1].is_string(t)?m.shift():p(ln,e,{value:""}),m.reduce((function(e,t){return p(Tt,t,{operator:"+",left:e,right:t})}),d).optimize(t)):((D=e.clone()).expression=D.expression.clone(),D.expression.expression=D.expression.expression.clone(),D.expression.expression.elements=m,Vi(t,e,D));var D;}}break;case"charAt":if(n.expression.is_string(t)){var S=e.args[0],v=S?S.evaluate(t):0;if(v!==S)return p(Dt,n,{expression:n.expression,property:mi(0|v,S||n)}).optimize(t)}break;case"apply":if(2==e.args.length&&e.args[1]instanceof Ot)return (L=e.args[1].elements.slice()).unshift(e.args[0]),p(dt,e,{expression:p(gt,n,{expression:n.expression,property:"call"}),args:L}).optimize(t);break;case"call":var y=n.expression;if(y instanceof nn&&(y=y.fixed_value()),y instanceof ke&&!y.contains_this())return (e.args.length?di(this,[e.args[0],p(dt,e,{expression:n.expression,args:e.args.slice(1)})]):p(dt,e,{expression:n.expression,args:[]})).optimize(t)}if(t.option("unsafe_Function")&&Ti(n)&&"Function"==n.name){if(0==e.args.length)return p(Le,e,{argnames:[],body:[]}).optimize(t);if(e.args.every(e=>e instanceof ln))try{var b=ue(M="n(function("+e.args.slice(0,-1).map((function(e){return e.value})).join(",")+"){"+e.args[e.args.length-1].value+"})"),C={ie8:t.option("ie8")};b.figure_out_scope(C);var O,F=new ri(t.options);(b=b.transform(F)).figure_out_scope(C),Yn.reset(),b.compute_char_frequency(C),b.mangle_names(C),Tn(b,e=>{if(ci(e))return O=e,bn});var M=Pn();return De.prototype._codegen.call(O,O,M),e.args=[p(ln,e,{value:O.argnames.map((function(e){return e.print_to_string()})).join(",")}),p(ln,e.args[e.args.length-1],{value:M.get().replace(/^{|}$/g,"")})],e}catch(n){if(!(n instanceof J))throw n;t.warn("Error parsing code passed to new Function [{file}:{line},{col}]",e.args[e.args.length-1].start),t.warn(n.toString());}}var R=r&&i.body[0],w=r&&!i.is_generator&&!i.async,x=w&&t.option("inline")&&!e.is_expr_pure(t);if(x&&R instanceof ze){let n=R.value;if(!n||n.is_constant_expression()){n=n?n.clone(!0):p(En,e);const i=e.args.concat(n);return di(e,i).optimize(t)}if(1===i.argnames.length&&i.argnames[0]instanceof zt&&e.args.length<2&&n instanceof nn&&n.name===i.argnames[0].name)return (e.args[0]||p(En)).optimize(t)}if(x){var N,k,I=-1;let r,a;if(o&&!i.uses_arguments&&!i.pinned()&&!(t.parent()instanceof kt)&&!(i.name&&i instanceof Le)&&(a=function(e){var n=i.body,o=n.length;if(t.option("inline")<3)return 1==o&&P(e);e=null;for(var r=0;r<o;r++){var a=n[r];if(a instanceof st){if(e&&!a.definitions.every(e=>!e.value))return !1}else{if(e)return !1;a instanceof Se||(e=a);}}return P(e)}(R))&&(n===i||T(e,Mn)||t.option("unused")&&1==(r=n.definition()).references.length&&!Zi(t,r)&&i.is_constant_expression(n.scope))&&!T(e,Fn|Rn)&&!i.contains_this()&&function(){var n=new Set;do{if((N=t.parent(++I)).is_block_scope()&&N.block_scope&&N.block_scope.variables.forEach((function(e){n.add(e.name);})),N instanceof ot)N.argname&&n.add(N.argname.name);else if(N instanceof Te)k=[];else if(N instanceof nn&&N.fixed_value()instanceof we)return !1}while(!(N instanceof we));var o=!(N instanceof xe)||t.toplevel.vars,r=t.option("inline");return !!function(e,t){for(var n=i.body.length,o=0;o<n;o++){var r=i.body[o];if(r instanceof st){if(!t)return !1;for(var a=r.definitions.length;--a>=0;){var s=r.definitions[a].name;if(s instanceof Be||e.has(s.name)||Ci.has(s.name)||N.var_names().has(s.name))return !1;k&&k.push(s.definition());}}}return !0}(n,r>=3&&o)&&(!!function(e,t){for(var n=0,o=i.argnames.length;n<o;n++){var r=i.argnames[n];if(r instanceof Ct){if(ni(r.left,1))continue;return !1}if(r instanceof Be)return !1;if(r instanceof Ne){if(ni(r.expression,1))continue;return !1}if(!ni(r,1)){if(!t||e.has(r.name)||Ci.has(r.name)||N.var_names().has(r.name))return !1;k&&k.push(r.definition());}}return !0}(n,r>=2&&o)&&(!!function(){var t=new Set;const n=e=>{if(e instanceof we){var n=new Set;return e.enclosed.forEach((function(e){n.add(e.name);})),e.variables.forEach((function(e){n.delete(e);})),n.forEach((function(e){t.add(e);})),!0}};for(let t=0;t<e.args.length;t++)Tn(e.args[t],n);if(0==t.size)return !0;for(let e=0,n=i.argnames.length;e<n;e++){var o=i.argnames[e];if(!(o instanceof Ct&&ni(o.left,1))&&(!(o instanceof Ne&&ni(o.expression,1))&&!ni(o,1)&&t.has(o.name)))return !1}for(let e=0,n=i.body.length;e<n;e++){var r=i.body[e];if(r instanceof st)for(var a=r.definitions.length;--a>=0;){var s=r.definitions[a].name;if(s instanceof Be||t.has(s.name))return !1}}return !0}()&&(!k||0==k.length||!eo(i,k))))}()&&!Ji(N,i)&&!(N instanceof kt))return ii(i,256),pi(t,!0).add_child_scope(i),di(e,function(n){var o=[],r=[];if(function(t,n){for(var o=i.argnames.length,r=e.args.length;--r>=o;)n.push(e.args[r]);for(r=o;--r>=0;){var a=i.argnames[r],s=e.args[r];if(ni(a,1)||!a.name||N.var_names().has(a.name))s&&n.push(s);else{var u=p(Ut,a,a);a.definition().orig.push(u),!s&&k&&(s=p(En,e)),B(t,n,u,s);}}t.reverse(),n.reverse();}(o,r),function(e,t){for(var n=t.length,o=0,r=i.body.length;o<r;o++){var a=i.body[o];if(a instanceof st)for(var s=0,u=a.definitions.length;s<u;s++){var c=a.definitions[s],l=c.name;if(B(e,t,l,c.value),k&&i.argnames.every(e=>e.name!=l.name)){var f=i.variables.get(l.name),_=p(nn,l,l);f.references.push(_),t.splice(n++,0,p(bt,c,{operator:"=",left:_,right:p(En,l)}));}}}}(o,r),r.push(n),o.length){const e=N.body.indexOf(t.parent(I-1))+1;N.body.splice(e,0,p(st,i,{definitions:o}));}return r.map(e=>e.clone(!0))}(a)).optimize(t)}if(w&&t.option("side_effects")&&i.body.every(Di)){var L=e.args.concat(p(En,e));return di(e,L).optimize(t)}if(t.option("negate_iife")&&t.parent()instanceof me&&Ai(e))return e.negate(t,!0);var V=e.evaluate(t);return V!==e?(V=mi(V,e).optimize(t),Vi(t,V,e)):e;function P(t){return t?t instanceof ze?t.value?t.value.clone(!0):p(En,e):t instanceof me?p(vt,t,{operator:"void",expression:t.body.clone(!0)}):void 0:p(En,e)}function B(t,n,i,o){var r=i.definition();N.variables.set(i.name,r),N.enclosed.push(r),N.var_names().has(i.name)||(N.add_var_name(i.name),t.push(p(lt,i,{name:i,value:null})));var a=p(nn,i,i);r.references.push(a),o&&n.push(p(bt,e,{operator:"=",left:a,right:o.clone()}));}})),ai(mt,(function(e,t){return t.option("unsafe")&&Ti(e.expression)&&["Object","RegExp","Function","Error","Array"].includes(e.expression.name)?p(dt,e,e).transform(t):e})),ai(ht,(function(e,t){if(!t.option("side_effects"))return e;var n,i,o=[];n=kn(t),i=e.expressions.length-1,e.expressions.forEach((function(e,r){r<i&&(e=e.drop_side_effect_free(t,n)),e&&(Ei(o,e),n=!1);}));var r=o.length-1;return function(){for(;r>0&&wi(o[r],t);)r--;r<o.length-1&&(o[r]=p(vt,e,{operator:"void",expression:o[r]}),o.length=r+1);}(),0==r?((e=hi(t.parent(),t.self(),o[0]))instanceof ht||(e=e.optimize(t)),e):(e.expressions=o,e)})),St.DEFMETHOD("lift_sequences",(function(e){if(e.option("sequences")&&this.expression instanceof ht){var t=this.expression.expressions.slice(),n=this.clone();return n.expression=t.pop(),t.push(n),di(this,t).optimize(e)}return this})),ai(At,(function(e,t){return e.lift_sequences(t)})),ai(vt,(function(e,t){var n=e.expression;if("delete"==e.operator&&!(n instanceof nn||n instanceof Et||Oi(n))){if(n instanceof ht){const i=n.expressions.slice();return i.push(p(An,e)),di(e,i).optimize(t)}return di(e,[n,p(An,e)]).optimize(t)}var i=e.lift_sequences(t);if(i!==e)return i;if(t.option("side_effects")&&"void"==e.operator)return (n=n.drop_side_effect_free(t))?(e.expression=n,e):p(En,e).optimize(t);if(t.in_boolean_context())switch(e.operator){case"!":if(n instanceof vt&&"!"==n.operator)return n.expression;n instanceof Tt&&(e=Vi(t,e,n.negate(t,kn(t))));break;case"typeof":return t.warn("Boolean expression always true [{file}:{line},{col}]",e.start),(n instanceof nn?p(An,e):di(e,[n,p(An,e)])).optimize(t)}if("-"==e.operator&&n instanceof Dn&&(n=n.transform(t)),n instanceof Tt&&("+"==e.operator||"-"==e.operator)&&("*"==n.operator||"/"==n.operator||"%"==n.operator))return p(Tt,e,{operator:n.operator,left:p(vt,n.left,{operator:e.operator,expression:n.left}),right:n.right});if("-"!=e.operator||!(n instanceof fn||n instanceof Dn||n instanceof pn)){var o=e.evaluate(t);if(o!==e)return Vi(t,o=mi(o,e).optimize(t),e)}return e})),Tt.DEFMETHOD("lift_sequences",(function(e){if(e.option("sequences")){if(this.left instanceof ht){var t=this.left.expressions.slice();return (n=this.clone()).left=t.pop(),t.push(n),di(this,t).optimize(e)}if(this.right instanceof ht&&!this.left.has_side_effects(e)){for(var n,i="="==this.operator&&this.left instanceof nn,o=(t=this.right.expressions).length-1,r=0;r<o&&(i||!t[r].has_side_effects(e));r++);if(r==o)return t=t.slice(),(n=this.clone()).right=t.pop(),t.push(n),di(this,t).optimize(e);if(r>0)return (n=this.clone()).right=di(this.right,t.slice(r)),(t=t.slice(0,r)).push(n),di(this,t).optimize(e)}}return this}));var ji=E("== === != !== * & | ^");function Zi(e,t){for(var n,i=0;n=e.parent(i);i++)if(n instanceof ke||n instanceof kt){var o=n.name;if(o&&o.definition()===t)break}return n}function Ji(e,t){for(const n of t.enclosed){if(t.variables.has(n.name))continue;const i=e.find_variable(n.name);if(i){if(i===n)continue;return !0}}return !1}function Qi(e,t){return e instanceof nn||e.TYPE===t.TYPE}function eo(e,t){const n=e=>{if(e instanceof nn&&i(e.definition(),t))return bn};return yn(e,(t,i)=>{if(t instanceof we&&t!==e){var o=i.parent();if(o instanceof dt&&o.expression===t)return;return !Tn(t,n)||bn}})}ai(Tt,(function(e,t){function n(){return e.left.is_constant()||e.right.is_constant()||!e.left.has_side_effects(t)&&!e.right.has_side_effects(t)}function i(t){if(n()){t&&(e.operator=t);var i=e.left;e.left=e.right,e.right=i;}}if(ji.has(e.operator)&&e.right.is_constant()&&!e.left.is_constant()&&(e.left instanceof Tt&&ae[e.left.operator]>=ae[e.operator]||i()),e=e.lift_sequences(t),t.option("comparisons"))switch(e.operator){case"===":case"!==":var o=!0;(e.left.is_string(t)&&e.right.is_string(t)||e.left.is_number(t)&&e.right.is_number(t)||e.left.is_boolean()&&e.right.is_boolean()||e.left.equivalent_to(e.right))&&(e.operator=e.operator.substr(0,2));case"==":case"!=":if(!o&&wi(e.left,t))e.left=p(mn,e.left);else if(t.option("typeofs")&&e.left instanceof ln&&"undefined"==e.left.value&&e.right instanceof vt&&"typeof"==e.right.operator){var r=e.right.expression;(r instanceof nn?!r.is_declared(t):r instanceof Et&&t.option("ie8"))||(e.right=r,e.left=p(En,e.left).optimize(t),2==e.operator.length&&(e.operator+="="));}else if(e.left instanceof nn&&e.right instanceof nn&&e.left.definition()===e.right.definition()&&((u=e.left.fixed_value())instanceof Ot||u instanceof ke||u instanceof Ft||u instanceof kt))return p("="==e.operator[0]?An:vn,e);break;case"&&":case"||":var a=e.left;if(a.operator==e.operator&&(a=a.right),a instanceof Tt&&a.operator==("&&"==e.operator?"!==":"===")&&e.right instanceof Tt&&a.operator==e.right.operator&&(wi(a.left,t)&&e.right.left instanceof mn||a.left instanceof mn&&wi(e.right.left,t))&&!a.right.has_side_effects(t)&&a.right.equivalent_to(e.right.right)){var s=p(Tt,e,{operator:a.operator.slice(0,-1),left:p(mn,e),right:a.right});return a!==e.left&&(s=p(Tt,e,{operator:e.operator,left:e.left.left,right:s})),s}}var u;if("+"==e.operator&&t.in_boolean_context()){var c=e.left.evaluate(t),l=e.right.evaluate(t);if(c&&"string"==typeof c)return t.warn("+ in boolean context always true [{file}:{line},{col}]",e.start),di(e,[e.right,p(An,e)]).optimize(t);if(l&&"string"==typeof l)return t.warn("+ in boolean context always true [{file}:{line},{col}]",e.start),di(e,[e.left,p(An,e)]).optimize(t)}if(t.option("comparisons")&&e.is_boolean()){if(!(t.parent()instanceof Tt)||t.parent()instanceof bt){var f=p(vt,e,{operator:"!",expression:e.negate(t,kn(t))});e=Vi(t,e,f);}if(t.option("unsafe_comps"))switch(e.operator){case"<":i(">");break;case"<=":i(">=");}}if("+"==e.operator){if(e.right instanceof ln&&""==e.right.getValue()&&e.left.is_string(t))return e.left;if(e.left instanceof ln&&""==e.left.getValue()&&e.right.is_string(t))return e.right;if(e.left instanceof Tt&&"+"==e.left.operator&&e.left.left instanceof ln&&""==e.left.left.getValue()&&e.right.is_string(t))return e.left=e.left.right,e.transform(t)}if(t.option("evaluate")){switch(e.operator){case"&&":if(!(c=!!ni(e.left,2)||!ni(e.left,4)&&e.left.evaluate(t)))return t.warn("Condition left of && always false [{file}:{line},{col}]",e.start),hi(t.parent(),t.self(),e.left).optimize(t);if(!(c instanceof fe))return t.warn("Condition left of && always true [{file}:{line},{col}]",e.start),di(e,[e.left,e.right]).optimize(t);if(l=e.right.evaluate(t)){if(!(l instanceof fe)){if("&&"==(_=t.parent()).operator&&_.left===t.self()||t.in_boolean_context())return t.warn("Dropping side-effect-free && [{file}:{line},{col}]",e.start),e.left.optimize(t)}}else{if(t.in_boolean_context())return t.warn("Boolean && always false [{file}:{line},{col}]",e.start),di(e,[e.left,p(vn,e)]).optimize(t);ii(e,4);}if("||"==e.left.operator)if(!(d=e.left.right.evaluate(t)))return p(yt,e,{condition:e.left.left,consequent:e.right,alternative:e.left.right}).optimize(t);break;case"||":var _,d;if(!(c=!!ni(e.left,2)||!ni(e.left,4)&&e.left.evaluate(t)))return t.warn("Condition left of || always false [{file}:{line},{col}]",e.start),di(e,[e.left,e.right]).optimize(t);if(!(c instanceof fe))return t.warn("Condition left of || always true [{file}:{line},{col}]",e.start),hi(t.parent(),t.self(),e.left).optimize(t);if(l=e.right.evaluate(t)){if(!(l instanceof fe)){if(t.in_boolean_context())return t.warn("Boolean || always true [{file}:{line},{col}]",e.start),di(e,[e.left,p(An,e)]).optimize(t);ii(e,2);}}else if("||"==(_=t.parent()).operator&&_.left===t.self()||t.in_boolean_context())return t.warn("Dropping side-effect-free || [{file}:{line},{col}]",e.start),e.left.optimize(t);if("&&"==e.left.operator)if((d=e.left.right.evaluate(t))&&!(d instanceof fe))return p(yt,e,{condition:e.left.left,consequent:e.left.right,alternative:e.right}).optimize(t)}var m=!0;switch(e.operator){case"+":if(e.left instanceof cn&&e.right instanceof Tt&&"+"==e.right.operator&&e.right.left instanceof cn&&e.right.is_string(t)&&(e=p(Tt,e,{operator:"+",left:p(ln,e.left,{value:""+e.left.getValue()+e.right.left.getValue(),start:e.left.start,end:e.right.left.end}),right:e.right.right})),e.right instanceof cn&&e.left instanceof Tt&&"+"==e.left.operator&&e.left.right instanceof cn&&e.left.is_string(t)&&(e=p(Tt,e,{operator:"+",left:e.left.left,right:p(ln,e.right,{value:""+e.left.right.getValue()+e.right.getValue(),start:e.left.right.start,end:e.right.end})})),e.left instanceof Tt&&"+"==e.left.operator&&e.left.is_string(t)&&e.left.right instanceof cn&&e.right instanceof Tt&&"+"==e.right.operator&&e.right.left instanceof cn&&e.right.is_string(t)&&(e=p(Tt,e,{operator:"+",left:p(Tt,e.left,{operator:"+",left:e.left.left,right:p(ln,e.left.right,{value:""+e.left.right.getValue()+e.right.left.getValue(),start:e.left.right.start,end:e.right.left.end})}),right:e.right.right})),e.right instanceof vt&&"-"==e.right.operator&&e.left.is_number(t)){e=p(Tt,e,{operator:"-",left:e.left,right:e.right.expression});break}if(e.left instanceof vt&&"-"==e.left.operator&&n()&&e.right.is_number(t)){e=p(Tt,e,{operator:"-",left:e.right,right:e.left.expression});break}case"*":m=t.option("unsafe_math");case"&":case"|":case"^":if(e.left.is_number(t)&&e.right.is_number(t)&&n()&&!(e.left instanceof Tt&&e.left.operator!=e.operator&&ae[e.left.operator]>=ae[e.operator])){var h=p(Tt,e,{operator:e.operator,left:e.right,right:e.left});e=e.right instanceof cn&&!(e.left instanceof cn)?Vi(t,h,e):Vi(t,e,h);}m&&e.is_number(t)&&(e.right instanceof Tt&&e.right.operator==e.operator&&(e=p(Tt,e,{operator:e.operator,left:p(Tt,e.left,{operator:e.operator,left:e.left,right:e.right.left,start:e.left.start,end:e.right.left.end}),right:e.right.right})),e.right instanceof cn&&e.left instanceof Tt&&e.left.operator==e.operator&&(e.left.left instanceof cn?e=p(Tt,e,{operator:e.operator,left:p(Tt,e.left,{operator:e.operator,left:e.left.left,right:e.right,start:e.left.left.start,end:e.right.end}),right:e.left.right}):e.left.right instanceof cn&&(e=p(Tt,e,{operator:e.operator,left:p(Tt,e.left,{operator:e.operator,left:e.left.right,right:e.right,start:e.left.right.start,end:e.right.end}),right:e.left.left}))),e.left instanceof Tt&&e.left.operator==e.operator&&e.left.right instanceof cn&&e.right instanceof Tt&&e.right.operator==e.operator&&e.right.left instanceof cn&&(e=p(Tt,e,{operator:e.operator,left:p(Tt,e.left,{operator:e.operator,left:p(Tt,e.left.left,{operator:e.operator,left:e.left.right,right:e.right.left,start:e.left.right.start,end:e.right.left.end}),right:e.left.left}),right:e.right.right})));}}if(e.right instanceof Tt&&e.right.operator==e.operator&&(xi.has(e.operator)||"+"==e.operator&&(e.right.left.is_string(t)||e.left.is_string(t)&&e.right.right.is_string(t))))return e.left=p(Tt,e.left,{operator:e.operator,left:e.left,right:e.right.left}),e.right=e.right.right,e.transform(t);var E=e.evaluate(t);return E!==e?(E=mi(E,e).optimize(t),Vi(t,E,e)):e})),ai(on,(function(e){return e})),ai(nn,(function(e,t){if(!t.option("ie8")&&Ti(e)&&(!e.scope.uses_with||!t.find_parent(Re)))switch(e.name){case"undefined":return p(En,e).optimize(t);case"NaN":return p(hn,e).optimize(t);case"Infinity":return p(Dn,e).optimize(t)}var n=t.parent();if(t.option("reduce_vars")&&ki(e,n)!==e){const f=e.definition();if(t.top_retain&&f.global&&t.top_retain(f))return f.fixed=!1,f.should_replace=!1,f.single_use=!1,e;var i=e.fixed_value(),o=f.single_use&&!(n instanceof dt&&n.is_expr_pure(t)||T(n,Rn));if(o&&(i instanceof ke||i instanceof kt))if($i(i,t))o=!1;else if(f.scope!==e.scope&&(1==f.escaped||ni(i,16)||function(e){for(var t,n=0;t=e.parent(n++);){if(t instanceof pe)return !1;if(t instanceof Ot||t instanceof Rt||t instanceof Ft)return !0}return !1}(t)))o=!1;else if(Zi(t,f))o=!1;else if((f.scope!==e.scope||f.orig[0]instanceof zt)&&"f"==(o=i.is_constant_expression(e.scope))){var r=e.scope;do{(r instanceof Pe||ci(r))&&ii(r,16);}while(r=r.parent_scope)}if(o&&i instanceof ke){const r=pi(t,!0);o=f.scope===e.scope&&!Ji(r,i)||n instanceof dt&&n.expression===e&&!Ji(r,i);}if(o&&i instanceof kt){o=(!i.extends||!i.extends.may_throw(t)&&!i.extends.has_side_effects(t))&&!i.properties.some(e=>e.may_throw(t)||e.has_side_effects(t));}if(o&&i){if(i instanceof Lt&&(ii(i,256),i=p(Vt,i,i)),i instanceof Pe&&(ii(i,256),i=p(Le,i,i)),f.recursive_refs>0&&i.name instanceof Wt){const e=i.name.definition();let t=i.variables.get(i.name.name),n=t&&t.orig[0];n instanceof $t||(n=p($t,i.name,i.name),n.scope=i,i.name=n,t=i.def_function(n)),Tn(i,n=>{n instanceof nn&&n.definition()===e&&(n.thedef=t,t.references.push(n));});}return (i instanceof ke||i instanceof kt)&&pi(t,!0).add_child_scope(i),i.optimize(t)}if(i&&void 0===f.should_replace){let e;if(i instanceof sn)f.orig[0]instanceof zt||!f.references.every(e=>f.scope===e.scope)||(e=i);else{var a=i.evaluate(t);a===i||!t.option("unsafe_regexp")&&a instanceof RegExp||(e=mi(a,i));}if(e){var s,u=e.optimize(t).size();Tn(i,e=>{if(e instanceof nn)return bn})?s=function(){var n=e.optimize(t);return n===e?n.clone(!0):n}:(u=Math.min(u,i.size()),s=function(){var n=Ii(e.optimize(t),i);return n===e||n===i?n.clone(!0):n});var c=f.name.length,l=0;t.option("unused")&&!t.exposed(f)&&(l=(c+2+u)/(f.references.length-f.assignments)),f.should_replace=u<=c+l&&s;}else f.should_replace=!1;}if(f.should_replace)return f.should_replace()}return e})),ai(En,(function(e,t){if(t.option("unsafe_undefined")){var n=_i(t,"undefined");if(n){var i=p(nn,e,{name:"undefined",scope:n.scope,thedef:n});return ii(i,8),i}}var o=ki(t.self(),t.parent());return o&&Qi(o,e)?e:p(vt,e,{operator:"void",expression:p(fn,e,{value:0})})})),ai(Dn,(function(e,t){var n=ki(t.self(),t.parent());return n&&Qi(n,e)?e:!t.option("keep_infinity")||n&&!Qi(n,e)||_i(t,"Infinity")?p(Tt,e,{operator:"/",left:p(fn,e,{value:1}),right:p(fn,e,{value:0})}):e})),ai(hn,(function(e,t){var n=ki(t.self(),t.parent());return n&&!Qi(n,e)||_i(t,"NaN")?p(Tt,e,{operator:"/",left:p(fn,e,{value:0}),right:p(fn,e,{value:0})}):e}));const to=E("+ - / * % >> << >>> | ^ &"),no=E("* | ^ &");function io(e,t){return e instanceof nn&&(e=e.fixed_value()),!!e&&(!(e instanceof ke||e instanceof kt)||(!(e instanceof ke&&e.contains_this())||t.parent()instanceof mt))}function oo(e,t){return t.in_boolean_context()?Vi(t,e,di(e,[e,p(An,e)]).optimize(t)):e}function ro(e,t,n){for(var i=0;i<n.length;i++){var o=n[i];if(o instanceof Ne){var r=o.expression;r instanceof Ot&&(n.splice(i,1,...r.elements),i--);}}return e}function ao(e,t){if(!t.option("computed_props"))return e;if(!(e.key instanceof cn))return e;if(e.key instanceof ln||e.key instanceof fn){if("__proto__"===e.key.value)return e;if("constructor"==e.key.value&&t.parent()instanceof kt)return e;e.key=e instanceof Rt?e.key.value:p(e instanceof It?qt:Yt,e.key,{name:e.key.value});}return e}ai(bt,(function(e,t){var n;if(t.option("dead_code")&&e.left instanceof nn&&(n=e.left.definition()).scope===t.find_parent(ke)){var i,o=0,r=e;do{if(i=r,(r=t.parent(o++))instanceof Xe){if(a(o,r))break;if(eo(n.scope,[n]))break;return "="==e.operator?e.right:(n.fixed=!1,p(Tt,e,{operator:e.operator.slice(0,-1),left:e.left,right:e.right}).optimize(t))}}while(r instanceof Tt&&r.right===i||r instanceof ht&&r.tail_node()===i)}return "="==(e=e.lift_sequences(t)).operator&&e.left instanceof nn&&e.right instanceof Tt&&(e.right.left instanceof nn&&e.right.left.name==e.left.name&&to.has(e.right.operator)?(e.operator=e.right.operator+"=",e.right=e.right.right):e.right.right instanceof nn&&e.right.right.name==e.left.name&&no.has(e.right.operator)&&!e.right.left.has_side_effects(t)&&(e.operator=e.right.operator+"=",e.right=e.right.left)),e;function a(n,i){var o=e.right;e.right=p(mn,o);var r=i.may_throw(t);e.right=o;for(var a,s=e.left.definition().scope;(a=t.parent(n++))!==s;)if(a instanceof it){if(a.bfinally)return !0;if(r&&a.bcatch)return !0}}})),ai(Ct,(function(e,t){if(!t.option("evaluate"))return e;var n=e.right.evaluate(t);return void 0===n?e=e.left:n!==e.right&&(n=mi(n,e.right),e.right=Ii(n,e.right)),e})),ai(yt,(function(e,t){if(!t.option("conditionals"))return e;if(e.condition instanceof ht){var n=e.condition.expressions.slice();return e.condition=n.pop(),n.push(e),di(e,n)}var i=e.condition.evaluate(t);if(i!==e.condition)return i?(t.warn("Condition always true [{file}:{line},{col}]",e.start),hi(t.parent(),t.self(),e.consequent)):(t.warn("Condition always false [{file}:{line},{col}]",e.start),hi(t.parent(),t.self(),e.alternative));var o=i.negate(t,kn(t));Vi(t,i,o)===o&&(e=p(yt,e,{condition:o,consequent:e.alternative,alternative:e.consequent}));var r,a=e.condition,s=e.consequent,u=e.alternative;if(a instanceof nn&&s instanceof nn&&a.definition()===s.definition())return p(Tt,e,{operator:"||",left:a,right:u});if(s instanceof bt&&u instanceof bt&&s.operator==u.operator&&s.left.equivalent_to(u.left)&&(!e.condition.has_side_effects(t)||"="==s.operator&&!s.left.has_side_effects(t)))return p(bt,e,{operator:s.operator,left:s.left,right:p(yt,e,{condition:e.condition,consequent:s.right,alternative:u.right})});if(s instanceof dt&&u.TYPE===s.TYPE&&s.args.length>0&&s.args.length==u.args.length&&s.expression.equivalent_to(u.expression)&&!e.condition.has_side_effects(t)&&!s.expression.has_side_effects(t)&&"number"==typeof(r=function(){for(var e=s.args,t=u.args,n=0,i=e.length;n<i;n++){if(e[n]instanceof Ne)return;if(!e[n].equivalent_to(t[n])){if(t[n]instanceof Ne)return;for(var o=n+1;o<i;o++){if(e[o]instanceof Ne)return;if(!e[o].equivalent_to(t[o]))return}return n}}}())){var c=s.clone();return c.args[r]=p(yt,e,{condition:e.condition,consequent:s.args[r],alternative:u.args[r]}),c}if(u instanceof yt&&s.equivalent_to(u.consequent))return p(yt,e,{condition:p(Tt,e,{operator:"||",left:a,right:u.condition}),consequent:s,alternative:u.alternative}).optimize(t);if(u instanceof ht&&s.equivalent_to(u.expressions[u.expressions.length-1]))return di(e,[p(Tt,e,{operator:"||",left:a,right:di(e,u.expressions.slice(0,-1))}),s]).optimize(t);if(u instanceof Tt&&"&&"==u.operator&&s.equivalent_to(u.right))return p(Tt,e,{operator:"&&",left:p(Tt,e,{operator:"||",left:a,right:u.left}),right:s}).optimize(t);if(s instanceof yt&&s.alternative.equivalent_to(u))return p(yt,e,{condition:p(Tt,e,{left:e.condition,operator:"&&",right:s.condition}),consequent:s.consequent,alternative:u});if(s.equivalent_to(u))return di(e,[e.condition,s]).optimize(t);if(s instanceof Tt&&"||"==s.operator&&s.right.equivalent_to(u))return p(Tt,e,{operator:"||",left:p(Tt,e,{operator:"&&",left:e.condition,right:s.left}),right:u}).optimize(t);var l=t.in_boolean_context();return _(e.consequent)?d(e.alternative)?f(e.condition):p(Tt,e,{operator:"||",left:f(e.condition),right:e.alternative}):d(e.consequent)?_(e.alternative)?f(e.condition.negate(t)):p(Tt,e,{operator:"&&",left:f(e.condition.negate(t)),right:e.alternative}):_(e.alternative)?p(Tt,e,{operator:"||",left:f(e.condition.negate(t)),right:e.consequent}):d(e.alternative)?p(Tt,e,{operator:"&&",left:f(e.condition),right:e.consequent}):e;function f(e){return e.is_boolean()?e:p(vt,e,{operator:"!",expression:e.negate(t)})}function _(e){return e instanceof An||l&&e instanceof cn&&e.getValue()||e instanceof vt&&"!"==e.operator&&e.expression instanceof cn&&!e.expression.getValue()}function d(e){return e instanceof vn||l&&e instanceof cn&&!e.getValue()||e instanceof vt&&"!"==e.operator&&e.expression instanceof cn&&e.expression.getValue()}})),ai(Sn,(function(e,t){if(t.in_boolean_context())return p(fn,e,{value:+e.value});var n=t.parent();return t.option("booleans_as_integers")?(n instanceof Tt&&("==="==n.operator||"!=="==n.operator)&&(n.operator=n.operator.replace(/=$/,"")),p(fn,e,{value:+e.value})):t.option("booleans")?n instanceof Tt&&("=="==n.operator||"!="==n.operator)?(t.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]",{operator:n.operator,value:e.value,file:n.start.file,line:n.start.line,col:n.start.col}),p(fn,e,{value:+e.value})):p(vt,e,{operator:"!",expression:p(fn,e,{value:1-e.value})}):e})),ai(Dt,(function(e,t){var n,i=e.expression,o=e.property;if(t.option("properties")){var r=o.evaluate(t);if(r!==o){if("string"==typeof r)if("undefined"==r)r=void 0;else(A=parseFloat(r)).toString()==r&&(r=A);o=e.property=Ii(o,mi(r,o).transform(t));var a=""+r;if(j(a)&&a.length<=o.size()+1)return p(gt,e,{expression:i,property:a,quote:o.quote}).optimize(t)}}e:if(t.option("arguments")&&i instanceof nn&&"arguments"==i.name&&1==i.definition().orig.length&&(n=i.scope)instanceof ke&&n.uses_arguments&&!(n instanceof Ve)&&o instanceof fn){for(var s=o.getValue(),u=new Set,c=n.argnames,l=0;l<c.length;l++){if(!(c[l]instanceof zt))break e;var f=c[l].name;if(u.has(f))break e;u.add(f);}var _=n.argnames[s];if(_&&t.has_directive("use strict")){var d=_.definition();(!t.option("reduce_vars")||d.assignments||d.orig.length>1)&&(_=null);}else if(!_&&!t.option("keep_fargs")&&s<n.argnames.length+5)for(;s>=n.argnames.length;)_=p(zt,n,{name:n.make_var_name("argument_"+n.argnames.length),scope:n}),n.argnames.push(_),n.enclosed.push(n.def_variable(_));if(_){var m=p(nn,e,_);return m.reference({}),oi(_,1),m}}if(ki(e,t.parent()))return e;if(r!==o){var h=e.flatten_object(a,t);h&&(i=e.expression=h.expression,o=e.property=h.property);}if(t.option("properties")&&t.option("side_effects")&&o instanceof fn&&i instanceof Ot){s=o.getValue();var E=i.elements,g=E[s];e:if(io(g,t)){for(var D=!0,S=[],v=E.length;--v>s;){(A=E[v].drop_side_effect_free(t))&&(S.unshift(A),D&&A.has_side_effects(t)&&(D=!1));}if(g instanceof Ne)break e;for(g=g instanceof gn?p(En,g):g,D||S.unshift(g);--v>=0;){var A;if((A=E[v])instanceof Ne)break e;(A=A.drop_side_effect_free(t))?S.unshift(A):s--;}return D?(S.push(g),di(e,S).optimize(t)):p(Dt,e,{expression:p(Ot,i,{elements:S}),property:p(fn,o,{value:s})})}}var T=e.evaluate(t);return T!==e?Vi(t,T=mi(T,e).optimize(t),e):e})),ke.DEFMETHOD("contains_this",(function(){return Tn(this,e=>e instanceof sn?bn:e!==this&&e instanceof we&&!(e instanceof Ve)||void 0)})),Et.DEFMETHOD("flatten_object",(function(e,t){if(t.option("properties")){var n=t.option("unsafe_arrows")&&t.option("ecma")>=2015,i=this.expression;if(i instanceof Ft)for(var o=i.properties,r=o.length;--r>=0;){var a=o[r];if(""+(a instanceof Nt?a.key.name:a.key)==e){if(!o.every(e=>e instanceof Rt||n&&e instanceof Nt&&!e.is_generator))break;if(!io(a.value,t))break;return p(Dt,this,{expression:p(Ot,i,{elements:o.map((function(e){var t=e.value;t instanceof Ie&&(t=p(Le,t,t));var n=e.key;return n instanceof fe&&!(n instanceof Yt)?di(e,[n,t]):t}))}),property:p(fn,this,{value:r})})}}}})),ai(gt,(function(e,t){"arguments"!=e.property&&"caller"!=e.property||t.warn("Function.prototype.{prop} not supported [{file}:{line},{col}]",{prop:e.property,file:e.start.file,line:e.start.line,col:e.start.col});const n=t.parent();if(ki(e,n))return e;if(t.option("unsafe_proto")&&e.expression instanceof gt&&"prototype"==e.expression.property){var i=e.expression.expression;if(Ti(i))switch(i.name){case"Array":e.expression=p(Ot,e.expression,{elements:[]});break;case"Function":e.expression=p(Le,e.expression,{argnames:[],body:[]});break;case"Number":e.expression=p(fn,e.expression,{value:0});break;case"Object":e.expression=p(Ft,e.expression,{properties:[]});break;case"RegExp":e.expression=p(_n,e.expression,{value:{source:"t",flags:""}});break;case"String":e.expression=p(ln,e.expression,{value:""});}}if(!(n instanceof dt&&T(n,Rn))){const n=e.flatten_object(e.property,t);if(n)return n.optimize(t)}let o=e.evaluate(t);return o!==e?(o=mi(o,e).optimize(t),Vi(t,o,e)):e})),ai(Ot,(function(e,t){var n=oo(e,t);return n!==e?n:ro(e,0,e.elements)})),ai(Ft,(function(e,t){var n=oo(e,t);if(n!==e)return n;for(var i=e.properties,o=0;o<i.length;o++){var r=i[o];if(r instanceof Ne){var a=r.expression;a instanceof Ft?(i.splice.apply(i,[o,1].concat(r.expression.properties)),o--):a instanceof cn&&!(a instanceof ln)&&i.splice(o,1);}}return e})),ai(_n,oo),ai(ze,(function(e,t){return e.value&&wi(e.value,t)&&(e.value=null),e})),ai(Ve,Wi),ai(Le,(function(e,t){if(e=Wi(e,t),t.option("unsafe_arrows")&&t.option("ecma")>=2015&&!e.name&&!e.is_generator&&!e.uses_arguments&&!e.pinned()){if(!Tn(e,e=>{if(e instanceof sn)return bn}))return p(Ve,e,e).optimize(t)}return e})),ai(kt,(function(e){return e})),ai(Ze,(function(e,t){return e.expression&&!e.is_star&&wi(e.expression,t)&&(e.expression=null),e})),ai(Ue,(function(e,t){if(!t.option("evaluate")||t.parent()instanceof Ke)return e;for(var n=[],i=0;i<e.segments.length;i++){var o=e.segments[i];if(o instanceof fe){var r=o.evaluate(t);if(r!==o&&(r+"").length<=o.size()+"${}".length){n[n.length-1].value=n[n.length-1].value+r+e.segments[++i].value;continue}}n.push(o);}return e.segments=n,1==n.length?p(ln,e,n[0]):e})),ai(Ke,(function(e){return e})),ai(Mt,ao),ai(Nt,(function(e,t){if(ao(e,t),t.option("arrows")&&t.parent()instanceof Ft&&!e.is_generator&&!e.value.uses_arguments&&!e.value.pinned()&&1==e.value.body.length&&e.value.body[0]instanceof ze&&e.value.body[0].value&&!e.value.contains_this()){var n=p(Ve,e.value,e.value);return n.async=e.async,n.is_generator=e.is_generator,p(Rt,e,{key:e.key instanceof Yt?e.key.name:e.key,value:n,quote:e.quote})}return e})),ai(Rt,(function(e,t){ao(e,t);var n=t.option("unsafe_methods");if(n&&t.option("ecma")>=2015&&(!(n instanceof RegExp)||n.test(e.key+""))){var i=e.key,o=e.value;if((o instanceof Ve&&Array.isArray(o.body)&&!o.contains_this()||o instanceof Le)&&!o.name)return p(Nt,e,{async:o.async,is_generator:o.is_generator,key:i instanceof fe?i:p(Yt,e,{name:i}),value:p(Ie,o,o),quote:e.quote})}return e})),ai(Be,(function(e,t){if(1==t.option("pure_getters")&&t.option("unused")&&!e.is_array&&Array.isArray(e.names)&&!function(e){for(var t=[/^VarDef$/,/^(Const|Let|Var)$/,/^Export$/],n=0,i=0,o=t.length;n<o;i++){var r=e.parent(i);if(!r)return !1;if(0!==n||"Destructuring"!=r.TYPE){if(!t[n].test(r.TYPE))return !1;n++;}}return !0}(t)){for(var n=[],i=0;i<e.names.length;i++){var o=e.names[i];o instanceof Rt&&"string"==typeof o.key&&o.value instanceof Kt&&!r(t,o.value.definition())||n.push(o);}n.length!=e.names.length&&(e.names=n);}return e;function r(e,t){return !!t.references.length||!!t.global&&(!e.toplevel.vars||!!e.top_retain&&e.top_retain(t))}}));var so=["$&","$'","$*","$+","$1","$2","$3","$4","$5","$6","$7","$8","$9","$_","$`","$input","@@iterator","ABORT_ERR","ACTIVE","ACTIVE_ATTRIBUTES","ACTIVE_TEXTURE","ACTIVE_UNIFORMS","ADDITION","ALIASED_LINE_WIDTH_RANGE","ALIASED_POINT_SIZE_RANGE","ALLOW_KEYBOARD_INPUT","ALLPASS","ALPHA","ALPHA_BITS","ALT_MASK","ALWAYS","ANY_TYPE","ANY_UNORDERED_NODE_TYPE","ARRAY_BUFFER","ARRAY_BUFFER_BINDING","ATTACHED_SHADERS","ATTRIBUTE_NODE","AT_TARGET","AddSearchProvider","AnalyserNode","AnimationEvent","AnonXMLHttpRequest","ApplicationCache","ApplicationCacheErrorEvent","Array","ArrayBuffer","Attr","Audio","AudioBuffer","AudioBufferSourceNode","AudioContext","AudioDestinationNode","AudioListener","AudioNode","AudioParam","AudioProcessingEvent","AudioStreamTrack","AutocompleteErrorEvent","BACK","BAD_BOUNDARYPOINTS_ERR","BANDPASS","BLEND","BLEND_COLOR","BLEND_DST_ALPHA","BLEND_DST_RGB","BLEND_EQUATION","BLEND_EQUATION_ALPHA","BLEND_EQUATION_RGB","BLEND_SRC_ALPHA","BLEND_SRC_RGB","BLUE_BITS","BLUR","BOOL","BOOLEAN_TYPE","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","BOTH","BROWSER_DEFAULT_WEBGL","BUBBLING_PHASE","BUFFER_SIZE","BUFFER_USAGE","BYTE","BYTES_PER_ELEMENT","BarProp","BaseHref","BatteryManager","BeforeLoadEvent","BeforeUnloadEvent","BiquadFilterNode","Blob","BlobEvent","Boolean","CAPTURING_PHASE","CCW","CDATASection","CDATA_SECTION_NODE","CHANGE","CHARSET_RULE","CHECKING","CLAMP_TO_EDGE","CLICK","CLOSED","CLOSING","COLOR_ATTACHMENT0","COLOR_BUFFER_BIT","COLOR_CLEAR_VALUE","COLOR_WRITEMASK","COMMENT_NODE","COMPILE_STATUS","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_TEXTURE_FORMATS","CONNECTING","CONSTANT_ALPHA","CONSTANT_COLOR","CONSTRAINT_ERR","CONTEXT_LOST_WEBGL","CONTROL_MASK","COUNTER_STYLE_RULE","CSS","CSS2Properties","CSSCharsetRule","CSSConditionRule","CSSCounterStyleRule","CSSFontFaceRule","CSSFontFeatureValuesRule","CSSGroupingRule","CSSImportRule","CSSKeyframeRule","CSSKeyframesRule","CSSMediaRule","CSSMozDocumentRule","CSSNameSpaceRule","CSSPageRule","CSSPrimitiveValue","CSSRule","CSSRuleList","CSSStyleDeclaration","CSSStyleRule","CSSStyleSheet","CSSSupportsRule","CSSUnknownRule","CSSValue","CSSValueList","CSSVariablesDeclaration","CSSVariablesRule","CSSViewportRule","CSS_ATTR","CSS_CM","CSS_COUNTER","CSS_CUSTOM","CSS_DEG","CSS_DIMENSION","CSS_EMS","CSS_EXS","CSS_FILTER_BLUR","CSS_FILTER_BRIGHTNESS","CSS_FILTER_CONTRAST","CSS_FILTER_CUSTOM","CSS_FILTER_DROP_SHADOW","CSS_FILTER_GRAYSCALE","CSS_FILTER_HUE_ROTATE","CSS_FILTER_INVERT","CSS_FILTER_OPACITY","CSS_FILTER_REFERENCE","CSS_FILTER_SATURATE","CSS_FILTER_SEPIA","CSS_GRAD","CSS_HZ","CSS_IDENT","CSS_IN","CSS_INHERIT","CSS_KHZ","CSS_MATRIX","CSS_MATRIX3D","CSS_MM","CSS_MS","CSS_NUMBER","CSS_PC","CSS_PERCENTAGE","CSS_PERSPECTIVE","CSS_PRIMITIVE_VALUE","CSS_PT","CSS_PX","CSS_RAD","CSS_RECT","CSS_RGBCOLOR","CSS_ROTATE","CSS_ROTATE3D","CSS_ROTATEX","CSS_ROTATEY","CSS_ROTATEZ","CSS_S","CSS_SCALE","CSS_SCALE3D","CSS_SCALEX","CSS_SCALEY","CSS_SCALEZ","CSS_SKEW","CSS_SKEWX","CSS_SKEWY","CSS_STRING","CSS_TRANSLATE","CSS_TRANSLATE3D","CSS_TRANSLATEX","CSS_TRANSLATEY","CSS_TRANSLATEZ","CSS_UNKNOWN","CSS_URI","CSS_VALUE_LIST","CSS_VH","CSS_VMAX","CSS_VMIN","CSS_VW","CULL_FACE","CULL_FACE_MODE","CURRENT_PROGRAM","CURRENT_VERTEX_ATTRIB","CUSTOM","CW","CanvasGradient","CanvasPattern","CanvasRenderingContext2D","CaretPosition","ChannelMergerNode","ChannelSplitterNode","CharacterData","ClientRect","ClientRectList","Clipboard","ClipboardEvent","CloseEvent","Collator","CommandEvent","Comment","CompositionEvent","Console","Controllers","ConvolverNode","Counter","Crypto","CryptoKey","CustomEvent","DATABASE_ERR","DATA_CLONE_ERR","DATA_ERR","DBLCLICK","DECR","DECR_WRAP","DELETE_STATUS","DEPTH_ATTACHMENT","DEPTH_BITS","DEPTH_BUFFER_BIT","DEPTH_CLEAR_VALUE","DEPTH_COMPONENT","DEPTH_COMPONENT16","DEPTH_FUNC","DEPTH_RANGE","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","DEPTH_TEST","DEPTH_WRITEMASK","DIRECTION_DOWN","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DISABLED","DISPATCH_REQUEST_ERR","DITHER","DOCUMENT_FRAGMENT_NODE","DOCUMENT_NODE","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_DISCONNECTED","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_PRECEDING","DOCUMENT_TYPE_NODE","DOMCursor","DOMError","DOMException","DOMImplementation","DOMImplementationLS","DOMMatrix","DOMMatrixReadOnly","DOMParser","DOMPoint","DOMPointReadOnly","DOMQuad","DOMRect","DOMRectList","DOMRectReadOnly","DOMRequest","DOMSTRING_SIZE_ERR","DOMSettableTokenList","DOMStringList","DOMStringMap","DOMTokenList","DOMTransactionEvent","DOM_DELTA_LINE","DOM_DELTA_PAGE","DOM_DELTA_PIXEL","DOM_INPUT_METHOD_DROP","DOM_INPUT_METHOD_HANDWRITING","DOM_INPUT_METHOD_IME","DOM_INPUT_METHOD_KEYBOARD","DOM_INPUT_METHOD_MULTIMODAL","DOM_INPUT_METHOD_OPTION","DOM_INPUT_METHOD_PASTE","DOM_INPUT_METHOD_SCRIPT","DOM_INPUT_METHOD_UNKNOWN","DOM_INPUT_METHOD_VOICE","DOM_KEY_LOCATION_JOYSTICK","DOM_KEY_LOCATION_LEFT","DOM_KEY_LOCATION_MOBILE","DOM_KEY_LOCATION_NUMPAD","DOM_KEY_LOCATION_RIGHT","DOM_KEY_LOCATION_STANDARD","DOM_VK_0","DOM_VK_1","DOM_VK_2","DOM_VK_3","DOM_VK_4","DOM_VK_5","DOM_VK_6","DOM_VK_7","DOM_VK_8","DOM_VK_9","DOM_VK_A","DOM_VK_ACCEPT","DOM_VK_ADD","DOM_VK_ALT","DOM_VK_ALTGR","DOM_VK_AMPERSAND","DOM_VK_ASTERISK","DOM_VK_AT","DOM_VK_ATTN","DOM_VK_B","DOM_VK_BACKSPACE","DOM_VK_BACK_QUOTE","DOM_VK_BACK_SLASH","DOM_VK_BACK_SPACE","DOM_VK_C","DOM_VK_CANCEL","DOM_VK_CAPS_LOCK","DOM_VK_CIRCUMFLEX","DOM_VK_CLEAR","DOM_VK_CLOSE_BRACKET","DOM_VK_CLOSE_CURLY_BRACKET","DOM_VK_CLOSE_PAREN","DOM_VK_COLON","DOM_VK_COMMA","DOM_VK_CONTEXT_MENU","DOM_VK_CONTROL","DOM_VK_CONVERT","DOM_VK_CRSEL","DOM_VK_CTRL","DOM_VK_D","DOM_VK_DECIMAL","DOM_VK_DELETE","DOM_VK_DIVIDE","DOM_VK_DOLLAR","DOM_VK_DOUBLE_QUOTE","DOM_VK_DOWN","DOM_VK_E","DOM_VK_EISU","DOM_VK_END","DOM_VK_ENTER","DOM_VK_EQUALS","DOM_VK_EREOF","DOM_VK_ESCAPE","DOM_VK_EXCLAMATION","DOM_VK_EXECUTE","DOM_VK_EXSEL","DOM_VK_F","DOM_VK_F1","DOM_VK_F10","DOM_VK_F11","DOM_VK_F12","DOM_VK_F13","DOM_VK_F14","DOM_VK_F15","DOM_VK_F16","DOM_VK_F17","DOM_VK_F18","DOM_VK_F19","DOM_VK_F2","DOM_VK_F20","DOM_VK_F21","DOM_VK_F22","DOM_VK_F23","DOM_VK_F24","DOM_VK_F25","DOM_VK_F26","DOM_VK_F27","DOM_VK_F28","DOM_VK_F29","DOM_VK_F3","DOM_VK_F30","DOM_VK_F31","DOM_VK_F32","DOM_VK_F33","DOM_VK_F34","DOM_VK_F35","DOM_VK_F36","DOM_VK_F4","DOM_VK_F5","DOM_VK_F6","DOM_VK_F7","DOM_VK_F8","DOM_VK_F9","DOM_VK_FINAL","DOM_VK_FRONT","DOM_VK_G","DOM_VK_GREATER_THAN","DOM_VK_H","DOM_VK_HANGUL","DOM_VK_HANJA","DOM_VK_HASH","DOM_VK_HELP","DOM_VK_HK_TOGGLE","DOM_VK_HOME","DOM_VK_HYPHEN_MINUS","DOM_VK_I","DOM_VK_INSERT","DOM_VK_J","DOM_VK_JUNJA","DOM_VK_K","DOM_VK_KANA","DOM_VK_KANJI","DOM_VK_L","DOM_VK_LEFT","DOM_VK_LEFT_TAB","DOM_VK_LESS_THAN","DOM_VK_M","DOM_VK_META","DOM_VK_MODECHANGE","DOM_VK_MULTIPLY","DOM_VK_N","DOM_VK_NONCONVERT","DOM_VK_NUMPAD0","DOM_VK_NUMPAD1","DOM_VK_NUMPAD2","DOM_VK_NUMPAD3","DOM_VK_NUMPAD4","DOM_VK_NUMPAD5","DOM_VK_NUMPAD6","DOM_VK_NUMPAD7","DOM_VK_NUMPAD8","DOM_VK_NUMPAD9","DOM_VK_NUM_LOCK","DOM_VK_O","DOM_VK_OEM_1","DOM_VK_OEM_102","DOM_VK_OEM_2","DOM_VK_OEM_3","DOM_VK_OEM_4","DOM_VK_OEM_5","DOM_VK_OEM_6","DOM_VK_OEM_7","DOM_VK_OEM_8","DOM_VK_OEM_COMMA","DOM_VK_OEM_MINUS","DOM_VK_OEM_PERIOD","DOM_VK_OEM_PLUS","DOM_VK_OPEN_BRACKET","DOM_VK_OPEN_CURLY_BRACKET","DOM_VK_OPEN_PAREN","DOM_VK_P","DOM_VK_PA1","DOM_VK_PAGEDOWN","DOM_VK_PAGEUP","DOM_VK_PAGE_DOWN","DOM_VK_PAGE_UP","DOM_VK_PAUSE","DOM_VK_PERCENT","DOM_VK_PERIOD","DOM_VK_PIPE","DOM_VK_PLAY","DOM_VK_PLUS","DOM_VK_PRINT","DOM_VK_PRINTSCREEN","DOM_VK_PROCESSKEY","DOM_VK_PROPERITES","DOM_VK_Q","DOM_VK_QUESTION_MARK","DOM_VK_QUOTE","DOM_VK_R","DOM_VK_REDO","DOM_VK_RETURN","DOM_VK_RIGHT","DOM_VK_S","DOM_VK_SCROLL_LOCK","DOM_VK_SELECT","DOM_VK_SEMICOLON","DOM_VK_SEPARATOR","DOM_VK_SHIFT","DOM_VK_SLASH","DOM_VK_SLEEP","DOM_VK_SPACE","DOM_VK_SUBTRACT","DOM_VK_T","DOM_VK_TAB","DOM_VK_TILDE","DOM_VK_U","DOM_VK_UNDERSCORE","DOM_VK_UNDO","DOM_VK_UNICODE","DOM_VK_UP","DOM_VK_V","DOM_VK_VOLUME_DOWN","DOM_VK_VOLUME_MUTE","DOM_VK_VOLUME_UP","DOM_VK_W","DOM_VK_WIN","DOM_VK_WINDOW","DOM_VK_WIN_ICO_00","DOM_VK_WIN_ICO_CLEAR","DOM_VK_WIN_ICO_HELP","DOM_VK_WIN_OEM_ATTN","DOM_VK_WIN_OEM_AUTO","DOM_VK_WIN_OEM_BACKTAB","DOM_VK_WIN_OEM_CLEAR","DOM_VK_WIN_OEM_COPY","DOM_VK_WIN_OEM_CUSEL","DOM_VK_WIN_OEM_ENLW","DOM_VK_WIN_OEM_FINISH","DOM_VK_WIN_OEM_FJ_JISHO","DOM_VK_WIN_OEM_FJ_LOYA","DOM_VK_WIN_OEM_FJ_MASSHOU","DOM_VK_WIN_OEM_FJ_ROYA","DOM_VK_WIN_OEM_FJ_TOUROKU","DOM_VK_WIN_OEM_JUMP","DOM_VK_WIN_OEM_PA1","DOM_VK_WIN_OEM_PA2","DOM_VK_WIN_OEM_PA3","DOM_VK_WIN_OEM_RESET","DOM_VK_WIN_OEM_WSCTRL","DOM_VK_X","DOM_VK_XF86XK_ADD_FAVORITE","DOM_VK_XF86XK_APPLICATION_LEFT","DOM_VK_XF86XK_APPLICATION_RIGHT","DOM_VK_XF86XK_AUDIO_CYCLE_TRACK","DOM_VK_XF86XK_AUDIO_FORWARD","DOM_VK_XF86XK_AUDIO_LOWER_VOLUME","DOM_VK_XF86XK_AUDIO_MEDIA","DOM_VK_XF86XK_AUDIO_MUTE","DOM_VK_XF86XK_AUDIO_NEXT","DOM_VK_XF86XK_AUDIO_PAUSE","DOM_VK_XF86XK_AUDIO_PLAY","DOM_VK_XF86XK_AUDIO_PREV","DOM_VK_XF86XK_AUDIO_RAISE_VOLUME","DOM_VK_XF86XK_AUDIO_RANDOM_PLAY","DOM_VK_XF86XK_AUDIO_RECORD","DOM_VK_XF86XK_AUDIO_REPEAT","DOM_VK_XF86XK_AUDIO_REWIND","DOM_VK_XF86XK_AUDIO_STOP","DOM_VK_XF86XK_AWAY","DOM_VK_XF86XK_BACK","DOM_VK_XF86XK_BACK_FORWARD","DOM_VK_XF86XK_BATTERY","DOM_VK_XF86XK_BLUE","DOM_VK_XF86XK_BLUETOOTH","DOM_VK_XF86XK_BOOK","DOM_VK_XF86XK_BRIGHTNESS_ADJUST","DOM_VK_XF86XK_CALCULATOR","DOM_VK_XF86XK_CALENDAR","DOM_VK_XF86XK_CD","DOM_VK_XF86XK_CLOSE","DOM_VK_XF86XK_COMMUNITY","DOM_VK_XF86XK_CONTRAST_ADJUST","DOM_VK_XF86XK_COPY","DOM_VK_XF86XK_CUT","DOM_VK_XF86XK_CYCLE_ANGLE","DOM_VK_XF86XK_DISPLAY","DOM_VK_XF86XK_DOCUMENTS","DOM_VK_XF86XK_DOS","DOM_VK_XF86XK_EJECT","DOM_VK_XF86XK_EXCEL","DOM_VK_XF86XK_EXPLORER","DOM_VK_XF86XK_FAVORITES","DOM_VK_XF86XK_FINANCE","DOM_VK_XF86XK_FORWARD","DOM_VK_XF86XK_FRAME_BACK","DOM_VK_XF86XK_FRAME_FORWARD","DOM_VK_XF86XK_GAME","DOM_VK_XF86XK_GO","DOM_VK_XF86XK_GREEN","DOM_VK_XF86XK_HIBERNATE","DOM_VK_XF86XK_HISTORY","DOM_VK_XF86XK_HOME_PAGE","DOM_VK_XF86XK_HOT_LINKS","DOM_VK_XF86XK_I_TOUCH","DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN","DOM_VK_XF86XK_KBD_BRIGHTNESS_UP","DOM_VK_XF86XK_KBD_LIGHT_ON_OFF","DOM_VK_XF86XK_LAUNCH0","DOM_VK_XF86XK_LAUNCH1","DOM_VK_XF86XK_LAUNCH2","DOM_VK_XF86XK_LAUNCH3","DOM_VK_XF86XK_LAUNCH4","DOM_VK_XF86XK_LAUNCH5","DOM_VK_XF86XK_LAUNCH6","DOM_VK_XF86XK_LAUNCH7","DOM_VK_XF86XK_LAUNCH8","DOM_VK_XF86XK_LAUNCH9","DOM_VK_XF86XK_LAUNCH_A","DOM_VK_XF86XK_LAUNCH_B","DOM_VK_XF86XK_LAUNCH_C","DOM_VK_XF86XK_LAUNCH_D","DOM_VK_XF86XK_LAUNCH_E","DOM_VK_XF86XK_LAUNCH_F","DOM_VK_XF86XK_LIGHT_BULB","DOM_VK_XF86XK_LOG_OFF","DOM_VK_XF86XK_MAIL","DOM_VK_XF86XK_MAIL_FORWARD","DOM_VK_XF86XK_MARKET","DOM_VK_XF86XK_MEETING","DOM_VK_XF86XK_MEMO","DOM_VK_XF86XK_MENU_KB","DOM_VK_XF86XK_MENU_PB","DOM_VK_XF86XK_MESSENGER","DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN","DOM_VK_XF86XK_MON_BRIGHTNESS_UP","DOM_VK_XF86XK_MUSIC","DOM_VK_XF86XK_MY_COMPUTER","DOM_VK_XF86XK_MY_SITES","DOM_VK_XF86XK_NEW","DOM_VK_XF86XK_NEWS","DOM_VK_XF86XK_OFFICE_HOME","DOM_VK_XF86XK_OPEN","DOM_VK_XF86XK_OPEN_URL","DOM_VK_XF86XK_OPTION","DOM_VK_XF86XK_PASTE","DOM_VK_XF86XK_PHONE","DOM_VK_XF86XK_PICTURES","DOM_VK_XF86XK_POWER_DOWN","DOM_VK_XF86XK_POWER_OFF","DOM_VK_XF86XK_RED","DOM_VK_XF86XK_REFRESH","DOM_VK_XF86XK_RELOAD","DOM_VK_XF86XK_REPLY","DOM_VK_XF86XK_ROCKER_DOWN","DOM_VK_XF86XK_ROCKER_ENTER","DOM_VK_XF86XK_ROCKER_UP","DOM_VK_XF86XK_ROTATE_WINDOWS","DOM_VK_XF86XK_ROTATION_KB","DOM_VK_XF86XK_ROTATION_PB","DOM_VK_XF86XK_SAVE","DOM_VK_XF86XK_SCREEN_SAVER","DOM_VK_XF86XK_SCROLL_CLICK","DOM_VK_XF86XK_SCROLL_DOWN","DOM_VK_XF86XK_SCROLL_UP","DOM_VK_XF86XK_SEARCH","DOM_VK_XF86XK_SEND","DOM_VK_XF86XK_SHOP","DOM_VK_XF86XK_SPELL","DOM_VK_XF86XK_SPLIT_SCREEN","DOM_VK_XF86XK_STANDBY","DOM_VK_XF86XK_START","DOM_VK_XF86XK_STOP","DOM_VK_XF86XK_SUBTITLE","DOM_VK_XF86XK_SUPPORT","DOM_VK_XF86XK_SUSPEND","DOM_VK_XF86XK_TASK_PANE","DOM_VK_XF86XK_TERMINAL","DOM_VK_XF86XK_TIME","DOM_VK_XF86XK_TOOLS","DOM_VK_XF86XK_TOP_MENU","DOM_VK_XF86XK_TO_DO_LIST","DOM_VK_XF86XK_TRAVEL","DOM_VK_XF86XK_USER1KB","DOM_VK_XF86XK_USER2KB","DOM_VK_XF86XK_USER_PB","DOM_VK_XF86XK_UWB","DOM_VK_XF86XK_VENDOR_HOME","DOM_VK_XF86XK_VIDEO","DOM_VK_XF86XK_VIEW","DOM_VK_XF86XK_WAKE_UP","DOM_VK_XF86XK_WEB_CAM","DOM_VK_XF86XK_WHEEL_BUTTON","DOM_VK_XF86XK_WLAN","DOM_VK_XF86XK_WORD","DOM_VK_XF86XK_WWW","DOM_VK_XF86XK_XFER","DOM_VK_XF86XK_YELLOW","DOM_VK_XF86XK_ZOOM_IN","DOM_VK_XF86XK_ZOOM_OUT","DOM_VK_Y","DOM_VK_Z","DOM_VK_ZOOM","DONE","DONT_CARE","DOWNLOADING","DRAGDROP","DST_ALPHA","DST_COLOR","DYNAMIC_DRAW","DataChannel","DataTransfer","DataTransferItem","DataTransferItemList","DataView","Date","DateTimeFormat","DelayNode","DesktopNotification","DesktopNotificationCenter","DeviceLightEvent","DeviceMotionEvent","DeviceOrientationEvent","DeviceProximityEvent","DeviceStorage","DeviceStorageChangeEvent","Document","DocumentFragment","DocumentType","DragEvent","DynamicsCompressorNode","E","ELEMENT_ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER_BINDING","ELEMENT_NODE","EMPTY","ENCODING_ERR","ENDED","END_TO_END","END_TO_START","ENTITY_NODE","ENTITY_REFERENCE_NODE","EPSILON","EQUAL","EQUALPOWER","ERROR","EXPONENTIAL_DISTANCE","Element","ElementQuery","Entity","EntityReference","Error","ErrorEvent","EvalError","Event","EventException","EventSource","EventTarget","External","FASTEST","FIDOSDK","FILTER_ACCEPT","FILTER_INTERRUPT","FILTER_REJECT","FILTER_SKIP","FINISHED_STATE","FIRST_ORDERED_NODE_TYPE","FLOAT","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","FOCUS","FONT_FACE_RULE","FONT_FEATURE_VALUES_RULE","FRAGMENT_SHADER","FRAGMENT_SHADER_DERIVATIVE_HINT_OES","FRAMEBUFFER","FRAMEBUFFER_ATTACHMENT_OBJECT_NAME","FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE","FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE","FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL","FRAMEBUFFER_BINDING","FRAMEBUFFER_COMPLETE","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_UNSUPPORTED","FRONT","FRONT_AND_BACK","FRONT_FACE","FUNC_ADD","FUNC_REVERSE_SUBTRACT","FUNC_SUBTRACT","Feed","FeedEntry","File","FileError","FileList","FileReader","FindInPage","Float32Array","Float64Array","FocusEvent","FontFace","FormData","Function","GENERATE_MIPMAP_HINT","GEQUAL","GREATER","GREEN_BITS","GainNode","Gamepad","GamepadButton","GamepadEvent","GestureEvent","HAVE_CURRENT_DATA","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","HAVE_METADATA","HAVE_NOTHING","HEADERS_RECEIVED","HIDDEN","HIERARCHY_REQUEST_ERR","HIGHPASS","HIGHSHELF","HIGH_FLOAT","HIGH_INT","HORIZONTAL","HORIZONTAL_AXIS","HRTF","HTMLAllCollection","HTMLAnchorElement","HTMLAppletElement","HTMLAreaElement","HTMLAudioElement","HTMLBRElement","HTMLBaseElement","HTMLBaseFontElement","HTMLBlockquoteElement","HTMLBodyElement","HTMLButtonElement","HTMLCanvasElement","HTMLCollection","HTMLCommandElement","HTMLContentElement","HTMLDListElement","HTMLDataElement","HTMLDataListElement","HTMLDetailsElement","HTMLDialogElement","HTMLDirectoryElement","HTMLDivElement","HTMLDocument","HTMLElement","HTMLEmbedElement","HTMLFieldSetElement","HTMLFontElement","HTMLFormControlsCollection","HTMLFormElement","HTMLFrameElement","HTMLFrameSetElement","HTMLHRElement","HTMLHeadElement","HTMLHeadingElement","HTMLHtmlElement","HTMLIFrameElement","HTMLImageElement","HTMLInputElement","HTMLIsIndexElement","HTMLKeygenElement","HTMLLIElement","HTMLLabelElement","HTMLLegendElement","HTMLLinkElement","HTMLMapElement","HTMLMarqueeElement","HTMLMediaElement","HTMLMenuElement","HTMLMenuItemElement","HTMLMetaElement","HTMLMeterElement","HTMLModElement","HTMLOListElement","HTMLObjectElement","HTMLOptGroupElement","HTMLOptionElement","HTMLOptionsCollection","HTMLOutputElement","HTMLParagraphElement","HTMLParamElement","HTMLPictureElement","HTMLPreElement","HTMLProgressElement","HTMLPropertiesCollection","HTMLQuoteElement","HTMLScriptElement","HTMLSelectElement","HTMLShadowElement","HTMLSourceElement","HTMLSpanElement","HTMLStyleElement","HTMLTableCaptionElement","HTMLTableCellElement","HTMLTableColElement","HTMLTableElement","HTMLTableRowElement","HTMLTableSectionElement","HTMLTemplateElement","HTMLTextAreaElement","HTMLTimeElement","HTMLTitleElement","HTMLTrackElement","HTMLUListElement","HTMLUnknownElement","HTMLVideoElement","HashChangeEvent","Headers","History","ICE_CHECKING","ICE_CLOSED","ICE_COMPLETED","ICE_CONNECTED","ICE_FAILED","ICE_GATHERING","ICE_WAITING","IDBCursor","IDBCursorWithValue","IDBDatabase","IDBDatabaseException","IDBFactory","IDBFileHandle","IDBFileRequest","IDBIndex","IDBKeyRange","IDBMutableFile","IDBObjectStore","IDBOpenDBRequest","IDBRequest","IDBTransaction","IDBVersionChangeEvent","IDLE","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","IMPORT_RULE","INCR","INCR_WRAP","INDEX_SIZE_ERR","INT","INT_VEC2","INT_VEC3","INT_VEC4","INUSE_ATTRIBUTE_ERR","INVALID_ACCESS_ERR","INVALID_CHARACTER_ERR","INVALID_ENUM","INVALID_EXPRESSION_ERR","INVALID_FRAMEBUFFER_OPERATION","INVALID_MODIFICATION_ERR","INVALID_NODE_TYPE_ERR","INVALID_OPERATION","INVALID_STATE_ERR","INVALID_VALUE","INVERSE_DISTANCE","INVERT","IceCandidate","Image","ImageBitmap","ImageData","Infinity","InputEvent","InputMethodContext","InstallTrigger","Int16Array","Int32Array","Int8Array","Intent","InternalError","Intl","IsSearchProviderInstalled","Iterator","JSON","KEEP","KEYDOWN","KEYFRAMES_RULE","KEYFRAME_RULE","KEYPRESS","KEYUP","KeyEvent","KeyboardEvent","LENGTHADJUST_SPACING","LENGTHADJUST_SPACINGANDGLYPHS","LENGTHADJUST_UNKNOWN","LEQUAL","LESS","LINEAR","LINEAR_DISTANCE","LINEAR_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINES","LINE_LOOP","LINE_STRIP","LINE_WIDTH","LINK_STATUS","LIVE","LN10","LN2","LOADED","LOADING","LOG10E","LOG2E","LOWPASS","LOWSHELF","LOW_FLOAT","LOW_INT","LSException","LSParserFilter","LUMINANCE","LUMINANCE_ALPHA","LocalMediaStream","Location","MAX_COMBINED_TEXTURE_IMAGE_UNITS","MAX_CUBE_MAP_TEXTURE_SIZE","MAX_FRAGMENT_UNIFORM_VECTORS","MAX_RENDERBUFFER_SIZE","MAX_SAFE_INTEGER","MAX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_MAX_ANISOTROPY_EXT","MAX_TEXTURE_SIZE","MAX_VALUE","MAX_VARYING_VECTORS","MAX_VERTEX_ATTRIBS","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_VERTEX_UNIFORM_VECTORS","MAX_VIEWPORT_DIMS","MEDIA_ERR_ABORTED","MEDIA_ERR_DECODE","MEDIA_ERR_ENCRYPTED","MEDIA_ERR_NETWORK","MEDIA_ERR_SRC_NOT_SUPPORTED","MEDIA_KEYERR_CLIENT","MEDIA_KEYERR_DOMAIN","MEDIA_KEYERR_HARDWARECHANGE","MEDIA_KEYERR_OUTPUT","MEDIA_KEYERR_SERVICE","MEDIA_KEYERR_UNKNOWN","MEDIA_RULE","MEDIUM_FLOAT","MEDIUM_INT","META_MASK","MIN_SAFE_INTEGER","MIN_VALUE","MIRRORED_REPEAT","MODE_ASYNCHRONOUS","MODE_SYNCHRONOUS","MODIFICATION","MOUSEDOWN","MOUSEDRAG","MOUSEMOVE","MOUSEOUT","MOUSEOVER","MOUSEUP","MOZ_KEYFRAMES_RULE","MOZ_KEYFRAME_RULE","MOZ_SOURCE_CURSOR","MOZ_SOURCE_ERASER","MOZ_SOURCE_KEYBOARD","MOZ_SOURCE_MOUSE","MOZ_SOURCE_PEN","MOZ_SOURCE_TOUCH","MOZ_SOURCE_UNKNOWN","MSGESTURE_FLAG_BEGIN","MSGESTURE_FLAG_CANCEL","MSGESTURE_FLAG_END","MSGESTURE_FLAG_INERTIA","MSGESTURE_FLAG_NONE","MSPOINTER_TYPE_MOUSE","MSPOINTER_TYPE_PEN","MSPOINTER_TYPE_TOUCH","MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE","MS_ASYNC_CALLBACK_STATUS_CANCEL","MS_ASYNC_CALLBACK_STATUS_CHOOSEANY","MS_ASYNC_CALLBACK_STATUS_ERROR","MS_ASYNC_CALLBACK_STATUS_JOIN","MS_ASYNC_OP_STATUS_CANCELED","MS_ASYNC_OP_STATUS_ERROR","MS_ASYNC_OP_STATUS_SUCCESS","MS_MANIPULATION_STATE_ACTIVE","MS_MANIPULATION_STATE_CANCELLED","MS_MANIPULATION_STATE_COMMITTED","MS_MANIPULATION_STATE_DRAGGING","MS_MANIPULATION_STATE_INERTIA","MS_MANIPULATION_STATE_PRESELECT","MS_MANIPULATION_STATE_SELECTING","MS_MANIPULATION_STATE_STOPPED","MS_MEDIA_ERR_ENCRYPTED","MS_MEDIA_KEYERR_CLIENT","MS_MEDIA_KEYERR_DOMAIN","MS_MEDIA_KEYERR_HARDWARECHANGE","MS_MEDIA_KEYERR_OUTPUT","MS_MEDIA_KEYERR_SERVICE","MS_MEDIA_KEYERR_UNKNOWN","Map","Math","MediaController","MediaDevices","MediaElementAudioSourceNode","MediaEncryptedEvent","MediaError","MediaKeyError","MediaKeyEvent","MediaKeyMessageEvent","MediaKeyNeededEvent","MediaKeySession","MediaKeyStatusMap","MediaKeySystemAccess","MediaKeys","MediaList","MediaQueryList","MediaQueryListEvent","MediaRecorder","MediaSource","MediaStream","MediaStreamAudioDestinationNode","MediaStreamAudioSourceNode","MediaStreamEvent","MediaStreamTrack","MediaStreamTrackEvent","MessageChannel","MessageEvent","MessagePort","Methods","MimeType","MimeTypeArray","MouseEvent","MouseScrollEvent","MozAnimation","MozAnimationDelay","MozAnimationDirection","MozAnimationDuration","MozAnimationFillMode","MozAnimationIterationCount","MozAnimationName","MozAnimationPlayState","MozAnimationTimingFunction","MozAppearance","MozBackfaceVisibility","MozBinding","MozBorderBottomColors","MozBorderEnd","MozBorderEndColor","MozBorderEndStyle","MozBorderEndWidth","MozBorderImage","MozBorderLeftColors","MozBorderRightColors","MozBorderStart","MozBorderStartColor","MozBorderStartStyle","MozBorderStartWidth","MozBorderTopColors","MozBoxAlign","MozBoxDirection","MozBoxFlex","MozBoxOrdinalGroup","MozBoxOrient","MozBoxPack","MozBoxSizing","MozCSSKeyframeRule","MozCSSKeyframesRule","MozColumnCount","MozColumnFill","MozColumnGap","MozColumnRule","MozColumnRuleColor","MozColumnRuleStyle","MozColumnRuleWidth","MozColumnWidth","MozColumns","MozContactChangeEvent","MozFloatEdge","MozFontFeatureSettings","MozFontLanguageOverride","MozForceBrokenImageIcon","MozHyphens","MozImageRegion","MozMarginEnd","MozMarginStart","MozMmsEvent","MozMmsMessage","MozMobileMessageThread","MozOSXFontSmoothing","MozOrient","MozOutlineRadius","MozOutlineRadiusBottomleft","MozOutlineRadiusBottomright","MozOutlineRadiusTopleft","MozOutlineRadiusTopright","MozPaddingEnd","MozPaddingStart","MozPerspective","MozPerspectiveOrigin","MozPowerManager","MozSettingsEvent","MozSmsEvent","MozSmsMessage","MozStackSizing","MozTabSize","MozTextAlignLast","MozTextDecorationColor","MozTextDecorationLine","MozTextDecorationStyle","MozTextSizeAdjust","MozTransform","MozTransformOrigin","MozTransformStyle","MozTransition","MozTransitionDelay","MozTransitionDuration","MozTransitionProperty","MozTransitionTimingFunction","MozUserFocus","MozUserInput","MozUserModify","MozUserSelect","MozWindowDragging","MozWindowShadow","MutationEvent","MutationObserver","MutationRecord","NAMESPACE_ERR","NAMESPACE_RULE","NEAREST","NEAREST_MIPMAP_LINEAR","NEAREST_MIPMAP_NEAREST","NEGATIVE_INFINITY","NETWORK_EMPTY","NETWORK_ERR","NETWORK_IDLE","NETWORK_LOADED","NETWORK_LOADING","NETWORK_NO_SOURCE","NEVER","NEW","NEXT","NEXT_NO_DUPLICATE","NICEST","NODE_AFTER","NODE_BEFORE","NODE_BEFORE_AND_AFTER","NODE_INSIDE","NONE","NON_TRANSIENT_ERR","NOTATION_NODE","NOTCH","NOTEQUAL","NOT_ALLOWED_ERR","NOT_FOUND_ERR","NOT_READABLE_ERR","NOT_SUPPORTED_ERR","NO_DATA_ALLOWED_ERR","NO_ERR","NO_ERROR","NO_MODIFICATION_ALLOWED_ERR","NUMBER_TYPE","NUM_COMPRESSED_TEXTURE_FORMATS","NaN","NamedNodeMap","Navigator","NearbyLinks","NetworkInformation","Node","NodeFilter","NodeIterator","NodeList","Notation","Notification","NotifyPaintEvent","Number","NumberFormat","OBSOLETE","ONE","ONE_MINUS_CONSTANT_ALPHA","ONE_MINUS_CONSTANT_COLOR","ONE_MINUS_DST_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_SRC_COLOR","OPEN","OPENED","OPENING","ORDERED_NODE_ITERATOR_TYPE","ORDERED_NODE_SNAPSHOT_TYPE","OUT_OF_MEMORY","Object","OfflineAudioCompletionEvent","OfflineAudioContext","OfflineResourceList","Option","OscillatorNode","OverflowEvent","PACK_ALIGNMENT","PAGE_RULE","PARSE_ERR","PATHSEG_ARC_ABS","PATHSEG_ARC_REL","PATHSEG_CLOSEPATH","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","PATHSEG_LINETO_ABS","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_REL","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_MOVETO_ABS","PATHSEG_MOVETO_REL","PATHSEG_UNKNOWN","PATH_EXISTS_ERR","PEAKING","PERMISSION_DENIED","PERSISTENT","PI","PLAYING_STATE","POINTS","POLYGON_OFFSET_FACTOR","POLYGON_OFFSET_FILL","POLYGON_OFFSET_UNITS","POSITION_UNAVAILABLE","POSITIVE_INFINITY","PREV","PREV_NO_DUPLICATE","PROCESSING_INSTRUCTION_NODE","PageChangeEvent","PageTransitionEvent","PaintRequest","PaintRequestList","PannerNode","Path2D","Performance","PerformanceEntry","PerformanceMark","PerformanceMeasure","PerformanceNavigation","PerformanceResourceTiming","PerformanceTiming","PeriodicWave","Plugin","PluginArray","PopStateEvent","PopupBlockedEvent","ProcessingInstruction","ProgressEvent","Promise","PropertyNodeList","Proxy","PushManager","PushSubscription","Q","QUOTA_ERR","QUOTA_EXCEEDED_ERR","QueryInterface","READ_ONLY","READ_ONLY_ERR","READ_WRITE","RED_BITS","REMOVAL","RENDERBUFFER","RENDERBUFFER_ALPHA_SIZE","RENDERBUFFER_BINDING","RENDERBUFFER_BLUE_SIZE","RENDERBUFFER_DEPTH_SIZE","RENDERBUFFER_GREEN_SIZE","RENDERBUFFER_HEIGHT","RENDERBUFFER_INTERNAL_FORMAT","RENDERBUFFER_RED_SIZE","RENDERBUFFER_STENCIL_SIZE","RENDERBUFFER_WIDTH","RENDERER","RENDERING_INTENT_ABSOLUTE_COLORIMETRIC","RENDERING_INTENT_AUTO","RENDERING_INTENT_PERCEPTUAL","RENDERING_INTENT_RELATIVE_COLORIMETRIC","RENDERING_INTENT_SATURATION","RENDERING_INTENT_UNKNOWN","REPEAT","REPLACE","RGB","RGB565","RGB5_A1","RGBA","RGBA4","RGBColor","ROTATION_CLOCKWISE","ROTATION_COUNTERCLOCKWISE","RTCDataChannelEvent","RTCIceCandidate","RTCPeerConnectionIceEvent","RTCRtpReceiver","RTCRtpSender","RTCSessionDescription","RTCStatsReport","RadioNodeList","Range","RangeError","RangeException","RecordErrorEvent","Rect","ReferenceError","RegExp","Request","Response","SAMPLER_2D","SAMPLER_CUBE","SAMPLES","SAMPLE_ALPHA_TO_COVERAGE","SAMPLE_BUFFERS","SAMPLE_COVERAGE","SAMPLE_COVERAGE_INVERT","SAMPLE_COVERAGE_VALUE","SAWTOOTH","SCHEDULED_STATE","SCISSOR_BOX","SCISSOR_TEST","SCROLL_PAGE_DOWN","SCROLL_PAGE_UP","SDP_ANSWER","SDP_OFFER","SDP_PRANSWER","SECURITY_ERR","SELECT","SERIALIZE_ERR","SEVERITY_ERROR","SEVERITY_FATAL_ERROR","SEVERITY_WARNING","SHADER_COMPILER","SHADER_TYPE","SHADING_LANGUAGE_VERSION","SHIFT_MASK","SHORT","SHOWING","SHOW_ALL","SHOW_ATTRIBUTE","SHOW_CDATA_SECTION","SHOW_COMMENT","SHOW_DOCUMENT","SHOW_DOCUMENT_FRAGMENT","SHOW_DOCUMENT_TYPE","SHOW_ELEMENT","SHOW_ENTITY","SHOW_ENTITY_REFERENCE","SHOW_NOTATION","SHOW_PROCESSING_INSTRUCTION","SHOW_TEXT","SINE","SOUNDFIELD","SQLException","SQRT1_2","SQRT2","SQUARE","SRC_ALPHA","SRC_ALPHA_SATURATE","SRC_COLOR","START_TO_END","START_TO_START","STATIC_DRAW","STENCIL_ATTACHMENT","STENCIL_BACK_FAIL","STENCIL_BACK_FUNC","STENCIL_BACK_PASS_DEPTH_FAIL","STENCIL_BACK_PASS_DEPTH_PASS","STENCIL_BACK_REF","STENCIL_BACK_VALUE_MASK","STENCIL_BACK_WRITEMASK","STENCIL_BITS","STENCIL_BUFFER_BIT","STENCIL_CLEAR_VALUE","STENCIL_FAIL","STENCIL_FUNC","STENCIL_INDEX","STENCIL_INDEX8","STENCIL_PASS_DEPTH_FAIL","STENCIL_PASS_DEPTH_PASS","STENCIL_REF","STENCIL_TEST","STENCIL_VALUE_MASK","STENCIL_WRITEMASK","STREAM_DRAW","STRING_TYPE","STYLE_RULE","SUBPIXEL_BITS","SUPPORTS_RULE","SVGAElement","SVGAltGlyphDefElement","SVGAltGlyphElement","SVGAltGlyphItemElement","SVGAngle","SVGAnimateColorElement","SVGAnimateElement","SVGAnimateMotionElement","SVGAnimateTransformElement","SVGAnimatedAngle","SVGAnimatedBoolean","SVGAnimatedEnumeration","SVGAnimatedInteger","SVGAnimatedLength","SVGAnimatedLengthList","SVGAnimatedNumber","SVGAnimatedNumberList","SVGAnimatedPreserveAspectRatio","SVGAnimatedRect","SVGAnimatedString","SVGAnimatedTransformList","SVGAnimationElement","SVGCircleElement","SVGClipPathElement","SVGColor","SVGComponentTransferFunctionElement","SVGCursorElement","SVGDefsElement","SVGDescElement","SVGDiscardElement","SVGDocument","SVGElement","SVGElementInstance","SVGElementInstanceList","SVGEllipseElement","SVGException","SVGFEBlendElement","SVGFEColorMatrixElement","SVGFEComponentTransferElement","SVGFECompositeElement","SVGFEConvolveMatrixElement","SVGFEDiffuseLightingElement","SVGFEDisplacementMapElement","SVGFEDistantLightElement","SVGFEDropShadowElement","SVGFEFloodElement","SVGFEFuncAElement","SVGFEFuncBElement","SVGFEFuncGElement","SVGFEFuncRElement","SVGFEGaussianBlurElement","SVGFEImageElement","SVGFEMergeElement","SVGFEMergeNodeElement","SVGFEMorphologyElement","SVGFEOffsetElement","SVGFEPointLightElement","SVGFESpecularLightingElement","SVGFESpotLightElement","SVGFETileElement","SVGFETurbulenceElement","SVGFilterElement","SVGFontElement","SVGFontFaceElement","SVGFontFaceFormatElement","SVGFontFaceNameElement","SVGFontFaceSrcElement","SVGFontFaceUriElement","SVGForeignObjectElement","SVGGElement","SVGGeometryElement","SVGGlyphElement","SVGGlyphRefElement","SVGGradientElement","SVGGraphicsElement","SVGHKernElement","SVGImageElement","SVGLength","SVGLengthList","SVGLineElement","SVGLinearGradientElement","SVGMPathElement","SVGMarkerElement","SVGMaskElement","SVGMatrix","SVGMetadataElement","SVGMissingGlyphElement","SVGNumber","SVGNumberList","SVGPaint","SVGPathElement","SVGPathSeg","SVGPathSegArcAbs","SVGPathSegArcRel","SVGPathSegClosePath","SVGPathSegCurvetoCubicAbs","SVGPathSegCurvetoCubicRel","SVGPathSegCurvetoCubicSmoothAbs","SVGPathSegCurvetoCubicSmoothRel","SVGPathSegCurvetoQuadraticAbs","SVGPathSegCurvetoQuadraticRel","SVGPathSegCurvetoQuadraticSmoothAbs","SVGPathSegCurvetoQuadraticSmoothRel","SVGPathSegLinetoAbs","SVGPathSegLinetoHorizontalAbs","SVGPathSegLinetoHorizontalRel","SVGPathSegLinetoRel","SVGPathSegLinetoVerticalAbs","SVGPathSegLinetoVerticalRel","SVGPathSegList","SVGPathSegMovetoAbs","SVGPathSegMovetoRel","SVGPatternElement","SVGPoint","SVGPointList","SVGPolygonElement","SVGPolylineElement","SVGPreserveAspectRatio","SVGRadialGradientElement","SVGRect","SVGRectElement","SVGRenderingIntent","SVGSVGElement","SVGScriptElement","SVGSetElement","SVGStopElement","SVGStringList","SVGStyleElement","SVGSwitchElement","SVGSymbolElement","SVGTRefElement","SVGTSpanElement","SVGTextContentElement","SVGTextElement","SVGTextPathElement","SVGTextPositioningElement","SVGTitleElement","SVGTransform","SVGTransformList","SVGUnitTypes","SVGUseElement","SVGVKernElement","SVGViewElement","SVGViewSpec","SVGZoomAndPan","SVGZoomEvent","SVG_ANGLETYPE_DEG","SVG_ANGLETYPE_GRAD","SVG_ANGLETYPE_RAD","SVG_ANGLETYPE_UNKNOWN","SVG_ANGLETYPE_UNSPECIFIED","SVG_CHANNEL_A","SVG_CHANNEL_B","SVG_CHANNEL_G","SVG_CHANNEL_R","SVG_CHANNEL_UNKNOWN","SVG_COLORTYPE_CURRENTCOLOR","SVG_COLORTYPE_RGBCOLOR","SVG_COLORTYPE_RGBCOLOR_ICCCOLOR","SVG_COLORTYPE_UNKNOWN","SVG_EDGEMODE_DUPLICATE","SVG_EDGEMODE_NONE","SVG_EDGEMODE_UNKNOWN","SVG_EDGEMODE_WRAP","SVG_FEBLEND_MODE_COLOR","SVG_FEBLEND_MODE_COLOR_BURN","SVG_FEBLEND_MODE_COLOR_DODGE","SVG_FEBLEND_MODE_DARKEN","SVG_FEBLEND_MODE_DIFFERENCE","SVG_FEBLEND_MODE_EXCLUSION","SVG_FEBLEND_MODE_HARD_LIGHT","SVG_FEBLEND_MODE_HUE","SVG_FEBLEND_MODE_LIGHTEN","SVG_FEBLEND_MODE_LUMINOSITY","SVG_FEBLEND_MODE_MULTIPLY","SVG_FEBLEND_MODE_NORMAL","SVG_FEBLEND_MODE_OVERLAY","SVG_FEBLEND_MODE_SATURATION","SVG_FEBLEND_MODE_SCREEN","SVG_FEBLEND_MODE_SOFT_LIGHT","SVG_FEBLEND_MODE_UNKNOWN","SVG_FECOLORMATRIX_TYPE_HUEROTATE","SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA","SVG_FECOLORMATRIX_TYPE_MATRIX","SVG_FECOLORMATRIX_TYPE_SATURATE","SVG_FECOLORMATRIX_TYPE_UNKNOWN","SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE","SVG_FECOMPONENTTRANSFER_TYPE_GAMMA","SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY","SVG_FECOMPONENTTRANSFER_TYPE_LINEAR","SVG_FECOMPONENTTRANSFER_TYPE_TABLE","SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN","SVG_FECOMPOSITE_OPERATOR_ARITHMETIC","SVG_FECOMPOSITE_OPERATOR_ATOP","SVG_FECOMPOSITE_OPERATOR_IN","SVG_FECOMPOSITE_OPERATOR_OUT","SVG_FECOMPOSITE_OPERATOR_OVER","SVG_FECOMPOSITE_OPERATOR_UNKNOWN","SVG_FECOMPOSITE_OPERATOR_XOR","SVG_INVALID_VALUE_ERR","SVG_LENGTHTYPE_CM","SVG_LENGTHTYPE_EMS","SVG_LENGTHTYPE_EXS","SVG_LENGTHTYPE_IN","SVG_LENGTHTYPE_MM","SVG_LENGTHTYPE_NUMBER","SVG_LENGTHTYPE_PC","SVG_LENGTHTYPE_PERCENTAGE","SVG_LENGTHTYPE_PT","SVG_LENGTHTYPE_PX","SVG_LENGTHTYPE_UNKNOWN","SVG_MARKERUNITS_STROKEWIDTH","SVG_MARKERUNITS_UNKNOWN","SVG_MARKERUNITS_USERSPACEONUSE","SVG_MARKER_ORIENT_ANGLE","SVG_MARKER_ORIENT_AUTO","SVG_MARKER_ORIENT_UNKNOWN","SVG_MASKTYPE_ALPHA","SVG_MASKTYPE_LUMINANCE","SVG_MATRIX_NOT_INVERTABLE","SVG_MEETORSLICE_MEET","SVG_MEETORSLICE_SLICE","SVG_MEETORSLICE_UNKNOWN","SVG_MORPHOLOGY_OPERATOR_DILATE","SVG_MORPHOLOGY_OPERATOR_ERODE","SVG_MORPHOLOGY_OPERATOR_UNKNOWN","SVG_PAINTTYPE_CURRENTCOLOR","SVG_PAINTTYPE_NONE","SVG_PAINTTYPE_RGBCOLOR","SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR","SVG_PAINTTYPE_UNKNOWN","SVG_PAINTTYPE_URI","SVG_PAINTTYPE_URI_CURRENTCOLOR","SVG_PAINTTYPE_URI_NONE","SVG_PAINTTYPE_URI_RGBCOLOR","SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR","SVG_PRESERVEASPECTRATIO_NONE","SVG_PRESERVEASPECTRATIO_UNKNOWN","SVG_PRESERVEASPECTRATIO_XMAXYMAX","SVG_PRESERVEASPECTRATIO_XMAXYMID","SVG_PRESERVEASPECTRATIO_XMAXYMIN","SVG_PRESERVEASPECTRATIO_XMIDYMAX","SVG_PRESERVEASPECTRATIO_XMIDYMID","SVG_PRESERVEASPECTRATIO_XMIDYMIN","SVG_PRESERVEASPECTRATIO_XMINYMAX","SVG_PRESERVEASPECTRATIO_XMINYMID","SVG_PRESERVEASPECTRATIO_XMINYMIN","SVG_SPREADMETHOD_PAD","SVG_SPREADMETHOD_REFLECT","SVG_SPREADMETHOD_REPEAT","SVG_SPREADMETHOD_UNKNOWN","SVG_STITCHTYPE_NOSTITCH","SVG_STITCHTYPE_STITCH","SVG_STITCHTYPE_UNKNOWN","SVG_TRANSFORM_MATRIX","SVG_TRANSFORM_ROTATE","SVG_TRANSFORM_SCALE","SVG_TRANSFORM_SKEWX","SVG_TRANSFORM_SKEWY","SVG_TRANSFORM_TRANSLATE","SVG_TRANSFORM_UNKNOWN","SVG_TURBULENCE_TYPE_FRACTALNOISE","SVG_TURBULENCE_TYPE_TURBULENCE","SVG_TURBULENCE_TYPE_UNKNOWN","SVG_UNIT_TYPE_OBJECTBOUNDINGBOX","SVG_UNIT_TYPE_UNKNOWN","SVG_UNIT_TYPE_USERSPACEONUSE","SVG_WRONG_TYPE_ERR","SVG_ZOOMANDPAN_DISABLE","SVG_ZOOMANDPAN_MAGNIFY","SVG_ZOOMANDPAN_UNKNOWN","SYNTAX_ERR","SavedPages","Screen","ScreenOrientation","Script","ScriptProcessorNode","ScrollAreaEvent","SecurityPolicyViolationEvent","Selection","ServiceWorker","ServiceWorkerContainer","ServiceWorkerRegistration","SessionDescription","Set","ShadowRoot","SharedWorker","SimpleGestureEvent","SpeechSynthesisEvent","SpeechSynthesisUtterance","StopIteration","Storage","StorageEvent","String","StyleSheet","StyleSheetList","SubtleCrypto","Symbol","SyntaxError","TEMPORARY","TEXTPATH_METHODTYPE_ALIGN","TEXTPATH_METHODTYPE_STRETCH","TEXTPATH_METHODTYPE_UNKNOWN","TEXTPATH_SPACINGTYPE_AUTO","TEXTPATH_SPACINGTYPE_EXACT","TEXTPATH_SPACINGTYPE_UNKNOWN","TEXTURE","TEXTURE0","TEXTURE1","TEXTURE10","TEXTURE11","TEXTURE12","TEXTURE13","TEXTURE14","TEXTURE15","TEXTURE16","TEXTURE17","TEXTURE18","TEXTURE19","TEXTURE2","TEXTURE20","TEXTURE21","TEXTURE22","TEXTURE23","TEXTURE24","TEXTURE25","TEXTURE26","TEXTURE27","TEXTURE28","TEXTURE29","TEXTURE3","TEXTURE30","TEXTURE31","TEXTURE4","TEXTURE5","TEXTURE6","TEXTURE7","TEXTURE8","TEXTURE9","TEXTURE_2D","TEXTURE_BINDING_2D","TEXTURE_BINDING_CUBE_MAP","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Z","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_MAG_FILTER","TEXTURE_MAX_ANISOTROPY_EXT","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXT_NODE","TIMEOUT","TIMEOUT_ERR","TOO_LARGE_ERR","TRANSACTION_INACTIVE_ERR","TRIANGLE","TRIANGLES","TRIANGLE_FAN","TRIANGLE_STRIP","TYPE_BACK_FORWARD","TYPE_ERR","TYPE_MISMATCH_ERR","TYPE_NAVIGATE","TYPE_RELOAD","TYPE_RESERVED","Text","TextDecoder","TextEncoder","TextEvent","TextMetrics","TextTrack","TextTrackCue","TextTrackCueList","TextTrackList","TimeEvent","TimeRanges","Touch","TouchEvent","TouchList","TrackEvent","TransitionEvent","TreeWalker","TypeError","UIEvent","UNCACHED","UNKNOWN_ERR","UNKNOWN_RULE","UNMASKED_RENDERER_WEBGL","UNMASKED_VENDOR_WEBGL","UNORDERED_NODE_ITERATOR_TYPE","UNORDERED_NODE_SNAPSHOT_TYPE","UNPACK_ALIGNMENT","UNPACK_COLORSPACE_CONVERSION_WEBGL","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNSCHEDULED_STATE","UNSENT","UNSIGNED_BYTE","UNSIGNED_INT","UNSIGNED_SHORT","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","UNSPECIFIED_EVENT_TYPE_ERR","UPDATEREADY","URIError","URL","URLSearchParams","URLUnencoded","URL_MISMATCH_ERR","UTC","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","UserMessageHandler","UserMessageHandlersNamespace","UserProximityEvent","VALIDATE_STATUS","VALIDATION_ERR","VARIABLES_RULE","VENDOR","VERSION","VERSION_CHANGE","VERSION_ERR","VERTEX_ATTRIB_ARRAY_BUFFER_BINDING","VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE","VERTEX_ATTRIB_ARRAY_ENABLED","VERTEX_ATTRIB_ARRAY_NORMALIZED","VERTEX_ATTRIB_ARRAY_POINTER","VERTEX_ATTRIB_ARRAY_SIZE","VERTEX_ATTRIB_ARRAY_STRIDE","VERTEX_ATTRIB_ARRAY_TYPE","VERTEX_SHADER","VERTICAL","VERTICAL_AXIS","VER_ERR","VIEWPORT","VIEWPORT_RULE","VTTCue","VTTRegion","ValidityState","VideoStreamTrack","WEBKIT_FILTER_RULE","WEBKIT_KEYFRAMES_RULE","WEBKIT_KEYFRAME_RULE","WEBKIT_REGION_RULE","WRONG_DOCUMENT_ERR","WaveShaperNode","WeakMap","WeakSet","WebGLActiveInfo","WebGLBuffer","WebGLContextEvent","WebGLFramebuffer","WebGLProgram","WebGLRenderbuffer","WebGLRenderingContext","WebGLShader","WebGLShaderPrecisionFormat","WebGLTexture","WebGLUniformLocation","WebGLVertexArray","WebKitAnimationEvent","WebKitBlobBuilder","WebKitCSSFilterRule","WebKitCSSFilterValue","WebKitCSSKeyframeRule","WebKitCSSKeyframesRule","WebKitCSSMatrix","WebKitCSSRegionRule","WebKitCSSTransformValue","WebKitDataCue","WebKitGamepad","WebKitMediaKeyError","WebKitMediaKeyMessageEvent","WebKitMediaKeySession","WebKitMediaKeys","WebKitMediaSource","WebKitMutationObserver","WebKitNamespace","WebKitPlaybackTargetAvailabilityEvent","WebKitPoint","WebKitShadowRoot","WebKitSourceBuffer","WebKitSourceBufferList","WebKitTransitionEvent","WebSocket","WheelEvent","Window","Worker","XMLDocument","XMLHttpRequest","XMLHttpRequestEventTarget","XMLHttpRequestException","XMLHttpRequestProgressEvent","XMLHttpRequestUpload","XMLSerializer","XMLStylesheetProcessingInstruction","XPathEvaluator","XPathException","XPathExpression","XPathNSResolver","XPathResult","XSLTProcessor","ZERO","_XD0M_","_YD0M_","__defineGetter__","__defineSetter__","__lookupGetter__","__lookupSetter__","__opera","__proto__","_browserjsran","a","aLink","abbr","abort","abs","absolute","acceleration","accelerationIncludingGravity","accelerator","accept","acceptCharset","acceptNode","accessKey","accessKeyLabel","accuracy","acos","acosh","action","actionURL","active","activeCues","activeElement","activeSourceBuffers","activeSourceCount","activeTexture","add","addBehavior","addCandidate","addColorStop","addCue","addElement","addEventListener","addFilter","addFromString","addFromUri","addIceCandidate","addImport","addListener","addNamed","addPageRule","addPath","addPointer","addRange","addRegion","addRule","addSearchEngine","addSourceBuffer","addStream","addTextTrack","addTrack","addWakeLockListener","addedNodes","additionalName","additiveSymbols","addons","adoptNode","adr","advance","alert","algorithm","align","align-content","align-items","align-self","alignContent","alignItems","alignSelf","alignmentBaseline","alinkColor","all","allSettled","allowFullscreen","allowedDirections","alpha","alt","altGraphKey","altHtml","altKey","altLeft","altitude","altitudeAccuracy","amplitude","ancestorOrigins","anchor","anchorNode","anchorOffset","anchors","angle","animVal","animate","animatedInstanceRoot","animatedNormalizedPathSegList","animatedPathSegList","animatedPoints","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","animationDelay","animationDirection","animationDuration","animationFillMode","animationIterationCount","animationName","animationPlayState","animationStartTime","animationTimingFunction","animationsPaused","anniversary","any","app","appCodeName","appMinorVersion","appName","appNotifications","appVersion","append","appendBuffer","appendChild","appendData","appendItem","appendMedium","appendNamed","appendRule","appendStream","appendWindowEnd","appendWindowStart","applets","applicationCache","apply","applyElement","arc","arcTo","archive","areas","arguments","arrayBuffer","asin","asinh","assert","assign","async","atEnd","atan","atan2","atanh","atob","attachEvent","attachShader","attachShadow","attachments","attack","attrChange","attrName","attributeFilter","attributeName","attributeNamespace","attributeOldValue","attributes","audioTracks","autoIncrement","autobuffer","autocapitalize","autocomplete","autocorrect","autofocus","autoplay","availHeight","availLeft","availTop","availWidth","availability","available","aversion","axes","axis","azimuth","b","back","backface-visibility","backfaceVisibility","background","background-attachment","background-blend-mode","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","backgroundAttachment","backgroundBlendMode","backgroundClip","backgroundColor","backgroundImage","backgroundOrigin","backgroundPosition","backgroundPositionX","backgroundPositionY","backgroundRepeat","backgroundSize","badInput","balance","baseFrequencyX","baseFrequencyY","baseNode","baseOffset","baseURI","baseVal","baselineShift","battery","bday","beginElement","beginElementAt","beginPath","behavior","behaviorCookie","behaviorPart","behaviorUrns","beta","bezierCurveTo","bgColor","bgProperties","bias","big","binaryType","bind","bindAttribLocation","bindBuffer","bindFramebuffer","bindRenderbuffer","bindTexture","blendColor","blendEquation","blendEquationSeparate","blendFunc","blendFuncSeparate","blink","blob","blockDirection","blue","blur","body","bodyUsed","bold","bookmarks","booleanValue","border","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","borderBottom","borderBottomColor","borderBottomLeftRadius","borderBottomRightRadius","borderBottomStyle","borderBottomWidth","borderCollapse","borderColor","borderColorDark","borderColorLight","borderImage","borderImageOutset","borderImageRepeat","borderImageSlice","borderImageSource","borderImageWidth","borderLeft","borderLeftColor","borderLeftStyle","borderLeftWidth","borderRadius","borderRight","borderRightColor","borderRightStyle","borderRightWidth","borderSpacing","borderStyle","borderTop","borderTopColor","borderTopLeftRadius","borderTopRightRadius","borderTopStyle","borderTopWidth","borderWidth","bottom","bottomMargin","bound","boundElements","boundingClientRect","boundingHeight","boundingLeft","boundingTop","boundingWidth","bounds","box-decoration-break","box-shadow","box-sizing","boxDecorationBreak","boxShadow","boxSizing","breakAfter","breakBefore","breakInside","browserLanguage","btoa","bubbles","buffer","bufferData","bufferDepth","bufferSize","bufferSubData","buffered","bufferedAmount","buildID","buildNumber","button","buttonID","buttons","byteLength","byteOffset","c","call","caller","canBeFormatted","canBeMounted","canBeShared","canHaveChildren","canHaveHTML","canPlayType","cancel","cancelAnimationFrame","cancelBubble","cancelScheduledValues","cancelable","candidate","canvas","caption","caption-side","captionSide","capture","captureEvents","captureStackTrace","caretPositionFromPoint","caretRangeFromPoint","cast","catch","category","cbrt","cd","ceil","cellIndex","cellPadding","cellSpacing","cells","ch","chOff","chain","challenge","changedTouches","channel","channelCount","channelCountMode","channelInterpretation","char","charAt","charCode","charCodeAt","charIndex","characterData","characterDataOldValue","characterSet","charging","chargingTime","charset","checkEnclosure","checkFramebufferStatus","checkIntersection","checkValidity","checked","childElementCount","childList","childNodes","children","chrome","ciphertext","cite","classList","className","classid","clear","clearAttributes","clearColor","clearData","clearDepth","clearImmediate","clearInterval","clearMarks","clearMeasures","clearParameters","clearRect","clearResourceTimings","clearShadow","clearStencil","clearTimeout","clearWatch","click","clickCount","clientHeight","clientInformation","clientLeft","clientRect","clientRects","clientTop","clientWidth","clientX","clientY","clip","clip-path","clip-rule","clipBottom","clipLeft","clipPath","clipPathUnits","clipRight","clipRule","clipTop","clipboardData","clone","cloneContents","cloneNode","cloneRange","close","closePath","closed","closest","clz","clz32","cmp","code","codeBase","codePointAt","codeType","colSpan","collapse","collapseToEnd","collapseToStart","collapsed","collect","colno","color","color-interpolation","color-interpolation-filters","colorDepth","colorInterpolation","colorInterpolationFilters","colorMask","colorType","cols","columnCount","columnFill","columnGap","columnNumber","columnRule","columnRuleColor","columnRuleStyle","columnRuleWidth","columnSpan","columnWidth","columns","command","commitPreferences","commonAncestorContainer","compact","compareBoundaryPoints","compareDocumentPosition","compareEndPoints","compareNode","comparePoint","compatMode","compatible","compile","compileShader","complete","componentFromPoint","compositionEndOffset","compositionStartOffset","compressedTexImage2D","compressedTexSubImage2D","concat","conditionText","coneInnerAngle","coneOuterAngle","coneOuterGain","confirm","confirmComposition","confirmSiteSpecificTrackingException","confirmWebWideTrackingException","connect","connectEnd","connectStart","connected","connection","connectionSpeed","console","consolidate","constrictionActive","constructor","contactID","contains","containsNode","content","contentDocument","contentEditable","contentOverflow","contentScriptType","contentStyleType","contentType","contentWindow","context","contextMenu","contextmenu","continue","continuous","control","controller","controls","convertToSpecifiedUnits","cookie","cookieEnabled","coords","copyFromChannel","copyTexImage2D","copyTexSubImage2D","copyToChannel","copyWithin","correspondingElement","correspondingUseElement","cos","cosh","count","counter-increment","counter-reset","counterIncrement","counterReset","cpuClass","cpuSleepAllowed","create","createAnalyser","createAnswer","createAttribute","createAttributeNS","createBiquadFilter","createBuffer","createBufferSource","createCDATASection","createCSSStyleSheet","createCaption","createChannelMerger","createChannelSplitter","createComment","createContextualFragment","createControlRange","createConvolver","createDTMFSender","createDataChannel","createDelay","createDelayNode","createDocument","createDocumentFragment","createDocumentType","createDynamicsCompressor","createElement","createElementNS","createEntityReference","createEvent","createEventObject","createExpression","createFramebuffer","createFunction","createGain","createGainNode","createHTMLDocument","createImageBitmap","createImageData","createIndex","createJavaScriptNode","createLinearGradient","createMediaElementSource","createMediaKeys","createMediaStreamDestination","createMediaStreamSource","createMutableFile","createNSResolver","createNodeIterator","createNotification","createObjectStore","createObjectURL","createOffer","createOscillator","createPanner","createPattern","createPeriodicWave","createPopup","createProcessingInstruction","createProgram","createRadialGradient","createRange","createRangeCollection","createRenderbuffer","createSVGAngle","createSVGLength","createSVGMatrix","createSVGNumber","createSVGPathSegArcAbs","createSVGPathSegArcRel","createSVGPathSegClosePath","createSVGPathSegCurvetoCubicAbs","createSVGPathSegCurvetoCubicRel","createSVGPathSegCurvetoCubicSmoothAbs","createSVGPathSegCurvetoCubicSmoothRel","createSVGPathSegCurvetoQuadraticAbs","createSVGPathSegCurvetoQuadraticRel","createSVGPathSegCurvetoQuadraticSmoothAbs","createSVGPathSegCurvetoQuadraticSmoothRel","createSVGPathSegLinetoAbs","createSVGPathSegLinetoHorizontalAbs","createSVGPathSegLinetoHorizontalRel","createSVGPathSegLinetoRel","createSVGPathSegLinetoVerticalAbs","createSVGPathSegLinetoVerticalRel","createSVGPathSegMovetoAbs","createSVGPathSegMovetoRel","createSVGPoint","createSVGRect","createSVGTransform","createSVGTransformFromMatrix","createScriptProcessor","createSession","createShader","createShadowRoot","createStereoPanner","createStyleSheet","createTBody","createTFoot","createTHead","createTextNode","createTextRange","createTexture","createTouch","createTouchList","createTreeWalker","createWaveShaper","creationTime","crossOrigin","crypto","csi","cssFloat","cssRules","cssText","cssValueType","ctrlKey","ctrlLeft","cues","cullFace","currentNode","currentPage","currentScale","currentScript","currentSrc","currentState","currentStyle","currentTarget","currentTime","currentTranslate","currentView","cursor","curve","customError","cx","cy","d","data","dataFld","dataFormatAs","dataPageSize","dataSrc","dataTransfer","database","dataset","dateTime","db","debug","debuggerEnabled","declare","decode","decodeAudioData","decodeURI","decodeURIComponent","decodingInfo","decrypt","default","defaultCharset","defaultChecked","defaultMuted","defaultPlaybackRate","defaultPrevented","defaultSelected","defaultStatus","defaultURL","defaultValue","defaultView","defaultstatus","defer","defineMagicFunction","defineMagicVariable","defineProperties","defineProperty","delayTime","delete","deleteBuffer","deleteCaption","deleteCell","deleteContents","deleteData","deleteDatabase","deleteFramebuffer","deleteFromDocument","deleteIndex","deleteMedium","deleteObjectStore","deleteProgram","deleteRenderbuffer","deleteRow","deleteRule","deleteShader","deleteTFoot","deleteTHead","deleteTexture","deliverChangeRecords","delivery","deliveryInfo","deliveryStatus","deliveryTimestamp","delta","deltaMode","deltaX","deltaY","deltaZ","depthFunc","depthMask","depthRange","deriveBits","deriveKey","description","deselectAll","designMode","destination","destinationURL","detach","detachEvent","detachShader","detail","detune","devicePixelRatio","deviceXDPI","deviceYDPI","diffuseConstant","digest","dimensions","dir","dirName","direction","dirxml","disable","disableVertexAttribArray","disabled","dischargingTime","disconnect","dispatchEvent","display","distanceModel","divisor","djsapi","djsproxy","doImport","doNotTrack","doScroll","doctype","document","documentElement","documentMode","documentURI","dolphin","dolphinGameCenter","dolphininfo","dolphinmeta","domComplete","domContentLoadedEventEnd","domContentLoadedEventStart","domInteractive","domLoading","domain","domainLookupEnd","domainLookupStart","dominant-baseline","dominantBaseline","done","dopplerFactor","download","dragDrop","draggable","drawArrays","drawArraysInstancedANGLE","drawCustomFocusRing","drawElements","drawElementsInstancedANGLE","drawFocusIfNeeded","drawImage","drawImageFromRect","drawSystemFocusRing","drawingBufferHeight","drawingBufferWidth","dropEffect","droppedVideoFrames","dropzone","dump","duplicate","duration","dvname","dvnum","dx","dy","dynsrc","e","edgeMode","effectAllowed","elapsedTime","elementFromPoint","elements","elevation","ellipse","email","embeds","empty","empty-cells","emptyCells","enable","enableBackground","enableStyleSheetsForSet","enableVertexAttribArray","enabled","enabledPlugin","encode","encodeURI","encodeURIComponent","encoding","encrypt","enctype","end","endContainer","endElement","endElementAt","endOfStream","endOffset","endTime","ended","endsWith","entities","entries","entryType","enumerate","enumerateEditable","error","errorCode","escape","eval","evaluate","event","eventPhase","every","exception","exec","execCommand","execCommandShowHelp","execScript","exitFullscreen","exitPointerLock","exp","expand","expandEntityReferences","expando","expansion","expiryDate","explicitOriginalTarget","expm1","exponent","exponentialRampToValueAtTime","exportKey","extend","extensions","extentNode","extentOffset","external","externalResourcesRequired","extractContents","extractable","f","face","factoryReset","fallback","familyName","farthestViewportElement","fastSeek","fatal","fetch","fetchStart","fftSize","fgColor","fileCreatedDate","fileHandle","fileModifiedDate","fileName","fileSize","fileUpdatedDate","filename","files","fill","fill-opacity","fill-rule","fillOpacity","fillRect","fillRule","fillStyle","fillText","filter","filterResX","filterResY","filterUnits","filters","finally","find","findIndex","findRule","findText","finish","fireEvent","firstChild","firstElementChild","firstPage","fixed","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","flexBasis","flexDirection","flexFlow","flexGrow","flexShrink","flexWrap","flipX","flipY","float","flood-color","flood-opacity","floodColor","floodOpacity","floor","flush","focus","focusNode","focusOffset","font","font-family","font-feature-settings","font-kerning","font-language-override","font-size","font-size-adjust","font-stretch","font-style","font-synthesis","font-variant","font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-weight","fontFamily","fontFeatureSettings","fontKerning","fontLanguageOverride","fontSize","fontSizeAdjust","fontSmoothingEnabled","fontStretch","fontStyle","fontSynthesis","fontVariant","fontVariantAlternates","fontVariantCaps","fontVariantEastAsian","fontVariantLigatures","fontVariantNumeric","fontVariantPosition","fontWeight","fontcolor","fonts","fontsize","for","forEach","forceRedraw","form","formAction","formEnctype","formMethod","formNoValidate","formTarget","format","formatToParts","forms","forward","fr","frame","frameBorder","frameElement","frameSpacing","framebufferRenderbuffer","framebufferTexture2D","frames","freeSpace","freeze","frequency","frequencyBinCount","from","fromCharCode","fromCodePoint","fromElement","frontFace","fround","fullScreen","fullscreenElement","fullscreenEnabled","fx","fy","gain","gamepad","gamma","genderIdentity","generateKey","generateMipmap","generateRequest","geolocation","gestureObject","get","getActiveAttrib","getActiveUniform","getAdjacentText","getAll","getAllResponseHeaders","getAsFile","getAsString","getAttachedShaders","getAttribLocation","getAttribute","getAttributeNS","getAttributeNode","getAttributeNodeNS","getAudioTracks","getBBox","getBattery","getBlob","getBookmark","getBoundingClientRect","getBufferParameter","getByteFrequencyData","getByteTimeDomainData","getCSSCanvasContext","getCTM","getCandidateWindowClientRect","getChannelData","getCharNumAtPosition","getClientRect","getClientRects","getCompositionAlternatives","getComputedStyle","getComputedTextLength","getConfiguration","getContext","getContextAttributes","getCounterValue","getCueAsHTML","getCueById","getCurrentPosition","getCurrentTime","getData","getDatabaseNames","getDate","getDay","getDefaultComputedStyle","getDestinationInsertionPoints","getDistributedNodes","getEditable","getElementById","getElementsByClassName","getElementsByName","getElementsByTagName","getElementsByTagNameNS","getEnclosureList","getEndPositionOfChar","getEntries","getEntriesByName","getEntriesByType","getError","getExtension","getExtentOfChar","getFeature","getFile","getFloat32","getFloat64","getFloatFrequencyData","getFloatTimeDomainData","getFloatValue","getFramebufferAttachmentParameter","getFrequencyResponse","getFullYear","getGamepads","getHours","getImageData","getInt16","getInt32","getInt8","getIntersectionList","getItem","getItems","getKey","getLineDash","getLocalStreams","getMarks","getMatchedCSSRules","getMeasures","getMetadata","getMilliseconds","getMinutes","getModifierState","getMonth","getNamedItem","getNamedItemNS","getNotifier","getNumberOfChars","getOverrideHistoryNavigationMode","getOverrideStyle","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","getParameter","getPathSegAtLength","getPointAtLength","getPreference","getPreferenceDefault","getPresentationAttribute","getPreventDefault","getProgramInfoLog","getProgramParameter","getPropertyCSSValue","getPropertyPriority","getPropertyShorthand","getPropertyValue","getPrototypeOf","getRGBColorValue","getRandomValues","getRangeAt","getReceivers","getRectValue","getRegistration","getRemoteStreams","getRenderbufferParameter","getResponseHeader","getRoot","getRotationOfChar","getSVGDocument","getScreenCTM","getSeconds","getSelection","getSenders","getShaderInfoLog","getShaderParameter","getShaderPrecisionFormat","getShaderSource","getSimpleDuration","getSiteIcons","getSources","getSpeculativeParserUrls","getStartPositionOfChar","getStartTime","getStats","getStorageUpdates","getStreamById","getStringValue","getSubStringLength","getSubscription","getSupportedExtensions","getTexParameter","getTime","getTimezoneOffset","getTotalLength","getTrackById","getTracks","getTransformToElement","getUTCDate","getUTCDay","getUTCFullYear","getUTCHours","getUTCMilliseconds","getUTCMinutes","getUTCMonth","getUTCSeconds","getUint16","getUint32","getUint8","getUniform","getUniformLocation","getUserMedia","getValues","getVarDate","getVariableValue","getVertexAttrib","getVertexAttribOffset","getVideoPlaybackQuality","getVideoTracks","getWakeLockState","getYear","givenName","global","globalAlpha","globalCompositeOperation","glyphOrientationHorizontal","glyphOrientationVertical","glyphRef","go","gradientTransform","gradientUnits","grammars","green","group","groupCollapsed","groupEnd","hardwareConcurrency","has","hasAttribute","hasAttributeNS","hasAttributes","hasChildNodes","hasComposition","hasExtension","hasFeature","hasFocus","hasLayout","hasOwnProperty","hash","head","headers","heading","height","hidden","hide","hideFocus","high","hint","history","honorificPrefix","honorificSuffix","horizontalOverflow","host","hostname","href","hreflang","hspace","html5TagCheckInerface","htmlFor","htmlText","httpEquiv","hwTimestamp","hypot","iccId","iceConnectionState","iceGatheringState","icon","id","identifier","identity","ignoreBOM","ignoreCase","image-orientation","image-rendering","imageOrientation","imageRendering","images","ime-mode","imeMode","implementation","importKey","importNode","importStylesheet","imports","impp","imul","in1","in2","inBandMetadataTrackDispatchType","inRange","includes","incremental","indeterminate","index","indexNames","indexOf","indexedDB","inertiaDestinationX","inertiaDestinationY","info","init","initAnimationEvent","initBeforeLoadEvent","initClipboardEvent","initCloseEvent","initCommandEvent","initCompositionEvent","initCustomEvent","initData","initDeviceMotionEvent","initDeviceOrientationEvent","initDragEvent","initErrorEvent","initEvent","initFocusEvent","initGestureEvent","initHashChangeEvent","initKeyEvent","initKeyboardEvent","initMSManipulationEvent","initMessageEvent","initMouseEvent","initMouseScrollEvent","initMouseWheelEvent","initMutationEvent","initNSMouseEvent","initOverflowEvent","initPageEvent","initPageTransitionEvent","initPointerEvent","initPopStateEvent","initProgressEvent","initScrollAreaEvent","initSimpleGestureEvent","initStorageEvent","initTextEvent","initTimeEvent","initTouchEvent","initTransitionEvent","initUIEvent","initWebKitAnimationEvent","initWebKitTransitionEvent","initWebKitWheelEvent","initWheelEvent","initialTime","initialize","initiatorType","inner","innerHTML","innerHeight","innerText","innerWidth","input","inputBuffer","inputEncoding","inputMethod","insertAdjacentElement","insertAdjacentHTML","insertAdjacentText","insertBefore","insertCell","insertData","insertItemBefore","insertNode","insertRow","insertRule","instanceRoot","intercept","interimResults","internalSubset","intersectsNode","interval","invalidIteratorState","inverse","invertSelf","is","is2D","isAlternate","isArray","isBingCurrentSearchDefault","isBuffer","isCandidateWindowVisible","isChar","isCollapsed","isComposing","isContentEditable","isContentHandlerRegistered","isContextLost","isDefaultNamespace","isDisabled","isEnabled","isEqual","isEqualNode","isExtensible","isFinite","isFramebuffer","isFrozen","isGenerator","isId","isInjected","isInteger","isMap","isMultiLine","isNaN","isOpen","isPointInFill","isPointInPath","isPointInRange","isPointInStroke","isPrefAlternate","isPrimary","isProgram","isPropertyImplicit","isProtocolHandlerRegistered","isPrototypeOf","isRenderbuffer","isSafeInteger","isSameNode","isSealed","isShader","isSupported","isTextEdit","isTexture","isTrusted","isTypeSupported","isView","isolation","italics","item","itemId","itemProp","itemRef","itemScope","itemType","itemValue","iterateNext","iterator","javaEnabled","jobTitle","join","json","justify-content","justifyContent","k1","k2","k3","k4","kernelMatrix","kernelUnitLengthX","kernelUnitLengthY","kerning","key","keyCode","keyFor","keyIdentifier","keyLightEnabled","keyLocation","keyPath","keySystem","keyText","keyUsage","keys","keytype","kind","knee","label","labels","lang","language","languages","largeArcFlag","lastChild","lastElementChild","lastEventId","lastIndex","lastIndexOf","lastMatch","lastMessageSubject","lastMessageType","lastModified","lastModifiedDate","lastPage","lastParen","lastState","lastStyleSheetSet","latitude","layerX","layerY","layoutFlow","layoutGrid","layoutGridChar","layoutGridLine","layoutGridMode","layoutGridType","lbound","left","leftContext","leftMargin","length","lengthAdjust","lengthComputable","letter-spacing","letterSpacing","level","lighting-color","lightingColor","limitingConeAngle","line","line-height","lineAlign","lineBreak","lineCap","lineDashOffset","lineHeight","lineJoin","lineNumber","lineTo","lineWidth","linearRampToValueAtTime","lineno","link","linkColor","linkProgram","links","list","list-style","list-style-image","list-style-position","list-style-type","listStyle","listStyleImage","listStylePosition","listStyleType","listener","load","loadEventEnd","loadEventStart","loadTimes","loaded","localDescription","localName","localStorage","locale","localeCompare","location","locationbar","lock","lockedFile","log","log10","log1p","log2","logicalXDPI","logicalYDPI","longDesc","longitude","lookupNamespaceURI","lookupPrefix","loop","loopEnd","loopStart","looping","low","lower","lowerBound","lowerOpen","lowsrc","m11","m12","m13","m14","m21","m22","m23","m24","m31","m32","m33","m34","m41","m42","m43","m44","manifest","map","mapping","margin","margin-bottom","margin-left","margin-right","margin-top","marginBottom","marginHeight","marginLeft","marginRight","marginTop","marginWidth","mark","marker","marker-end","marker-mid","marker-offset","marker-start","markerEnd","markerHeight","markerMid","markerOffset","markerStart","markerUnits","markerWidth","marks","mask","mask-type","maskContentUnits","maskType","maskUnits","match","matchMedia","matchMedium","matches","matrix","matrixTransform","max","max-height","max-width","maxAlternatives","maxChannelCount","maxConnectionsPerServer","maxDecibels","maxDistance","maxHeight","maxLength","maxTouchPoints","maxValue","maxWidth","measure","measureText","media","mediaCapabilities","mediaDevices","mediaElement","mediaGroup","mediaKeys","mediaText","meetOrSlice","memory","menubar","mergeAttributes","message","messageClass","messageHandlers","metaKey","method","mimeType","mimeTypes","min","min-height","min-width","minDecibels","minHeight","minValue","minWidth","miterLimit","mix-blend-mode","mixBlendMode","mode","modify","mount","move","moveBy","moveEnd","moveFirst","moveFocusDown","moveFocusLeft","moveFocusRight","moveFocusUp","moveNext","moveRow","moveStart","moveTo","moveToBookmark","moveToElementText","moveToPoint","mozAdd","mozAnimationStartTime","mozAnon","mozApps","mozAudioCaptured","mozAudioChannelType","mozAutoplayEnabled","mozCancelAnimationFrame","mozCancelFullScreen","mozCancelRequestAnimationFrame","mozCaptureStream","mozCaptureStreamUntilEnded","mozClearDataAt","mozContact","mozContacts","mozCreateFileHandle","mozCurrentTransform","mozCurrentTransformInverse","mozCursor","mozDash","mozDashOffset","mozDecodedFrames","mozExitPointerLock","mozFillRule","mozFragmentEnd","mozFrameDelay","mozFullScreen","mozFullScreenElement","mozFullScreenEnabled","mozGetAll","mozGetAllKeys","mozGetAsFile","mozGetDataAt","mozGetMetadata","mozGetUserMedia","mozHasAudio","mozHasItem","mozHidden","mozImageSmoothingEnabled","mozIndexedDB","mozInnerScreenX","mozInnerScreenY","mozInputSource","mozIsTextField","mozItem","mozItemCount","mozItems","mozLength","mozLockOrientation","mozMatchesSelector","mozMovementX","mozMovementY","mozOpaque","mozOrientation","mozPaintCount","mozPaintedFrames","mozParsedFrames","mozPay","mozPointerLockElement","mozPresentedFrames","mozPreservesPitch","mozPressure","mozPrintCallback","mozRTCIceCandidate","mozRTCPeerConnection","mozRTCSessionDescription","mozRemove","mozRequestAnimationFrame","mozRequestFullScreen","mozRequestPointerLock","mozSetDataAt","mozSetImageElement","mozSourceNode","mozSrcObject","mozSystem","mozTCPSocket","mozTextStyle","mozTypesAt","mozUnlockOrientation","mozUserCancelled","mozVisibilityState","msAnimation","msAnimationDelay","msAnimationDirection","msAnimationDuration","msAnimationFillMode","msAnimationIterationCount","msAnimationName","msAnimationPlayState","msAnimationStartTime","msAnimationTimingFunction","msBackfaceVisibility","msBlockProgression","msCSSOMElementFloatMetrics","msCaching","msCachingEnabled","msCancelRequestAnimationFrame","msCapsLockWarningOff","msClearImmediate","msClose","msContentZoomChaining","msContentZoomFactor","msContentZoomLimit","msContentZoomLimitMax","msContentZoomLimitMin","msContentZoomSnap","msContentZoomSnapPoints","msContentZoomSnapType","msContentZooming","msConvertURL","msCrypto","msDoNotTrack","msElementsFromPoint","msElementsFromRect","msExitFullscreen","msExtendedCode","msFillRule","msFirstPaint","msFlex","msFlexAlign","msFlexDirection","msFlexFlow","msFlexItemAlign","msFlexLinePack","msFlexNegative","msFlexOrder","msFlexPack","msFlexPositive","msFlexPreferredSize","msFlexWrap","msFlowFrom","msFlowInto","msFontFeatureSettings","msFullscreenElement","msFullscreenEnabled","msGetInputContext","msGetRegionContent","msGetUntransformedBounds","msGraphicsTrustStatus","msGridColumn","msGridColumnAlign","msGridColumnSpan","msGridColumns","msGridRow","msGridRowAlign","msGridRowSpan","msGridRows","msHidden","msHighContrastAdjust","msHyphenateLimitChars","msHyphenateLimitLines","msHyphenateLimitZone","msHyphens","msImageSmoothingEnabled","msImeAlign","msIndexedDB","msInterpolationMode","msIsStaticHTML","msKeySystem","msKeys","msLaunchUri","msLockOrientation","msManipulationViewsEnabled","msMatchMedia","msMatchesSelector","msMaxTouchPoints","msOrientation","msOverflowStyle","msPerspective","msPerspectiveOrigin","msPlayToDisabled","msPlayToPreferredSourceUri","msPlayToPrimary","msPointerEnabled","msRegionOverflow","msReleasePointerCapture","msRequestAnimationFrame","msRequestFullscreen","msSaveBlob","msSaveOrOpenBlob","msScrollChaining","msScrollLimit","msScrollLimitXMax","msScrollLimitXMin","msScrollLimitYMax","msScrollLimitYMin","msScrollRails","msScrollSnapPointsX","msScrollSnapPointsY","msScrollSnapType","msScrollSnapX","msScrollSnapY","msScrollTranslation","msSetImmediate","msSetMediaKeys","msSetPointerCapture","msTextCombineHorizontal","msTextSizeAdjust","msToBlob","msTouchAction","msTouchSelect","msTraceAsyncCallbackCompleted","msTraceAsyncCallbackStarting","msTraceAsyncOperationCompleted","msTraceAsyncOperationStarting","msTransform","msTransformOrigin","msTransformStyle","msTransition","msTransitionDelay","msTransitionDuration","msTransitionProperty","msTransitionTimingFunction","msUnlockOrientation","msUpdateAsyncCallbackRelation","msUserSelect","msVisibilityState","msWrapFlow","msWrapMargin","msWrapThrough","msWriteProfilerMark","msZoom","msZoomTo","mt","multiEntry","multiSelectionObj","multiline","multiple","multiply","multiplySelf","mutableFile","muted","n","name","nameProp","namedItem","namedRecordset","names","namespaceURI","namespaces","naturalHeight","naturalWidth","navigate","navigation","navigationMode","navigationStart","navigator","near","nearestViewportElement","negative","netscape","networkState","newScale","newTranslate","newURL","newValue","newValueSpecifiedUnits","newVersion","newhome","next","nextElementSibling","nextNode","nextPage","nextSibling","nickname","noHref","noResize","noShade","noValidate","noWrap","nodeName","nodeType","nodeValue","normalize","normalizedPathSegList","notationName","notations","note","noteGrainOn","noteOff","noteOn","now","numOctaves","number","numberOfChannels","numberOfInputs","numberOfItems","numberOfOutputs","numberValue","oMatchesSelector","object","object-fit","object-position","objectFit","objectPosition","objectStore","objectStoreNames","observe","of","offscreenBuffering","offset","offsetHeight","offsetLeft","offsetNode","offsetParent","offsetTop","offsetWidth","offsetX","offsetY","ok","oldURL","oldValue","oldVersion","olderShadowRoot","onLine","onabort","onactivate","onactive","onaddstream","onaddtrack","onafterprint","onafterscriptexecute","onafterupdate","onaudioend","onaudioprocess","onaudiostart","onautocomplete","onautocompleteerror","onbeforeactivate","onbeforecopy","onbeforecut","onbeforedeactivate","onbeforeeditfocus","onbeforepaste","onbeforeprint","onbeforescriptexecute","onbeforeunload","onbeforeupdate","onblocked","onblur","onbounce","onboundary","oncached","oncancel","oncandidatewindowhide","oncandidatewindowshow","oncandidatewindowupdate","oncanplay","oncanplaythrough","once","oncellchange","onchange","onchargingchange","onchargingtimechange","onchecking","onclick","onclose","oncompassneedscalibration","oncomplete","oncontextmenu","oncontrolselect","oncopy","oncuechange","oncut","ondataavailable","ondatachannel","ondatasetchanged","ondatasetcomplete","ondblclick","ondeactivate","ondevicelight","ondevicemotion","ondeviceorientation","ondeviceproximity","ondischargingtimechange","ondisplay","ondownloading","ondrag","ondragend","ondragenter","ondragleave","ondragover","ondragstart","ondrop","ondurationchange","onemptied","onencrypted","onend","onended","onenter","onerror","onerrorupdate","onexit","onfilterchange","onfinish","onfocus","onfocusin","onfocusout","onfullscreenchange","onfullscreenerror","ongesturechange","ongestureend","ongesturestart","ongotpointercapture","onhashchange","onhelp","onicecandidate","oniceconnectionstatechange","oninactive","oninput","oninvalid","onkeydown","onkeypress","onkeyup","onlanguagechange","onlayoutcomplete","onlevelchange","onload","onloadeddata","onloadedmetadata","onloadend","onloadstart","onlosecapture","onlostpointercapture","only","onmark","onmessage","onmousedown","onmouseenter","onmouseleave","onmousemove","onmouseout","onmouseover","onmouseup","onmousewheel","onmove","onmoveend","onmovestart","onmozfullscreenchange","onmozfullscreenerror","onmozorientationchange","onmozpointerlockchange","onmozpointerlockerror","onmscontentzoom","onmsfullscreenchange","onmsfullscreenerror","onmsgesturechange","onmsgesturedoubletap","onmsgestureend","onmsgesturehold","onmsgesturestart","onmsgesturetap","onmsgotpointercapture","onmsinertiastart","onmslostpointercapture","onmsmanipulationstatechanged","onmsneedkey","onmsorientationchange","onmspointercancel","onmspointerdown","onmspointerenter","onmspointerhover","onmspointerleave","onmspointermove","onmspointerout","onmspointerover","onmspointerup","onmssitemodejumplistitemremoved","onmsthumbnailclick","onnegotiationneeded","onnomatch","onnoupdate","onobsolete","onoffline","ononline","onopen","onorientationchange","onpagechange","onpagehide","onpageshow","onpaste","onpause","onplay","onplaying","onpluginstreamstart","onpointercancel","onpointerdown","onpointerenter","onpointerleave","onpointerlockchange","onpointerlockerror","onpointermove","onpointerout","onpointerover","onpointerup","onpopstate","onprogress","onpropertychange","onratechange","onreadystatechange","onremovestream","onremovetrack","onreset","onresize","onresizeend","onresizestart","onresourcetimingbufferfull","onresult","onresume","onrowenter","onrowexit","onrowsdelete","onrowsinserted","onscroll","onsearch","onseeked","onseeking","onselect","onselectionchange","onselectstart","onshow","onsignalingstatechange","onsoundend","onsoundstart","onspeechend","onspeechstart","onstalled","onstart","onstatechange","onstop","onstorage","onstoragecommit","onsubmit","onsuccess","onsuspend","ontextinput","ontimeout","ontimeupdate","ontoggle","ontouchcancel","ontouchend","ontouchmove","ontouchstart","ontransitionend","onunload","onupdateready","onupgradeneeded","onuserproximity","onversionchange","onvoiceschanged","onvolumechange","onwaiting","onwarning","onwebkitanimationend","onwebkitanimationiteration","onwebkitanimationstart","onwebkitcurrentplaybacktargetiswirelesschanged","onwebkitfullscreenchange","onwebkitfullscreenerror","onwebkitkeyadded","onwebkitkeyerror","onwebkitkeymessage","onwebkitneedkey","onwebkitorientationchange","onwebkitplaybacktargetavailabilitychanged","onwebkitpointerlockchange","onwebkitpointerlockerror","onwebkitresourcetimingbufferfull","onwebkittransitionend","onwheel","onzoom","opacity","open","openCursor","openDatabase","openKeyCursor","opener","opera","operationType","operator","opr","optimum","options","order","orderX","orderY","ordered","org","orient","orientAngle","orientType","orientation","origin","originalTarget","orphans","oscpu","outerHTML","outerHeight","outerText","outerWidth","outline","outline-color","outline-offset","outline-style","outline-width","outlineColor","outlineOffset","outlineStyle","outlineWidth","outputBuffer","overflow","overflow-x","overflow-y","overflowX","overflowY","overrideMimeType","oversample","ownerDocument","ownerElement","ownerNode","ownerRule","ownerSVGElement","owningElement","p1","p2","p3","p4","pad","padding","padding-bottom","padding-left","padding-right","padding-top","paddingBottom","paddingLeft","paddingRight","paddingTop","page","page-break-after","page-break-before","page-break-inside","pageBreakAfter","pageBreakBefore","pageBreakInside","pageCount","pageX","pageXOffset","pageY","pageYOffset","pages","paint-order","paintOrder","paintRequests","paintType","palette","panningModel","parent","parentElement","parentNode","parentRule","parentStyleSheet","parentTextEdit","parentWindow","parse","parseFloat","parseFromString","parseInt","participants","passive","password","pasteHTML","path","pathLength","pathSegList","pathSegType","pathSegTypeAsLetter","pathname","pattern","patternContentUnits","patternMismatch","patternTransform","patternUnits","pause","pauseAnimations","pauseOnExit","paused","pending","performance","permission","persisted","personalbar","perspective","perspective-origin","perspectiveOrigin","phoneticFamilyName","phoneticGivenName","photo","ping","pitch","pixelBottom","pixelDepth","pixelHeight","pixelLeft","pixelRight","pixelStorei","pixelTop","pixelUnitToMillimeterX","pixelUnitToMillimeterY","pixelWidth","placeholder","platform","play","playbackRate","playbackState","playbackTime","played","plugins","pluginspage","pname","pointer-events","pointerBeforeReferenceNode","pointerEnabled","pointerEvents","pointerId","pointerLockElement","pointerType","points","pointsAtX","pointsAtY","pointsAtZ","polygonOffset","pop","popupWindowFeatures","popupWindowName","popupWindowURI","port","port1","port2","ports","posBottom","posHeight","posLeft","posRight","posTop","posWidth","position","positionAlign","postError","postMessage","poster","pow","powerOff","preMultiplySelf","precision","preferredStyleSheetSet","preferredStylesheetSet","prefix","preload","prepend","preserveAlpha","preserveAspectRatio","preserveAspectRatioString","pressed","pressure","prevValue","preventDefault","preventExtensions","previousElementSibling","previousNode","previousPage","previousScale","previousSibling","previousTranslate","primaryKey","primitiveType","primitiveUnits","principals","print","privateKey","probablySupportsContext","process","processIceMessage","product","productSub","profile","profileEnd","profiles","prompt","properties","propertyIsEnumerable","propertyName","protocol","protocolLong","prototype","pseudoClass","pseudoElement","publicId","publicKey","published","push","pushNotification","pushState","put","putImageData","quadraticCurveTo","qualifier","queryCommandEnabled","queryCommandIndeterm","queryCommandState","queryCommandSupported","queryCommandText","queryCommandValue","querySelector","querySelectorAll","quote","quotes","r","r1","r2","race","radiogroup","radiusX","radiusY","random","range","rangeCount","rangeMax","rangeMin","rangeOffset","rangeOverflow","rangeParent","rangeUnderflow","rate","ratio","raw","read","readAsArrayBuffer","readAsBinaryString","readAsBlob","readAsDataURL","readAsText","readOnly","readPixels","readReportRequested","readyState","reason","reboot","receiver","receivers","recordNumber","recordset","rect","red","redirectCount","redirectEnd","redirectStart","reduce","reduceRight","reduction","refDistance","refX","refY","referenceNode","referrer","refresh","region","regionAnchorX","regionAnchorY","regionId","regions","register","registerContentHandler","registerElement","registerProtocolHandler","reject","rel","relList","relatedNode","relatedTarget","release","releaseCapture","releaseEvents","releasePointerCapture","releaseShaderCompiler","reliable","reload","remainingSpace","remoteDescription","remove","removeAllRanges","removeAttribute","removeAttributeNS","removeAttributeNode","removeBehavior","removeChild","removeCue","removeEventListener","removeFilter","removeImport","removeItem","removeListener","removeNamedItem","removeNamedItemNS","removeNode","removeParameter","removeProperty","removeRange","removeRegion","removeRule","removeSiteSpecificTrackingException","removeSourceBuffer","removeStream","removeTrack","removeVariable","removeWakeLockListener","removeWebWideTrackingException","removedNodes","renderbufferStorage","renderedBuffer","renderingMode","repeat","replace","replaceAdjacentText","replaceChild","replaceData","replaceId","replaceItem","replaceNode","replaceState","replaceTrack","replaceWholeText","reportValidity","requestAnimationFrame","requestAutocomplete","requestData","requestFullscreen","requestMediaKeySystemAccess","requestPermission","requestPointerLock","requestStart","requestingWindow","required","requiredExtensions","requiredFeatures","reset","resetTransform","resize","resizeBy","resizeTo","resolve","response","responseBody","responseEnd","responseStart","responseText","responseType","responseURL","responseXML","restore","result","resultType","resume","returnValue","rev","reverse","reversed","revocable","revokeObjectURL","rgbColor","right","rightContext","rightMargin","rolloffFactor","root","rootElement","rotate","rotateAxisAngle","rotateAxisAngleSelf","rotateFromVector","rotateFromVectorSelf","rotateSelf","rotation","rotationRate","round","rowIndex","rowSpan","rows","rubyAlign","rubyOverhang","rubyPosition","rules","runtime","runtimeStyle","rx","ry","safari","sampleCoverage","sampleRate","sandbox","save","scale","scale3d","scale3dSelf","scaleNonUniform","scaleNonUniformSelf","scaleSelf","scheme","scissor","scope","scopeName","scoped","screen","screenBrightness","screenEnabled","screenLeft","screenPixelToMillimeterX","screenPixelToMillimeterY","screenTop","screenX","screenY","scripts","scroll","scroll-behavior","scrollAmount","scrollBehavior","scrollBy","scrollByLines","scrollByPages","scrollDelay","scrollHeight","scrollIntoView","scrollIntoViewIfNeeded","scrollLeft","scrollLeftMax","scrollMaxX","scrollMaxY","scrollTo","scrollTop","scrollTopMax","scrollWidth","scrollX","scrollY","scrollbar3dLightColor","scrollbarArrowColor","scrollbarBaseColor","scrollbarDarkShadowColor","scrollbarFaceColor","scrollbarHighlightColor","scrollbarShadowColor","scrollbarTrackColor","scrollbars","scrolling","sdp","sdpMLineIndex","sdpMid","seal","search","searchBox","searchBoxJavaBridge_","searchParams","sectionRowIndex","secureConnectionStart","security","seed","seekable","seeking","select","selectAllChildren","selectNode","selectNodeContents","selectNodes","selectSingleNode","selectSubString","selected","selectedIndex","selectedOptions","selectedStyleSheetSet","selectedStylesheetSet","selection","selectionDirection","selectionEnd","selectionStart","selector","selectorText","self","send","sendAsBinary","sendBeacon","sender","sentTimestamp","separator","serializeToString","serviceWorker","sessionId","sessionStorage","set","setActive","setAlpha","setAttribute","setAttributeNS","setAttributeNode","setAttributeNodeNS","setBaseAndExtent","setBingCurrentSearchDefault","setCapture","setColor","setCompositeOperation","setCurrentTime","setCustomValidity","setData","setDate","setDragImage","setEnd","setEndAfter","setEndBefore","setEndPoint","setFillColor","setFilterRes","setFloat32","setFloat64","setFloatValue","setFullYear","setHours","setImmediate","setInt16","setInt32","setInt8","setInterval","setItem","setLineCap","setLineDash","setLineJoin","setLineWidth","setLocalDescription","setMatrix","setMatrixValue","setMediaKeys","setMilliseconds","setMinutes","setMiterLimit","setMonth","setNamedItem","setNamedItemNS","setNonUserCodeExceptions","setOrientToAngle","setOrientToAuto","setOrientation","setOverrideHistoryNavigationMode","setPaint","setParameter","setPeriodicWave","setPointerCapture","setPosition","setPreference","setProperty","setPrototypeOf","setRGBColor","setRGBColorICCColor","setRadius","setRangeText","setRemoteDescription","setRequestHeader","setResizable","setResourceTimingBufferSize","setRotate","setScale","setSeconds","setSelectionRange","setServerCertificate","setShadow","setSkewX","setSkewY","setStart","setStartAfter","setStartBefore","setStdDeviation","setStringValue","setStrokeColor","setSuggestResult","setTargetAtTime","setTargetValueAtTime","setTime","setTimeout","setTransform","setTranslate","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setUint16","setUint32","setUint8","setUri","setValueAtTime","setValueCurveAtTime","setVariable","setVelocity","setVersion","setYear","settingName","settingValue","sex","shaderSource","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","shadowRoot","shape","shape-rendering","shapeRendering","sheet","shift","shiftKey","shiftLeft","show","showHelp","showModal","showModalDialog","showModelessDialog","showNotification","sidebar","sign","signalingState","sin","singleNodeValue","sinh","size","sizeToContent","sizes","skewX","skewXSelf","skewY","skewYSelf","slice","slope","small","smil","smooth","smoothingTimeConstant","snapToLines","snapshotItem","snapshotLength","some","sort","source","sourceBuffer","sourceBuffers","sourceIndex","spacing","span","speakAs","speaking","specified","specularConstant","specularExponent","speechSynthesis","speed","speedOfSound","spellcheck","splice","split","splitText","spreadMethod","sqrt","src","srcElement","srcFilter","srcUrn","srcdoc","srclang","srcset","stack","stackTraceLimit","stacktrace","standalone","standby","start","startContainer","startIce","startOffset","startRendering","startTime","startsWith","state","status","statusMessage","statusText","statusbar","stdDeviationX","stdDeviationY","stencilFunc","stencilFuncSeparate","stencilMask","stencilMaskSeparate","stencilOp","stencilOpSeparate","step","stepDown","stepMismatch","stepUp","sticky","stitchTiles","stop","stop-color","stop-opacity","stopColor","stopImmediatePropagation","stopOpacity","stopPropagation","storageArea","storageName","storageStatus","storeSiteSpecificTrackingException","storeWebWideTrackingException","stpVersion","stream","strike","stringValue","stringify","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","strokeDasharray","strokeDashoffset","strokeLinecap","strokeLinejoin","strokeMiterlimit","strokeOpacity","strokeRect","strokeStyle","strokeText","strokeWidth","style","styleFloat","styleMedia","styleSheet","styleSheetSets","styleSheets","sub","subarray","subject","submit","subscribe","substr","substring","substringData","subtle","subtree","suffix","suffixes","summary","sup","supports","surfaceScale","surroundContents","suspend","suspendRedraw","swapCache","swapNode","sweepFlag","symbols","system","systemCode","systemId","systemLanguage","systemXDPI","systemYDPI","tBodies","tFoot","tHead","tabIndex","table","table-layout","tableLayout","tableValues","tag","tagName","tagUrn","tags","taintEnabled","takeRecords","tan","tanh","target","targetElement","targetTouches","targetX","targetY","tel","terminate","test","texImage2D","texParameterf","texParameteri","texSubImage2D","text","text-align","text-anchor","text-decoration","text-decoration-color","text-decoration-line","text-decoration-style","text-indent","text-overflow","text-rendering","text-shadow","text-transform","textAlign","textAlignLast","textAnchor","textAutospace","textBaseline","textContent","textDecoration","textDecorationBlink","textDecorationColor","textDecorationLine","textDecorationLineThrough","textDecorationNone","textDecorationOverline","textDecorationStyle","textDecorationUnderline","textIndent","textJustify","textJustifyTrim","textKashida","textKashidaSpace","textLength","textOverflow","textRendering","textShadow","textTracks","textTransform","textUnderlinePosition","then","threadId","threshold","tiltX","tiltY","time","timeEnd","timeStamp","timeout","timestamp","timestampOffset","timing","title","toArray","toBlob","toDataURL","toDateString","toElement","toExponential","toFixed","toFloat32Array","toFloat64Array","toGMTString","toISOString","toJSON","toLocaleDateString","toLocaleFormat","toLocaleLowerCase","toLocaleString","toLocaleTimeString","toLocaleUpperCase","toLowerCase","toMethod","toPrecision","toSdp","toSource","toStaticHTML","toString","toStringTag","toTimeString","toUTCString","toUpperCase","toggle","toggleLongPressEnabled","tooLong","toolbar","top","topMargin","total","totalFrameDelay","totalVideoFrames","touchAction","touches","trace","track","transaction","transactions","transform","transform-origin","transform-style","transformOrigin","transformPoint","transformString","transformStyle","transformToDocument","transformToFragment","transition","transition-delay","transition-duration","transition-property","transition-timing-function","transitionDelay","transitionDuration","transitionProperty","transitionTimingFunction","translate","translateSelf","translationX","translationY","trim","trimLeft","trimRight","trueSpeed","trunc","truncate","type","typeDetail","typeMismatch","typeMustMatch","types","ubound","undefined","unescape","uneval","unicode-bidi","unicodeBidi","uniform1f","uniform1fv","uniform1i","uniform1iv","uniform2f","uniform2fv","uniform2i","uniform2iv","uniform3f","uniform3fv","uniform3i","uniform3iv","uniform4f","uniform4fv","uniform4i","uniform4iv","uniformMatrix2fv","uniformMatrix3fv","uniformMatrix4fv","unique","uniqueID","uniqueNumber","unitType","units","unloadEventEnd","unloadEventStart","unlock","unmount","unobserve","unpause","unpauseAnimations","unreadCount","unregister","unregisterContentHandler","unregisterProtocolHandler","unscopables","unselectable","unshift","unsubscribe","unsuspendRedraw","unsuspendRedrawAll","unwatch","unwrapKey","update","updateCommands","updateIce","updateInterval","updateSettings","updated","updating","upload","upper","upperBound","upperOpen","uri","url","urn","urns","usages","useCurrentView","useMap","useProgram","usedSpace","userAgent","userLanguage","username","v8BreakIterator","vAlign","vLink","valid","validateProgram","validationMessage","validity","value","valueAsDate","valueAsNumber","valueAsString","valueInSpecifiedUnits","valueMissing","valueOf","valueText","valueType","values","vector-effect","vectorEffect","velocityAngular","velocityExpansion","velocityX","velocityY","vendor","vendorSub","verify","version","vertexAttrib1f","vertexAttrib1fv","vertexAttrib2f","vertexAttrib2fv","vertexAttrib3f","vertexAttrib3fv","vertexAttrib4f","vertexAttrib4fv","vertexAttribDivisorANGLE","vertexAttribPointer","vertical","vertical-align","verticalAlign","verticalOverflow","vibrate","videoHeight","videoTracks","videoWidth","view","viewBox","viewBoxString","viewTarget","viewTargetString","viewport","viewportAnchorX","viewportAnchorY","viewportElement","visibility","visibilityState","visible","vlinkColor","voice","volume","vrml","vspace","w","wand","warn","wasClean","watch","watchPosition","webdriver","webkitAddKey","webkitAnimation","webkitAnimationDelay","webkitAnimationDirection","webkitAnimationDuration","webkitAnimationFillMode","webkitAnimationIterationCount","webkitAnimationName","webkitAnimationPlayState","webkitAnimationTimingFunction","webkitAppearance","webkitAudioContext","webkitAudioDecodedByteCount","webkitAudioPannerNode","webkitBackfaceVisibility","webkitBackground","webkitBackgroundAttachment","webkitBackgroundClip","webkitBackgroundColor","webkitBackgroundImage","webkitBackgroundOrigin","webkitBackgroundPosition","webkitBackgroundPositionX","webkitBackgroundPositionY","webkitBackgroundRepeat","webkitBackgroundSize","webkitBackingStorePixelRatio","webkitBorderImage","webkitBorderImageOutset","webkitBorderImageRepeat","webkitBorderImageSlice","webkitBorderImageSource","webkitBorderImageWidth","webkitBoxAlign","webkitBoxDirection","webkitBoxFlex","webkitBoxOrdinalGroup","webkitBoxOrient","webkitBoxPack","webkitBoxSizing","webkitCancelAnimationFrame","webkitCancelFullScreen","webkitCancelKeyRequest","webkitCancelRequestAnimationFrame","webkitClearResourceTimings","webkitClosedCaptionsVisible","webkitConvertPointFromNodeToPage","webkitConvertPointFromPageToNode","webkitCreateShadowRoot","webkitCurrentFullScreenElement","webkitCurrentPlaybackTargetIsWireless","webkitDirectionInvertedFromDevice","webkitDisplayingFullscreen","webkitEnterFullScreen","webkitEnterFullscreen","webkitExitFullScreen","webkitExitFullscreen","webkitExitPointerLock","webkitFullScreenKeyboardInputAllowed","webkitFullscreenElement","webkitFullscreenEnabled","webkitGenerateKeyRequest","webkitGetAsEntry","webkitGetDatabaseNames","webkitGetEntries","webkitGetEntriesByName","webkitGetEntriesByType","webkitGetFlowByName","webkitGetGamepads","webkitGetImageDataHD","webkitGetNamedFlows","webkitGetRegionFlowRanges","webkitGetUserMedia","webkitHasClosedCaptions","webkitHidden","webkitIDBCursor","webkitIDBDatabase","webkitIDBDatabaseError","webkitIDBDatabaseException","webkitIDBFactory","webkitIDBIndex","webkitIDBKeyRange","webkitIDBObjectStore","webkitIDBRequest","webkitIDBTransaction","webkitImageSmoothingEnabled","webkitIndexedDB","webkitInitMessageEvent","webkitIsFullScreen","webkitKeys","webkitLineDashOffset","webkitLockOrientation","webkitMatchesSelector","webkitMediaStream","webkitNotifications","webkitOfflineAudioContext","webkitOrientation","webkitPeerConnection00","webkitPersistentStorage","webkitPointerLockElement","webkitPostMessage","webkitPreservesPitch","webkitPutImageDataHD","webkitRTCPeerConnection","webkitRegionOverset","webkitRequestAnimationFrame","webkitRequestFileSystem","webkitRequestFullScreen","webkitRequestFullscreen","webkitRequestPointerLock","webkitResolveLocalFileSystemURL","webkitSetMediaKeys","webkitSetResourceTimingBufferSize","webkitShadowRoot","webkitShowPlaybackTargetPicker","webkitSlice","webkitSpeechGrammar","webkitSpeechGrammarList","webkitSpeechRecognition","webkitSpeechRecognitionError","webkitSpeechRecognitionEvent","webkitStorageInfo","webkitSupportsFullscreen","webkitTemporaryStorage","webkitTextSizeAdjust","webkitTransform","webkitTransformOrigin","webkitTransition","webkitTransitionDelay","webkitTransitionDuration","webkitTransitionProperty","webkitTransitionTimingFunction","webkitURL","webkitUnlockOrientation","webkitUserSelect","webkitVideoDecodedByteCount","webkitVisibilityState","webkitWirelessVideoPlaybackDisabled","webkitdropzone","webstore","weight","whatToShow","wheelDelta","wheelDeltaX","wheelDeltaY","which","white-space","whiteSpace","wholeText","widows","width","will-change","willChange","willValidate","window","withCredentials","word-break","word-spacing","word-wrap","wordBreak","wordSpacing","wordWrap","wrap","wrapKey","write","writeln","writingMode","x","x1","x2","xChannelSelector","xmlEncoding","xmlStandalone","xmlVersion","xmlbase","xmllang","xmlspace","y","y1","y2","yChannelSelector","yandex","z","z-index","zIndex","zoom","zoomAndPan","zoomRectScreen"];function uo(e,t){function n(e){_(t,e);}e.walk(new Cn((function(e){e instanceof Rt&&e.quote?n(e.key):e instanceof Mt&&e.quote?n(e.key.name):e instanceof Dt&&co(e.property,n);})));}function co(e,t){e.walk(new Cn((function(e){return e instanceof ht?co(e.tail_node(),t):e instanceof ln?t(e.value):e instanceof yt&&(co(e.consequent,t),co(e.alternative,t)),!0})));}function lo(e,t){var n=(t=r(t,{builtins:!1,cache:null,debug:!1,keep_quoted:!1,only_cache:!1,regex:null,reserved:null,undeclared:!1},!0)).reserved;Array.isArray(n)||(n=[n]);var i=new Set(n);t.builtins||function(e){so.forEach(i);var t={},n="object"==typeof commonjsGlobal?commonjsGlobal:self;function i(t){e.add(t);}["Symbol","Map","Promise","Proxy","Reflect","Set","WeakMap","WeakSet"].forEach((function(e){t[e]=n[e]||new Function;})),["null","true","false","Infinity","-Infinity","undefined"].forEach(i),[Object,Array,Function,Number,String,Boolean,Error,Math,Date,RegExp,t.Symbol,ArrayBuffer,DataView,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,eval,EvalError,Float32Array,Float64Array,Int8Array,Int16Array,Int32Array,isFinite,isNaN,JSON,t.Map,parseFloat,parseInt,t.Promise,t.Proxy,RangeError,ReferenceError,t.Reflect,t.Set,SyntaxError,TypeError,Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,URIError,t.WeakMap,t.WeakSet].forEach((function(e){Object.getOwnPropertyNames(e).map(i),e.prototype&&Object.getOwnPropertyNames(e.prototype).map(i);}));}(i);var o,a=-1;t.cache?(o=t.cache.props).forEach((function(e){i.add(e);})):o=new Map;var s,u=t.regex&&new RegExp(t.regex),c=!1!==t.debug;c&&(s=!0===t.debug?"":t.debug);var l=new Set,f=new Set,p="strict"===t.keep_quoted;return e.walk(new Cn((function(e){if(e instanceof Rt)"string"!=typeof e.key||p&&e.quote||m(e.key);else if(e instanceof Mt)p&&e.key.end.quote||m(e.key.name);else if(e instanceof gt){var n=!!t.undeclared;if(!n){for(var i=e;i.expression;)i=i.expression;n=!(i.thedef&&i.thedef.undeclared);}!n||p&&e.quote||m(e.property);}else e instanceof Dt?p||co(e.property,m):e instanceof dt&&"Object.defineProperty"==e.expression.print_to_string()&&co(e.args[1],m);}))),e.transform(new On((function(e){e instanceof Rt?"string"!=typeof e.key||p&&e.quote||(e.key=h(e.key)):e instanceof Mt?p&&e.key.end.quote||(e.key.name=h(e.key.name)):e instanceof gt?p&&e.quote||(e.property=h(e.property)):!t.keep_quoted&&e instanceof Dt?e.property=E(e.property):e instanceof dt&&"Object.defineProperty"==e.expression.print_to_string()&&(e.args[1]=E(e.args[1]));})));function _(e){return !f.has(e)&&(!i.has(e)&&(t.only_cache?o.has(e):!/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(e)))}function d(e){return !(u&&!u.test(e))&&(!i.has(e)&&(o.has(e)||l.has(e)))}function m(e){_(e)&&l.add(e),d(e)||f.add(e);}function h(e){if(!d(e))return e;var t=o.get(e);if(!t){if(c){var n="_$"+e+"$"+s+"_";_(n)&&(t=n);}if(!t)do{t=Yn(++a);}while(!_(t));o.set(e,t);}return t}function E(e){return e.transform(new On((function(e){if(e instanceof ht){var t=e.expressions.length-1;e.expressions[t]=E(e.expressions[t]);}else e instanceof ln?e.value=h(e.value):e instanceof yt&&(e.consequent=E(e.consequent),e.alternative=E(e.alternative));return e})))}}var fo="undefined"==typeof atob?function(e){return Buffer.from(e,"base64").toString()}:atob,po="undefined"==typeof btoa?function(e){return Buffer.from(e).toString("base64")}:btoa;function _o(e,t,n){t[e]&&n.forEach((function(n){t[n]&&("object"!=typeof t[n]&&(t[n]={}),e in t[n]||(t[n][e]=t[e]));}));}function mo(e){e&&("props"in e?e.props instanceof Map||(e.props=function(e){var t=new Map;for(var n in e)D(e,n)&&"$"===n.charAt(0)&&t.set(n.substr(1),e[n]);return t}(e.props)):e.props=new Map);}function ho(e){return {props:(t=e.props,n=Object.create(null),t.forEach((function(e,t){n["$"+t]=e;})),n)};var t,n;}function Eo(e,n){var i,o,a=fe.warn_function;try{var s,u=(n=r(n,{compress:{},ecma:void 0,enclose:!1,ie8:!1,keep_classnames:void 0,keep_fnames:!1,mangle:{},module:!1,nameCache:null,output:{},parse:{},rename:void 0,safari10:!1,sourceMap:!1,timings:!1,toplevel:!1,warnings:!1,wrap:!1},!0)).timings&&{start:Date.now()};void 0===n.keep_classnames&&(n.keep_classnames=n.keep_fnames),void 0===n.rename&&(n.rename=n.compress&&n.mangle),_o("ecma",n,["parse","compress","output"]),_o("ie8",n,["compress","mangle","output"]),_o("keep_classnames",n,["compress","mangle"]),_o("keep_fnames",n,["compress","mangle"]),_o("module",n,["parse","compress","mangle"]),_o("safari10",n,["mangle","output"]),_o("toplevel",n,["compress","mangle"]),_o("warnings",n,["compress"]),n.mangle&&(n.mangle=r(n.mangle,{cache:n.nameCache&&(n.nameCache.vars||{}),eval:!1,ie8:!1,keep_classnames:!1,keep_fnames:!1,module:!1,properties:!1,reserved:[],safari10:!1,toplevel:!1},!0),n.mangle.properties&&("object"!=typeof n.mangle.properties&&(n.mangle.properties={}),n.mangle.properties.keep_quoted&&(s=n.mangle.properties.reserved,Array.isArray(s)||(s=[]),n.mangle.properties.reserved=s),!n.nameCache||"cache"in n.mangle.properties||(n.mangle.properties.cache=n.nameCache.props||{})),mo(n.mangle.cache),mo(n.mangle.properties.cache)),n.sourceMap&&(n.sourceMap=r(n.sourceMap,{asObject:!1,content:null,filename:null,includeSources:!1,root:null,url:null},!0));var c,l=[];if(n.warnings&&!fe.warn_function&&(fe.warn_function=function(e){l.push(e);}),u&&(u.parse=Date.now()),e instanceof xe)c=e;else{for(var f in "string"==typeof e&&(e=[e]),n.parse=n.parse||{},n.parse.toplevel=null,e)if(D(e,f)&&(n.parse.filename=f,n.parse.toplevel=ue(e[f],n.parse),n.sourceMap&&"inline"==n.sourceMap.content)){if(Object.keys(e).length>1)throw new Error("inline source map only works with singular input");n.sourceMap.content=(i=e[f],o=void 0,(o=/(?:^|[^.])\/\/# sourceMappingURL=data:application\/json(;[\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\s*$/.exec(i))?fo(o[2]):(fe.warn("inline source map not found"),null));}c=n.parse.toplevel;}s&&"strict"!==n.mangle.properties.keep_quoted&&uo(c,s),n.wrap&&(c=c.wrap_commonjs(n.wrap)),n.enclose&&(c=c.wrap_enclose(n.enclose)),u&&(u.rename=Date.now()),u&&(u.compress=Date.now()),n.compress&&(c=new ri(n.compress).compress(c)),u&&(u.scope=Date.now()),n.mangle&&c.figure_out_scope(n.mangle),u&&(u.mangle=Date.now()),n.mangle&&(Yn.reset(),c.compute_char_frequency(n.mangle),c.mangle_names(n.mangle)),u&&(u.properties=Date.now()),n.mangle&&n.mangle.properties&&(c=lo(c,n.mangle.properties)),u&&(u.output=Date.now());var p={};if(n.output.ast&&(p.ast=c),!D(n.output,"code")||n.output.code){if(n.sourceMap&&("string"==typeof n.sourceMap.content&&(n.sourceMap.content=JSON.parse(n.sourceMap.content)),n.output.source_map=function(e){e=r(e,{file:null,root:null,orig:null,orig_line_diff:0,dest_line_diff:0});var n=new t.SourceMapGenerator({file:e.file,sourceRoot:e.root}),i=e.orig&&new t.SourceMapConsumer(e.orig);return i&&i.sources.forEach((function(e){var t=i.sourceContentFor(e,!0);t&&n.setSourceContent(e,t);})),{add:function(t,o,r,a,s,u){if(i){var c=i.originalPositionFor({line:a,column:s});if(null===c.source)return;t=c.source,a=c.line,s=c.column,u=c.name||u;}n.addMapping({generated:{line:o+e.dest_line_diff,column:r},original:{line:a+e.orig_line_diff,column:s},source:t,name:u});},get:function(){return n},toString:function(){return JSON.stringify(n.toJSON())}}}({file:n.sourceMap.filename,orig:n.sourceMap.content,root:n.sourceMap.root}),n.sourceMap.includeSources)){if(e instanceof xe)throw new Error("original source content unavailable");for(var f in e)D(e,f)&&n.output.source_map.get().setSourceContent(f,e[f]);}delete n.output.ast,delete n.output.code;var _=Pn(n.output);if(c.print(_),p.code=_.get(),n.sourceMap)if(n.sourceMap.asObject?p.map=n.output.source_map.get().toJSON():p.map=n.output.source_map.toString(),"inline"==n.sourceMap.url){var d="object"==typeof p.map?JSON.stringify(p.map):p.map;p.code+="\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,"+po(d);}else n.sourceMap.url&&(p.code+="\n//# sourceMappingURL="+n.sourceMap.url);}return n.nameCache&&n.mangle&&(n.mangle.cache&&(n.nameCache.vars=ho(n.mangle.cache)),n.mangle.properties&&n.mangle.properties.cache&&(n.nameCache.props=ho(n.mangle.properties.cache))),u&&(u.end=Date.now(),p.timings={parse:.001*(u.rename-u.parse),rename:.001*(u.compress-u.rename),compress:.001*(u.scope-u.compress),scope:.001*(u.mangle-u.scope),mangle:.001*(u.properties-u.mangle),properties:.001*(u.output-u.properties),output:.001*(u.end-u.output),total:.001*(u.end-u.start)}),l.length&&(p.warnings=l),p}catch(e){return {error:e}}finally{fe.warn_function=a;}}!function(){var e=function(e){for(var t=!0,n=0;n<e.length;n++)t&&e[n]instanceof pe&&e[n].body instanceof ln?e[n]=new de({start:e[n].start,end:e[n].end,value:e[n].body.value}):!t||e[n]instanceof pe&&e[n].body instanceof ln||(t=!1);return e},t={Program:function(t){return new xe({start:i(t),end:o(t),body:e(t.body.map(s))})},ArrayPattern:function(e){return new Be({start:i(e),end:o(e),names:e.elements.map((function(e){return null===e?new gn:s(e)})),is_array:!0})},ObjectPattern:function(e){return new Be({start:i(e),end:o(e),names:e.properties.map(s),is_array:!1})},AssignmentPattern:function(e){var t=Tt;if(a.length>2){var n=a[a.length-2];"FunctionDeclaration"!==n.type&&"FunctionExpression"!==n.type&&"ArrowFunctionExpression"!==n.type||(t=Ct);}return new t({start:i(e),end:o(e),left:s(e.left),operator:"=",right:s(e.right)})},SpreadElement:function(e){return new Ne({start:i(e),end:o(e),expression:s(e.argument)})},RestElement:function(e){return new Ne({start:i(e),end:o(e),expression:s(e.argument)})},TemplateElement:function(e){return new Ge({start:i(e),end:o(e),value:e.value.cooked,raw:e.value.raw})},TemplateLiteral:function(e){for(var t=[],n=0;n<e.quasis.length;n++)t.push(s(e.quasis[n])),e.expressions[n]&&t.push(s(e.expressions[n]));return new Ue({start:i(e),end:o(e),segments:t})},TaggedTemplateExpression:function(e){return new Ke({start:i(e),end:o(e),template_string:s(e.quasi),prefix:s(e.tag)})},FunctionDeclaration:function(t){return new Pe({start:i(t),end:o(t),name:s(t.id),argnames:t.params.map(s),is_generator:t.generator,async:t.async,body:e(s(t.body).body)})},FunctionExpression:function(t){return new Le({start:i(t),end:o(t),name:s(t.id),argnames:t.params.map(s),is_generator:t.generator,async:t.async,body:e(s(t.body).body)})},ArrowFunctionExpression:function(e){const t="BlockStatement"===e.body.type?s(e.body).body:[p(ze,{},{value:s(e.body)})];return new Ve({start:i(e),end:o(e),argnames:e.params.map(s),body:t,async:e.async})},ExpressionStatement:function(e){return new me({start:i(e),end:o(e),body:s(e.expression)})},TryStatement:function(e){var t=e.handlers||[e.handler];if(t.length>1||e.guardedHandlers&&e.guardedHandlers.length)throw new Error("Multiple catch clauses are not supported.");return new it({start:i(e),end:o(e),body:s(e.block).body,bcatch:s(t[0]),bfinally:e.finalizer?new rt(s(e.finalizer)):null})},Property:function(e){var t=e.key,n={start:i(t||e.value),end:o(e.value),key:"Identifier"==t.type?t.name:t.value,value:s(e.value)};return e.computed&&(n.key=s(e.key)),e.method?(n.is_generator=e.value.generator,n.async=e.value.async,e.computed?n.key=s(e.key):n.key=new Yt({name:n.key}),new Nt(n)):"init"==e.kind?("Identifier"!=t.type&&"Literal"!=t.type&&(n.key=s(t)),new Rt(n)):("string"!=typeof n.key&&"number"!=typeof n.key||(n.key=new Yt({name:n.key})),n.value=new Ie(n.value),"get"==e.kind?new xt(n):"set"==e.kind?new wt(n):"method"==e.kind?(n.async=e.value.async,n.is_generator=e.value.generator,n.quote=e.computed?'"':null,new Nt(n)):void 0)},MethodDefinition:function(e){var t={start:i(e),end:o(e),key:e.computed?s(e.key):new Yt({name:e.key.name||e.key.value}),value:s(e.value),static:e.static};return "get"==e.kind?new xt(t):"set"==e.kind?new wt(t):(t.is_generator=e.value.generator,t.async=e.value.async,new Nt(t))},FieldDefinition:function(e){let t;if(e.computed)t=s(e.key);else{if("Identifier"!==e.key.type)throw new Error("Non-Identifier key in FieldDefinition");t=s(e.key);}return new It({start:i(e),end:o(e),key:t,value:s(e.value),static:e.static})},ArrayExpression:function(e){return new Ot({start:i(e),end:o(e),elements:e.elements.map((function(e){return null===e?new gn:s(e)}))})},ObjectExpression:function(e){return new Ft({start:i(e),end:o(e),properties:e.properties.map((function(e){return "SpreadElement"===e.type||(e.type="Property"),s(e)}))})},SequenceExpression:function(e){return new ht({start:i(e),end:o(e),expressions:e.expressions.map(s)})},MemberExpression:function(e){return new(e.computed?Dt:gt)({start:i(e),end:o(e),property:e.computed?s(e.property):e.property.name,expression:s(e.object)})},SwitchCase:function(e){return new(e.test?nt:tt)({start:i(e),end:o(e),expression:s(e.test),body:e.consequent.map(s)})},VariableDeclaration:function(e){return new("const"===e.kind?ct:"let"===e.kind?ut:st)({start:i(e),end:o(e),definitions:e.declarations.map(s)})},ImportDeclaration:function(e){var t=null,n=null;return e.specifiers.forEach((function(e){"ImportSpecifier"===e.type?(n||(n=[]),n.push(new ft({start:i(e),end:o(e),foreign_name:s(e.imported),name:s(e.local)}))):"ImportDefaultSpecifier"===e.type?t=s(e.local):"ImportNamespaceSpecifier"===e.type&&(n||(n=[]),n.push(new ft({start:i(e),end:o(e),foreign_name:new en({name:"*"}),name:s(e.local)})));})),new pt({start:i(e),end:o(e),imported_name:t,imported_names:n,module_name:s(e.source)})},ExportAllDeclaration:function(e){return new _t({start:i(e),end:o(e),exported_names:[new ft({name:new rn({name:"*"}),foreign_name:new rn({name:"*"})})],module_name:s(e.source)})},ExportNamedDeclaration:function(e){return new _t({start:i(e),end:o(e),exported_definition:s(e.declaration),exported_names:e.specifiers&&e.specifiers.length?e.specifiers.map((function(e){return new ft({foreign_name:s(e.exported),name:s(e.local)})})):null,module_name:s(e.source)})},ExportDefaultDeclaration:function(e){return new _t({start:i(e),end:o(e),exported_value:s(e.declaration),is_default:!0})},Literal:function(e){var t=e.value,n={start:i(e),end:o(e)},r=e.regex;if(r&&r.pattern)return n.value={source:r.pattern,flags:r.flags},new _n(n);if(r){const i=e.raw||t,o=i.match(/^\/(.*)\/(\w*)$/);if(!o)throw new Error("Invalid regex source "+i);const[r,a,s]=o;return n.value={source:a,flags:s},new _n(n)}if(null===t)return new mn(n);switch(typeof t){case"string":return n.value=t,new ln(n);case"number":return n.value=t,new fn(n);case"boolean":return new(t?An:vn)(n)}},MetaProperty:function(e){if("new"===e.meta.name&&"target"===e.property.name)return new Bt({start:i(e),end:o(e)})},Identifier:function(e){var t=a[a.length-2];return new("LabeledStatement"==t.type?tn:"VariableDeclarator"==t.type&&t.id===e?"const"==t.kind?Ht:"let"==t.kind?Xt:Ut:/Import.*Specifier/.test(t.type)?t.local===e?Qt:en:"ExportSpecifier"==t.type?t.local===e?on:rn:"FunctionExpression"==t.type?t.id===e?$t:zt:"FunctionDeclaration"==t.type?t.id===e?Wt:zt:"ArrowFunctionExpression"==t.type?t.params.includes(e)?zt:nn:"ClassExpression"==t.type?t.id===e?Zt:nn:"Property"==t.type?t.key===e&&t.computed||t.value===e?nn:Yt:"FieldDefinition"==t.type?t.key===e&&t.computed||t.value===e?nn:qt:"ClassDeclaration"==t.type?t.id===e?jt:nn:"MethodDefinition"==t.type?t.computed?nn:Yt:"CatchClause"==t.type?Jt:"BreakStatement"==t.type||"ContinueStatement"==t.type?an:nn)({start:i(e),end:o(e),name:e.name})},BigIntLiteral:e=>new pn({start:i(e),end:o(e),value:e.value})};function n(e){if("Literal"==e.type)return null!=e.raw?e.raw:e.value+""}function i(e){var t=e.loc,i=t&&t.start,o=e.range;return new le({file:t&&t.source,line:i&&i.line,col:i&&i.column,pos:o?o[0]:e.start,endline:i&&i.line,endcol:i&&i.column,endpos:o?o[0]:e.start,raw:n(e)})}function o(e){var t=e.loc,i=t&&t.end,o=e.range;return new le({file:t&&t.source,line:i&&i.line,col:i&&i.column,pos:o?o[1]:e.end,endline:i&&i.line,endcol:i&&i.column,endpos:o?o[1]:e.end,raw:n(e)})}function r(e,n,r){var a="function From_Moz_"+e+"(M){\n";a+="return new U2."+n.name+"({\nstart: my_start_token(M),\nend: my_end_token(M)";var c="function To_Moz_"+e+"(M){\n";c+="return {\ntype: "+JSON.stringify(e),r&&r.split(/\s*,\s*/).forEach((function(e){var t=/([a-z0-9$_]+)([=@>%])([a-z0-9$_]+)/i.exec(e);if(!t)throw new Error("Can't understand property map: "+e);var n=t[1],i=t[2],o=t[3];switch(a+=",\n"+o+": ",c+=",\n"+n+": ",i){case"@":a+="M."+n+".map(from_moz)",c+="M."+o+".map(to_moz)";break;case">":a+="from_moz(M."+n+")",c+="to_moz(M."+o+")";break;case"=":a+="M."+n,c+="M."+o;break;case"%":a+="from_moz(M."+n+").body",c+="to_moz_block(M)";break;default:throw new Error("Can't understand operator in propmap: "+e)}})),a+="\n})\n}",c+="\n}\n}",a=new Function("U2","my_start_token","my_end_token","from_moz","return("+a+")")(wn,i,o,s),c=new Function("to_moz","to_moz_block","to_moz_scope","return("+c+")")(l,_,d),t[e]=a,u(n,c);}t.UpdateExpression=t.UnaryExpression=function(e){return new(("prefix"in e?e.prefix:"UnaryExpression"==e.type)?vt:At)({start:i(e),end:o(e),operator:e.operator,expression:s(e.argument)})},t.ClassDeclaration=t.ClassExpression=function(e){return new("ClassDeclaration"===e.type?Lt:Vt)({start:i(e),end:o(e),name:s(e.id),extends:s(e.superClass),properties:e.body.body.map(s)})},r("EmptyStatement",Se),r("BlockStatement",De,"body@body"),r("IfStatement",Je,"test>condition, consequent>body, alternate>alternative"),r("LabeledStatement",Ae,"label>label, body>body"),r("BreakStatement",qe,"label>label"),r("ContinueStatement",$e,"label>label"),r("WithStatement",Re,"object>expression, body>body"),r("SwitchStatement",Qe,"discriminant>expression, cases@body"),r("ReturnStatement",ze,"argument>value"),r("ThrowStatement",We,"argument>value"),r("WhileStatement",Ce,"test>condition, body>body"),r("DoWhileStatement",be,"test>condition, body>body"),r("ForStatement",Oe,"init>init, test>condition, update>step, body>body"),r("ForInStatement",Fe,"left>init, right>object, body>body"),r("ForOfStatement",Me,"left>init, right>object, body>body, await=await"),r("AwaitExpression",je,"argument>expression"),r("YieldExpression",Ze,"argument>expression, delegate=is_star"),r("DebuggerStatement",_e),r("VariableDeclarator",lt,"id>name, init>value"),r("CatchClause",ot,"param>argname, body%body"),r("ThisExpression",sn),r("Super",un),r("BinaryExpression",Tt,"operator=operator, left>left, right>right"),r("LogicalExpression",Tt,"operator=operator, left>left, right>right"),r("AssignmentExpression",bt,"operator=operator, left>left, right>right"),r("ConditionalExpression",yt,"test>condition, consequent>consequent, alternate>alternative"),r("NewExpression",mt,"callee>expression, arguments@args"),r("CallExpression",dt,"callee>expression, arguments@args"),u(xe,(function(e){return d("Program",e)})),u(Ne,(function(e){return {type:f()?"RestElement":"SpreadElement",argument:l(e.expression)}})),u(Ke,(function(e){return {type:"TaggedTemplateExpression",tag:l(e.prefix),quasi:l(e.template_string)}})),u(Ue,(function(e){for(var t=[],n=[],i=0;i<e.segments.length;i++)i%2!=0?n.push(l(e.segments[i])):t.push({type:"TemplateElement",value:{raw:e.segments[i].raw,cooked:e.segments[i].value},tail:i===e.segments.length-1});return {type:"TemplateLiteral",quasis:t,expressions:n}})),u(Pe,(function(e){return {type:"FunctionDeclaration",id:l(e.name),params:e.argnames.map(l),generator:e.is_generator,async:e.async,body:d("BlockStatement",e)}})),u(Le,(function(e,t){var n=void 0!==t.is_generator?t.is_generator:e.is_generator;return {type:"FunctionExpression",id:l(e.name),params:e.argnames.map(l),generator:n,async:e.async,body:d("BlockStatement",e)}})),u(Ve,(function(e){var t={type:"BlockStatement",body:e.body.map(l)};return {type:"ArrowFunctionExpression",params:e.argnames.map(l),async:e.async,body:t}})),u(Be,(function(e){return e.is_array?{type:"ArrayPattern",elements:e.names.map(l)}:{type:"ObjectPattern",properties:e.names.map(l)}})),u(de,(function(e){return {type:"ExpressionStatement",expression:{type:"Literal",value:e.value}}})),u(me,(function(e){return {type:"ExpressionStatement",expression:l(e.body)}})),u(et,(function(e){return {type:"SwitchCase",test:l(e.expression),consequent:e.body.map(l)}})),u(it,(function(e){return {type:"TryStatement",block:_(e),handler:l(e.bcatch),guardedHandlers:[],finalizer:l(e.bfinally)}})),u(ot,(function(e){return {type:"CatchClause",param:l(e.argname),guard:null,body:_(e)}})),u(at,(function(e){return {type:"VariableDeclaration",kind:e instanceof ct?"const":e instanceof ut?"let":"var",declarations:e.definitions.map(l)}})),u(_t,(function(e){return e.exported_names?"*"===e.exported_names[0].name.name?{type:"ExportAllDeclaration",source:l(e.module_name)}:{type:"ExportNamedDeclaration",specifiers:e.exported_names.map((function(e){return {type:"ExportSpecifier",exported:l(e.foreign_name),local:l(e.name)}})),declaration:l(e.exported_definition),source:l(e.module_name)}:{type:e.is_default?"ExportDefaultDeclaration":"ExportNamedDeclaration",declaration:l(e.exported_value||e.exported_definition)}})),u(pt,(function(e){var t=[];return e.imported_name&&t.push({type:"ImportDefaultSpecifier",local:l(e.imported_name)}),e.imported_names&&"*"===e.imported_names[0].foreign_name.name?t.push({type:"ImportNamespaceSpecifier",local:l(e.imported_names[0].name)}):e.imported_names&&e.imported_names.forEach((function(e){t.push({type:"ImportSpecifier",local:l(e.name),imported:l(e.foreign_name)});})),{type:"ImportDeclaration",specifiers:t,source:l(e.module_name)}})),u(ht,(function(e){return {type:"SequenceExpression",expressions:e.expressions.map(l)}})),u(Et,(function(e){var t=e instanceof Dt;return {type:"MemberExpression",object:l(e.expression),computed:t,property:t?l(e.property):{type:"Identifier",name:e.property}}})),u(St,(function(e){return {type:"++"==e.operator||"--"==e.operator?"UpdateExpression":"UnaryExpression",operator:e.operator,prefix:e instanceof vt,argument:l(e.expression)}})),u(Tt,(function(e){return "="==e.operator&&f()?{type:"AssignmentPattern",left:l(e.left),right:l(e.right)}:{type:"&&"==e.operator||"||"==e.operator?"LogicalExpression":"BinaryExpression",left:l(e.left),operator:e.operator,right:l(e.right)}})),u(Ot,(function(e){return {type:"ArrayExpression",elements:e.elements.map(l)}})),u(Ft,(function(e){return {type:"ObjectExpression",properties:e.properties.map(l)}})),u(Mt,(function(e,t){var n,i=e.key instanceof fe?l(e.key):{type:"Identifier",value:e.key};"number"==typeof e.key&&(i={type:"Literal",value:Number(e.key)}),"string"==typeof e.key&&(i={type:"Identifier",name:e.key});var o="string"==typeof e.key||"number"==typeof e.key,r=!o&&(!(e.key instanceof Pt)||e.key instanceof nn);return e instanceof Rt?(n="init",r=!o):e instanceof xt?n="get":e instanceof wt&&(n="set"),e instanceof It?{type:"FieldDefinition",computed:r,key:i,value:l(e.value),static:e.static}:t instanceof kt?{type:"MethodDefinition",computed:r,kind:n,static:e.static,key:l(e.key),value:l(e.value)}:{type:"Property",computed:r,kind:n,key:i,value:l(e.value)}})),u(Nt,(function(e,t){return t instanceof Ft?{type:"Property",computed:!(e.key instanceof Pt)||e.key instanceof nn,kind:"init",method:!0,shorthand:!1,key:l(e.key),value:l(e.value)}:{type:"MethodDefinition",computed:!(e.key instanceof Pt)||e.key instanceof nn,kind:"constructor"===e.key?"constructor":"method",static:e.static,key:l(e.key),value:l(e.value)}})),u(kt,(function(e){return {type:e instanceof Vt?"ClassExpression":"ClassDeclaration",superClass:l(e.extends),id:e.name?l(e.name):null,body:{type:"ClassBody",body:e.properties.map(l)}}})),u(Bt,(function(){return {type:"MetaProperty",meta:{type:"Identifier",name:"new"},property:{type:"Identifier",name:"target"}}})),u(Pt,(function(e,t){if(e instanceof Yt&&t.quote)return {type:"Literal",value:e.name};var n=e.definition();return {type:"Identifier",name:n?n.mangled_name||n.name:e.name}})),u(_n,(function(e){const t=e.value.source,n=e.value.flags;return {type:"Literal",value:null,raw:e.print_to_string(),regex:{pattern:t,flags:n}}})),u(cn,(function(e){var t=e.value;return "number"==typeof t&&(t<0||0===t&&1/t<0)?{type:"UnaryExpression",operator:"-",prefix:!0,argument:{type:"Literal",value:-t,raw:e.start.raw}}:{type:"Literal",value:t,raw:e.start.raw}})),u(dn,(function(e){return {type:"Identifier",name:String(e.value)}})),u(pn,e=>({type:"BigIntLiteral",value:e.value})),Sn.DEFMETHOD("to_mozilla_ast",cn.prototype.to_mozilla_ast),mn.DEFMETHOD("to_mozilla_ast",cn.prototype.to_mozilla_ast),gn.DEFMETHOD("to_mozilla_ast",(function(){return null})),ge.DEFMETHOD("to_mozilla_ast",De.prototype.to_mozilla_ast),ke.DEFMETHOD("to_mozilla_ast",Le.prototype.to_mozilla_ast);var a=null;function s(e){a.push(e);var n=null!=e?t[e.type](e):null;return a.pop(),n}function u(e,t){e.DEFMETHOD("to_mozilla_ast",(function(e){return n=this,i=t(this,e),o=n.start,r=n.end,o&&r?(null!=o.pos&&null!=r.endpos&&(i.range=[o.pos,r.endpos]),o.line&&(i.loc={start:{line:o.line,column:o.col},end:r.endline?{line:r.endline,column:r.endcol}:null},o.file&&(i.loc.source=o.file)),i):i;var n,i,o,r;}));}fe.from_mozilla_ast=function(e){var t=a;a=[];var n=s(e);return a=t,n};var c=null;function l(e){null===c&&(c=[]),c.push(e);var t=null!=e?e.to_mozilla_ast(c[c.length-2]):null;return c.pop(),0===c.length&&(c=null),t}function f(){for(var e=c.length;e--;)if(c[e]instanceof Be)return !0;return !1}function _(e){return {type:"BlockStatement",body:e.body.map(l)}}function d(e,t){var n=t.body.map(l);return t.body[0]instanceof me&&t.body[0].body instanceof ln&&n.unshift(l(new Se(t.body[0]))),{type:e,body:n}}}(),e.AST_Accessor=Ie,e.AST_Array=Ot,e.AST_Arrow=Ve,e.AST_Assign=bt,e.AST_Atom=dn,e.AST_Await=je,e.AST_Binary=Tt,e.AST_Block=ge,e.AST_BlockStatement=De,e.AST_Boolean=Sn,e.AST_Break=qe,e.AST_Call=dt,e.AST_Case=nt,e.AST_Catch=ot,e.AST_Class=kt,e.AST_ClassExpression=Vt,e.AST_ConciseMethod=Nt,e.AST_Conditional=yt,e.AST_Const=ct,e.AST_Constant=cn,e.AST_Continue=$e,e.AST_DWLoop=ye,e.AST_Debugger=_e,e.AST_DefClass=Lt,e.AST_Default=tt,e.AST_DefaultAssign=Ct,e.AST_Definitions=at,e.AST_Defun=Pe,e.AST_Destructuring=Be,e.AST_Directive=de,e.AST_Do=be,e.AST_Dot=gt,e.AST_EmptyStatement=Se,e.AST_Exit=Xe,e.AST_Expansion=Ne,e.AST_Export=_t,e.AST_False=vn,e.AST_Finally=rt,e.AST_For=Oe,e.AST_ForIn=Fe,e.AST_ForOf=Me,e.AST_Function=Le,e.AST_Hole=gn,e.AST_If=Je,e.AST_Import=pt,e.AST_Infinity=Dn,e.AST_IterationStatement=Te,e.AST_Jump=He,e.AST_Label=tn,e.AST_LabelRef=an,e.AST_LabeledStatement=Ae,e.AST_Lambda=ke,e.AST_Let=ut,e.AST_LoopControl=Ye,e.AST_NaN=hn,e.AST_NameMapping=ft,e.AST_New=mt,e.AST_NewTarget=Bt,e.AST_Node=fe,e.AST_Null=mn,e.AST_Number=fn,e.AST_Object=Ft,e.AST_ObjectGetter=xt,e.AST_ObjectKeyVal=Rt,e.AST_ObjectProperty=Mt,e.AST_ObjectSetter=wt,e.AST_PrefixedTemplateString=Ke,e.AST_PropAccess=Et,e.AST_RegExp=_n,e.AST_Return=ze,e.AST_Scope=we,e.AST_Sequence=ht,e.AST_SimpleStatement=me,e.AST_Statement=pe,e.AST_StatementWithBody=ve,e.AST_String=ln,e.AST_Sub=Dt,e.AST_Super=un,e.AST_Switch=Qe,e.AST_SwitchBranch=et,e.AST_Symbol=Pt,e.AST_SymbolBlockDeclaration=Gt,e.AST_SymbolCatch=Jt,e.AST_SymbolClass=Zt,e.AST_SymbolConst=Ht,e.AST_SymbolDeclaration=Kt,e.AST_SymbolDefClass=jt,e.AST_SymbolDefun=Wt,e.AST_SymbolExport=on,e.AST_SymbolExportForeign=rn,e.AST_SymbolFunarg=zt,e.AST_SymbolImport=Qt,e.AST_SymbolImportForeign=en,e.AST_SymbolLambda=$t,e.AST_SymbolLet=Xt,e.AST_SymbolMethod=Yt,e.AST_SymbolRef=nn,e.AST_SymbolVar=Ut,e.AST_TemplateSegment=Ge,e.AST_TemplateString=Ue,e.AST_This=sn,e.AST_Throw=We,e.AST_Token=le,e.AST_Toplevel=xe,e.AST_True=An,e.AST_Try=it,e.AST_Unary=St,e.AST_UnaryPostfix=At,e.AST_UnaryPrefix=vt,e.AST_Undefined=En,e.AST_Var=st,e.AST_VarDef=lt,e.AST_While=Ce,e.AST_With=Re,e.AST_Yield=Ze,e.Compressor=ri,e.OutputStream=Pn,e.TreeTransformer=On,e.TreeWalker=Cn,e._INLINE=Mn,e._JS_Parse_Error=J,e._NOINLINE=Rn,e._PURE=Fn,e._has_annotation=T,e._tokenizer=ne,e.base54=Yn,e.default_options=qn,e.defaults=r,e.mangle_properties=lo,e.minify=Eo,e.parse=ue,e.push_uniq=_,e.reserve_quoted_keys=uo,e.string_template=d,e.to_ascii=fo;}));

});

// MODULE: compiler/optimize/minify-js.js
const minifyJs = async (input, opts) => {
  if (opts) {
    const mangle = opts.mangle;
    if (mangle) {
      const mangleProperties = mangle.properties;
      if (mangleProperties && mangleProperties.regex) {
        mangleProperties.regex = new RegExp(mangleProperties.regex);
      }
    }
  }
  const result = bundle_min.minify(input, opts);
  const diagnostics = loadMinifyJsDiagnostics(input, result);
  if (diagnostics.length === 0) {
    const compress = opts.compress;
    if (compress && compress.module && result.code.endsWith('};')) {
      result.code = result.code.substring(0, result.code.length - 1);
    }
  }
  return {
    output: result.code,
    sourceMap: result.map,
    diagnostics: diagnostics,
  };
};
const loadMinifyJsDiagnostics = (sourceText, result) => {
  const diagnostics = [];
  if (!result || !result.error) {
    return diagnostics;
  }
  const d = {
    level: 'error',
    type: 'build',
    language: 'javascript',
    header: 'Minify JS',
    code: '',
    messageText: result.error.message,
    absFilePath: null,
    relFilePath: null,
    lines: [],
  };
  const err = result.error;
  if (typeof err.line === 'number' && err.line > -1) {
    const srcLines = splitLineBreaks(sourceText);
    const errorLine = {
      lineIndex: err.line - 1,
      lineNumber: err.line,
      text: srcLines[err.line - 1],
      errorCharStart: err.col,
      errorLength: 0,
    };
    d.lineNumber = errorLine.lineNumber;
    d.columnNumber = errorLine.errorCharStart;
    const highlightLine = errorLine.text.substr(d.columnNumber);
    for (let i = 0; i < highlightLine.length; i++) {
      if (CHAR_BREAK.has(highlightLine.charAt(i))) {
        break;
      }
      errorLine.errorLength++;
    }
    d.lines.push(errorLine);
    if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
      errorLine.errorLength = 1;
      errorLine.errorCharStart--;
    }
    if (errorLine.lineIndex > 0) {
      const previousLine = {
        lineIndex: errorLine.lineIndex - 1,
        lineNumber: errorLine.lineNumber - 1,
        text: srcLines[errorLine.lineIndex - 1],
        errorCharStart: -1,
        errorLength: -1,
      };
      d.lines.unshift(previousLine);
    }
    if (errorLine.lineIndex + 1 < srcLines.length) {
      const nextLine = {
        lineIndex: errorLine.lineIndex + 1,
        lineNumber: errorLine.lineNumber + 1,
        text: srcLines[errorLine.lineIndex + 1],
        errorCharStart: -1,
        errorLength: -1,
      };
      d.lines.push(nextLine);
    }
  }
  diagnostics.push(d);
  return diagnostics;
};
const CHAR_BREAK = new Set([' ', '=', '.', ',', '?', ':', ';', '(', ')', '{', '}', '[', ']', '|', `'`, `"`, '`']);

// MODULE: compiler/optimize/optimize-module.js
const optimizeModule = async (config, compilerCtx, opts) => {
  if (!opts.minify && opts.sourceTarget !== 'es5') {
    return {
      output: opts.input,
      diagnostics: [],
    };
  }
  const isDebug = config.logLevel === 'debug';
  const cacheKey = await compilerCtx.cache.createKey('optimizeModule', minfyJsId, opts, isDebug);
  const cachedContent = await compilerCtx.cache.get(cacheKey);
  if (cachedContent != null) {
    return {
      output: cachedContent,
      diagnostics: [],
    };
  }
  let minifyOpts;
  if (opts.minify) {
    minifyOpts = getTerserOptions(config, opts.sourceTarget, isDebug);
    const compressOpts = minifyOpts.compress;
    const mangleOptions = minifyOpts.mangle;
    if (opts.sourceTarget !== 'es5' && opts.isCore) {
      if (!isDebug) {
        compressOpts.passes = 3;
        compressOpts.global_defs = {
          'supportsListenerOptions': true,
          'plt.$cssShim$': false,
        };
        compressOpts.pure_funcs = compressOpts.pure_funcs || [];
        compressOpts.pure_funcs = ['getHostRef', ...compressOpts.pure_funcs];
      }
      mangleOptions.properties = {
        regex: '^\\$.+\\$$',
        debug: isDebug,
      };
      compressOpts.inline = 1;
      compressOpts.unsafe = true;
      compressOpts.unsafe_undefined = true;
    }
    if (opts.modeName && opts.modeName !== DEFAULT_STYLE_MODE) {
      const regex = new RegExp(`\\/\\*STENCIL:MODE:((?!${opts.modeName}).)*\\*\\/.*$`, 'gm');
      opts.input = opts.input.replace(regex, '');
    }
  }
  const shouldTranspile = opts.sourceTarget === 'es5';
  const results = await compilerCtx.worker.prepareModule(opts.input, minifyOpts, shouldTranspile, opts.inlineHelpers);
  if (results != null && typeof results.output === 'string' && results.diagnostics.length === 0 && compilerCtx != null) {
    if (opts.isCore) {
      results.output = results.output.replace(/disconnectedCallback\(\)\{\},/g, '');
    }
    await compilerCtx.cache.put(cacheKey, results.output);
  }
  return results;
};
const getTerserOptions = (config, sourceTarget, prettyOutput) => {
  const opts = {
    ie8: false,
    safari10: !!config.extras.safari10,
    output: {},
  };
  if (sourceTarget === 'es5') {
    opts.ecma = opts.output.ecma = 5;
    opts.compress = false;
    opts.mangle = true;
  }
  else {
    opts.mangle = {
      properties: {
        regex: '^\\$.+\\$$',
      },
    };
    opts.compress = {
      pure_getters: true,
      keep_fargs: false,
      passes: 2,
    };
    opts.ecma = opts.output.ecma = opts.compress.ecma = 8;
    opts.toplevel = true;
    opts.module = true;
    opts.mangle.toplevel = true;
    opts.compress.arrows = true;
    opts.compress.module = true;
    opts.compress.toplevel = true;
  }
  if (prettyOutput) {
    opts.mangle = { keep_fnames: true };
    opts.compress = {};
    opts.compress.drop_console = false;
    opts.compress.drop_debugger = false;
    opts.compress.pure_funcs = [];
    opts.output.beautify = true;
    opts.output.indent_level = 2;
    opts.output.comments = 'all';
  }
  return opts;
};
const prepareModule = async (input, minifyOpts, transpile, inlineHelpers) => {
  if (transpile) {
    const transpile = await transpileToEs5(input, inlineHelpers);
    if (hasError(transpile.diagnostics)) {
      return {
        sourceMap: null,
        output: null,
        diagnostics: transpile.diagnostics,
      };
    }
    input = transpile.code;
  }
  if (minifyOpts) {
    return minifyJs(input, minifyOpts);
  }
  return {
    output: input,
    diagnostics: [],
    sourceMap: null,
  };
};

// MODULE: compiler/worker/worker-thread.js
const createWorkerContext = () => {
  return {
    compileModule: compile$1,
    transformCssToEsm,
    prepareModule,
    optimizeCss,
    transpileToEs5,
  };
};
const createWorkerMsgHandler = () => {
  const workerCtx = createWorkerContext();
  const handleMsg = async (msgToWorker) => {
    const fnName = msgToWorker.args[0];
    const fnArgs = msgToWorker.args.slice(1);
    const fn = workerCtx[fnName];
    if (typeof fn === 'function') {
      return fn.apply(null, fnArgs);
    }
  };
  return handleMsg;
};
const initWorkerThread = (glbl) => {
  if (IS_WEB_WORKER_ENV) {
    initWebWorkerThread(glbl, createWorkerMsgHandler());
  }
  else if (IS_NODE_ENV && glbl.process.argv.includes('stencil-compiler-worker')) {
    initNodeWorkerThread(glbl.process, createWorkerMsgHandler());
  }
};

// MODULE: compiler/cache.js
class Cache {
  constructor(config, cacheFs) {
    this.config = config;
    this.cacheFs = cacheFs;
    this.failed = 0;
    this.skip = false;
    this.sys = config.sys;
    this.logger = config.logger;
  }
  async initCacheDir() {
    if (this.config._isTesting) {
      return;
    }
    if (!this.config.enableCache || !this.cacheFs) {
      this.config.logger.info(`cache optimizations disabled`);
      this.clearDiskCache();
      return;
    }
    this.config.logger.debug(`cache enabled, cacheDir: ${this.config.cacheDir}`);
    try {
      const readmeFilePath = join(this.config.cacheDir, '_README.log');
      await this.cacheFs.writeFile(readmeFilePath, CACHE_DIR_README);
    }
    catch (e) {
      this.logger.error(`Cache, initCacheDir: ${e}`);
      this.config.enableCache = false;
    }
  }
  async get(key) {
    if (!this.config.enableCache || this.skip) {
      return null;
    }
    if (this.failed >= MAX_FAILED) {
      if (!this.skip) {
        this.skip = true;
        this.logger.debug(`cache had ${this.failed} failed ops, skip disk ops for remander of build`);
      }
      return null;
    }
    let result;
    try {
      result = await this.cacheFs.readFile(this.getCacheFilePath(key));
      this.failed = 0;
      this.skip = false;
    }
    catch (e) {
      this.failed++;
      result = null;
    }
    return result;
  }
  async put(key, value) {
    if (!this.config.enableCache) {
      return false;
    }
    let result;
    try {
      await this.cacheFs.writeFile(this.getCacheFilePath(key), value);
      result = true;
    }
    catch (e) {
      this.failed++;
      result = false;
    }
    return result;
  }
  async has(key) {
    const val = await this.get(key);
    return typeof val === 'string';
  }
  async createKey(domain, ...args) {
    if (!this.config.enableCache) {
      return domain + Math.random() * 9999999;
    }
    const hash = await this.sys.generateContentHash(JSON.stringify(args), 32);
    return domain + '_' + hash;
  }
  async commit() {
    if (this.config.enableCache) {
      this.skip = false;
      this.failed = 0;
      await this.cacheFs.commit();
      await this.clearExpiredCache();
    }
  }
  clear() {
    if (this.cacheFs != null) {
      this.cacheFs.clearCache();
    }
  }
  async clearExpiredCache() {
    if (this.cacheFs == null || this.sys.cacheStorage == null) {
      return;
    }
    const now = Date.now();
    const lastClear = (await this.sys.cacheStorage.get(EXP_STORAGE_KEY));
    if (lastClear != null) {
      const diff = now - lastClear;
      if (diff < ONE_DAY) {
        return;
      }
      const fs = this.cacheFs.sys;
      const cachedFileNames = await fs.readdir(this.config.cacheDir);
      const cachedFilePaths = cachedFileNames.map(f => join(this.config.cacheDir, f));
      let totalCleared = 0;
      const promises = cachedFilePaths.map(async (filePath) => {
        const stat = await fs.stat(filePath);
        const lastModified = stat.mtime.getTime();
        const diff = now - lastModified;
        if (diff > ONE_WEEK) {
          await fs.unlink(filePath);
          totalCleared++;
        }
      });
      await Promise.all(promises);
      this.logger.debug(`clearExpiredCache, cachedFileNames: ${cachedFileNames.length}, totalCleared: ${totalCleared}`);
    }
    this.logger.debug(`clearExpiredCache, set last clear`);
    await this.sys.cacheStorage.set(EXP_STORAGE_KEY, now);
  }
  async clearDiskCache() {
    if (this.cacheFs != null) {
      const hasAccess = await this.cacheFs.access(this.config.cacheDir);
      if (hasAccess) {
        await this.cacheFs.remove(this.config.cacheDir);
        await this.cacheFs.commit();
      }
    }
  }
  getCacheFilePath(key) {
    return join(this.config.cacheDir, key) + '.log';
  }
  getMemoryStats() {
    if (this.cacheFs != null) {
      return this.cacheFs.getMemoryStats();
    }
    return null;
  }
}
const MAX_FAILED = 100;
const ONE_DAY = 1000 * 60 * 60 * 24;
const ONE_WEEK = ONE_DAY * 7;
const EXP_STORAGE_KEY = `last_clear_expired_cache`;
const CACHE_DIR_README = `# Stencil Cache Directory

This directory contains files which the compiler has
cached for faster builds. To disable caching, please set
"enableCache: false" within the stencil config.

To change the cache directory, please update the
"cacheDir" property within the stencil config.
`;

// MODULE: compiler/output-targets/output-utils.js
const relativeImport = (pathFrom, pathTo, ext, addPrefix = true) => {
  let relativePath = relative(dirname(pathFrom), dirname(pathTo));
  if (addPrefix) {
    if (relativePath === '') {
      relativePath = '.';
    }
    else if (relativePath[0] !== '.') {
      relativePath = './' + relativePath;
    }
  }
  return normalizePath(`${relativePath}/${basename(pathTo, ext)}`);
};
const getComponentsDtsSrcFilePath = (config) => join(config.srcDir, GENERATED_DTS);
const getComponentsDtsTypesFilePath = (outputTarget) => join(outputTarget.typesDir, GENERATED_DTS);
const isOutputTargetDist = (o) => o.type === DIST;
const isOutputTargetDistCollection = (o) => o.type === DIST_COLLECTION;
const isOutputTargetDistCustomElements = (o) => o.type === DIST_CUSTOM_ELEMENTS;
const isOutputTargetDistCustomElementsBundle = (o) => o.type === DIST_CUSTOM_ELEMENTS_BUNDLE || o.type === EXPERIMENTAL_DIST_MODULE;
const isOutputTargetCopy = (o) => o.type === COPY;
const isOutputTargetDistLazy = (o) => o.type === DIST_LAZY;
const isOutputTargetAngular = (o) => o.type === ANGULAR;
const isOutputTargetDistLazyLoader = (o) => o.type === DIST_LAZY_LOADER;
const isOutputTargetDistGlobalStyles = (o) => o.type === DIST_GLOBAL_STYLES;
const isOutputTargetDistSelfContained = (o) => o.type === DIST_SELF_CONTAINED;
const isOutputTargetHydrate = (o) => o.type === DIST_HYDRATE_SCRIPT;
const isOutputTargetCustom = (o) => o.type === CUSTOM;
const isOutputTargetDocs = (o) => o.type === DOCS || o.type === DOCS_README || o.type === DOCS_JSON || o.type === DOCS_CUSTOM || o.type === DOCS_VSCODE;
const isOutputTargetDocsReadme = (o) => o.type === DOCS_README || o.type === DOCS;
const isOutputTargetDocsJson = (o) => o.type === DOCS_JSON;
const isOutputTargetDocsCustom = (o) => o.type === DOCS_CUSTOM;
const isOutputTargetDocsVscode = (o) => o.type === DOCS_VSCODE;
const isOutputTargetWww = (o) => o.type === WWW;
const isOutputTargetStats = (o) => o.type === STATS;
const isOutputTargetDistTypes = (o) => o.type === DIST_TYPES;
const getComponentsFromModules = (moduleFiles) => sortBy(flatOne(moduleFiles.map(m => m.cmps)), (c) => c.tagName);
const ANGULAR = `angular`;
const COPY = 'copy';
const CUSTOM = `custom`;
const DIST = `dist`;
const DIST_COLLECTION = `dist-collection`;
const DIST_CUSTOM_ELEMENTS = `dist-custom-elements`;
const DIST_CUSTOM_ELEMENTS_BUNDLE = `dist-custom-elements-bundle`;
const EXPERIMENTAL_DIST_MODULE = `experimental-dist-module`;
const DIST_TYPES = `dist-types`;
const DIST_HYDRATE_SCRIPT = `dist-hydrate-script`;
const DIST_LAZY = `dist-lazy`;
const DIST_LAZY_LOADER = `dist-lazy-loader`;
const DIST_SELF_CONTAINED = `dist-self-contained`;
const DIST_GLOBAL_STYLES = 'dist-global-styles';
const DOCS = `docs`;
const DOCS_CUSTOM = 'docs-custom';
const DOCS_JSON = `docs-json`;
const DOCS_README = `docs-readme`;
const DOCS_VSCODE = `docs-vscode`;
const STATS = `stats`;
const WWW = `www`;
const VALID_TYPES_NEXT = [
  // DIST
  WWW,
  DIST,
  DIST_COLLECTION,
  // DIST_CUSTOM_ELEMENTS,
  DIST_CUSTOM_ELEMENTS_BUNDLE,
  EXPERIMENTAL_DIST_MODULE,
  DIST_LAZY,
  DIST_HYDRATE_SCRIPT,
  // DOCS
  DOCS,
  DOCS_JSON,
  DOCS_README,
  DOCS_VSCODE,
  DOCS_CUSTOM,
  // MISC
  ANGULAR,
  COPY,
  CUSTOM,
  STATS,
];
const GENERATED_DTS = 'components.d.ts';

// MODULE: ../node_modules/concat-map/index.js
var concatMap = function (xs, fn) {
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    var x = fn(xs[i], i);
    if (isArray$1(x)) res.push.apply(res, x);
    else res.push(x);
  }
  return res;
};

var isArray$1 = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

// MODULE: ../node_modules/balanced-match/index.js
var balancedMatch = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
  start: r[0],
  end: r[1],
  pre: str.slice(0, r[0]),
  body: str.slice(r[0] + a.length, r[1]),
  post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
  begs = [];
  left = str.length;

  while (i >= 0 && !result) {
    if (i == ai) {
    begs.push(i);
    ai = str.indexOf(a, i + 1);
    } else if (begs.length == 1) {
    result = [ begs.pop(), bi ];
    } else {
    beg = begs.pop();
    if (beg < left) {
      left = beg;
      right = bi;
    }

    bi = str.indexOf(b, i + 1);
    }

    i = ai < bi && ai >= 0 ? ai : bi;
  }

  if (begs.length) {
    result = [ left, right ];
  }
  }

  return result;
}

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/concat-map/index.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/balanced-match/index.js?commonjs-proxy

// MODULE: ../node_modules/brace-expansion/index.js

var braceExpansion = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
  ? parseInt(str, 10)
  : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
      .split('\\{').join(escOpen)
      .split('\\}').join(escClose)
      .split('\\,').join(escComma)
      .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
      .split(escOpen).join('{')
      .split(escClose).join('}')
      .split(escComma).join(',')
      .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
  return [''];

  var parts = [];
  var m = balancedMatch('{', '}', str);

  if (!m)
  return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
  p[p.length-1] += postParts.shift();
  p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
  return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
  str = '\\{\\}' + str.substr(2);
  }

  return expand$1(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand$1(str, isTop) {
  var expansions = [];

  var m = balancedMatch('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
  // {a},b}
  if (m.post.match(/,.*\}/)) {
    str = m.pre + '{' + m.body + escClose + m.post;
    return expand$1(str);
  }
  return [str];
  }

  var n;
  if (isSequence) {
  n = m.body.split(/\.\./);
  } else {
  n = parseCommaParts(m.body);
  if (n.length === 1) {
    // x{{a,b}}y ==> x{a}y x{b}y
    n = expand$1(n[0], false).map(embrace);
    if (n.length === 1) {
    var post = m.post.length
      ? expand$1(m.post, false)
      : [''];
    return post.map(function(p) {
      return m.pre + n[0] + p;
    });
    }
  }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
  ? expand$1(m.post, false)
  : [''];

  var N;

  if (isSequence) {
  var x = numeric(n[0]);
  var y = numeric(n[1]);
  var width = Math.max(n[0].length, n[1].length);
  var incr = n.length == 3
    ? Math.abs(numeric(n[2]))
    : 1;
  var test = lte;
  var reverse = y < x;
  if (reverse) {
    incr *= -1;
    test = gte;
  }
  var pad = n.some(isPadded);

  N = [];

  for (var i = x; test(i, y); i += incr) {
    var c;
    if (isAlphaSequence) {
    c = String.fromCharCode(i);
    if (c === '\\')
      c = '';
    } else {
    c = String(i);
    if (pad) {
      var need = width - c.length;
      if (need > 0) {
      var z = new Array(need + 1).join('0');
      if (i < 0)
        c = '-' + z + c.slice(1);
      else
        c = z + c;
      }
    }
    }
    N.push(c);
  }
  } else {
  N = concatMap(n, function(el) { return expand$1(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
  for (var k = 0; k < post.length; k++) {
    var expansion = pre + N[j] + post[k];
    if (!isTop || isSequence || expansion)
    expansions.push(expansion);
  }
  }

  return expansions;
}

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/brace-expansion/index.js?commonjs-proxy

// MODULE: ../node_modules/minimatch/minimatch.js

var minimatch_1 = minimatch;
minimatch.Minimatch = Minimatch;

var path$3 = { sep: '/' };
try {
  path$3 = path;
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};


var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]';

// * => any number of characters
var star = qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
  set[c] = true;
  return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/;

minimatch.filter = filter;
function filter (pattern, options) {
  options = options || {};
  return function (p, i, list) {
  return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
  t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
  t[k] = a[k];
  });
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch;

  var m = function minimatch (p, pattern, options) {
  return orig.minimatch(p, pattern, ext(def, options))
  };

  m.Minimatch = function Minimatch (pattern, options) {
  return new orig.Minimatch(pattern, ext(def, options))
  };

  return m
};

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
};

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
  throw new TypeError('glob pattern string required')
  }

  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
  return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
  return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
  throw new TypeError('glob pattern string required')
  }

  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (path$3.sep !== '/') {
  pattern = pattern.split(path$3.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;

  // make the set of regexps etc.
  this.make();
}

Minimatch.prototype.debug = function () {};

Minimatch.prototype.make = make;
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
  this.comment = true;
  return
  }
  if (!pattern) {
  this.empty = true;
  return
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
  return s.split(slashSplit)
  });

  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
  return s.map(this.parse, this)
  }, this);

  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
  return s.indexOf(false) === -1
  });

  this.debug(this.pattern, set);

  this.set = set;
}

Minimatch.prototype.parseNegate = parseNegate;
function parseNegate () {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
  ; i < l && pattern.charAt(i) === '!'
  ; i++) {
  negate = !negate;
  negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
};

Minimatch.prototype.braceExpand = braceExpand;

function braceExpand (pattern, options) {
  if (!options) {
  if (this instanceof Minimatch) {
    options = this.options;
  } else {
    options = {};
  }
  }

  pattern = typeof pattern === 'undefined'
  ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
  throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
  !pattern.match(/\{.*\}/)) {
  // shortcut. no need to expand.
  return [pattern]
  }

  return braceExpansion(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse$2;
var SUBPARSE = {};
function parse$2 (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
  throw new TypeError('pattern is too long')
  }

  var options = this.options;

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)';
  var self = this;

  function clearStateChar () {
  if (stateChar) {
    // we had some state-tracking character
    // that wasn't consumed by this pass.
    switch (stateChar) {
    case '*':
      re += star;
      hasMagic = true;
    break
    case '?':
      re += qmark;
      hasMagic = true;
    break
    default:
      re += '\\' + stateChar;
    break
    }
    self.debug('clearStateChar %j %j', stateChar, re);
    stateChar = false;
  }
  }

  for (var i = 0, len = pattern.length, c
  ; (i < len) && (c = pattern.charAt(i))
  ; i++) {
  this.debug('%s\t%s %s %j', pattern, i, re, c);

  // skip over any that are escaped.
  if (escaping && reSpecials[c]) {
    re += '\\' + c;
    escaping = false;
    continue
  }

  switch (c) {
    case '/':
    // completely not allowed, even escaped.
    // Should already be path-split by now.
    return false

    case '\\':
    clearStateChar();
    escaping = true;
    continue

    // the various stateChar values
    // for the "extglob" stuff.
    case '?':
    case '*':
    case '+':
    case '@':
    case '!':
    this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

    // all of those are literals inside a class, except that
    // the glob [!a] means [^a] in regexp
    if (inClass) {
      this.debug('  in class');
      if (c === '!' && i === classStart + 1) c = '^';
      re += c;
      continue
    }

    // if we already have a stateChar, then it means
    // that there was something like ** or +? in there.
    // Handle the stateChar, then proceed with this one.
    self.debug('call clearStateChar %j', stateChar);
    clearStateChar();
    stateChar = c;
    // if extglob is disabled, then +(asdf|foo) isn't a thing.
    // just clear the statechar *now*, rather than even diving into
    // the patternList stuff.
    if (options.noext) clearStateChar();
    continue

    case '(':
    if (inClass) {
      re += '(';
      continue
    }

    if (!stateChar) {
      re += '\\(';
      continue
    }

    patternListStack.push({
      type: stateChar,
      start: i - 1,
      reStart: re.length,
      open: plTypes[stateChar].open,
      close: plTypes[stateChar].close
    });
    // negation is (?:(?!js)[^/]*)
    re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
    this.debug('plType %j %j', stateChar, re);
    stateChar = false;
    continue

    case ')':
    if (inClass || !patternListStack.length) {
      re += '\\)';
      continue
    }

    clearStateChar();
    hasMagic = true;
    var pl = patternListStack.pop();
    // negation is (?:(?!js)[^/]*)
    // The others are (?:<pattern>)<type>
    re += pl.close;
    if (pl.type === '!') {
      negativeLists.push(pl);
    }
    pl.reEnd = re.length;
    continue

    case '|':
    if (inClass || !patternListStack.length || escaping) {
      re += '\\|';
      escaping = false;
      continue
    }

    clearStateChar();
    re += '|';
    continue

    // these are mostly the same in regexp and glob
    case '[':
    // swallow any state-tracking char before the [
    clearStateChar();

    if (inClass) {
      re += '\\' + c;
      continue
    }

    inClass = true;
    classStart = i;
    reClassStart = re.length;
    re += c;
    continue

    case ']':
    //  a right bracket shall lose its special
    //  meaning and represent itself in
    //  a bracket expression if it occurs
    //  first in the list.  -- POSIX.2 2.8.3.2
    if (i === classStart + 1 || !inClass) {
      re += '\\' + c;
      escaping = false;
      continue
    }

    // handle the case where we left a class open.
    // "[z-a]" is valid, equivalent to "\[z-a\]"
    if (inClass) {
      // split where the last [ was, make sure we don't have
      // an invalid re. if so, re-walk the contents of the
      // would-be class to re-translate any characters that
      // were passed through as-is
      // TODO: It would probably be faster to determine this
      // without a try/catch and a new RegExp, but it's tricky
      // to do safely.  For now, this is safe and works.
      var cs = pattern.substring(classStart + 1, i);
      try {
      RegExp('[' + cs + ']');
      } catch (er) {
      // not a valid class!
      var sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
      hasMagic = hasMagic || sp[1];
      inClass = false;
      continue
      }
    }

    // finish up the class.
    hasMagic = true;
    inClass = false;
    re += c;
    continue

    default:
    // swallow any state char that wasn't consumed
    clearStateChar();

    if (escaping) {
      // no need
      escaping = false;
    } else if (reSpecials[c]
      && !(c === '^' && inClass)) {
      re += '\\';
    }

    re += c;

  } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
  // split where the last [ was, and escape it
  // this is a huge pita.  We now have to re-walk
  // the contents of the would-be class to re-translate
  // any characters that were passed through as-is
  cs = pattern.substr(classStart + 1);
  sp = this.parse(cs, SUBPARSE);
  re = re.substr(0, reClassStart) + '\\[' + sp[0];
  hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
  var tail = re.slice(pl.reStart + pl.open.length);
  this.debug('setting tail', re, pl);
  // maybe some even number of \, then maybe 1 \, followed by a |
  tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
    if (!$2) {
    // the | isn't already escaped, so escape it.
    $2 = '\\';
    }

    // need to escape all those slashes *again*, without escaping the
    // one that we need for escaping the | character.  As it works out,
    // escaping an even number of slashes can be done by simply repeating
    // it exactly after itself.  That's why this trick works.
    //
    // I am sorry that you have to see this.
    return $1 + $1 + $2 + '|'
  });

  this.debug('tail=%j\n   %s', tail, tail, pl, re);
  var t = pl.type === '*' ? star
    : pl.type === '?' ? qmark
    : '\\' + pl.type;

  hasMagic = true;
  re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
  // trailing \\
  re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
  case '.':
  case '[':
  case '(': addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
  var nl = negativeLists[n];

  var nlBefore = re.slice(0, nl.reStart);
  var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
  var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
  var nlAfter = re.slice(nl.reEnd);

  nlLast += nlAfter;

  // Handle nested stuff like *(*.js|!(*.json)), where open parens
  // mean that we should *not* include the ) in the bit that is considered
  // "after" the negated section.
  var openParensBefore = nlBefore.split('(').length - 1;
  var cleanAfter = nlAfter;
  for (i = 0; i < openParensBefore; i++) {
    cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
  }
  nlAfter = cleanAfter;

  var dollar = '';
  if (nlAfter === '' && isSub !== SUBPARSE) {
    dollar = '$';
  }
  var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
  re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
  re = '(?=.)' + re;
  }

  if (addPatternStart) {
  re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
  return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
  return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : '';
  try {
  var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
  // If it was an invalid regular expression, then it can't match
  // anything.  This trick looks for a character after the end of
  // the string, which is of course impossible, except in multi-line
  // mode, but it's not a /m regex.
  return new RegExp('$.')
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
};

Minimatch.prototype.makeRe = makeRe;
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;

  if (!set.length) {
  this.regexp = false;
  return this.regexp
  }
  var options = this.options;

  var twoStar = options.noglobstar ? star
  : options.dot ? twoStarDot
  : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
  return pattern.map(function (p) {
    return (p === GLOBSTAR) ? twoStar
    : (typeof p === 'string') ? regExpEscape(p)
    : p._src
  }).join('\\\/')
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
  this.regexp = new RegExp(re, flags);
  } catch (ex) {
  this.regexp = false;
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch(pattern, options);
  list = list.filter(function (f) {
  return mm.match(f)
  });
  if (mm.options.nonull && !list.length) {
  list.push(pattern);
  }
  return list
};

Minimatch.prototype.match = match;
function match (f, partial) {
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options;

  // windows: need to use /, not \
  if (path$3.sep !== '/') {
  f = f.split(path$3.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
  filename = f[i];
  if (filename) break
  }

  for (i = 0; i < set.length; i++) {
  var pattern = set[i];
  var file = f;
  if (options.matchBase && pattern.length === 1) {
    file = [filename];
  }
  var hit = this.matchOne(file, pattern, partial);
  if (hit) {
    if (options.flipNegate) return true
    return !this.negate
  }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne',
  { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0,
    pi = 0,
    fl = file.length,
    pl = pattern.length
    ; (fi < fl) && (pi < pl)
    ; fi++, pi++) {
  this.debug('matchOne loop');
  var p = pattern[pi];
  var f = file[fi];

  this.debug(pattern, p, f);

  // should be impossible.
  // some invalid regexp stuff in the set.
  if (p === false) return false

  if (p === GLOBSTAR) {
    this.debug('GLOBSTAR', [pattern, p, f]);

    // "**"
    // a/**/b/**/c would match the following:
    // a/b/x/y/z/c
    // a/x/y/z/b/c
    // a/b/x/b/x/c
    // a/b/c
    // To do this, take the rest of the pattern after
    // the **, and see if it would match the file remainder.
    // If so, return success.
    // If not, the ** "swallows" a segment, and try again.
    // This is recursively awful.
    //
    // a/**/b/**/c matching a/b/x/y/z/c
    // - a matches a
    // - doublestar
    //   - matchOne(b/x/y/z/c, b/**/c)
    //   - b matches b
    //   - doublestar
    //     - matchOne(x/y/z/c, c) -> no
    //     - matchOne(y/z/c, c) -> no
    //     - matchOne(z/c, c) -> no
    //     - matchOne(c, c) yes, hit
    var fr = fi;
    var pr = pi + 1;
    if (pr === pl) {
    this.debug('** at the end');
    // a ** at the end will just swallow the rest.
    // We have found a match.
    // however, it will not swallow /.x, unless
    // options.dot is set.
    // . and .. are *never* matched by **, for explosively
    // exponential reasons.
    for (; fi < fl; fi++) {
      if (file[fi] === '.' || file[fi] === '..' ||
      (!options.dot && file[fi].charAt(0) === '.')) return false
    }
    return true
    }

    // ok, let's see if we can swallow whatever we can.
    while (fr < fl) {
    var swallowee = file[fr];

    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

    // XXX remove this slice.  Just pass the start index.
    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
      this.debug('globstar found match!', fr, fl, swallowee);
      // found a match.
      return true
    } else {
      // can't swallow "." or ".." ever.
      // can only swallow ".foo" when explicitly asked.
      if (swallowee === '.' || swallowee === '..' ||
      (!options.dot && swallowee.charAt(0) === '.')) {
      this.debug('dot detected!', file, fr, pattern, pr);
      break
      }

      // ** swallows a segment, and continue.
      this.debug('globstar swallow a segment, and continue');
      fr++;
    }
    }

    // no match was found.
    // However, in partial mode, we can't say this is necessarily over.
    // If there's more *pattern* left, then
    if (partial) {
    // ran out of file
    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
    if (fr === fl) return true
    }
    return false
  }

  // something other than **
  // non-magic patterns just have to match exactly
  // patterns with magic have been turned into regexps.
  var hit;
  if (typeof p === 'string') {
    if (options.nocase) {
    hit = f.toLowerCase() === p.toLowerCase();
    } else {
    hit = f === p;
    }
    this.debug('string match', p, f, hit);
  } else {
    hit = f.match(p);
    this.debug('pattern match', p, f, hit);
  }

  if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
  // ran out of pattern and filename at the same time.
  // an exact hit!
  return true
  } else if (fi === fl) {
  // ran out of file, but still had pattern left.
  // this is ok if we're doing the match as part of
  // a glob fs traversal.
  return partial
  } else if (pi === pl) {
  // ran out of pattern, still have file left.
  // this is only acceptable if we're on the very last
  // empty segment of a file with a trailing slash.
  // a/* should match a/b/
  var emptyFileEnd = (fi === fl - 1) && (file[fi] === '');
  return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
};

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}

// MODULE: compiler/build/build-hmr.js
const generateHmr = (config, compilerCtx, buildCtx) => {
  if (config.devServer == null || config.devServer.reloadStrategy == null) {
    return null;
  }
  const hmr = {
    reloadStrategy: config.devServer.reloadStrategy,
    versionId: Date.now()
      .toString()
      .substring(6) +
      '' +
      Math.round(Math.random() * 89999 + 10000),
  };
  if (buildCtx.scriptsAdded.length > 0) {
    hmr.scriptsAdded = buildCtx.scriptsAdded.slice();
  }
  if (buildCtx.scriptsDeleted.length > 0) {
    hmr.scriptsDeleted = buildCtx.scriptsDeleted.slice();
  }
  const excludeHmr = excludeHmrFiles(config, config.devServer.excludeHmr, buildCtx.filesChanged);
  if (excludeHmr.length > 0) {
    hmr.excludeHmr = excludeHmr.slice();
  }
  if (buildCtx.hasHtmlChanges) {
    hmr.indexHtmlUpdated = true;
  }
  if (buildCtx.hasServiceWorkerChanges) {
    hmr.serviceWorkerUpdated = true;
  }
  const outputTargetsWww = config.outputTargets.filter(isOutputTargetWww);
  const componentsUpdated = getComponentsUpdated(compilerCtx, buildCtx);
  if (componentsUpdated) {
    hmr.componentsUpdated = componentsUpdated;
  }
  if (Object.keys(buildCtx.stylesUpdated).length > 0) {
    hmr.inlineStylesUpdated = sortBy(buildCtx.stylesUpdated.map(s => {
      return {
        styleId: getScopeId(s.styleTag, s.styleMode),
        styleTag: s.styleTag,
        styleText: s.styleText,
      };
    }), s => s.styleId);
  }
  const externalStylesUpdated = getExternalStylesUpdated(buildCtx, outputTargetsWww);
  if (externalStylesUpdated) {
    hmr.externalStylesUpdated = externalStylesUpdated;
  }
  const externalImagesUpdated = getImagesUpdated(buildCtx, outputTargetsWww);
  if (externalImagesUpdated) {
    hmr.imagesUpdated = externalImagesUpdated;
  }
  return hmr;
};
const getComponentsUpdated = (compilerCtx, buildCtx) => {
  // find all of the components that would be affected from the file changes
  if (!buildCtx.filesChanged) {
    return null;
  }
  const filesToLookForImporters = buildCtx.filesChanged.filter(f => {
    return f.endsWith('.ts') || f.endsWith('.tsx') || f.endsWith('.js') || f.endsWith('.jsx');
  });
  if (filesToLookForImporters.length === 0) {
    return null;
  }
  const changedScriptFiles = [];
  const checkedFiles = new Set();
  const allModuleFiles = buildCtx.moduleFiles.filter(m => m.localImports && m.localImports.length > 0);
  while (filesToLookForImporters.length > 0) {
    const scriptFile = filesToLookForImporters.shift();
    addTsFileImporters(allModuleFiles, filesToLookForImporters, checkedFiles, changedScriptFiles, scriptFile);
  }
  const tags = changedScriptFiles.reduce((tags, changedTsFile) => {
    const moduleFile = compilerCtx.moduleMap.get(changedTsFile);
    if (moduleFile != null) {
      moduleFile.cmps.forEach(cmp => {
        if (typeof cmp.tagName === 'string') {
          if (!tags.includes(cmp.tagName)) {
            tags.push(cmp.tagName);
          }
        }
      });
    }
    return tags;
  }, []);
  if (tags.length === 0) {
    return null;
  }
  return tags.sort();
};
const addTsFileImporters = (allModuleFiles, filesToLookForImporters, checkedFiles, changedScriptFiles, scriptFile) => {
  if (!changedScriptFiles.includes(scriptFile)) {
    // add it to our list of files to transpile
    changedScriptFiles.push(scriptFile);
  }
  if (checkedFiles.has(scriptFile)) {
    // already checked this file
    return;
  }
  checkedFiles.add(scriptFile);
  // get all the ts files that import this ts file
  const tsFilesThatImportsThisTsFile = allModuleFiles.reduce((arr, moduleFile) => {
    moduleFile.localImports.forEach(localImport => {
      let checkFile = localImport;
      if (checkFile === scriptFile) {
        arr.push(moduleFile.sourceFilePath);
        return;
      }
      checkFile = localImport + '.tsx';
      if (checkFile === scriptFile) {
        arr.push(moduleFile.sourceFilePath);
        return;
      }
      checkFile = localImport + '.ts';
      if (checkFile === scriptFile) {
        arr.push(moduleFile.sourceFilePath);
        return;
      }
      checkFile = localImport + '.js';
      if (checkFile === scriptFile) {
        arr.push(moduleFile.sourceFilePath);
        return;
      }
    });
    return arr;
  }, []);
  // add all the files that import this ts file to the list of ts files we need to look through
  tsFilesThatImportsThisTsFile.forEach(tsFileThatImportsThisTsFile => {
    // if we add to this array, then the while look will keep working until it's empty
    filesToLookForImporters.push(tsFileThatImportsThisTsFile);
  });
};
const getExternalStylesUpdated = (buildCtx, outputTargetsWww) => {
  if (!buildCtx.isRebuild || outputTargetsWww.length === 0) {
    return null;
  }
  const cssFiles = buildCtx.filesWritten.filter(f => f.endsWith('.css'));
  if (cssFiles.length === 0) {
    return null;
  }
  return cssFiles.map(cssFile => basename(cssFile)).sort();
};
const getImagesUpdated = (buildCtx, outputTargetsWww) => {
  if (outputTargetsWww.length === 0) {
    return null;
  }
  const imageFiles = buildCtx.filesChanged.reduce((arr, filePath) => {
    if (IMAGE_EXT.some(ext => filePath.toLowerCase().endsWith(ext))) {
      const fileName = basename(filePath);
      if (!arr.includes(fileName)) {
        arr.push(fileName);
      }
    }
    return arr;
  }, []);
  if (imageFiles.length === 0) {
    return null;
  }
  return imageFiles.sort();
};
const excludeHmrFiles = (config, excludeHmr, filesChanged) => {
  const excludeFiles = [];
  if (!excludeHmr || excludeHmr.length === 0) {
    return excludeFiles;
  }
  excludeHmr.forEach(excludeHmr => {
    return filesChanged
      .map(fileChanged => {
      let shouldExclude = false;
      if (isGlob(excludeHmr)) {
        shouldExclude = minimatch_1(fileChanged, excludeHmr);
      }
      else {
        shouldExclude = normalizePath(excludeHmr) === normalizePath(fileChanged);
      }
      if (shouldExclude) {
        config.logger.debug(`excludeHmr: ${fileChanged}`);
        excludeFiles.push(basename(fileChanged));
      }
      return shouldExclude;
    })
      .some(r => r);
  });
  return excludeFiles.sort();
};
const IMAGE_EXT = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.ico', '.svg'];

// MODULE: compiler/build/build-results.js
const generateBuildResults = (config, compilerCtx, buildCtx) => {
  const componentGraph = buildCtx.componentGraph ? fromEntries(buildCtx.componentGraph.entries()) : undefined;
  const buildResults = {
    buildId: buildCtx.buildId,
    diagnostics: normalizeDiagnostics(compilerCtx, buildCtx.diagnostics),
    dirsAdded: buildCtx.dirsAdded.slice().sort(),
    dirsDeleted: buildCtx.dirsDeleted.slice().sort(),
    duration: Date.now() - buildCtx.startTime,
    filesAdded: buildCtx.filesAdded.slice().sort(),
    filesChanged: buildCtx.filesChanged.slice().sort(),
    filesDeleted: buildCtx.filesDeleted.slice().sort(),
    filesUpdated: buildCtx.filesUpdated.slice().sort(),
    hasError: hasError(buildCtx.diagnostics),
    hasSuccessfulBuild: compilerCtx.hasSuccessfulBuild,
    isRebuild: buildCtx.isRebuild,
    namespace: config.namespace,
    outputs: compilerCtx.fs.getBuildOutputs(),
    rootDir: config.rootDir,
    srcDir: config.srcDir,
    timestamp: getBuildTimestamp(),
    componentGraph,
  };
  const hmr = generateHmr(config, compilerCtx, buildCtx);
  if (hmr != null) {
    buildResults.hmr = hmr;
  }
  if (isString(buildCtx.hydrateAppFilePath)) {
    buildResults.hydrateAppFilePath = buildCtx.hydrateAppFilePath;
  }
  compilerCtx.lastBuildResults = Object.assign({}, buildResults);
  return buildResults;
};

// MODULE: compiler/build/build-finish.js
const buildFinish = async (buildCtx) => {
  const results = await buildDone(buildCtx.config, buildCtx.compilerCtx, buildCtx, false);
  const buildLog = {
    buildId: buildCtx.buildId,
    messages: buildCtx.buildMessages.slice(),
    progress: 1,
  };
  buildCtx.compilerCtx.events.emit('buildLog', buildLog);
  return results;
};
const buildAbort = (buildCtx) => {
  return buildDone(buildCtx.config, buildCtx.compilerCtx, buildCtx, true);
};
const buildDone = async (config, compilerCtx, buildCtx, aborted) => {
  if (buildCtx.hasFinished && buildCtx.buildResults_next) {
    // we've already marked this build as finished and
    // already created the build results, just return these
    return buildCtx.buildResults_next;
  }
  buildCtx.debug(`${aborted ? 'aborted' : 'finished'} build, ${buildCtx.timestamp}`);
  // create the build results data
  buildCtx.buildResults_next = generateBuildResults(config, compilerCtx, buildCtx);
  // log any errors/warnings
  if (!buildCtx.hasFinished) {
    // haven't set this build as finished yet
    if (!buildCtx.hasPrintedResults) {
      cleanDiagnostics(config, buildCtx.buildResults_next.diagnostics);
      config.logger.printDiagnostics(buildCtx.buildResults_next.diagnostics);
    }
    const hasChanges = buildCtx.hasScriptChanges || buildCtx.hasStyleChanges;
    if (buildCtx.isRebuild && hasChanges && buildCtx.buildResults_next.hmr && !aborted) {
      // this is a rebuild, and we've got hmr data
      // and this build hasn't been aborted
      logHmr(config.logger, buildCtx);
    }
    // create a nice pretty message stating what happend
    const buildText = buildCtx.isRebuild ? 'rebuild' : 'build';
    const watchText = config.watch ? ', watching for changes...' : '';
    let buildStatus = 'finished';
    let statusColor = 'green';
    if (buildCtx.hasError) {
      // gosh darn, build had errors
      // ಥ_ಥ
      buildStatus = 'failed';
      statusColor = 'red';
    }
    else {
      // successful build!
      // ┏(°.°)┛ ┗(°.°)┓ ┗(°.°)┛ ┏(°.°)┓
      compilerCtx.changedFiles.clear();
      compilerCtx.hasSuccessfulBuild = true;
      buildCtx.buildResults_next.hasSuccessfulBuild = true;
    }
    // print out the time it took to build
    // and add the duration to the build results
    if (!buildCtx.hasPrintedResults) {
      buildCtx.timeSpan.finish(`${buildText} ${buildStatus}${watchText}`, statusColor, true, true);
      buildCtx.hasPrintedResults = true;
    }
    // emit a buildFinish event for anyone who cares
    compilerCtx.events.emit('buildFinish', buildCtx.buildResults_next);
    // write all of our logs to disk if config'd to do so
    // do this even if there are errors or not the active build
    config.logger.writeLogs(buildCtx.isRebuild);
  }
  // it's official, this build has finished
  buildCtx.hasFinished = true;
  if (!config.watch) {
    compilerCtx.reset();
    if (IS_NODE_ENV && global.gc) {
      buildCtx.debug(`triggering forced gc`);
      global.gc();
      buildCtx.debug(`forced gc finished`);
    }
  }
  return buildCtx.buildResults_next;
};
const logHmr = (logger, buildCtx) => {
  // this is a rebuild, and we've got hmr data
  // and this build hasn't been aborted
  const hmr = buildCtx.buildResults_next.hmr;
  if (hmr.componentsUpdated) {
    cleanupUpdateMsg(logger, `updated component`, hmr.componentsUpdated);
  }
  if (hmr.inlineStylesUpdated) {
    const inlineStyles = hmr.inlineStylesUpdated
      .map(s => s.styleTag)
      .reduce((arr, v) => {
      if (!arr.includes(v)) {
        arr.push(v);
      }
      return arr;
    }, []);
    cleanupUpdateMsg(logger, `updated style`, inlineStyles);
  }
  if (hmr.externalStylesUpdated) {
    cleanupUpdateMsg(logger, `updated stylesheet`, hmr.externalStylesUpdated);
  }
  if (hmr.imagesUpdated) {
    cleanupUpdateMsg(logger, `updated image`, hmr.imagesUpdated);
  }
};
const cleanupUpdateMsg = (logger, msg, fileNames) => {
  if (fileNames.length > 0) {
    let fileMsg = '';
    if (fileNames.length > 7) {
      const remaining = fileNames.length - 6;
      fileNames = fileNames.slice(0, 6);
      fileMsg = fileNames.join(', ') + `, +${remaining} others`;
    }
    else {
      fileMsg = fileNames.join(', ');
    }
    if (fileNames.length > 1) {
      msg += 's';
    }
    logger.info(`${msg}: ${logger.cyan(fileMsg)}`);
  }
};
const cleanDiagnostics = (config, diagnostics) => {
  diagnostics.forEach(diagnostic => {
    if (!diagnostic.relFilePath && diagnostic.absFilePath && config.rootDir) {
      diagnostic.relFilePath = path.relative(config.rootDir, diagnostic.absFilePath);
    }
  });
};

// MODULE: runtime/runtime-constants.js
const CONTENT_REF_ID = 'r';
const ORG_LOCATION_ID = 'o';
const SLOT_NODE_ID = 's';
const TEXT_NODE_ID = 't';
const HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';
const XLINK_NS = 'http://www.w3.org/1999/xlink';

// MODULE: mock-doc/attribute.js
const attrHandler = {
  get(obj, prop) {
    if (prop in obj) {
      return obj[prop];
    }
    if (!isNaN(prop)) {
      return obj.__items[prop];
    }
    return undefined;
  },
};
const createAttributeProxy = (caseInsensitive) => new Proxy(new MockAttributeMap(caseInsensitive), attrHandler);
class MockAttributeMap {
  constructor(caseInsensitive = false) {
    this.caseInsensitive = caseInsensitive;
    this.__items = [];
  }
  get length() {
    return this.__items.length;
  }
  item(index) {
    return this.__items[index] || null;
  }
  setNamedItem(attr) {
    attr.namespaceURI = null;
    this.setNamedItemNS(attr);
  }
  setNamedItemNS(attr) {
    if (attr != null && attr.value != null) {
      attr.value = String(attr.value);
    }
    const existingAttr = this.__items.find(a => a.name === attr.name && a.namespaceURI === attr.namespaceURI);
    if (existingAttr != null) {
      existingAttr.value = attr.value;
    }
    else {
      this.__items.push(attr);
    }
  }
  getNamedItem(attrName) {
    if (this.caseInsensitive) {
      attrName = attrName.toLowerCase();
    }
    return this.getNamedItemNS(null, attrName);
  }
  getNamedItemNS(namespaceURI, attrName) {
    namespaceURI = getNamespaceURI(namespaceURI);
    return this.__items.find(attr => attr.name === attrName && getNamespaceURI(attr.namespaceURI) === namespaceURI) || null;
  }
  removeNamedItem(attr) {
    this.removeNamedItemNS(attr);
  }
  removeNamedItemNS(attr) {
    for (let i = 0, ii = this.__items.length; i < ii; i++) {
      if (this.__items[i].name === attr.name && this.__items[i].namespaceURI === attr.namespaceURI) {
        this.__items.splice(i, 1);
        break;
      }
    }
  }
}
function getNamespaceURI(namespaceURI) {
  return namespaceURI === XLINK_NS ? null : namespaceURI;
}
function cloneAttributes(srcAttrs, sortByName = false) {
  const dstAttrs = new MockAttributeMap(srcAttrs.caseInsensitive);
  if (srcAttrs != null) {
    const attrLen = srcAttrs.length;
    if (sortByName && attrLen > 1) {
      const sortedAttrs = [];
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        sortedAttrs.push(dstAttr);
      }
      sortedAttrs.sort(sortAttributes).forEach(attr => {
        dstAttrs.setNamedItemNS(attr);
      });
    }
    else {
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        dstAttrs.setNamedItemNS(dstAttr);
      }
    }
  }
  return dstAttrs;
}
function sortAttributes(a, b) {
  if (a.name < b.name)
    return -1;
  if (a.name > b.name)
    return 1;
  return 0;
}
class MockAttr {
  constructor(attrName, attrValue, namespaceURI = null) {
    this._name = attrName;
    this._value = String(attrValue);
    this._namespaceURI = namespaceURI;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = String(value);
  }
  get nodeName() {
    return this._name;
  }
  set nodeName(value) {
    this._name = value;
  }
  get nodeValue() {
    return this._value;
  }
  set nodeValue(value) {
    this._value = String(value);
  }
  get namespaceURI() {
    return this._namespaceURI;
  }
  set namespaceURI(namespaceURI) {
    this._namespaceURI = namespaceURI;
  }
}

// MODULE: mock-doc/custom-element-registry.js
class MockCustomElementRegistry {
  constructor(win) {
    this.win = win;
  }
  define(tagName, cstr, options) {
    if (tagName.toLowerCase() !== tagName) {
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': "${tagName}" is not a valid custom element name`);
    }
    if (this.__registry == null) {
      this.__registry = new Map();
    }
    this.__registry.set(tagName, { cstr, options });
    if (this.__whenDefined != null) {
      const whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns != null) {
        whenDefinedResolveFns.forEach(whenDefinedResolveFn => {
          whenDefinedResolveFn();
        });
        whenDefinedResolveFns.length = 0;
        this.__whenDefined.delete(tagName);
      }
    }
    const doc = this.win.document;
    if (doc != null) {
      const hosts = doc.querySelectorAll(tagName);
      hosts.forEach(host => {
        if (upgradedElements.has(host) === false) {
          tempDisableCallbacks.add(doc);
          const upgradedCmp = createCustomElement(this, doc, tagName);
          for (let i = 0; i < host.childNodes.length; i++) {
            const childNode = host.childNodes[i];
            childNode.remove();
            upgradedCmp.appendChild(childNode);
          }
          tempDisableCallbacks.delete(doc);
          if (proxyElements.has(host)) {
            proxyElements.set(host, upgradedCmp);
          }
        }
        fireConnectedCallback(host);
      });
    }
  }
  get(tagName) {
    if (this.__registry != null) {
      const def = this.__registry.get(tagName.toLowerCase());
      if (def != null) {
        return def.cstr;
      }
    }
    return undefined;
  }
  upgrade(_rootNode) {
    //
  }
  clear() {
    if (this.__registry != null) {
      this.__registry.clear();
    }
    if (this.__whenDefined != null) {
      this.__whenDefined.clear();
    }
  }
  whenDefined(tagName) {
    tagName = tagName.toLowerCase();
    if (this.__registry != null && this.__registry.has(tagName) === true) {
      return Promise.resolve();
    }
    return new Promise(resolve => {
      if (this.__whenDefined == null) {
        this.__whenDefined = new Map();
      }
      let whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns == null) {
        whenDefinedResolveFns = [];
        this.__whenDefined.set(tagName, whenDefinedResolveFns);
      }
      whenDefinedResolveFns.push(resolve);
    });
  }
}
function createCustomElement(customElements, ownerDocument, tagName) {
  const Cstr = customElements.get(tagName);
  if (Cstr != null) {
    const cmp = new Cstr(ownerDocument);
    cmp.nodeName = tagName.toUpperCase();
    upgradedElements.add(cmp);
    return cmp;
  }
  const host = new Proxy({}, {
    get(obj, prop) {
      const elm = proxyElements.get(host);
      if (elm != null) {
        return elm[prop];
      }
      return obj[prop];
    },
    set(obj, prop, val) {
      const elm = proxyElements.get(host);
      if (elm != null) {
        elm[prop] = val;
      }
      else {
        obj[prop] = val;
      }
      return true;
    },
    has(obj, prop) {
      const elm = proxyElements.get(host);
      if (prop in elm) {
        return true;
      }
      if (prop in obj) {
        return true;
      }
      return false;
    },
  });
  const elm = new MockHTMLElement(ownerDocument, tagName);
  proxyElements.set(host, elm);
  return host;
}
const proxyElements = new WeakMap();
const upgradedElements = new WeakSet();
function connectNode(ownerDocument, node) {
  node.ownerDocument = ownerDocument;
  if (node.nodeType === 1 /* ELEMENT_NODE */) {
    if (ownerDocument != null && node.nodeName.includes('-')) {
      const win = ownerDocument.defaultView;
      if (win != null && typeof node.connectedCallback === 'function' && node.isConnected) {
        fireConnectedCallback(node);
      }
      const shadowRoot = node.shadowRoot;
      if (shadowRoot != null) {
        shadowRoot.childNodes.forEach(childNode => {
          connectNode(ownerDocument, childNode);
        });
      }
    }
    node.childNodes.forEach(childNode => {
      connectNode(ownerDocument, childNode);
    });
  }
  else {
    node.childNodes.forEach(childNode => {
      childNode.ownerDocument = ownerDocument;
    });
  }
}
function fireConnectedCallback(node) {
  if (typeof node.connectedCallback === 'function') {
    if (tempDisableCallbacks.has(node.ownerDocument) === false) {
      try {
        node.connectedCallback();
      }
      catch (e) {
        console.error(e);
      }
    }
  }
}
function disconnectNode(node) {
  if (node.nodeType === 1 /* ELEMENT_NODE */) {
    if (node.nodeName.includes('-') === true && typeof node.disconnectedCallback === 'function') {
      if (tempDisableCallbacks.has(node.ownerDocument) === false) {
        try {
          node.disconnectedCallback();
        }
        catch (e) {
          console.error(e);
        }
      }
    }
    node.childNodes.forEach(disconnectNode);
  }
}
function attributeChanged(node, attrName, oldValue, newValue) {
  attrName = attrName.toLowerCase();
  const observedAttributes = node.constructor.observedAttributes;
  if (Array.isArray(observedAttributes) === true && observedAttributes.some(obs => obs.toLowerCase() === attrName) === true) {
    try {
      node.attributeChangedCallback(attrName, oldValue, newValue);
    }
    catch (e) {
      console.error(e);
    }
  }
}
function checkAttributeChanged(node) {
  return node.nodeName.includes('-') === true && typeof node.attributeChangedCallback === 'function';
}
const tempDisableCallbacks = new Set();

// MODULE: mock-doc/dataset.js
function dataset(elm) {
  const ds = {};
  const attributes = elm.attributes;
  const attrLen = attributes.length;
  for (let i = 0; i < attrLen; i++) {
    const attr = attributes.item(i);
    const nodeName = attr.nodeName;
    if (nodeName.startsWith('data-')) {
      ds[dashToPascalCase$1(nodeName)] = attr.nodeValue;
    }
  }
  return new Proxy(ds, {
    get(_obj, camelCaseProp) {
      return ds[camelCaseProp];
    },
    set(_obj, camelCaseProp, value) {
      const dataAttr = toDataAttribute(camelCaseProp);
      elm.setAttribute(dataAttr, value);
      return true;
    },
  });
}
function toDataAttribute(str) {
  return ('data-' +
    String(str)
      .replace(/([A-Z0-9])/g, g => ' ' + g[0])
      .trim()
      .replace(/ /g, '-')
      .toLowerCase());
}
function dashToPascalCase$1(str) {
  str = String(str).substr(5);
  return str
    .split('-')
    .map((segment, index) => {
    if (index === 0) {
      return segment.charAt(0).toLowerCase() + segment.slice(1);
    }
    return segment.charAt(0).toUpperCase() + segment.slice(1);
  })
    .join('');
}

// MODULE: ../sizzle
const Sizzle = (function() {

const window = {
  document: {
  createElement() {
    return {};
  },
  nodeType: 9,
  documentElement: {
    nodeType: 1,
    nodeName: 'HTML'
  }
  }
};

const module = { exports: {} };

/*! Sizzle v2.3.5 | (c) JS Foundation and other contributors | js.foundation */
!function(e){var t,n,r,i,o,u,l,a,c,s,d,f,p,h,g,m,y,v,w,b="sizzle"+1*new Date,N=e.document,C=0,x=0,E=ae(),A=ae(),S=ae(),D=ae(),T=function(e,t){return e===t&&(d=!0),0},L={}.hasOwnProperty,q=[],I=q.pop,B=q.push,R=q.push,$=q.slice,k=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return -1},H="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",P="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",z="\\["+M+"*("+P+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+P+"))|)"+M+"*\\]",F=":("+P+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+z+")*)|.*)\\)|)",O=new RegExp(M+"+","g"),j=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),G=new RegExp("^"+M+"*,"+M+"*"),U=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),V=new RegExp(M+"|>"),X=new RegExp(F),J=new RegExp("^"+P+"$"),K={ID:new RegExp("^#("+P+")"),CLASS:new RegExp("^\\.("+P+")"),TAG:new RegExp("^("+P+"|[*])"),ATTR:new RegExp("^"+z),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+H+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Q=/HTML$/i,W=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){f();},ue=ve(function(e){return !0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{R.apply(q=$.call(N.childNodes),N.childNodes),q[N.childNodes.length].nodeType;}catch(e){R={apply:q.length?function(e,t){B.apply(e,$.call(t));}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1;}};}function le(e,t,r,i){var o,l,c,s,d,h,y,v=t&&t.ownerDocument,N=t?t.nodeType:9;if(r=r||[],"string"!=typeof e||!e||1!==N&&9!==N&&11!==N)return r;if(!i&&(f(t),t=t||p,g)){if(11!==N&&(d=_.exec(e)))if(o=d[1]){if(9===N){if(!(c=t.getElementById(o)))return r;if(c.id===o)return r.push(c),r}else if(v&&(c=v.getElementById(o))&&w(t,c)&&c.id===o)return r.push(c),r}else{if(d[2])return R.apply(r,t.getElementsByTagName(e)),r;if((o=d[3])&&n.getElementsByClassName&&t.getElementsByClassName)return R.apply(r,t.getElementsByClassName(o)),r}if(n.qsa&&!D[e+" "]&&(!m||!m.test(e))&&(1!==N||"object"!==t.nodeName.toLowerCase())){if(y=e,v=t,1===N&&(V.test(e)||U.test(e))){(v=ee.test(e)&&ge(t.parentNode)||t)===t&&n.scope||((s=t.getAttribute("id"))?s=s.replace(re,ie):t.setAttribute("id",s=b)),l=(h=u(e)).length;while(l--)h[l]=(s?"#"+s:":scope")+" "+ye(h[l]);y=h.join(",");}try{return R.apply(r,v.querySelectorAll(y)),r}catch(t){D(e,!0);}finally{s===b&&t.removeAttribute("id");}}}return a(e.replace(j,"$1"),t,r,i)}function ae(){var e=[];function t(n,i){return e.push(n+" ")>r.cacheLength&&delete t[e.shift()],t[n+" "]=i}return t}function ce(e){return e[b]=!0,e}function se(e){var t=p.createElement("fieldset");try{return !!e(t)}catch(e){return !1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null;}}function de(e,t){var n=e.split("|"),i=n.length;while(i--)r.attrHandle[n[i]]=t;}function fe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return -1;return e?1:-1}function pe(e){return function(t){return "form"in t?t.parentNode&&!1===t.disabled?"label"in t?"label"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&ue(t)===e:t.disabled===e:"label"in t&&t.disabled===e}}function he(e){return ce(function(t){return t=+t,ce(function(n,r){var i,o=e([],n.length,t),u=o.length;while(u--)n[i=o[u]]&&(n[i]=!(r[i]=n[i]));})})}function ge(e){return e&&void 0!==e.getElementsByTagName&&e}n=le.support={},o=le.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return !Q.test(t||n&&n.nodeName||"HTML")},f=le.setDocument=function(e){var t,i,u=e?e.ownerDocument||e:N;return u!=p&&9===u.nodeType&&u.documentElement?(p=u,h=p.documentElement,g=!o(p),N!=p&&(i=p.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener("unload",oe,!1):i.attachEvent&&i.attachEvent("onunload",oe)),n.scope=se(function(e){return h.appendChild(e).appendChild(p.createElement("div")),void 0!==e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),n.attributes=se(function(e){return e.className="i",!e.getAttribute("className")}),n.getElementsByTagName=se(function(e){return e.appendChild(p.createComment("")),!e.getElementsByTagName("*").length}),n.getElementsByClassName=Z.test(p.getElementsByClassName),n.getById=se(function(e){return h.appendChild(e).id=b,!p.getElementsByName||!p.getElementsByName(b).length}),n.getById?(r.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},r.find.ID=function(e,t){if(void 0!==t.getElementById&&g){var n=t.getElementById(e);return n?[n]:[]}}):(r.filter.ID=function(e){var t=e.replace(te,ne);return function(e){var n=void 0!==e.getAttributeNode&&e.getAttributeNode("id");return n&&n.value===t}},r.find.ID=function(e,t){if(void 0!==t.getElementById&&g){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return [o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return [o]}return []}}),r.find.TAG=n.getElementsByTagName?function(e,t){return void 0!==t.getElementsByTagName?t.getElementsByTagName(e):n.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},r.find.CLASS=n.getElementsByClassName&&function(e,t){if(void 0!==t.getElementsByClassName&&g)return t.getElementsByClassName(e)},y=[],m=[],(n.qsa=Z.test(p.querySelectorAll))&&(se(function(e){var t;h.appendChild(e).innerHTML="<a id='"+b+"'></a><select id='"+b+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&m.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||m.push("\\["+M+"*(?:value|"+H+")"),e.querySelectorAll("[id~="+b+"-]").length||m.push("~="),(t=p.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||m.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||m.push(":checked"),e.querySelectorAll("a#"+b+"+*").length||m.push(".#.+[+~]"),e.querySelectorAll("\\\f"),m.push("[\\r\\n\\f]");}),se(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=p.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&m.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&m.push(":enabled",":disabled"),h.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&m.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),m.push(",.*:");})),(n.matchesSelector=Z.test(v=h.matches||h.webkitMatchesSelector||h.mozMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&se(function(e){n.disconnectedMatch=v.call(e,"*"),v.call(e,"[s!='']:x"),y.push("!=",F);}),m=m.length&&new RegExp(m.join("|")),y=y.length&&new RegExp(y.join("|")),t=Z.test(h.compareDocumentPosition),w=t||Z.test(h.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return !0;return !1},T=t?function(e,t){if(e===t)return d=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r||(1&(r=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!n.sortDetached&&t.compareDocumentPosition(e)===r?e==p||e.ownerDocument==N&&w(N,e)?-1:t==p||t.ownerDocument==N&&w(N,t)?1:s?k(s,e)-k(s,t):0:4&r?-1:1)}:function(e,t){if(e===t)return d=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,u=[e],l=[t];if(!i||!o)return e==p?-1:t==p?1:i?-1:o?1:s?k(s,e)-k(s,t):0;if(i===o)return fe(e,t);n=e;while(n=n.parentNode)u.unshift(n);n=t;while(n=n.parentNode)l.unshift(n);while(u[r]===l[r])r++;return r?fe(u[r],l[r]):u[r]==N?-1:l[r]==N?1:0},p):p},le.matches=function(e,t){return le(e,null,null,t)},le.matchesSelector=function(e,t){if(f(e),n.matchesSelector&&g&&!D[t+" "]&&(!y||!y.test(t))&&(!m||!m.test(t)))try{var r=v.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){D(t,!0);}return le(t,p,null,[e]).length>0},le.contains=function(e,t){return (e.ownerDocument||e)!=p&&f(e),w(e,t)},le.attr=function(e,t){(e.ownerDocument||e)!=p&&f(e);var i=r.attrHandle[t.toLowerCase()],o=i&&L.call(r.attrHandle,t.toLowerCase())?i(e,t,!g):void 0;return void 0!==o?o:n.attributes||!g?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null},le.escape=function(e){return (e+"").replace(re,ie)},le.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},le.uniqueSort=function(e){var t,r=[],i=0,o=0;if(d=!n.detectDuplicates,s=!n.sortStable&&e.slice(0),e.sort(T),d){while(t=e[o++])t===e[o]&&(i=r.push(o));while(i--)e.splice(r[i],1);}return s=null,e},i=le.getText=function(e){var t,n="",r=0,o=e.nodeType;if(o){if(1===o||9===o||11===o){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=i(e);}else if(3===o||4===o)return e.nodeValue}else while(t=e[r++])n+=i(t);return n},(r=le.selectors={cacheLength:50,createPseudo:ce,match:K,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||le.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&le.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return K.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=u(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return "*"===e?function(){return !0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=E[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&E(e,function(e){return t.test("string"==typeof e.className&&e.className||void 0!==e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=le.attr(r,e);return null==i?"!="===t:!t||(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i.replace(O," ")+" ").indexOf(n)>-1:"|="===t&&(i===n||i.slice(0,n.length+1)===n+"-"))}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),u="last"!==e.slice(-4),l="of-type"===t;return 1===r&&0===i?function(e){return !!e.parentNode}:function(t,n,a){var c,s,d,f,p,h,g=o!==u?"nextSibling":"previousSibling",m=t.parentNode,y=l&&t.nodeName.toLowerCase(),v=!a&&!l,w=!1;if(m){if(o){while(g){f=t;while(f=f[g])if(l?f.nodeName.toLowerCase()===y:1===f.nodeType)return !1;h=g="only"===e&&!h&&"nextSibling";}return !0}if(h=[u?m.firstChild:m.lastChild],u&&v){w=(p=(c=(s=(d=(f=m)[b]||(f[b]={}))[f.uniqueID]||(d[f.uniqueID]={}))[e]||[])[0]===C&&c[1])&&c[2],f=p&&m.childNodes[p];while(f=++p&&f&&f[g]||(w=p=0)||h.pop())if(1===f.nodeType&&++w&&f===t){s[e]=[C,p,w];break}}else if(v&&(w=p=(c=(s=(d=(f=t)[b]||(f[b]={}))[f.uniqueID]||(d[f.uniqueID]={}))[e]||[])[0]===C&&c[1]),!1===w)while(f=++p&&f&&f[g]||(w=p=0)||h.pop())if((l?f.nodeName.toLowerCase()===y:1===f.nodeType)&&++w&&(v&&((s=(d=f[b]||(f[b]={}))[f.uniqueID]||(d[f.uniqueID]={}))[e]=[C,w]),f===t))break;return (w-=i)===r||w%r==0&&w/r>=0}}},PSEUDO:function(e,t){var n,i=r.pseudos[e]||r.setFilters[e.toLowerCase()]||le.error("unsupported pseudo: "+e);return i[b]?i(t):i.length>1?(n=[e,e,"",t],r.setFilters.hasOwnProperty(e.toLowerCase())?ce(function(e,n){var r,o=i(e,t),u=o.length;while(u--)e[r=k(e,o[u])]=!(n[r]=o[u]);}):function(e){return i(e,0,n)}):i}},pseudos:{not:ce(function(e){var t=[],n=[],r=l(e.replace(j,"$1"));return r[b]?ce(function(e,t,n,i){var o,u=r(e,null,i,[]),l=e.length;while(l--)(o=u[l])&&(e[l]=!(t[l]=o));}):function(e,i,o){return t[0]=e,r(t,null,o,n),t[0]=null,!n.pop()}}),has:ce(function(e){return function(t){return le(e,t).length>0}}),contains:ce(function(e){return e=e.replace(te,ne),function(t){return (t.textContent||i(t)).indexOf(e)>-1}}),lang:ce(function(e){return J.test(e||"")||le.error("unsupported lang: "+e),e=e.replace(te,ne).toLowerCase(),function(t){var n;do{if(n=g?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return (n=n.toLowerCase())===e||0===n.indexOf(e+"-")}while((t=t.parentNode)&&1===t.nodeType);return !1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:pe(!1),disabled:pe(!0),checked:function(e){var t=e.nodeName.toLowerCase();return "input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return !1;return !0},parent:function(e){return !r.pseudos.empty(e)},header:function(e){return Y.test(e.nodeName)},input:function(e){return W.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return "input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return "input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:he(function(){return [0]}),last:he(function(e,t){return [t-1]}),eq:he(function(e,t,n){return [n<0?n+t:n]}),even:he(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:he(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:he(function(e,t,n){for(var r=n<0?n+t:n>t?t:n;--r>=0;)e.push(r);return e}),gt:he(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=r.pseudos.eq;for(t in {radio:!0,checkbox:!0,file:!0,password:!0,image:!0})r.pseudos[t]=function(e){return function(t){return "input"===t.nodeName.toLowerCase()&&t.type===e}}(t);for(t in {submit:!0,reset:!0})r.pseudos[t]=function(e){return function(t){var n=t.nodeName.toLowerCase();return ("input"===n||"button"===n)&&t.type===e}}(t);function me(){}me.prototype=r.filters=r.pseudos,r.setFilters=new me,u=le.tokenize=function(e,t){var n,i,o,u,l,a,c,s=A[e+" "];if(s)return t?0:s.slice(0);l=e,a=[],c=r.preFilter;while(l){n&&!(i=G.exec(l))||(i&&(l=l.slice(i[0].length)||l),a.push(o=[])),n=!1,(i=U.exec(l))&&(n=i.shift(),o.push({value:n,type:i[0].replace(j," ")}),l=l.slice(n.length));for(u in r.filter)!(i=K[u].exec(l))||c[u]&&!(i=c[u](i))||(n=i.shift(),o.push({value:n,type:u,matches:i}),l=l.slice(n.length));if(!n)break}return t?l.length:l?le.error(e):A(e,a).slice(0)};function ye(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function ve(e,t,n){var r=t.dir,i=t.next,o=i||r,u=n&&"parentNode"===o,l=x++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||u)return e(t,n,i);return !1}:function(t,n,a){var c,s,d,f=[C,l];if(a){while(t=t[r])if((1===t.nodeType||u)&&e(t,n,a))return !0}else while(t=t[r])if(1===t.nodeType||u)if(d=t[b]||(t[b]={}),s=d[t.uniqueID]||(d[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[r]||t;else{if((c=s[o])&&c[0]===C&&c[1]===l)return f[2]=c[2];if(s[o]=f,f[2]=e(t,n,a))return !0}return !1}}function we(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return !1;return !0}:e[0]}function be(e,t,n){for(var r=0,i=t.length;r<i;r++)le(e,t[r],n);return n}function Ne(e,t,n,r,i){for(var o,u=[],l=0,a=e.length,c=null!=t;l<a;l++)(o=e[l])&&(n&&!n(o,r,i)||(u.push(o),c&&t.push(l)));return u}function Ce(e,t,n,r,i,o){return r&&!r[b]&&(r=Ce(r)),i&&!i[b]&&(i=Ce(i,o)),ce(function(o,u,l,a){var c,s,d,f=[],p=[],h=u.length,g=o||be(t||"*",l.nodeType?[l]:l,[]),m=!e||!o&&t?g:Ne(g,f,e,l,a),y=n?i||(o?e:h||r)?[]:u:m;if(n&&n(m,y,l,a),r){c=Ne(y,p),r(c,[],l,a),s=c.length;while(s--)(d=c[s])&&(y[p[s]]=!(m[p[s]]=d));}if(o){if(i||e){if(i){c=[],s=y.length;while(s--)(d=y[s])&&c.push(m[s]=d);i(null,y=[],c,a);}s=y.length;while(s--)(d=y[s])&&(c=i?k(o,d):f[s])>-1&&(o[c]=!(u[c]=d));}}else y=Ne(y===u?y.splice(h,y.length):y),i?i(null,u,y,a):R.apply(u,y);})}function xe(e){for(var t,n,i,o=e.length,u=r.relative[e[0].type],l=u||r.relative[" "],a=u?1:0,s=ve(function(e){return e===t},l,!0),d=ve(function(e){return k(t,e)>-1},l,!0),f=[function(e,n,r){var i=!u&&(r||n!==c)||((t=n).nodeType?s(e,n,r):d(e,n,r));return t=null,i}];a<o;a++)if(n=r.relative[e[a].type])f=[ve(we(f),n)];else{if((n=r.filter[e[a].type].apply(null,e[a].matches))[b]){for(i=++a;i<o;i++)if(r.relative[e[i].type])break;return Ce(a>1&&we(f),a>1&&ye(e.slice(0,a-1).concat({value:" "===e[a-2].type?"*":""})).replace(j,"$1"),n,a<i&&xe(e.slice(a,i)),i<o&&xe(e=e.slice(i)),i<o&&ye(e))}f.push(n);}return we(f)}function Ee(e,t){var n=t.length>0,i=e.length>0,o=function(o,u,l,a,s){var d,h,m,y=0,v="0",w=o&&[],b=[],N=c,x=o||i&&r.find.TAG("*",s),E=C+=null==N?1:Math.random()||.1,A=x.length;for(s&&(c=u==p||u||s);v!==A&&null!=(d=x[v]);v++){if(i&&d){h=0,u||d.ownerDocument==p||(f(d),l=!g);while(m=e[h++])if(m(d,u||p,l)){a.push(d);break}s&&(C=E);}n&&((d=!m&&d)&&y--,o&&w.push(d));}if(y+=v,n&&v!==y){h=0;while(m=t[h++])m(w,b,u,l);if(o){if(y>0)while(v--)w[v]||b[v]||(b[v]=I.call(a));b=Ne(b);}R.apply(a,b),s&&!o&&b.length>0&&y+t.length>1&&le.uniqueSort(a);}return s&&(C=E,c=N),w};return n?ce(o):o}l=le.compile=function(e,t){var n,r=[],i=[],o=S[e+" "];if(!o){t||(t=u(e)),n=t.length;while(n--)(o=xe(t[n]))[b]?r.push(o):i.push(o);(o=S(e,Ee(i,r))).selector=e;}return o},a=le.select=function(e,t,n,i){var o,a,c,s,d,f="function"==typeof e&&e,p=!i&&u(e=f.selector||e);if(n=n||[],1===p.length){if((a=p[0]=p[0].slice(0)).length>2&&"ID"===(c=a[0]).type&&9===t.nodeType&&g&&r.relative[a[1].type]){if(!(t=(r.find.ID(c.matches[0].replace(te,ne),t)||[])[0]))return n;f&&(t=t.parentNode),e=e.slice(a.shift().value.length);}o=K.needsContext.test(e)?0:a.length;while(o--){if(c=a[o],r.relative[s=c.type])break;if((d=r.find[s])&&(i=d(c.matches[0].replace(te,ne),ee.test(a[0].type)&&ge(t.parentNode)||t))){if(a.splice(o,1),!(e=i.length&&ye(a)))return R.apply(n,i),n;break}}}return (f||l(e,p))(i,t,!g,n,!t||ee.test(e)&&ge(t.parentNode)||t),n},n.sortStable=b.split("").sort(T).join("")===b,n.detectDuplicates=!!d,f(),n.sortDetached=se(function(e){return 1&e.compareDocumentPosition(p.createElement("fieldset"))}),se(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||de("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),n.attributes&&se(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||de("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),se(function(e){return null==e.getAttribute("disabled")})||de(H,function(e,t,n){var r;if(!n)return !0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null});var Ae=e.Sizzle;le.noConflict=function(){return e.Sizzle===le&&(e.Sizzle=Ae),le},"function"==typeof define&&define.amd?define(function(){return le}):"undefined"!=typeof module&&module.exports?module.exports=le:e.Sizzle=le;}(window);


return module.exports;
})();

// MODULE: mock-doc/selector.js
function matches(selector, elm) {
  const r = Sizzle.matches(selector, [elm]);
  return r.length > 0;
}
function selectOne(selector, elm) {
  const r = Sizzle(selector, elm);
  return r[0] || null;
}
function selectAll(selector, elm) {
  return Sizzle(selector, elm);
}

// MODULE: mock-doc/class-list.js
class MockClassList {
  constructor(elm) {
    this.elm = elm;
  }
  add(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach(className => {
      className = String(className);
      validateClass(className);
      if (clsNames.includes(className) === false) {
        clsNames.push(className);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, 'class', clsNames.join(' '));
    }
  }
  remove(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach(className => {
      className = String(className);
      validateClass(className);
      const index = clsNames.indexOf(className);
      if (index > -1) {
        clsNames.splice(index, 1);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, 'class', clsNames.filter(c => c.length > 0).join(' '));
    }
  }
  contains(className) {
    className = String(className);
    return getItems(this.elm).includes(className);
  }
  toggle(className) {
    className = String(className);
    if (this.contains(className) === true) {
      this.remove(className);
    }
    else {
      this.add(className);
    }
  }
  get length() {
    return getItems(this.elm).length;
  }
  item(index) {
    return getItems(this.elm)[index];
  }
  toString() {
    return getItems(this.elm).join(' ');
  }
}
function validateClass(className) {
  if (className === '') {
    throw new Error('The token provided must not be empty.');
  }
  if (/\s/.test(className)) {
    throw new Error(`The token provided ('${className}') contains HTML space characters, which are not valid in tokens.`);
  }
}
function getItems(elm) {
  const className = elm.getAttribute('class');
  if (typeof className === 'string' && className.length > 0) {
    return className
      .trim()
      .split(' ')
      .filter(c => c.length > 0);
  }
  return [];
}

// MODULE: mock-doc/css-style-declaration.js
class MockCSSStyleDeclaration {
  constructor() {
    this._styles = new Map();
  }
  setProperty(prop, value) {
    prop = jsCaseToCssCase(prop);
    if (value == null || value === '') {
      this._styles.delete(prop);
    }
    else {
      this._styles.set(prop, String(value));
    }
  }
  getPropertyValue(prop) {
    prop = jsCaseToCssCase(prop);
    return String(this._styles.get(prop) || '');
  }
  removeProperty(prop) {
    prop = jsCaseToCssCase(prop);
    this._styles.delete(prop);
  }
  get length() {
    return this._styles.size;
  }
  get cssText() {
    const cssText = [];
    this._styles.forEach((value, prop) => {
      cssText.push(`${prop}: ${value};`);
    });
    return cssText.join(' ').trim();
  }
  set cssText(cssText) {
    if (cssText == null || cssText === '') {
      this._styles.clear();
      return;
    }
    cssText.split(';').forEach(rule => {
      rule = rule.trim();
      if (rule.length > 0) {
        const splt = rule.split(':');
        if (splt.length > 1) {
          const prop = splt[0].trim();
          const value = splt[1].trim();
          if (prop !== '' && value !== '') {
            this._styles.set(jsCaseToCssCase(prop), value);
          }
        }
      }
    });
  }
}
function createCSSStyleDeclaration() {
  return new Proxy(new MockCSSStyleDeclaration(), cssProxyHandler);
}
const cssProxyHandler = {
  get(cssStyle, prop) {
    if (prop in cssStyle) {
      return cssStyle[prop];
    }
    prop = cssCaseToJsCase(prop);
    return cssStyle.getPropertyValue(prop);
  },
  set(cssStyle, prop, value) {
    if (prop in cssStyle) {
      cssStyle[prop] = value;
    }
    else {
      cssStyle.setProperty(prop, value);
    }
    return true;
  },
};
function cssCaseToJsCase(str) {
  // font-size to fontSize
  if (str.length > 1 && str.includes('-') === true) {
    str = str
      .toLowerCase()
      .split('-')
      .map(segment => segment.charAt(0).toUpperCase() + segment.slice(1))
      .join('');
    str = str.substr(0, 1).toLowerCase() + str.substr(1);
  }
  return str;
}
function jsCaseToCssCase(str) {
  // fontSize to font-size
  if (str.length > 1 && str.includes('-') === false && /[A-Z]/.test(str) === true) {
    str = str
      .replace(/([A-Z])/g, g => ' ' + g[0])
      .trim()
      .replace(/ /g, '-')
      .toLowerCase();
  }
  return str;
}

// MODULE: mock-doc/event.js
class MockEvent {
  constructor(type, eventInitDict) {
    this.bubbles = false;
    this.cancelBubble = false;
    this.cancelable = false;
    this.composed = false;
    this.currentTarget = null;
    this.defaultPrevented = false;
    this.srcElement = null;
    this.target = null;
    if (typeof type !== 'string') {
      throw new Error(`Event type required`);
    }
    this.type = type;
    this.timeStamp = Date.now();
    if (eventInitDict != null) {
      Object.assign(this, eventInitDict);
    }
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
  stopImmediatePropagation() {
    this.cancelBubble = true;
  }
}
class MockCustomEvent extends MockEvent {
  constructor(type, customEventInitDic) {
    super(type);
    this.detail = null;
    if (customEventInitDic != null) {
      Object.assign(this, customEventInitDic);
    }
  }
}
class MockKeyboardEvent extends MockEvent {
  constructor(type, keyboardEventInitDic) {
    super(type);
    this.code = '';
    this.key = '';
    this.altKey = false;
    this.ctrlKey = false;
    this.metaKey = false;
    this.shiftKey = false;
    this.location = 0;
    this.repeat = false;
    if (keyboardEventInitDic != null) {
      Object.assign(this, keyboardEventInitDic);
    }
  }
}
class MockMouseEvent extends MockEvent {
  constructor(type, mouseEventInitDic) {
    super(type);
    this.screenX = 0;
    this.screenY = 0;
    this.clientX = 0;
    this.clientY = 0;
    this.ctrlKey = false;
    this.shiftKey = false;
    this.altKey = false;
    this.metaKey = false;
    this.button = 0;
    this.buttons = 0;
    this.relatedTarget = null;
    if (mouseEventInitDic != null) {
      Object.assign(this, mouseEventInitDic);
    }
  }
}
class MockEventListener {
  constructor(type, handler) {
    this.type = type;
    this.handler = handler;
  }
}
function addEventListener(elm, type, handler) {
  const target = elm;
  if (target.__listeners == null) {
    target.__listeners = [];
  }
  target.__listeners.push(new MockEventListener(type, handler));
}
function removeEventListener(elm, type, handler) {
  const target = elm;
  if (target != null && Array.isArray(target.__listeners) === true) {
    const elmListener = target.__listeners.find(e => e.type === type && e.handler === handler);
    if (elmListener != null) {
      const index = target.__listeners.indexOf(elmListener);
      target.__listeners.splice(index, 1);
    }
  }
}
function resetEventListeners(target) {
  if (target != null && target.__listeners != null) {
    target.__listeners = null;
  }
}
function triggerEventListener(elm, ev) {
  if (elm == null || ev.cancelBubble === true) {
    return;
  }
  const target = elm;
  ev.currentTarget = elm;
  if (Array.isArray(target.__listeners) === true) {
    const listeners = target.__listeners.filter(e => e.type === ev.type);
    listeners.forEach(listener => {
      try {
        listener.handler.call(target, ev);
      }
      catch (err) {
        console.error(err);
      }
    });
  }
  if (ev.bubbles === false) {
    return;
  }
  if (elm.nodeName === "#document" /* DOCUMENT_NODE */) {
    triggerEventListener(elm.defaultView, ev);
  }
  else {
    triggerEventListener(elm.parentElement, ev);
  }
}
function dispatchEvent(currentTarget, ev) {
  ev.target = currentTarget;
  triggerEventListener(currentTarget, ev);
  return true;
}

// MODULE: mock-doc/serialize-node.js
function serializeNodeToHtml(elm, opts = {}) {
  const output = {
    currentLineWidth: 0,
    indent: 0,
    isWithinBody: false,
    text: [],
  };
  if (opts.prettyHtml) {
    if (typeof opts.indentSpaces !== 'number') {
      opts.indentSpaces = 2;
    }
    if (typeof opts.newLines !== 'boolean') {
      opts.newLines = true;
    }
    opts.approximateLineWidth = -1;
  }
  else {
    opts.prettyHtml = false;
    if (typeof opts.newLines !== 'boolean') {
      opts.newLines = false;
    }
    if (typeof opts.indentSpaces !== 'number') {
      opts.indentSpaces = 0;
    }
  }
  if (typeof opts.approximateLineWidth !== 'number') {
    opts.approximateLineWidth = -1;
  }
  if (typeof opts.removeEmptyAttributes !== 'boolean') {
    opts.removeEmptyAttributes = true;
  }
  if (typeof opts.removeAttributeQuotes !== 'boolean') {
    opts.removeAttributeQuotes = false;
  }
  if (typeof opts.removeBooleanAttributeQuotes !== 'boolean') {
    opts.removeBooleanAttributeQuotes = false;
  }
  if (typeof opts.removeHtmlComments !== 'boolean') {
    opts.removeHtmlComments = false;
  }
  if (typeof opts.serializeShadowRoot !== 'boolean') {
    opts.serializeShadowRoot = false;
  }
  if (opts.outerHtml) {
    serializeToHtml(elm, opts, output, false);
  }
  else {
    for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
      serializeToHtml(elm.childNodes[i], opts, output, false);
    }
  }
  if (output.text[0] === '\n') {
    output.text.shift();
  }
  if (output.text[output.text.length - 1] === '\n') {
    output.text.pop();
  }
  return output.text.join('');
}
function serializeToHtml(node, opts, output, isShadowRoot) {
  if (node.nodeType === 1 /* ELEMENT_NODE */ || isShadowRoot) {
    const tagName = isShadowRoot ? 'mock:shadow-root' : getTagName(node);
    if (tagName === 'body') {
      output.isWithinBody = true;
    }
    const ignoreTag = opts.excludeTags != null && opts.excludeTags.includes(tagName);
    if (ignoreTag === false) {
      if (opts.newLines) {
        output.text.push('\n');
        output.currentLineWidth = 0;
      }
      if (opts.indentSpaces > 0) {
        for (let i = 0; i < output.indent; i++) {
          output.text.push(' ');
        }
        output.currentLineWidth += output.indent;
      }
      output.text.push('<' + tagName);
      output.currentLineWidth += tagName.length + 1;
      const attrsLength = node.attributes.length;
      const attributes = opts.prettyHtml && attrsLength > 1 ? cloneAttributes(node.attributes, true) : node.attributes;
      for (let i = 0; i < attrsLength; i++) {
        const attr = attributes.item(i);
        const attrName = attr.name;
        if (attrName === 'style') {
          continue;
        }
        let attrValue = attr.value;
        if (opts.removeEmptyAttributes && attrValue === '' && REMOVE_EMPTY_ATTR.has(attrName)) {
          continue;
        }
        const attrNamespaceURI = attr.namespaceURI;
        if (attrNamespaceURI == null) {
          output.currentLineWidth += attrName.length + 1;
          if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            output.text.push('\n' + attrName);
            output.currentLineWidth = 0;
          }
          else {
            output.text.push(' ' + attrName);
          }
        }
        else if (attrNamespaceURI === 'http://www.w3.org/XML/1998/namespace') {
          output.text.push(' xml:' + attrName);
          output.currentLineWidth += attrName.length + 5;
        }
        else if (attrNamespaceURI === 'http://www.w3.org/2000/xmlns/') {
          if (attrName !== 'xmlns') {
            output.text.push(' xmlns:' + attrName);
            output.currentLineWidth += attrName.length + 7;
          }
          else {
            output.text.push(' ' + attrName);
            output.currentLineWidth += attrName.length + 1;
          }
        }
        else if (attrNamespaceURI === XLINK_NS) {
          output.text.push(' xlink:' + attrName);
          output.currentLineWidth += attrName.length + 7;
        }
        else {
          output.text.push(' ' + attrNamespaceURI + ':' + attrName);
          output.currentLineWidth += attrNamespaceURI.length + attrName.length + 2;
        }
        if (opts.prettyHtml && attrName === 'class') {
          attrValue = attr.value = attrValue
            .split(' ')
            .filter(t => t !== '')
            .sort()
            .join(' ')
            .trim();
        }
        if (attrValue === '') {
          if (opts.removeBooleanAttributeQuotes && BOOLEAN_ATTR.has(attrName)) {
            continue;
          }
          if (opts.removeEmptyAttributes && attrName.startsWith('data-')) {
            continue;
          }
        }
        if (opts.removeAttributeQuotes && CAN_REMOVE_ATTR_QUOTES.test(attrValue)) {
          output.text.push('=' + escapeString(attrValue, true));
          output.currentLineWidth += attrValue.length + 1;
        }
        else {
          output.text.push('="' + escapeString(attrValue, true) + '"');
          output.currentLineWidth += attrValue.length + 3;
        }
      }
      if (node.hasAttribute('style')) {
        const cssText = node.style.cssText;
        if (opts.approximateLineWidth > 0 && output.currentLineWidth + cssText.length + 10 > opts.approximateLineWidth) {
          output.text.push(`\nstyle="${cssText}">`);
          output.currentLineWidth = 0;
        }
        else {
          output.text.push(` style="${cssText}">`);
          output.currentLineWidth += cssText.length + 10;
        }
      }
      else {
        output.text.push('>');
        output.currentLineWidth += 1;
      }
    }
    if (EMPTY_ELEMENTS.has(tagName) === false) {
      if (opts.serializeShadowRoot && node.shadowRoot != null) {
        output.indent = output.indent + opts.indentSpaces;
        serializeToHtml(node.shadowRoot, opts, output, true);
        output.indent = output.indent - opts.indentSpaces;
        if (opts.newLines &&
          (node.childNodes.length === 0 || (node.childNodes.length === 1 && node.childNodes[0].nodeType === 3 /* TEXT_NODE */ && node.childNodes[0].nodeValue.trim() === ''))) {
          output.text.push('\n');
          output.currentLineWidth = 0;
          for (let i = 0; i < output.indent; i++) {
            output.text.push(' ');
          }
          output.currentLineWidth += output.indent;
        }
      }
      if (opts.excludeTagContent == null || opts.excludeTagContent.includes(tagName) === false) {
        const childNodes = tagName === 'template' ? node.content.childNodes : node.childNodes;
        const childNodeLength = childNodes.length;
        if (childNodeLength > 0) {
          if (childNodeLength === 1 && childNodes[0].nodeType === 3 /* TEXT_NODE */ && (typeof childNodes[0].nodeValue !== 'string' || childNodes[0].nodeValue.trim() === '')) ;
          else {
            if (opts.indentSpaces > 0 && ignoreTag === false) {
              output.indent = output.indent + opts.indentSpaces;
            }
            for (let i = 0; i < childNodeLength; i++) {
              serializeToHtml(childNodes[i], opts, output, false);
            }
            if (ignoreTag === false) {
              if (opts.newLines) {
                output.text.push('\n');
                output.currentLineWidth = 0;
              }
              if (opts.indentSpaces > 0) {
                output.indent = output.indent - opts.indentSpaces;
                for (let i = 0; i < output.indent; i++) {
                  output.text.push(' ');
                }
                output.currentLineWidth += output.indent;
              }
            }
          }
        }
        if (ignoreTag === false) {
          output.text.push('</' + tagName + '>');
          output.currentLineWidth += tagName.length + 3;
        }
      }
    }
    if (opts.approximateLineWidth > 0 && STRUCTURE_ELEMENTS.has(tagName)) {
      output.text.push('\n');
      output.currentLineWidth = 0;
    }
    if (tagName === 'body') {
      output.isWithinBody = false;
    }
  }
  else if (node.nodeType === 3 /* TEXT_NODE */) {
    let textContent = node.nodeValue;
    if (typeof textContent === 'string') {
      const trimmedTextContent = textContent.trim();
      if (trimmedTextContent === '') {
        // this text node is whitespace only
        if (isWithinWhitespaceSensitive(node)) {
          // whitespace matters within this element
          // just add the exact text we were given
          output.text.push(textContent);
          output.currentLineWidth += textContent.length;
        }
        else if (opts.approximateLineWidth > 0 && !output.isWithinBody) ;
        else if (!opts.prettyHtml) {
          // this text node is only whitespace, and it's not
          // within a whitespace sensitive element like <pre> or <code>
          // so replace the entire white space with a single new line
          output.currentLineWidth += 1;
          if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            // good enough for a new line
            // for perf these are all just estimates
            // we don't care to ensure exact line lengths
            output.text.push('\n');
            output.currentLineWidth = 0;
          }
          else {
            // let's keep it all on the same line yet
            output.text.push(' ');
          }
        }
      }
      else {
        // this text node has text content
        if (opts.newLines) {
          output.text.push('\n');
          output.currentLineWidth = 0;
        }
        if (opts.indentSpaces > 0) {
          for (let i = 0; i < output.indent; i++) {
            output.text.push(' ');
          }
          output.currentLineWidth += output.indent;
        }
        let textContentLength = textContent.length;
        if (textContentLength > 0) {
          // this text node has text content
          const parentTagName = node.parentNode != null && node.parentNode.nodeType === 1 /* ELEMENT_NODE */ ? node.parentNode.nodeName : null;
          if (NON_ESCAPABLE_CONTENT.has(parentTagName)) {
            // this text node cannot have its content escaped since it's going
            // into an element like <style> or <script>
            if (isWithinWhitespaceSensitive(node)) {
              output.text.push(textContent);
            }
            else {
              output.text.push(trimmedTextContent);
              textContentLength = trimmedTextContent.length;
            }
            output.currentLineWidth += textContentLength;
          }
          else {
            // this text node is going into a normal element and html can be escaped
            if (opts.prettyHtml) {
              // pretty print the text node
              output.text.push(escapeString(textContent.replace(/\s\s+/g, ' ').trim(), false));
              output.currentLineWidth += textContentLength;
            }
            else {
              // not pretty printing the text node
              if (isWithinWhitespaceSensitive(node)) {
                output.currentLineWidth += textContentLength;
              }
              else {
                // this element is not a whitespace sensitive one, like <pre> or <code> so
                // any whitespace at the start and end can be cleaned up to just be one space
                if (/\s/.test(textContent.charAt(0))) {
                  textContent = ' ' + textContent.trimLeft();
                }
                textContentLength = textContent.length;
                if (textContentLength > 1) {
                  if (/\s/.test(textContent.charAt(textContentLength - 1))) {
                    if (opts.approximateLineWidth > 0 && output.currentLineWidth + textContentLength > opts.approximateLineWidth) {
                      textContent = textContent.trimRight() + '\n';
                      output.currentLineWidth = 0;
                    }
                    else {
                      textContent = textContent.trimRight() + ' ';
                    }
                  }
                }
                output.currentLineWidth += textContentLength;
              }
              output.text.push(escapeString(textContent, false));
            }
          }
        }
      }
    }
  }
  else if (node.nodeType === 8 /* COMMENT_NODE */) {
    const nodeValue = node.nodeValue;
    if (opts.removeHtmlComments) {
      const isHydrateAnnotation = nodeValue.startsWith(CONTENT_REF_ID + '.') ||
        nodeValue.startsWith(ORG_LOCATION_ID + '.') ||
        nodeValue.startsWith(SLOT_NODE_ID + '.') ||
        nodeValue.startsWith(TEXT_NODE_ID + '.');
      if (!isHydrateAnnotation) {
        return;
      }
    }
    if (opts.newLines) {
      output.text.push('\n');
      output.currentLineWidth = 0;
    }
    if (opts.indentSpaces > 0) {
      for (let i = 0; i < output.indent; i++) {
        output.text.push(' ');
      }
      output.currentLineWidth += output.indent;
    }
    output.text.push('<!--' + nodeValue + '-->');
    output.currentLineWidth += nodeValue.length + 7;
  }
  else if (node.nodeType === 10 /* DOCUMENT_TYPE_NODE */) {
    output.text.push('<!doctype html>');
  }
}
const AMP_REGEX = /&/g;
const NBSP_REGEX = /\u00a0/g;
const DOUBLE_QUOTE_REGEX = /"/g;
const LT_REGEX = /</g;
const GT_REGEX = />/g;
const CAN_REMOVE_ATTR_QUOTES = /^[^ \t\n\f\r"'`=<>\/\\-]+$/;
function getTagName(element) {
  if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
    return element.nodeName.toLowerCase();
  }
  else {
    return element.nodeName;
  }
}
function escapeString(str, attrMode) {
  str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');
  if (attrMode) {
    return str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
  }
  return str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
}
function isWithinWhitespaceSensitive(node) {
  while (node != null) {
    if (WHITESPACE_SENSITIVE.has(node.nodeName)) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
/*@__PURE__*/ const NON_ESCAPABLE_CONTENT = new Set(['STYLE', 'SCRIPT', 'IFRAME', 'NOSCRIPT', 'XMP', 'NOEMBED', 'NOFRAMES', 'PLAINTEXT']);
/*@__PURE__*/ const WHITESPACE_SENSITIVE = new Set(['CODE', 'OUTPUT', 'PLAINTEXT', 'PRE', 'TEMPLATE', 'TEXTAREA']);
/*@__PURE__*/ const EMPTY_ELEMENTS = new Set([
  'area',
  'base',
  'basefont',
  'bgsound',
  'br',
  'col',
  'embed',
  'frame',
  'hr',
  'img',
  'input',
  'keygen',
  'link',
  'meta',
  'param',
  'source',
  'trace',
  'wbr',
]);
/*@__PURE__*/ const REMOVE_EMPTY_ATTR = new Set(['class', 'dir', 'id', 'lang', 'name', 'title']);
/*@__PURE__*/ const BOOLEAN_ATTR = new Set([
  'allowfullscreen',
  'async',
  'autofocus',
  'autoplay',
  'checked',
  'compact',
  'controls',
  'declare',
  'default',
  'defaultchecked',
  'defaultmuted',
  'defaultselected',
  'defer',
  'disabled',
  'enabled',
  'formnovalidate',
  'hidden',
  'indeterminate',
  'inert',
  'ismap',
  'itemscope',
  'loop',
  'multiple',
  'muted',
  'nohref',
  'nomodule',
  'noresize',
  'noshade',
  'novalidate',
  'nowrap',
  'open',
  'pauseonexit',
  'readonly',
  'required',
  'reversed',
  'scoped',
  'seamless',
  'selected',
  'sortable',
  'truespeed',
  'typemustmatch',
  'visible',
]);
/*@__PURE__*/ const STRUCTURE_ELEMENTS = new Set(['html', 'body', 'head', 'iframe', 'meta', 'link', 'base', 'title', 'script', 'style']);

// MODULE: ../parse5
const parse5=/*@__PURE__*/function(e){const t=[65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];var n="�",s={EOF:-1,NULL:0,TABULATION:9,CARRIAGE_RETURN:13,LINE_FEED:10,FORM_FEED:12,SPACE:32,EXCLAMATION_MARK:33,QUOTATION_MARK:34,NUMBER_SIGN:35,AMPERSAND:38,APOSTROPHE:39,HYPHEN_MINUS:45,SOLIDUS:47,DIGIT_0:48,DIGIT_9:57,SEMICOLON:59,LESS_THAN_SIGN:60,EQUALS_SIGN:61,GREATER_THAN_SIGN:62,QUESTION_MARK:63,LATIN_CAPITAL_A:65,LATIN_CAPITAL_F:70,LATIN_CAPITAL_X:88,LATIN_CAPITAL_Z:90,RIGHT_SQUARE_BRACKET:93,GRAVE_ACCENT:96,LATIN_SMALL_A:97,LATIN_SMALL_F:102,LATIN_SMALL_X:120,LATIN_SMALL_Z:122,REPLACEMENT_CHARACTER:65533},r={DASH_DASH_STRING:[45,45],DOCTYPE_STRING:[68,79,67,84,89,80,69],CDATA_START_STRING:[91,67,68,65,84,65,91],SCRIPT_STRING:[115,99,114,105,112,116],PUBLIC_STRING:[80,85,66,76,73,67],SYSTEM_STRING:[83,89,83,84,69,77]},i=function(e){return e>=55296&&e<=57343},T=function(e){return e>=56320&&e<=57343},o=function(e,t){return 1024*(e-55296)+9216+t},E=function(e){return 32!==e&&10!==e&&13!==e&&9!==e&&12!==e&&e>=1&&e<=31||e>=127&&e<=159},a=function(e){return e>=64976&&e<=65007||t.indexOf(e)>-1},_="control-character-in-input-stream",A="noncharacter-in-input-stream",h="surrogate-in-input-stream",c="non-void-html-element-start-tag-with-trailing-solidus",l="end-tag-with-attributes",m="end-tag-with-trailing-solidus",p="unexpected-solidus-in-tag",N="unexpected-null-character",u="unexpected-question-mark-instead-of-tag-name",O="invalid-first-character-of-tag-name",S="unexpected-equals-sign-before-attribute-name",C="missing-end-tag-name",d="unexpected-character-in-attribute-name",R="unknown-named-character-reference",I="missing-semicolon-after-character-reference",f="unexpected-character-after-doctype-system-identifier",M="unexpected-character-in-unquoted-attribute-value",L="eof-before-tag-name",D="eof-in-tag",g="missing-attribute-value",P="missing-whitespace-between-attributes",k="missing-whitespace-after-doctype-public-keyword",H="missing-whitespace-between-doctype-public-and-system-identifiers",U="missing-whitespace-after-doctype-system-keyword",F="missing-quote-before-doctype-public-identifier",B="missing-quote-before-doctype-system-identifier",G="missing-doctype-public-identifier",K="missing-doctype-system-identifier",b="abrupt-doctype-public-identifier",Y="abrupt-doctype-system-identifier",x="cdata-in-html-content",y="incorrectly-opened-comment",v="eof-in-script-html-comment-like-text",w="eof-in-doctype",Q="nested-comment",X="abrupt-closing-of-empty-comment",W="eof-in-comment",V="incorrectly-closed-comment",j="eof-in-cdata",z="absence-of-digits-in-numeric-character-reference",q="null-character-reference",J="surrogate-character-reference",Z="character-reference-outside-unicode-range",$="control-character-reference",ee="noncharacter-character-reference",te="missing-whitespace-before-doctype-name",ne="missing-doctype-name",se="invalid-character-sequence-after-doctype-name",re="duplicate-attribute",ie="non-conforming-doctype",Te="missing-doctype",oe="misplaced-doctype",Ee="end-tag-without-matching-open-element",ae="closing-of-element-with-open-child-elements",_e="disallowed-content-in-noscript-in-head",Ae="open-elements-left-after-eof",he="abandoned-head-element-child",ce="misplaced-start-tag-for-head-element",le="nested-noscript-in-head",me="eof-in-element-that-can-contain-only-text";const pe=s;var Ne=class{constructor(){this.html=null,this.pos=-1,this.lastGapPos=-1,this.lastCharPos=-1,this.gapStack=[],this.skipNextNewLine=!1,this.lastChunkWritten=!1,this.endOfChunkHit=!1,this.bufferWaterline=65536;}_err(){}_addGap(){this.gapStack.push(this.lastGapPos),this.lastGapPos=this.pos;}_processSurrogate(e){if(this.pos!==this.lastCharPos){const t=this.html.charCodeAt(this.pos+1);if(T(t))return this.pos++,this._addGap(),o(e,t)}else if(!this.lastChunkWritten)return this.endOfChunkHit=!0,pe.EOF;return this._err(h),e}dropParsedChunk(){this.pos>this.bufferWaterline&&(this.lastCharPos-=this.pos,this.html=this.html.substring(this.pos),this.pos=0,this.lastGapPos=-1,this.gapStack=[]);}write(e,t){this.html?this.html+=e:this.html=e,this.lastCharPos=this.html.length-1,this.endOfChunkHit=!1,this.lastChunkWritten=t;}insertHtmlAtCurrentPos(e){this.html=this.html.substring(0,this.pos+1)+e+this.html.substring(this.pos+1,this.html.length),this.lastCharPos=this.html.length-1,this.endOfChunkHit=!1;}advance(){if(this.pos++,this.pos>this.lastCharPos)return this.endOfChunkHit=!this.lastChunkWritten,pe.EOF;let e=this.html.charCodeAt(this.pos);if(this.skipNextNewLine&&e===pe.LINE_FEED)return this.skipNextNewLine=!1,this._addGap(),this.advance();if(e===pe.CARRIAGE_RETURN)return this.skipNextNewLine=!0,pe.LINE_FEED;return this.skipNextNewLine=!1,i(e)&&(e=this._processSurrogate(e)),e>31&&e<127||e===pe.LINE_FEED||e===pe.CARRIAGE_RETURN||e>159&&e<64976||this._checkForProblematicCharacters(e),e}_checkForProblematicCharacters(e){E(e)?this._err(_):a(e)&&this._err(A);}retreat(){this.pos===this.lastGapPos&&(this.lastGapPos=this.gapStack.pop(),this.pos--),this.pos--;}},ue=new Uint16Array([4,52,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,106,303,412,810,1432,1701,1796,1987,2114,2360,2420,2484,3170,3251,4140,4393,4575,4610,5106,5512,5728,6117,6274,6315,6345,6427,6516,7002,7910,8733,9323,9870,10170,10631,10893,11318,11386,11467,12773,13092,14474,14922,15448,15542,16419,17666,18166,18611,19004,19095,19298,19397,4,16,69,77,97,98,99,102,103,108,109,110,111,112,114,115,116,117,140,150,158,169,176,194,199,210,216,222,226,242,256,266,283,294,108,105,103,5,198,1,59,148,1,198,80,5,38,1,59,156,1,38,99,117,116,101,5,193,1,59,167,1,193,114,101,118,101,59,1,258,4,2,105,121,182,191,114,99,5,194,1,59,189,1,194,59,1,1040,114,59,3,55349,56580,114,97,118,101,5,192,1,59,208,1,192,112,104,97,59,1,913,97,99,114,59,1,256,100,59,1,10835,4,2,103,112,232,237,111,110,59,1,260,102,59,3,55349,56632,112,108,121,70,117,110,99,116,105,111,110,59,1,8289,105,110,103,5,197,1,59,264,1,197,4,2,99,115,272,277,114,59,3,55349,56476,105,103,110,59,1,8788,105,108,100,101,5,195,1,59,292,1,195,109,108,5,196,1,59,301,1,196,4,8,97,99,101,102,111,114,115,117,321,350,354,383,388,394,400,405,4,2,99,114,327,336,107,115,108,97,115,104,59,1,8726,4,2,118,119,342,345,59,1,10983,101,100,59,1,8966,121,59,1,1041,4,3,99,114,116,362,369,379,97,117,115,101,59,1,8757,110,111,117,108,108,105,115,59,1,8492,97,59,1,914,114,59,3,55349,56581,112,102,59,3,55349,56633,101,118,101,59,1,728,99,114,59,1,8492,109,112,101,113,59,1,8782,4,14,72,79,97,99,100,101,102,104,105,108,111,114,115,117,442,447,456,504,542,547,569,573,577,616,678,784,790,796,99,121,59,1,1063,80,89,5,169,1,59,454,1,169,4,3,99,112,121,464,470,497,117,116,101,59,1,262,4,2,59,105,476,478,1,8914,116,97,108,68,105,102,102,101,114,101,110,116,105,97,108,68,59,1,8517,108,101,121,115,59,1,8493,4,4,97,101,105,111,514,520,530,535,114,111,110,59,1,268,100,105,108,5,199,1,59,528,1,199,114,99,59,1,264,110,105,110,116,59,1,8752,111,116,59,1,266,4,2,100,110,553,560,105,108,108,97,59,1,184,116,101,114,68,111,116,59,1,183,114,59,1,8493,105,59,1,935,114,99,108,101,4,4,68,77,80,84,591,596,603,609,111,116,59,1,8857,105,110,117,115,59,1,8854,108,117,115,59,1,8853,105,109,101,115,59,1,8855,111,4,2,99,115,623,646,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8754,101,67,117,114,108,121,4,2,68,81,658,671,111,117,98,108,101,81,117,111,116,101,59,1,8221,117,111,116,101,59,1,8217,4,4,108,110,112,117,688,701,736,753,111,110,4,2,59,101,696,698,1,8759,59,1,10868,4,3,103,105,116,709,717,722,114,117,101,110,116,59,1,8801,110,116,59,1,8751,111,117,114,73,110,116,101,103,114,97,108,59,1,8750,4,2,102,114,742,745,59,1,8450,111,100,117,99,116,59,1,8720,110,116,101,114,67,108,111,99,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8755,111,115,115,59,1,10799,99,114,59,3,55349,56478,112,4,2,59,67,803,805,1,8915,97,112,59,1,8781,4,11,68,74,83,90,97,99,101,102,105,111,115,834,850,855,860,865,888,903,916,921,1011,1415,4,2,59,111,840,842,1,8517,116,114,97,104,100,59,1,10513,99,121,59,1,1026,99,121,59,1,1029,99,121,59,1,1039,4,3,103,114,115,873,879,883,103,101,114,59,1,8225,114,59,1,8609,104,118,59,1,10980,4,2,97,121,894,900,114,111,110,59,1,270,59,1,1044,108,4,2,59,116,910,912,1,8711,97,59,1,916,114,59,3,55349,56583,4,2,97,102,927,998,4,2,99,109,933,992,114,105,116,105,99,97,108,4,4,65,68,71,84,950,957,978,985,99,117,116,101,59,1,180,111,4,2,116,117,964,967,59,1,729,98,108,101,65,99,117,116,101,59,1,733,114,97,118,101,59,1,96,105,108,100,101,59,1,732,111,110,100,59,1,8900,102,101,114,101,110,116,105,97,108,68,59,1,8518,4,4,112,116,117,119,1021,1026,1048,1249,102,59,3,55349,56635,4,3,59,68,69,1034,1036,1041,1,168,111,116,59,1,8412,113,117,97,108,59,1,8784,98,108,101,4,6,67,68,76,82,85,86,1065,1082,1101,1189,1211,1236,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8751,111,4,2,116,119,1089,1092,59,1,168,110,65,114,114,111,119,59,1,8659,4,2,101,111,1107,1141,102,116,4,3,65,82,84,1117,1124,1136,114,114,111,119,59,1,8656,105,103,104,116,65,114,114,111,119,59,1,8660,101,101,59,1,10980,110,103,4,2,76,82,1149,1177,101,102,116,4,2,65,82,1158,1165,114,114,111,119,59,1,10232,105,103,104,116,65,114,114,111,119,59,1,10234,105,103,104,116,65,114,114,111,119,59,1,10233,105,103,104,116,4,2,65,84,1199,1206,114,114,111,119,59,1,8658,101,101,59,1,8872,112,4,2,65,68,1218,1225,114,114,111,119,59,1,8657,111,119,110,65,114,114,111,119,59,1,8661,101,114,116,105,99,97,108,66,97,114,59,1,8741,110,4,6,65,66,76,82,84,97,1264,1292,1299,1352,1391,1408,114,114,111,119,4,3,59,66,85,1276,1278,1283,1,8595,97,114,59,1,10515,112,65,114,114,111,119,59,1,8693,114,101,118,101,59,1,785,101,102,116,4,3,82,84,86,1310,1323,1334,105,103,104,116,86,101,99,116,111,114,59,1,10576,101,101,86,101,99,116,111,114,59,1,10590,101,99,116,111,114,4,2,59,66,1345,1347,1,8637,97,114,59,1,10582,105,103,104,116,4,2,84,86,1362,1373,101,101,86,101,99,116,111,114,59,1,10591,101,99,116,111,114,4,2,59,66,1384,1386,1,8641,97,114,59,1,10583,101,101,4,2,59,65,1399,1401,1,8868,114,114,111,119,59,1,8615,114,114,111,119,59,1,8659,4,2,99,116,1421,1426,114,59,3,55349,56479,114,111,107,59,1,272,4,16,78,84,97,99,100,102,103,108,109,111,112,113,115,116,117,120,1466,1470,1478,1489,1515,1520,1525,1536,1544,1593,1609,1617,1650,1664,1668,1677,71,59,1,330,72,5,208,1,59,1476,1,208,99,117,116,101,5,201,1,59,1487,1,201,4,3,97,105,121,1497,1503,1512,114,111,110,59,1,282,114,99,5,202,1,59,1510,1,202,59,1,1069,111,116,59,1,278,114,59,3,55349,56584,114,97,118,101,5,200,1,59,1534,1,200,101,109,101,110,116,59,1,8712,4,2,97,112,1550,1555,99,114,59,1,274,116,121,4,2,83,86,1563,1576,109,97,108,108,83,113,117,97,114,101,59,1,9723,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9643,4,2,103,112,1599,1604,111,110,59,1,280,102,59,3,55349,56636,115,105,108,111,110,59,1,917,117,4,2,97,105,1624,1640,108,4,2,59,84,1631,1633,1,10869,105,108,100,101,59,1,8770,108,105,98,114,105,117,109,59,1,8652,4,2,99,105,1656,1660,114,59,1,8496,109,59,1,10867,97,59,1,919,109,108,5,203,1,59,1675,1,203,4,2,105,112,1683,1689,115,116,115,59,1,8707,111,110,101,110,116,105,97,108,69,59,1,8519,4,5,99,102,105,111,115,1713,1717,1722,1762,1791,121,59,1,1060,114,59,3,55349,56585,108,108,101,100,4,2,83,86,1732,1745,109,97,108,108,83,113,117,97,114,101,59,1,9724,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9642,4,3,112,114,117,1770,1775,1781,102,59,3,55349,56637,65,108,108,59,1,8704,114,105,101,114,116,114,102,59,1,8497,99,114,59,1,8497,4,12,74,84,97,98,99,100,102,103,111,114,115,116,1822,1827,1834,1848,1855,1877,1882,1887,1890,1896,1978,1984,99,121,59,1,1027,5,62,1,59,1832,1,62,109,109,97,4,2,59,100,1843,1845,1,915,59,1,988,114,101,118,101,59,1,286,4,3,101,105,121,1863,1869,1874,100,105,108,59,1,290,114,99,59,1,284,59,1,1043,111,116,59,1,288,114,59,3,55349,56586,59,1,8921,112,102,59,3,55349,56638,101,97,116,101,114,4,6,69,70,71,76,83,84,1915,1933,1944,1953,1959,1971,113,117,97,108,4,2,59,76,1925,1927,1,8805,101,115,115,59,1,8923,117,108,108,69,113,117,97,108,59,1,8807,114,101,97,116,101,114,59,1,10914,101,115,115,59,1,8823,108,97,110,116,69,113,117,97,108,59,1,10878,105,108,100,101,59,1,8819,99,114,59,3,55349,56482,59,1,8811,4,8,65,97,99,102,105,111,115,117,2005,2012,2026,2032,2036,2049,2073,2089,82,68,99,121,59,1,1066,4,2,99,116,2018,2023,101,107,59,1,711,59,1,94,105,114,99,59,1,292,114,59,1,8460,108,98,101,114,116,83,112,97,99,101,59,1,8459,4,2,112,114,2055,2059,102,59,1,8461,105,122,111,110,116,97,108,76,105,110,101,59,1,9472,4,2,99,116,2079,2083,114,59,1,8459,114,111,107,59,1,294,109,112,4,2,68,69,2097,2107,111,119,110,72,117,109,112,59,1,8782,113,117,97,108,59,1,8783,4,14,69,74,79,97,99,100,102,103,109,110,111,115,116,117,2144,2149,2155,2160,2171,2189,2194,2198,2209,2245,2307,2329,2334,2341,99,121,59,1,1045,108,105,103,59,1,306,99,121,59,1,1025,99,117,116,101,5,205,1,59,2169,1,205,4,2,105,121,2177,2186,114,99,5,206,1,59,2184,1,206,59,1,1048,111,116,59,1,304,114,59,1,8465,114,97,118,101,5,204,1,59,2207,1,204,4,3,59,97,112,2217,2219,2238,1,8465,4,2,99,103,2225,2229,114,59,1,298,105,110,97,114,121,73,59,1,8520,108,105,101,115,59,1,8658,4,2,116,118,2251,2281,4,2,59,101,2257,2259,1,8748,4,2,103,114,2265,2271,114,97,108,59,1,8747,115,101,99,116,105,111,110,59,1,8898,105,115,105,98,108,101,4,2,67,84,2293,2300,111,109,109,97,59,1,8291,105,109,101,115,59,1,8290,4,3,103,112,116,2315,2320,2325,111,110,59,1,302,102,59,3,55349,56640,97,59,1,921,99,114,59,1,8464,105,108,100,101,59,1,296,4,2,107,109,2347,2352,99,121,59,1,1030,108,5,207,1,59,2358,1,207,4,5,99,102,111,115,117,2372,2386,2391,2397,2414,4,2,105,121,2378,2383,114,99,59,1,308,59,1,1049,114,59,3,55349,56589,112,102,59,3,55349,56641,4,2,99,101,2403,2408,114,59,3,55349,56485,114,99,121,59,1,1032,107,99,121,59,1,1028,4,7,72,74,97,99,102,111,115,2436,2441,2446,2452,2467,2472,2478,99,121,59,1,1061,99,121,59,1,1036,112,112,97,59,1,922,4,2,101,121,2458,2464,100,105,108,59,1,310,59,1,1050,114,59,3,55349,56590,112,102,59,3,55349,56642,99,114,59,3,55349,56486,4,11,74,84,97,99,101,102,108,109,111,115,116,2508,2513,2520,2562,2585,2981,2986,3004,3011,3146,3167,99,121,59,1,1033,5,60,1,59,2518,1,60,4,5,99,109,110,112,114,2532,2538,2544,2548,2558,117,116,101,59,1,313,98,100,97,59,1,923,103,59,1,10218,108,97,99,101,116,114,102,59,1,8466,114,59,1,8606,4,3,97,101,121,2570,2576,2582,114,111,110,59,1,317,100,105,108,59,1,315,59,1,1051,4,2,102,115,2591,2907,116,4,10,65,67,68,70,82,84,85,86,97,114,2614,2663,2672,2728,2735,2760,2820,2870,2888,2895,4,2,110,114,2620,2633,103,108,101,66,114,97,99,107,101,116,59,1,10216,114,111,119,4,3,59,66,82,2644,2646,2651,1,8592,97,114,59,1,8676,105,103,104,116,65,114,114,111,119,59,1,8646,101,105,108,105,110,103,59,1,8968,111,4,2,117,119,2679,2692,98,108,101,66,114,97,99,107,101,116,59,1,10214,110,4,2,84,86,2699,2710,101,101,86,101,99,116,111,114,59,1,10593,101,99,116,111,114,4,2,59,66,2721,2723,1,8643,97,114,59,1,10585,108,111,111,114,59,1,8970,105,103,104,116,4,2,65,86,2745,2752,114,114,111,119,59,1,8596,101,99,116,111,114,59,1,10574,4,2,101,114,2766,2792,101,4,3,59,65,86,2775,2777,2784,1,8867,114,114,111,119,59,1,8612,101,99,116,111,114,59,1,10586,105,97,110,103,108,101,4,3,59,66,69,2806,2808,2813,1,8882,97,114,59,1,10703,113,117,97,108,59,1,8884,112,4,3,68,84,86,2829,2841,2852,111,119,110,86,101,99,116,111,114,59,1,10577,101,101,86,101,99,116,111,114,59,1,10592,101,99,116,111,114,4,2,59,66,2863,2865,1,8639,97,114,59,1,10584,101,99,116,111,114,4,2,59,66,2881,2883,1,8636,97,114,59,1,10578,114,114,111,119,59,1,8656,105,103,104,116,97,114,114,111,119,59,1,8660,115,4,6,69,70,71,76,83,84,2922,2936,2947,2956,2962,2974,113,117,97,108,71,114,101,97,116,101,114,59,1,8922,117,108,108,69,113,117,97,108,59,1,8806,114,101,97,116,101,114,59,1,8822,101,115,115,59,1,10913,108,97,110,116,69,113,117,97,108,59,1,10877,105,108,100,101,59,1,8818,114,59,3,55349,56591,4,2,59,101,2992,2994,1,8920,102,116,97,114,114,111,119,59,1,8666,105,100,111,116,59,1,319,4,3,110,112,119,3019,3110,3115,103,4,4,76,82,108,114,3030,3058,3070,3098,101,102,116,4,2,65,82,3039,3046,114,114,111,119,59,1,10229,105,103,104,116,65,114,114,111,119,59,1,10231,105,103,104,116,65,114,114,111,119,59,1,10230,101,102,116,4,2,97,114,3079,3086,114,114,111,119,59,1,10232,105,103,104,116,97,114,114,111,119,59,1,10234,105,103,104,116,97,114,114,111,119,59,1,10233,102,59,3,55349,56643,101,114,4,2,76,82,3123,3134,101,102,116,65,114,114,111,119,59,1,8601,105,103,104,116,65,114,114,111,119,59,1,8600,4,3,99,104,116,3154,3158,3161,114,59,1,8466,59,1,8624,114,111,107,59,1,321,59,1,8810,4,8,97,99,101,102,105,111,115,117,3188,3192,3196,3222,3227,3237,3243,3248,112,59,1,10501,121,59,1,1052,4,2,100,108,3202,3213,105,117,109,83,112,97,99,101,59,1,8287,108,105,110,116,114,102,59,1,8499,114,59,3,55349,56592,110,117,115,80,108,117,115,59,1,8723,112,102,59,3,55349,56644,99,114,59,1,8499,59,1,924,4,9,74,97,99,101,102,111,115,116,117,3271,3276,3283,3306,3422,3427,4120,4126,4137,99,121,59,1,1034,99,117,116,101,59,1,323,4,3,97,101,121,3291,3297,3303,114,111,110,59,1,327,100,105,108,59,1,325,59,1,1053,4,3,103,115,119,3314,3380,3415,97,116,105,118,101,4,3,77,84,86,3327,3340,3365,101,100,105,117,109,83,112,97,99,101,59,1,8203,104,105,4,2,99,110,3348,3357,107,83,112,97,99,101,59,1,8203,83,112,97,99,101,59,1,8203,101,114,121,84,104,105,110,83,112,97,99,101,59,1,8203,116,101,100,4,2,71,76,3389,3405,114,101,97,116,101,114,71,114,101,97,116,101,114,59,1,8811,101,115,115,76,101,115,115,59,1,8810,76,105,110,101,59,1,10,114,59,3,55349,56593,4,4,66,110,112,116,3437,3444,3460,3464,114,101,97,107,59,1,8288,66,114,101,97,107,105,110,103,83,112,97,99,101,59,1,160,102,59,1,8469,4,13,59,67,68,69,71,72,76,78,80,82,83,84,86,3492,3494,3517,3536,3578,3657,3685,3784,3823,3860,3915,4066,4107,1,10988,4,2,111,117,3500,3510,110,103,114,117,101,110,116,59,1,8802,112,67,97,112,59,1,8813,111,117,98,108,101,86,101,114,116,105,99,97,108,66,97,114,59,1,8742,4,3,108,113,120,3544,3552,3571,101,109,101,110,116,59,1,8713,117,97,108,4,2,59,84,3561,3563,1,8800,105,108,100,101,59,3,8770,824,105,115,116,115,59,1,8708,114,101,97,116,101,114,4,7,59,69,70,71,76,83,84,3600,3602,3609,3621,3631,3637,3650,1,8815,113,117,97,108,59,1,8817,117,108,108,69,113,117,97,108,59,3,8807,824,114,101,97,116,101,114,59,3,8811,824,101,115,115,59,1,8825,108,97,110,116,69,113,117,97,108,59,3,10878,824,105,108,100,101,59,1,8821,117,109,112,4,2,68,69,3666,3677,111,119,110,72,117,109,112,59,3,8782,824,113,117,97,108,59,3,8783,824,101,4,2,102,115,3692,3724,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3709,3711,3717,1,8938,97,114,59,3,10703,824,113,117,97,108,59,1,8940,115,4,6,59,69,71,76,83,84,3739,3741,3748,3757,3764,3777,1,8814,113,117,97,108,59,1,8816,114,101,97,116,101,114,59,1,8824,101,115,115,59,3,8810,824,108,97,110,116,69,113,117,97,108,59,3,10877,824,105,108,100,101,59,1,8820,101,115,116,101,100,4,2,71,76,3795,3812,114,101,97,116,101,114,71,114,101,97,116,101,114,59,3,10914,824,101,115,115,76,101,115,115,59,3,10913,824,114,101,99,101,100,101,115,4,3,59,69,83,3838,3840,3848,1,8832,113,117,97,108,59,3,10927,824,108,97,110,116,69,113,117,97,108,59,1,8928,4,2,101,105,3866,3881,118,101,114,115,101,69,108,101,109,101,110,116,59,1,8716,103,104,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3900,3902,3908,1,8939,97,114,59,3,10704,824,113,117,97,108,59,1,8941,4,2,113,117,3921,3973,117,97,114,101,83,117,4,2,98,112,3933,3952,115,101,116,4,2,59,69,3942,3945,3,8847,824,113,117,97,108,59,1,8930,101,114,115,101,116,4,2,59,69,3963,3966,3,8848,824,113,117,97,108,59,1,8931,4,3,98,99,112,3981,4e3,4045,115,101,116,4,2,59,69,3990,3993,3,8834,8402,113,117,97,108,59,1,8840,99,101,101,100,115,4,4,59,69,83,84,4015,4017,4025,4037,1,8833,113,117,97,108,59,3,10928,824,108,97,110,116,69,113,117,97,108,59,1,8929,105,108,100,101,59,3,8831,824,101,114,115,101,116,4,2,59,69,4056,4059,3,8835,8402,113,117,97,108,59,1,8841,105,108,100,101,4,4,59,69,70,84,4080,4082,4089,4100,1,8769,113,117,97,108,59,1,8772,117,108,108,69,113,117,97,108,59,1,8775,105,108,100,101,59,1,8777,101,114,116,105,99,97,108,66,97,114,59,1,8740,99,114,59,3,55349,56489,105,108,100,101,5,209,1,59,4135,1,209,59,1,925,4,14,69,97,99,100,102,103,109,111,112,114,115,116,117,118,4170,4176,4187,4205,4212,4217,4228,4253,4259,4292,4295,4316,4337,4346,108,105,103,59,1,338,99,117,116,101,5,211,1,59,4185,1,211,4,2,105,121,4193,4202,114,99,5,212,1,59,4200,1,212,59,1,1054,98,108,97,99,59,1,336,114,59,3,55349,56594,114,97,118,101,5,210,1,59,4226,1,210,4,3,97,101,105,4236,4241,4246,99,114,59,1,332,103,97,59,1,937,99,114,111,110,59,1,927,112,102,59,3,55349,56646,101,110,67,117,114,108,121,4,2,68,81,4272,4285,111,117,98,108,101,81,117,111,116,101,59,1,8220,117,111,116,101,59,1,8216,59,1,10836,4,2,99,108,4301,4306,114,59,3,55349,56490,97,115,104,5,216,1,59,4314,1,216,105,4,2,108,109,4323,4332,100,101,5,213,1,59,4330,1,213,101,115,59,1,10807,109,108,5,214,1,59,4344,1,214,101,114,4,2,66,80,4354,4380,4,2,97,114,4360,4364,114,59,1,8254,97,99,4,2,101,107,4372,4375,59,1,9182,101,116,59,1,9140,97,114,101,110,116,104,101,115,105,115,59,1,9180,4,9,97,99,102,104,105,108,111,114,115,4413,4422,4426,4431,4435,4438,4448,4471,4561,114,116,105,97,108,68,59,1,8706,121,59,1,1055,114,59,3,55349,56595,105,59,1,934,59,1,928,117,115,77,105,110,117,115,59,1,177,4,2,105,112,4454,4467,110,99,97,114,101,112,108,97,110,101,59,1,8460,102,59,1,8473,4,4,59,101,105,111,4481,4483,4526,4531,1,10939,99,101,100,101,115,4,4,59,69,83,84,4498,4500,4507,4519,1,8826,113,117,97,108,59,1,10927,108,97,110,116,69,113,117,97,108,59,1,8828,105,108,100,101,59,1,8830,109,101,59,1,8243,4,2,100,112,4537,4543,117,99,116,59,1,8719,111,114,116,105,111,110,4,2,59,97,4555,4557,1,8759,108,59,1,8733,4,2,99,105,4567,4572,114,59,3,55349,56491,59,1,936,4,4,85,102,111,115,4585,4594,4599,4604,79,84,5,34,1,59,4592,1,34,114,59,3,55349,56596,112,102,59,1,8474,99,114,59,3,55349,56492,4,12,66,69,97,99,101,102,104,105,111,114,115,117,4636,4642,4650,4681,4704,4763,4767,4771,5047,5069,5081,5094,97,114,114,59,1,10512,71,5,174,1,59,4648,1,174,4,3,99,110,114,4658,4664,4668,117,116,101,59,1,340,103,59,1,10219,114,4,2,59,116,4675,4677,1,8608,108,59,1,10518,4,3,97,101,121,4689,4695,4701,114,111,110,59,1,344,100,105,108,59,1,342,59,1,1056,4,2,59,118,4710,4712,1,8476,101,114,115,101,4,2,69,85,4722,4748,4,2,108,113,4728,4736,101,109,101,110,116,59,1,8715,117,105,108,105,98,114,105,117,109,59,1,8651,112,69,113,117,105,108,105,98,114,105,117,109,59,1,10607,114,59,1,8476,111,59,1,929,103,104,116,4,8,65,67,68,70,84,85,86,97,4792,4840,4849,4905,4912,4972,5022,5040,4,2,110,114,4798,4811,103,108,101,66,114,97,99,107,101,116,59,1,10217,114,111,119,4,3,59,66,76,4822,4824,4829,1,8594,97,114,59,1,8677,101,102,116,65,114,114,111,119,59,1,8644,101,105,108,105,110,103,59,1,8969,111,4,2,117,119,4856,4869,98,108,101,66,114,97,99,107,101,116,59,1,10215,110,4,2,84,86,4876,4887,101,101,86,101,99,116,111,114,59,1,10589,101,99,116,111,114,4,2,59,66,4898,4900,1,8642,97,114,59,1,10581,108,111,111,114,59,1,8971,4,2,101,114,4918,4944,101,4,3,59,65,86,4927,4929,4936,1,8866,114,114,111,119,59,1,8614,101,99,116,111,114,59,1,10587,105,97,110,103,108,101,4,3,59,66,69,4958,4960,4965,1,8883,97,114,59,1,10704,113,117,97,108,59,1,8885,112,4,3,68,84,86,4981,4993,5004,111,119,110,86,101,99,116,111,114,59,1,10575,101,101,86,101,99,116,111,114,59,1,10588,101,99,116,111,114,4,2,59,66,5015,5017,1,8638,97,114,59,1,10580,101,99,116,111,114,4,2,59,66,5033,5035,1,8640,97,114,59,1,10579,114,114,111,119,59,1,8658,4,2,112,117,5053,5057,102,59,1,8477,110,100,73,109,112,108,105,101,115,59,1,10608,105,103,104,116,97,114,114,111,119,59,1,8667,4,2,99,104,5087,5091,114,59,1,8475,59,1,8625,108,101,68,101,108,97,121,101,100,59,1,10740,4,13,72,79,97,99,102,104,105,109,111,113,115,116,117,5134,5150,5157,5164,5198,5203,5259,5265,5277,5283,5374,5380,5385,4,2,67,99,5140,5146,72,99,121,59,1,1065,121,59,1,1064,70,84,99,121,59,1,1068,99,117,116,101,59,1,346,4,5,59,97,101,105,121,5176,5178,5184,5190,5195,1,10940,114,111,110,59,1,352,100,105,108,59,1,350,114,99,59,1,348,59,1,1057,114,59,3,55349,56598,111,114,116,4,4,68,76,82,85,5216,5227,5238,5250,111,119,110,65,114,114,111,119,59,1,8595,101,102,116,65,114,114,111,119,59,1,8592,105,103,104,116,65,114,114,111,119,59,1,8594,112,65,114,114,111,119,59,1,8593,103,109,97,59,1,931,97,108,108,67,105,114,99,108,101,59,1,8728,112,102,59,3,55349,56650,4,2,114,117,5289,5293,116,59,1,8730,97,114,101,4,4,59,73,83,85,5306,5308,5322,5367,1,9633,110,116,101,114,115,101,99,116,105,111,110,59,1,8851,117,4,2,98,112,5329,5347,115,101,116,4,2,59,69,5338,5340,1,8847,113,117,97,108,59,1,8849,101,114,115,101,116,4,2,59,69,5358,5360,1,8848,113,117,97,108,59,1,8850,110,105,111,110,59,1,8852,99,114,59,3,55349,56494,97,114,59,1,8902,4,4,98,99,109,112,5395,5420,5475,5478,4,2,59,115,5401,5403,1,8912,101,116,4,2,59,69,5411,5413,1,8912,113,117,97,108,59,1,8838,4,2,99,104,5426,5468,101,101,100,115,4,4,59,69,83,84,5440,5442,5449,5461,1,8827,113,117,97,108,59,1,10928,108,97,110,116,69,113,117,97,108,59,1,8829,105,108,100,101,59,1,8831,84,104,97,116,59,1,8715,59,1,8721,4,3,59,101,115,5486,5488,5507,1,8913,114,115,101,116,4,2,59,69,5498,5500,1,8835,113,117,97,108,59,1,8839,101,116,59,1,8913,4,11,72,82,83,97,99,102,104,105,111,114,115,5536,5546,5552,5567,5579,5602,5607,5655,5695,5701,5711,79,82,78,5,222,1,59,5544,1,222,65,68,69,59,1,8482,4,2,72,99,5558,5563,99,121,59,1,1035,121,59,1,1062,4,2,98,117,5573,5576,59,1,9,59,1,932,4,3,97,101,121,5587,5593,5599,114,111,110,59,1,356,100,105,108,59,1,354,59,1,1058,114,59,3,55349,56599,4,2,101,105,5613,5631,4,2,114,116,5619,5627,101,102,111,114,101,59,1,8756,97,59,1,920,4,2,99,110,5637,5647,107,83,112,97,99,101,59,3,8287,8202,83,112,97,99,101,59,1,8201,108,100,101,4,4,59,69,70,84,5668,5670,5677,5688,1,8764,113,117,97,108,59,1,8771,117,108,108,69,113,117,97,108,59,1,8773,105,108,100,101,59,1,8776,112,102,59,3,55349,56651,105,112,108,101,68,111,116,59,1,8411,4,2,99,116,5717,5722,114,59,3,55349,56495,114,111,107,59,1,358,4,14,97,98,99,100,102,103,109,110,111,112,114,115,116,117,5758,5789,5805,5823,5830,5835,5846,5852,5921,5937,6089,6095,6101,6108,4,2,99,114,5764,5774,117,116,101,5,218,1,59,5772,1,218,114,4,2,59,111,5781,5783,1,8607,99,105,114,59,1,10569,114,4,2,99,101,5796,5800,121,59,1,1038,118,101,59,1,364,4,2,105,121,5811,5820,114,99,5,219,1,59,5818,1,219,59,1,1059,98,108,97,99,59,1,368,114,59,3,55349,56600,114,97,118,101,5,217,1,59,5844,1,217,97,99,114,59,1,362,4,2,100,105,5858,5905,101,114,4,2,66,80,5866,5892,4,2,97,114,5872,5876,114,59,1,95,97,99,4,2,101,107,5884,5887,59,1,9183,101,116,59,1,9141,97,114,101,110,116,104,101,115,105,115,59,1,9181,111,110,4,2,59,80,5913,5915,1,8899,108,117,115,59,1,8846,4,2,103,112,5927,5932,111,110,59,1,370,102,59,3,55349,56652,4,8,65,68,69,84,97,100,112,115,5955,5985,5996,6009,6026,6033,6044,6075,114,114,111,119,4,3,59,66,68,5967,5969,5974,1,8593,97,114,59,1,10514,111,119,110,65,114,114,111,119,59,1,8645,111,119,110,65,114,114,111,119,59,1,8597,113,117,105,108,105,98,114,105,117,109,59,1,10606,101,101,4,2,59,65,6017,6019,1,8869,114,114,111,119,59,1,8613,114,114,111,119,59,1,8657,111,119,110,97,114,114,111,119,59,1,8661,101,114,4,2,76,82,6052,6063,101,102,116,65,114,114,111,119,59,1,8598,105,103,104,116,65,114,114,111,119,59,1,8599,105,4,2,59,108,6082,6084,1,978,111,110,59,1,933,105,110,103,59,1,366,99,114,59,3,55349,56496,105,108,100,101,59,1,360,109,108,5,220,1,59,6115,1,220,4,9,68,98,99,100,101,102,111,115,118,6137,6143,6148,6152,6166,6250,6255,6261,6267,97,115,104,59,1,8875,97,114,59,1,10987,121,59,1,1042,97,115,104,4,2,59,108,6161,6163,1,8873,59,1,10982,4,2,101,114,6172,6175,59,1,8897,4,3,98,116,121,6183,6188,6238,97,114,59,1,8214,4,2,59,105,6194,6196,1,8214,99,97,108,4,4,66,76,83,84,6209,6214,6220,6231,97,114,59,1,8739,105,110,101,59,1,124,101,112,97,114,97,116,111,114,59,1,10072,105,108,100,101,59,1,8768,84,104,105,110,83,112,97,99,101,59,1,8202,114,59,3,55349,56601,112,102,59,3,55349,56653,99,114,59,3,55349,56497,100,97,115,104,59,1,8874,4,5,99,101,102,111,115,6286,6292,6298,6303,6309,105,114,99,59,1,372,100,103,101,59,1,8896,114,59,3,55349,56602,112,102,59,3,55349,56654,99,114,59,3,55349,56498,4,4,102,105,111,115,6325,6330,6333,6339,114,59,3,55349,56603,59,1,926,112,102,59,3,55349,56655,99,114,59,3,55349,56499,4,9,65,73,85,97,99,102,111,115,117,6365,6370,6375,6380,6391,6405,6410,6416,6422,99,121,59,1,1071,99,121,59,1,1031,99,121,59,1,1070,99,117,116,101,5,221,1,59,6389,1,221,4,2,105,121,6397,6402,114,99,59,1,374,59,1,1067,114,59,3,55349,56604,112,102,59,3,55349,56656,99,114,59,3,55349,56500,109,108,59,1,376,4,8,72,97,99,100,101,102,111,115,6445,6450,6457,6472,6477,6501,6505,6510,99,121,59,1,1046,99,117,116,101,59,1,377,4,2,97,121,6463,6469,114,111,110,59,1,381,59,1,1047,111,116,59,1,379,4,2,114,116,6483,6497,111,87,105,100,116,104,83,112,97,99,101,59,1,8203,97,59,1,918,114,59,1,8488,112,102,59,1,8484,99,114,59,3,55349,56501,4,16,97,98,99,101,102,103,108,109,110,111,112,114,115,116,117,119,6550,6561,6568,6612,6622,6634,6645,6672,6699,6854,6870,6923,6933,6963,6974,6983,99,117,116,101,5,225,1,59,6559,1,225,114,101,118,101,59,1,259,4,6,59,69,100,105,117,121,6582,6584,6588,6591,6600,6609,1,8766,59,3,8766,819,59,1,8767,114,99,5,226,1,59,6598,1,226,116,101,5,180,1,59,6607,1,180,59,1,1072,108,105,103,5,230,1,59,6620,1,230,4,2,59,114,6628,6630,1,8289,59,3,55349,56606,114,97,118,101,5,224,1,59,6643,1,224,4,2,101,112,6651,6667,4,2,102,112,6657,6663,115,121,109,59,1,8501,104,59,1,8501,104,97,59,1,945,4,2,97,112,6678,6692,4,2,99,108,6684,6688,114,59,1,257,103,59,1,10815,5,38,1,59,6697,1,38,4,2,100,103,6705,6737,4,5,59,97,100,115,118,6717,6719,6724,6727,6734,1,8743,110,100,59,1,10837,59,1,10844,108,111,112,101,59,1,10840,59,1,10842,4,7,59,101,108,109,114,115,122,6753,6755,6758,6762,6814,6835,6848,1,8736,59,1,10660,101,59,1,8736,115,100,4,2,59,97,6770,6772,1,8737,4,8,97,98,99,100,101,102,103,104,6790,6793,6796,6799,6802,6805,6808,6811,59,1,10664,59,1,10665,59,1,10666,59,1,10667,59,1,10668,59,1,10669,59,1,10670,59,1,10671,116,4,2,59,118,6821,6823,1,8735,98,4,2,59,100,6830,6832,1,8894,59,1,10653,4,2,112,116,6841,6845,104,59,1,8738,59,1,197,97,114,114,59,1,9084,4,2,103,112,6860,6865,111,110,59,1,261,102,59,3,55349,56658,4,7,59,69,97,101,105,111,112,6886,6888,6891,6897,6900,6904,6908,1,8776,59,1,10864,99,105,114,59,1,10863,59,1,8778,100,59,1,8779,115,59,1,39,114,111,120,4,2,59,101,6917,6919,1,8776,113,59,1,8778,105,110,103,5,229,1,59,6931,1,229,4,3,99,116,121,6941,6946,6949,114,59,3,55349,56502,59,1,42,109,112,4,2,59,101,6957,6959,1,8776,113,59,1,8781,105,108,100,101,5,227,1,59,6972,1,227,109,108,5,228,1,59,6981,1,228,4,2,99,105,6989,6997,111,110,105,110,116,59,1,8755,110,116,59,1,10769,4,16,78,97,98,99,100,101,102,105,107,108,110,111,112,114,115,117,7036,7041,7119,7135,7149,7155,7219,7224,7347,7354,7463,7489,7786,7793,7814,7866,111,116,59,1,10989,4,2,99,114,7047,7094,107,4,4,99,101,112,115,7058,7064,7073,7080,111,110,103,59,1,8780,112,115,105,108,111,110,59,1,1014,114,105,109,101,59,1,8245,105,109,4,2,59,101,7088,7090,1,8765,113,59,1,8909,4,2,118,119,7100,7105,101,101,59,1,8893,101,100,4,2,59,103,7113,7115,1,8965,101,59,1,8965,114,107,4,2,59,116,7127,7129,1,9141,98,114,107,59,1,9142,4,2,111,121,7141,7146,110,103,59,1,8780,59,1,1073,113,117,111,59,1,8222,4,5,99,109,112,114,116,7167,7181,7188,7193,7199,97,117,115,4,2,59,101,7176,7178,1,8757,59,1,8757,112,116,121,118,59,1,10672,115,105,59,1,1014,110,111,117,59,1,8492,4,3,97,104,119,7207,7210,7213,59,1,946,59,1,8502,101,101,110,59,1,8812,114,59,3,55349,56607,103,4,7,99,111,115,116,117,118,119,7241,7262,7288,7305,7328,7335,7340,4,3,97,105,117,7249,7253,7258,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,4,3,100,112,116,7270,7275,7281,111,116,59,1,10752,108,117,115,59,1,10753,105,109,101,115,59,1,10754,4,2,113,116,7294,7300,99,117,112,59,1,10758,97,114,59,1,9733,114,105,97,110,103,108,101,4,2,100,117,7318,7324,111,119,110,59,1,9661,112,59,1,9651,112,108,117,115,59,1,10756,101,101,59,1,8897,101,100,103,101,59,1,8896,97,114,111,119,59,1,10509,4,3,97,107,111,7362,7436,7458,4,2,99,110,7368,7432,107,4,3,108,115,116,7377,7386,7394,111,122,101,110,103,101,59,1,10731,113,117,97,114,101,59,1,9642,114,105,97,110,103,108,101,4,4,59,100,108,114,7411,7413,7419,7425,1,9652,111,119,110,59,1,9662,101,102,116,59,1,9666,105,103,104,116,59,1,9656,107,59,1,9251,4,2,49,51,7442,7454,4,2,50,52,7448,7451,59,1,9618,59,1,9617,52,59,1,9619,99,107,59,1,9608,4,2,101,111,7469,7485,4,2,59,113,7475,7478,3,61,8421,117,105,118,59,3,8801,8421,116,59,1,8976,4,4,112,116,119,120,7499,7504,7517,7523,102,59,3,55349,56659,4,2,59,116,7510,7512,1,8869,111,109,59,1,8869,116,105,101,59,1,8904,4,12,68,72,85,86,98,100,104,109,112,116,117,118,7549,7571,7597,7619,7655,7660,7682,7708,7715,7721,7728,7750,4,4,76,82,108,114,7559,7562,7565,7568,59,1,9559,59,1,9556,59,1,9558,59,1,9555,4,5,59,68,85,100,117,7583,7585,7588,7591,7594,1,9552,59,1,9574,59,1,9577,59,1,9572,59,1,9575,4,4,76,82,108,114,7607,7610,7613,7616,59,1,9565,59,1,9562,59,1,9564,59,1,9561,4,7,59,72,76,82,104,108,114,7635,7637,7640,7643,7646,7649,7652,1,9553,59,1,9580,59,1,9571,59,1,9568,59,1,9579,59,1,9570,59,1,9567,111,120,59,1,10697,4,4,76,82,108,114,7670,7673,7676,7679,59,1,9557,59,1,9554,59,1,9488,59,1,9484,4,5,59,68,85,100,117,7694,7696,7699,7702,7705,1,9472,59,1,9573,59,1,9576,59,1,9516,59,1,9524,105,110,117,115,59,1,8863,108,117,115,59,1,8862,105,109,101,115,59,1,8864,4,4,76,82,108,114,7738,7741,7744,7747,59,1,9563,59,1,9560,59,1,9496,59,1,9492,4,7,59,72,76,82,104,108,114,7766,7768,7771,7774,7777,7780,7783,1,9474,59,1,9578,59,1,9569,59,1,9566,59,1,9532,59,1,9508,59,1,9500,114,105,109,101,59,1,8245,4,2,101,118,7799,7804,118,101,59,1,728,98,97,114,5,166,1,59,7812,1,166,4,4,99,101,105,111,7824,7829,7834,7846,114,59,3,55349,56503,109,105,59,1,8271,109,4,2,59,101,7841,7843,1,8765,59,1,8909,108,4,3,59,98,104,7855,7857,7860,1,92,59,1,10693,115,117,98,59,1,10184,4,2,108,109,7872,7885,108,4,2,59,101,7879,7881,1,8226,116,59,1,8226,112,4,3,59,69,101,7894,7896,7899,1,8782,59,1,10926,4,2,59,113,7905,7907,1,8783,59,1,8783,4,15,97,99,100,101,102,104,105,108,111,114,115,116,117,119,121,7942,8021,8075,8080,8121,8126,8157,8279,8295,8430,8446,8485,8491,8707,8726,4,3,99,112,114,7950,7956,8007,117,116,101,59,1,263,4,6,59,97,98,99,100,115,7970,7972,7977,7984,7998,8003,1,8745,110,100,59,1,10820,114,99,117,112,59,1,10825,4,2,97,117,7990,7994,112,59,1,10827,112,59,1,10823,111,116,59,1,10816,59,3,8745,65024,4,2,101,111,8013,8017,116,59,1,8257,110,59,1,711,4,4,97,101,105,117,8031,8046,8056,8061,4,2,112,114,8037,8041,115,59,1,10829,111,110,59,1,269,100,105,108,5,231,1,59,8054,1,231,114,99,59,1,265,112,115,4,2,59,115,8069,8071,1,10828,109,59,1,10832,111,116,59,1,267,4,3,100,109,110,8088,8097,8104,105,108,5,184,1,59,8095,1,184,112,116,121,118,59,1,10674,116,5,162,2,59,101,8112,8114,1,162,114,100,111,116,59,1,183,114,59,3,55349,56608,4,3,99,101,105,8134,8138,8154,121,59,1,1095,99,107,4,2,59,109,8146,8148,1,10003,97,114,107,59,1,10003,59,1,967,114,4,7,59,69,99,101,102,109,115,8174,8176,8179,8258,8261,8268,8273,1,9675,59,1,10691,4,3,59,101,108,8187,8189,8193,1,710,113,59,1,8791,101,4,2,97,100,8200,8223,114,114,111,119,4,2,108,114,8210,8216,101,102,116,59,1,8634,105,103,104,116,59,1,8635,4,5,82,83,97,99,100,8235,8238,8241,8246,8252,59,1,174,59,1,9416,115,116,59,1,8859,105,114,99,59,1,8858,97,115,104,59,1,8861,59,1,8791,110,105,110,116,59,1,10768,105,100,59,1,10991,99,105,114,59,1,10690,117,98,115,4,2,59,117,8288,8290,1,9827,105,116,59,1,9827,4,4,108,109,110,112,8305,8326,8376,8400,111,110,4,2,59,101,8313,8315,1,58,4,2,59,113,8321,8323,1,8788,59,1,8788,4,2,109,112,8332,8344,97,4,2,59,116,8339,8341,1,44,59,1,64,4,3,59,102,108,8352,8354,8358,1,8705,110,59,1,8728,101,4,2,109,120,8365,8371,101,110,116,59,1,8705,101,115,59,1,8450,4,2,103,105,8382,8395,4,2,59,100,8388,8390,1,8773,111,116,59,1,10861,110,116,59,1,8750,4,3,102,114,121,8408,8412,8417,59,3,55349,56660,111,100,59,1,8720,5,169,2,59,115,8424,8426,1,169,114,59,1,8471,4,2,97,111,8436,8441,114,114,59,1,8629,115,115,59,1,10007,4,2,99,117,8452,8457,114,59,3,55349,56504,4,2,98,112,8463,8474,4,2,59,101,8469,8471,1,10959,59,1,10961,4,2,59,101,8480,8482,1,10960,59,1,10962,100,111,116,59,1,8943,4,7,100,101,108,112,114,118,119,8507,8522,8536,8550,8600,8697,8702,97,114,114,4,2,108,114,8516,8519,59,1,10552,59,1,10549,4,2,112,115,8528,8532,114,59,1,8926,99,59,1,8927,97,114,114,4,2,59,112,8545,8547,1,8630,59,1,10557,4,6,59,98,99,100,111,115,8564,8566,8573,8587,8592,8596,1,8746,114,99,97,112,59,1,10824,4,2,97,117,8579,8583,112,59,1,10822,112,59,1,10826,111,116,59,1,8845,114,59,1,10821,59,3,8746,65024,4,4,97,108,114,118,8610,8623,8663,8672,114,114,4,2,59,109,8618,8620,1,8631,59,1,10556,121,4,3,101,118,119,8632,8651,8656,113,4,2,112,115,8639,8645,114,101,99,59,1,8926,117,99,99,59,1,8927,101,101,59,1,8910,101,100,103,101,59,1,8911,101,110,5,164,1,59,8670,1,164,101,97,114,114,111,119,4,2,108,114,8684,8690,101,102,116,59,1,8630,105,103,104,116,59,1,8631,101,101,59,1,8910,101,100,59,1,8911,4,2,99,105,8713,8721,111,110,105,110,116,59,1,8754,110,116,59,1,8753,108,99,116,121,59,1,9005,4,19,65,72,97,98,99,100,101,102,104,105,106,108,111,114,115,116,117,119,122,8773,8778,8783,8821,8839,8854,8887,8914,8930,8944,9036,9041,9058,9197,9227,9258,9281,9297,9305,114,114,59,1,8659,97,114,59,1,10597,4,4,103,108,114,115,8793,8799,8805,8809,103,101,114,59,1,8224,101,116,104,59,1,8504,114,59,1,8595,104,4,2,59,118,8816,8818,1,8208,59,1,8867,4,2,107,108,8827,8834,97,114,111,119,59,1,10511,97,99,59,1,733,4,2,97,121,8845,8851,114,111,110,59,1,271,59,1,1076,4,3,59,97,111,8862,8864,8880,1,8518,4,2,103,114,8870,8876,103,101,114,59,1,8225,114,59,1,8650,116,115,101,113,59,1,10871,4,3,103,108,109,8895,8902,8907,5,176,1,59,8900,1,176,116,97,59,1,948,112,116,121,118,59,1,10673,4,2,105,114,8920,8926,115,104,116,59,1,10623,59,3,55349,56609,97,114,4,2,108,114,8938,8941,59,1,8643,59,1,8642,4,5,97,101,103,115,118,8956,8986,8989,8996,9001,109,4,3,59,111,115,8965,8967,8983,1,8900,110,100,4,2,59,115,8975,8977,1,8900,117,105,116,59,1,9830,59,1,9830,59,1,168,97,109,109,97,59,1,989,105,110,59,1,8946,4,3,59,105,111,9009,9011,9031,1,247,100,101,5,247,2,59,111,9020,9022,1,247,110,116,105,109,101,115,59,1,8903,110,120,59,1,8903,99,121,59,1,1106,99,4,2,111,114,9048,9053,114,110,59,1,8990,111,112,59,1,8973,4,5,108,112,116,117,119,9070,9076,9081,9130,9144,108,97,114,59,1,36,102,59,3,55349,56661,4,5,59,101,109,112,115,9093,9095,9109,9116,9122,1,729,113,4,2,59,100,9102,9104,1,8784,111,116,59,1,8785,105,110,117,115,59,1,8760,108,117,115,59,1,8724,113,117,97,114,101,59,1,8865,98,108,101,98,97,114,119,101,100,103,101,59,1,8966,110,4,3,97,100,104,9153,9160,9172,114,114,111,119,59,1,8595,111,119,110,97,114,114,111,119,115,59,1,8650,97,114,112,111,111,110,4,2,108,114,9184,9190,101,102,116,59,1,8643,105,103,104,116,59,1,8642,4,2,98,99,9203,9211,107,97,114,111,119,59,1,10512,4,2,111,114,9217,9222,114,110,59,1,8991,111,112,59,1,8972,4,3,99,111,116,9235,9248,9252,4,2,114,121,9241,9245,59,3,55349,56505,59,1,1109,108,59,1,10742,114,111,107,59,1,273,4,2,100,114,9264,9269,111,116,59,1,8945,105,4,2,59,102,9276,9278,1,9663,59,1,9662,4,2,97,104,9287,9292,114,114,59,1,8693,97,114,59,1,10607,97,110,103,108,101,59,1,10662,4,2,99,105,9311,9315,121,59,1,1119,103,114,97,114,114,59,1,10239,4,18,68,97,99,100,101,102,103,108,109,110,111,112,113,114,115,116,117,120,9361,9376,9398,9439,9444,9447,9462,9495,9531,9585,9598,9614,9659,9755,9771,9792,9808,9826,4,2,68,111,9367,9372,111,116,59,1,10871,116,59,1,8785,4,2,99,115,9382,9392,117,116,101,5,233,1,59,9390,1,233,116,101,114,59,1,10862,4,4,97,105,111,121,9408,9414,9430,9436,114,111,110,59,1,283,114,4,2,59,99,9421,9423,1,8790,5,234,1,59,9428,1,234,108,111,110,59,1,8789,59,1,1101,111,116,59,1,279,59,1,8519,4,2,68,114,9453,9458,111,116,59,1,8786,59,3,55349,56610,4,3,59,114,115,9470,9472,9482,1,10906,97,118,101,5,232,1,59,9480,1,232,4,2,59,100,9488,9490,1,10902,111,116,59,1,10904,4,4,59,105,108,115,9505,9507,9515,9518,1,10905,110,116,101,114,115,59,1,9191,59,1,8467,4,2,59,100,9524,9526,1,10901,111,116,59,1,10903,4,3,97,112,115,9539,9544,9564,99,114,59,1,275,116,121,4,3,59,115,118,9554,9556,9561,1,8709,101,116,59,1,8709,59,1,8709,112,4,2,49,59,9571,9583,4,2,51,52,9577,9580,59,1,8196,59,1,8197,1,8195,4,2,103,115,9591,9594,59,1,331,112,59,1,8194,4,2,103,112,9604,9609,111,110,59,1,281,102,59,3,55349,56662,4,3,97,108,115,9622,9635,9640,114,4,2,59,115,9629,9631,1,8917,108,59,1,10723,117,115,59,1,10865,105,4,3,59,108,118,9649,9651,9656,1,949,111,110,59,1,949,59,1,1013,4,4,99,115,117,118,9669,9686,9716,9747,4,2,105,111,9675,9680,114,99,59,1,8790,108,111,110,59,1,8789,4,2,105,108,9692,9696,109,59,1,8770,97,110,116,4,2,103,108,9705,9710,116,114,59,1,10902,101,115,115,59,1,10901,4,3,97,101,105,9724,9729,9734,108,115,59,1,61,115,116,59,1,8799,118,4,2,59,68,9741,9743,1,8801,68,59,1,10872,112,97,114,115,108,59,1,10725,4,2,68,97,9761,9766,111,116,59,1,8787,114,114,59,1,10609,4,3,99,100,105,9779,9783,9788,114,59,1,8495,111,116,59,1,8784,109,59,1,8770,4,2,97,104,9798,9801,59,1,951,5,240,1,59,9806,1,240,4,2,109,114,9814,9822,108,5,235,1,59,9820,1,235,111,59,1,8364,4,3,99,105,112,9834,9838,9843,108,59,1,33,115,116,59,1,8707,4,2,101,111,9849,9859,99,116,97,116,105,111,110,59,1,8496,110,101,110,116,105,97,108,101,59,1,8519,4,12,97,99,101,102,105,106,108,110,111,112,114,115,9896,9910,9914,9921,9954,9960,9967,9989,9994,10027,10036,10164,108,108,105,110,103,100,111,116,115,101,113,59,1,8786,121,59,1,1092,109,97,108,101,59,1,9792,4,3,105,108,114,9929,9935,9950,108,105,103,59,1,64259,4,2,105,108,9941,9945,103,59,1,64256,105,103,59,1,64260,59,3,55349,56611,108,105,103,59,1,64257,108,105,103,59,3,102,106,4,3,97,108,116,9975,9979,9984,116,59,1,9837,105,103,59,1,64258,110,115,59,1,9649,111,102,59,1,402,4,2,112,114,1e4,10005,102,59,3,55349,56663,4,2,97,107,10011,10016,108,108,59,1,8704,4,2,59,118,10022,10024,1,8916,59,1,10969,97,114,116,105,110,116,59,1,10765,4,2,97,111,10042,10159,4,2,99,115,10048,10155,4,6,49,50,51,52,53,55,10062,10102,10114,10135,10139,10151,4,6,50,51,52,53,54,56,10076,10083,10086,10093,10096,10099,5,189,1,59,10081,1,189,59,1,8531,5,188,1,59,10091,1,188,59,1,8533,59,1,8537,59,1,8539,4,2,51,53,10108,10111,59,1,8532,59,1,8534,4,3,52,53,56,10122,10129,10132,5,190,1,59,10127,1,190,59,1,8535,59,1,8540,53,59,1,8536,4,2,54,56,10145,10148,59,1,8538,59,1,8541,56,59,1,8542,108,59,1,8260,119,110,59,1,8994,99,114,59,3,55349,56507,4,17,69,97,98,99,100,101,102,103,105,106,108,110,111,114,115,116,118,10206,10217,10247,10254,10268,10273,10358,10363,10374,10380,10385,10406,10458,10464,10470,10497,10610,4,2,59,108,10212,10214,1,8807,59,1,10892,4,3,99,109,112,10225,10231,10244,117,116,101,59,1,501,109,97,4,2,59,100,10239,10241,1,947,59,1,989,59,1,10886,114,101,118,101,59,1,287,4,2,105,121,10260,10265,114,99,59,1,285,59,1,1075,111,116,59,1,289,4,4,59,108,113,115,10283,10285,10288,10308,1,8805,59,1,8923,4,3,59,113,115,10296,10298,10301,1,8805,59,1,8807,108,97,110,116,59,1,10878,4,4,59,99,100,108,10318,10320,10324,10345,1,10878,99,59,1,10921,111,116,4,2,59,111,10332,10334,1,10880,4,2,59,108,10340,10342,1,10882,59,1,10884,4,2,59,101,10351,10354,3,8923,65024,115,59,1,10900,114,59,3,55349,56612,4,2,59,103,10369,10371,1,8811,59,1,8921,109,101,108,59,1,8503,99,121,59,1,1107,4,4,59,69,97,106,10395,10397,10400,10403,1,8823,59,1,10898,59,1,10917,59,1,10916,4,4,69,97,101,115,10416,10419,10434,10453,59,1,8809,112,4,2,59,112,10426,10428,1,10890,114,111,120,59,1,10890,4,2,59,113,10440,10442,1,10888,4,2,59,113,10448,10450,1,10888,59,1,8809,105,109,59,1,8935,112,102,59,3,55349,56664,97,118,101,59,1,96,4,2,99,105,10476,10480,114,59,1,8458,109,4,3,59,101,108,10489,10491,10494,1,8819,59,1,10894,59,1,10896,5,62,6,59,99,100,108,113,114,10512,10514,10527,10532,10538,10545,1,62,4,2,99,105,10520,10523,59,1,10919,114,59,1,10874,111,116,59,1,8919,80,97,114,59,1,10645,117,101,115,116,59,1,10876,4,5,97,100,101,108,115,10557,10574,10579,10599,10605,4,2,112,114,10563,10570,112,114,111,120,59,1,10886,114,59,1,10616,111,116,59,1,8919,113,4,2,108,113,10586,10592,101,115,115,59,1,8923,108,101,115,115,59,1,10892,101,115,115,59,1,8823,105,109,59,1,8819,4,2,101,110,10616,10626,114,116,110,101,113,113,59,3,8809,65024,69,59,3,8809,65024,4,10,65,97,98,99,101,102,107,111,115,121,10653,10658,10713,10718,10724,10760,10765,10786,10850,10875,114,114,59,1,8660,4,4,105,108,109,114,10668,10674,10678,10684,114,115,112,59,1,8202,102,59,1,189,105,108,116,59,1,8459,4,2,100,114,10690,10695,99,121,59,1,1098,4,3,59,99,119,10703,10705,10710,1,8596,105,114,59,1,10568,59,1,8621,97,114,59,1,8463,105,114,99,59,1,293,4,3,97,108,114,10732,10748,10754,114,116,115,4,2,59,117,10741,10743,1,9829,105,116,59,1,9829,108,105,112,59,1,8230,99,111,110,59,1,8889,114,59,3,55349,56613,115,4,2,101,119,10772,10779,97,114,111,119,59,1,10533,97,114,111,119,59,1,10534,4,5,97,109,111,112,114,10798,10803,10809,10839,10844,114,114,59,1,8703,116,104,116,59,1,8763,107,4,2,108,114,10816,10827,101,102,116,97,114,114,111,119,59,1,8617,105,103,104,116,97,114,114,111,119,59,1,8618,102,59,3,55349,56665,98,97,114,59,1,8213,4,3,99,108,116,10858,10863,10869,114,59,3,55349,56509,97,115,104,59,1,8463,114,111,107,59,1,295,4,2,98,112,10881,10887,117,108,108,59,1,8259,104,101,110,59,1,8208,4,15,97,99,101,102,103,105,106,109,110,111,112,113,115,116,117,10925,10936,10958,10977,10990,11001,11039,11045,11101,11192,11220,11226,11237,11285,11299,99,117,116,101,5,237,1,59,10934,1,237,4,3,59,105,121,10944,10946,10955,1,8291,114,99,5,238,1,59,10953,1,238,59,1,1080,4,2,99,120,10964,10968,121,59,1,1077,99,108,5,161,1,59,10975,1,161,4,2,102,114,10983,10986,59,1,8660,59,3,55349,56614,114,97,118,101,5,236,1,59,10999,1,236,4,4,59,105,110,111,11011,11013,11028,11034,1,8520,4,2,105,110,11019,11024,110,116,59,1,10764,116,59,1,8749,102,105,110,59,1,10716,116,97,59,1,8489,108,105,103,59,1,307,4,3,97,111,112,11053,11092,11096,4,3,99,103,116,11061,11065,11088,114,59,1,299,4,3,101,108,112,11073,11076,11082,59,1,8465,105,110,101,59,1,8464,97,114,116,59,1,8465,104,59,1,305,102,59,1,8887,101,100,59,1,437,4,5,59,99,102,111,116,11113,11115,11121,11136,11142,1,8712,97,114,101,59,1,8453,105,110,4,2,59,116,11129,11131,1,8734,105,101,59,1,10717,100,111,116,59,1,305,4,5,59,99,101,108,112,11154,11156,11161,11179,11186,1,8747,97,108,59,1,8890,4,2,103,114,11167,11173,101,114,115,59,1,8484,99,97,108,59,1,8890,97,114,104,107,59,1,10775,114,111,100,59,1,10812,4,4,99,103,112,116,11202,11206,11211,11216,121,59,1,1105,111,110,59,1,303,102,59,3,55349,56666,97,59,1,953,114,111,100,59,1,10812,117,101,115,116,5,191,1,59,11235,1,191,4,2,99,105,11243,11248,114,59,3,55349,56510,110,4,5,59,69,100,115,118,11261,11263,11266,11271,11282,1,8712,59,1,8953,111,116,59,1,8949,4,2,59,118,11277,11279,1,8948,59,1,8947,59,1,8712,4,2,59,105,11291,11293,1,8290,108,100,101,59,1,297,4,2,107,109,11305,11310,99,121,59,1,1110,108,5,239,1,59,11316,1,239,4,6,99,102,109,111,115,117,11332,11346,11351,11357,11363,11380,4,2,105,121,11338,11343,114,99,59,1,309,59,1,1081,114,59,3,55349,56615,97,116,104,59,1,567,112,102,59,3,55349,56667,4,2,99,101,11369,11374,114,59,3,55349,56511,114,99,121,59,1,1112,107,99,121,59,1,1108,4,8,97,99,102,103,104,106,111,115,11404,11418,11433,11438,11445,11450,11455,11461,112,112,97,4,2,59,118,11413,11415,1,954,59,1,1008,4,2,101,121,11424,11430,100,105,108,59,1,311,59,1,1082,114,59,3,55349,56616,114,101,101,110,59,1,312,99,121,59,1,1093,99,121,59,1,1116,112,102,59,3,55349,56668,99,114,59,3,55349,56512,4,23,65,66,69,72,97,98,99,100,101,102,103,104,106,108,109,110,111,112,114,115,116,117,118,11515,11538,11544,11555,11560,11721,11780,11818,11868,12136,12160,12171,12203,12208,12246,12275,12327,12509,12523,12569,12641,12732,12752,4,3,97,114,116,11523,11528,11532,114,114,59,1,8666,114,59,1,8656,97,105,108,59,1,10523,97,114,114,59,1,10510,4,2,59,103,11550,11552,1,8806,59,1,10891,97,114,59,1,10594,4,9,99,101,103,109,110,112,113,114,116,11580,11586,11594,11600,11606,11624,11627,11636,11694,117,116,101,59,1,314,109,112,116,121,118,59,1,10676,114,97,110,59,1,8466,98,100,97,59,1,955,103,4,3,59,100,108,11615,11617,11620,1,10216,59,1,10641,101,59,1,10216,59,1,10885,117,111,5,171,1,59,11634,1,171,114,4,8,59,98,102,104,108,112,115,116,11655,11657,11669,11673,11677,11681,11685,11690,1,8592,4,2,59,102,11663,11665,1,8676,115,59,1,10527,115,59,1,10525,107,59,1,8617,112,59,1,8619,108,59,1,10553,105,109,59,1,10611,108,59,1,8610,4,3,59,97,101,11702,11704,11709,1,10923,105,108,59,1,10521,4,2,59,115,11715,11717,1,10925,59,3,10925,65024,4,3,97,98,114,11729,11734,11739,114,114,59,1,10508,114,107,59,1,10098,4,2,97,107,11745,11758,99,4,2,101,107,11752,11755,59,1,123,59,1,91,4,2,101,115,11764,11767,59,1,10635,108,4,2,100,117,11774,11777,59,1,10639,59,1,10637,4,4,97,101,117,121,11790,11796,11811,11815,114,111,110,59,1,318,4,2,100,105,11802,11807,105,108,59,1,316,108,59,1,8968,98,59,1,123,59,1,1083,4,4,99,113,114,115,11828,11832,11845,11864,97,59,1,10550,117,111,4,2,59,114,11840,11842,1,8220,59,1,8222,4,2,100,117,11851,11857,104,97,114,59,1,10599,115,104,97,114,59,1,10571,104,59,1,8626,4,5,59,102,103,113,115,11880,11882,12008,12011,12031,1,8804,116,4,5,97,104,108,114,116,11895,11913,11935,11947,11996,114,114,111,119,4,2,59,116,11905,11907,1,8592,97,105,108,59,1,8610,97,114,112,111,111,110,4,2,100,117,11925,11931,111,119,110,59,1,8637,112,59,1,8636,101,102,116,97,114,114,111,119,115,59,1,8647,105,103,104,116,4,3,97,104,115,11959,11974,11984,114,114,111,119,4,2,59,115,11969,11971,1,8596,59,1,8646,97,114,112,111,111,110,115,59,1,8651,113,117,105,103,97,114,114,111,119,59,1,8621,104,114,101,101,116,105,109,101,115,59,1,8907,59,1,8922,4,3,59,113,115,12019,12021,12024,1,8804,59,1,8806,108,97,110,116,59,1,10877,4,5,59,99,100,103,115,12043,12045,12049,12070,12083,1,10877,99,59,1,10920,111,116,4,2,59,111,12057,12059,1,10879,4,2,59,114,12065,12067,1,10881,59,1,10883,4,2,59,101,12076,12079,3,8922,65024,115,59,1,10899,4,5,97,100,101,103,115,12095,12103,12108,12126,12131,112,112,114,111,120,59,1,10885,111,116,59,1,8918,113,4,2,103,113,12115,12120,116,114,59,1,8922,103,116,114,59,1,10891,116,114,59,1,8822,105,109,59,1,8818,4,3,105,108,114,12144,12150,12156,115,104,116,59,1,10620,111,111,114,59,1,8970,59,3,55349,56617,4,2,59,69,12166,12168,1,8822,59,1,10897,4,2,97,98,12177,12198,114,4,2,100,117,12184,12187,59,1,8637,4,2,59,108,12193,12195,1,8636,59,1,10602,108,107,59,1,9604,99,121,59,1,1113,4,5,59,97,99,104,116,12220,12222,12227,12235,12241,1,8810,114,114,59,1,8647,111,114,110,101,114,59,1,8990,97,114,100,59,1,10603,114,105,59,1,9722,4,2,105,111,12252,12258,100,111,116,59,1,320,117,115,116,4,2,59,97,12267,12269,1,9136,99,104,101,59,1,9136,4,4,69,97,101,115,12285,12288,12303,12322,59,1,8808,112,4,2,59,112,12295,12297,1,10889,114,111,120,59,1,10889,4,2,59,113,12309,12311,1,10887,4,2,59,113,12317,12319,1,10887,59,1,8808,105,109,59,1,8934,4,8,97,98,110,111,112,116,119,122,12345,12359,12364,12421,12446,12467,12474,12490,4,2,110,114,12351,12355,103,59,1,10220,114,59,1,8701,114,107,59,1,10214,103,4,3,108,109,114,12373,12401,12409,101,102,116,4,2,97,114,12382,12389,114,114,111,119,59,1,10229,105,103,104,116,97,114,114,111,119,59,1,10231,97,112,115,116,111,59,1,10236,105,103,104,116,97,114,114,111,119,59,1,10230,112,97,114,114,111,119,4,2,108,114,12433,12439,101,102,116,59,1,8619,105,103,104,116,59,1,8620,4,3,97,102,108,12454,12458,12462,114,59,1,10629,59,3,55349,56669,117,115,59,1,10797,105,109,101,115,59,1,10804,4,2,97,98,12480,12485,115,116,59,1,8727,97,114,59,1,95,4,3,59,101,102,12498,12500,12506,1,9674,110,103,101,59,1,9674,59,1,10731,97,114,4,2,59,108,12517,12519,1,40,116,59,1,10643,4,5,97,99,104,109,116,12535,12540,12548,12561,12564,114,114,59,1,8646,111,114,110,101,114,59,1,8991,97,114,4,2,59,100,12556,12558,1,8651,59,1,10605,59,1,8206,114,105,59,1,8895,4,6,97,99,104,105,113,116,12583,12589,12594,12597,12614,12635,113,117,111,59,1,8249,114,59,3,55349,56513,59,1,8624,109,4,3,59,101,103,12606,12608,12611,1,8818,59,1,10893,59,1,10895,4,2,98,117,12620,12623,59,1,91,111,4,2,59,114,12630,12632,1,8216,59,1,8218,114,111,107,59,1,322,5,60,8,59,99,100,104,105,108,113,114,12660,12662,12675,12680,12686,12692,12698,12705,1,60,4,2,99,105,12668,12671,59,1,10918,114,59,1,10873,111,116,59,1,8918,114,101,101,59,1,8907,109,101,115,59,1,8905,97,114,114,59,1,10614,117,101,115,116,59,1,10875,4,2,80,105,12711,12716,97,114,59,1,10646,4,3,59,101,102,12724,12726,12729,1,9667,59,1,8884,59,1,9666,114,4,2,100,117,12739,12746,115,104,97,114,59,1,10570,104,97,114,59,1,10598,4,2,101,110,12758,12768,114,116,110,101,113,113,59,3,8808,65024,69,59,3,8808,65024,4,14,68,97,99,100,101,102,104,105,108,110,111,112,115,117,12803,12809,12893,12908,12914,12928,12933,12937,13011,13025,13032,13049,13052,13069,68,111,116,59,1,8762,4,4,99,108,112,114,12819,12827,12849,12887,114,5,175,1,59,12825,1,175,4,2,101,116,12833,12836,59,1,9794,4,2,59,101,12842,12844,1,10016,115,101,59,1,10016,4,2,59,115,12855,12857,1,8614,116,111,4,4,59,100,108,117,12869,12871,12877,12883,1,8614,111,119,110,59,1,8615,101,102,116,59,1,8612,112,59,1,8613,107,101,114,59,1,9646,4,2,111,121,12899,12905,109,109,97,59,1,10793,59,1,1084,97,115,104,59,1,8212,97,115,117,114,101,100,97,110,103,108,101,59,1,8737,114,59,3,55349,56618,111,59,1,8487,4,3,99,100,110,12945,12954,12985,114,111,5,181,1,59,12952,1,181,4,4,59,97,99,100,12964,12966,12971,12976,1,8739,115,116,59,1,42,105,114,59,1,10992,111,116,5,183,1,59,12983,1,183,117,115,4,3,59,98,100,12995,12997,13e3,1,8722,59,1,8863,4,2,59,117,13006,13008,1,8760,59,1,10794,4,2,99,100,13017,13021,112,59,1,10971,114,59,1,8230,112,108,117,115,59,1,8723,4,2,100,112,13038,13044,101,108,115,59,1,8871,102,59,3,55349,56670,59,1,8723,4,2,99,116,13058,13063,114,59,3,55349,56514,112,111,115,59,1,8766,4,3,59,108,109,13077,13079,13087,1,956,116,105,109,97,112,59,1,8888,97,112,59,1,8888,4,24,71,76,82,86,97,98,99,100,101,102,103,104,105,106,108,109,111,112,114,115,116,117,118,119,13142,13165,13217,13229,13247,13330,13359,13414,13420,13508,13513,13579,13602,13626,13631,13762,13767,13855,13936,13995,14214,14285,14312,14432,4,2,103,116,13148,13152,59,3,8921,824,4,2,59,118,13158,13161,3,8811,8402,59,3,8811,824,4,3,101,108,116,13173,13200,13204,102,116,4,2,97,114,13181,13188,114,114,111,119,59,1,8653,105,103,104,116,97,114,114,111,119,59,1,8654,59,3,8920,824,4,2,59,118,13210,13213,3,8810,8402,59,3,8810,824,105,103,104,116,97,114,114,111,119,59,1,8655,4,2,68,100,13235,13241,97,115,104,59,1,8879,97,115,104,59,1,8878,4,5,98,99,110,112,116,13259,13264,13270,13275,13308,108,97,59,1,8711,117,116,101,59,1,324,103,59,3,8736,8402,4,5,59,69,105,111,112,13287,13289,13293,13298,13302,1,8777,59,3,10864,824,100,59,3,8779,824,115,59,1,329,114,111,120,59,1,8777,117,114,4,2,59,97,13316,13318,1,9838,108,4,2,59,115,13325,13327,1,9838,59,1,8469,4,2,115,117,13336,13344,112,5,160,1,59,13342,1,160,109,112,4,2,59,101,13352,13355,3,8782,824,59,3,8783,824,4,5,97,101,111,117,121,13371,13385,13391,13407,13411,4,2,112,114,13377,13380,59,1,10819,111,110,59,1,328,100,105,108,59,1,326,110,103,4,2,59,100,13399,13401,1,8775,111,116,59,3,10861,824,112,59,1,10818,59,1,1085,97,115,104,59,1,8211,4,7,59,65,97,100,113,115,120,13436,13438,13443,13466,13472,13478,13494,1,8800,114,114,59,1,8663,114,4,2,104,114,13450,13454,107,59,1,10532,4,2,59,111,13460,13462,1,8599,119,59,1,8599,111,116,59,3,8784,824,117,105,118,59,1,8802,4,2,101,105,13484,13489,97,114,59,1,10536,109,59,3,8770,824,105,115,116,4,2,59,115,13503,13505,1,8708,59,1,8708,114,59,3,55349,56619,4,4,69,101,115,116,13523,13527,13563,13568,59,3,8807,824,4,3,59,113,115,13535,13537,13559,1,8817,4,3,59,113,115,13545,13547,13551,1,8817,59,3,8807,824,108,97,110,116,59,3,10878,824,59,3,10878,824,105,109,59,1,8821,4,2,59,114,13574,13576,1,8815,59,1,8815,4,3,65,97,112,13587,13592,13597,114,114,59,1,8654,114,114,59,1,8622,97,114,59,1,10994,4,3,59,115,118,13610,13612,13623,1,8715,4,2,59,100,13618,13620,1,8956,59,1,8954,59,1,8715,99,121,59,1,1114,4,7,65,69,97,100,101,115,116,13647,13652,13656,13661,13665,13737,13742,114,114,59,1,8653,59,3,8806,824,114,114,59,1,8602,114,59,1,8229,4,4,59,102,113,115,13675,13677,13703,13725,1,8816,116,4,2,97,114,13684,13691,114,114,111,119,59,1,8602,105,103,104,116,97,114,114,111,119,59,1,8622,4,3,59,113,115,13711,13713,13717,1,8816,59,3,8806,824,108,97,110,116,59,3,10877,824,4,2,59,115,13731,13734,3,10877,824,59,1,8814,105,109,59,1,8820,4,2,59,114,13748,13750,1,8814,105,4,2,59,101,13757,13759,1,8938,59,1,8940,105,100,59,1,8740,4,2,112,116,13773,13778,102,59,3,55349,56671,5,172,3,59,105,110,13787,13789,13829,1,172,110,4,4,59,69,100,118,13800,13802,13806,13812,1,8713,59,3,8953,824,111,116,59,3,8949,824,4,3,97,98,99,13820,13823,13826,59,1,8713,59,1,8951,59,1,8950,105,4,2,59,118,13836,13838,1,8716,4,3,97,98,99,13846,13849,13852,59,1,8716,59,1,8958,59,1,8957,4,3,97,111,114,13863,13892,13899,114,4,4,59,97,115,116,13874,13876,13883,13888,1,8742,108,108,101,108,59,1,8742,108,59,3,11005,8421,59,3,8706,824,108,105,110,116,59,1,10772,4,3,59,99,101,13907,13909,13914,1,8832,117,101,59,1,8928,4,2,59,99,13920,13923,3,10927,824,4,2,59,101,13929,13931,1,8832,113,59,3,10927,824,4,4,65,97,105,116,13946,13951,13971,13982,114,114,59,1,8655,114,114,4,3,59,99,119,13961,13963,13967,1,8603,59,3,10547,824,59,3,8605,824,103,104,116,97,114,114,111,119,59,1,8603,114,105,4,2,59,101,13990,13992,1,8939,59,1,8941,4,7,99,104,105,109,112,113,117,14011,14036,14060,14080,14085,14090,14106,4,4,59,99,101,114,14021,14023,14028,14032,1,8833,117,101,59,1,8929,59,3,10928,824,59,3,55349,56515,111,114,116,4,2,109,112,14045,14050,105,100,59,1,8740,97,114,97,108,108,101,108,59,1,8742,109,4,2,59,101,14067,14069,1,8769,4,2,59,113,14075,14077,1,8772,59,1,8772,105,100,59,1,8740,97,114,59,1,8742,115,117,4,2,98,112,14098,14102,101,59,1,8930,101,59,1,8931,4,3,98,99,112,14114,14157,14171,4,4,59,69,101,115,14124,14126,14130,14133,1,8836,59,3,10949,824,59,1,8840,101,116,4,2,59,101,14141,14144,3,8834,8402,113,4,2,59,113,14151,14153,1,8840,59,3,10949,824,99,4,2,59,101,14164,14166,1,8833,113,59,3,10928,824,4,4,59,69,101,115,14181,14183,14187,14190,1,8837,59,3,10950,824,59,1,8841,101,116,4,2,59,101,14198,14201,3,8835,8402,113,4,2,59,113,14208,14210,1,8841,59,3,10950,824,4,4,103,105,108,114,14224,14228,14238,14242,108,59,1,8825,108,100,101,5,241,1,59,14236,1,241,103,59,1,8824,105,97,110,103,108,101,4,2,108,114,14254,14269,101,102,116,4,2,59,101,14263,14265,1,8938,113,59,1,8940,105,103,104,116,4,2,59,101,14279,14281,1,8939,113,59,1,8941,4,2,59,109,14291,14293,1,957,4,3,59,101,115,14301,14303,14308,1,35,114,111,59,1,8470,112,59,1,8199,4,9,68,72,97,100,103,105,108,114,115,14332,14338,14344,14349,14355,14369,14376,14408,14426,97,115,104,59,1,8877,97,114,114,59,1,10500,112,59,3,8781,8402,97,115,104,59,1,8876,4,2,101,116,14361,14365,59,3,8805,8402,59,3,62,8402,110,102,105,110,59,1,10718,4,3,65,101,116,14384,14389,14393,114,114,59,1,10498,59,3,8804,8402,4,2,59,114,14399,14402,3,60,8402,105,101,59,3,8884,8402,4,2,65,116,14414,14419,114,114,59,1,10499,114,105,101,59,3,8885,8402,105,109,59,3,8764,8402,4,3,65,97,110,14440,14445,14468,114,114,59,1,8662,114,4,2,104,114,14452,14456,107,59,1,10531,4,2,59,111,14462,14464,1,8598,119,59,1,8598,101,97,114,59,1,10535,4,18,83,97,99,100,101,102,103,104,105,108,109,111,112,114,115,116,117,118,14512,14515,14535,14560,14597,14603,14618,14643,14657,14662,14701,14741,14747,14769,14851,14877,14907,14916,59,1,9416,4,2,99,115,14521,14531,117,116,101,5,243,1,59,14529,1,243,116,59,1,8859,4,2,105,121,14541,14557,114,4,2,59,99,14548,14550,1,8858,5,244,1,59,14555,1,244,59,1,1086,4,5,97,98,105,111,115,14572,14577,14583,14587,14591,115,104,59,1,8861,108,97,99,59,1,337,118,59,1,10808,116,59,1,8857,111,108,100,59,1,10684,108,105,103,59,1,339,4,2,99,114,14609,14614,105,114,59,1,10687,59,3,55349,56620,4,3,111,114,116,14626,14630,14640,110,59,1,731,97,118,101,5,242,1,59,14638,1,242,59,1,10689,4,2,98,109,14649,14654,97,114,59,1,10677,59,1,937,110,116,59,1,8750,4,4,97,99,105,116,14672,14677,14693,14698,114,114,59,1,8634,4,2,105,114,14683,14687,114,59,1,10686,111,115,115,59,1,10683,110,101,59,1,8254,59,1,10688,4,3,97,101,105,14709,14714,14719,99,114,59,1,333,103,97,59,1,969,4,3,99,100,110,14727,14733,14736,114,111,110,59,1,959,59,1,10678,117,115,59,1,8854,112,102,59,3,55349,56672,4,3,97,101,108,14755,14759,14764,114,59,1,10679,114,112,59,1,10681,117,115,59,1,8853,4,7,59,97,100,105,111,115,118,14785,14787,14792,14831,14837,14841,14848,1,8744,114,114,59,1,8635,4,4,59,101,102,109,14802,14804,14817,14824,1,10845,114,4,2,59,111,14811,14813,1,8500,102,59,1,8500,5,170,1,59,14822,1,170,5,186,1,59,14829,1,186,103,111,102,59,1,8886,114,59,1,10838,108,111,112,101,59,1,10839,59,1,10843,4,3,99,108,111,14859,14863,14873,114,59,1,8500,97,115,104,5,248,1,59,14871,1,248,108,59,1,8856,105,4,2,108,109,14884,14893,100,101,5,245,1,59,14891,1,245,101,115,4,2,59,97,14901,14903,1,8855,115,59,1,10806,109,108,5,246,1,59,14914,1,246,98,97,114,59,1,9021,4,12,97,99,101,102,104,105,108,109,111,114,115,117,14948,14992,14996,15033,15038,15068,15090,15189,15192,15222,15427,15441,114,4,4,59,97,115,116,14959,14961,14976,14989,1,8741,5,182,2,59,108,14968,14970,1,182,108,101,108,59,1,8741,4,2,105,108,14982,14986,109,59,1,10995,59,1,11005,59,1,8706,121,59,1,1087,114,4,5,99,105,109,112,116,15009,15014,15019,15024,15027,110,116,59,1,37,111,100,59,1,46,105,108,59,1,8240,59,1,8869,101,110,107,59,1,8241,114,59,3,55349,56621,4,3,105,109,111,15046,15057,15063,4,2,59,118,15052,15054,1,966,59,1,981,109,97,116,59,1,8499,110,101,59,1,9742,4,3,59,116,118,15076,15078,15087,1,960,99,104,102,111,114,107,59,1,8916,59,1,982,4,2,97,117,15096,15119,110,4,2,99,107,15103,15115,107,4,2,59,104,15110,15112,1,8463,59,1,8462,118,59,1,8463,115,4,9,59,97,98,99,100,101,109,115,116,15140,15142,15148,15151,15156,15168,15171,15179,15184,1,43,99,105,114,59,1,10787,59,1,8862,105,114,59,1,10786,4,2,111,117,15162,15165,59,1,8724,59,1,10789,59,1,10866,110,5,177,1,59,15177,1,177,105,109,59,1,10790,119,111,59,1,10791,59,1,177,4,3,105,112,117,15200,15208,15213,110,116,105,110,116,59,1,10773,102,59,3,55349,56673,110,100,5,163,1,59,15220,1,163,4,10,59,69,97,99,101,105,110,111,115,117,15244,15246,15249,15253,15258,15334,15347,15367,15416,15421,1,8826,59,1,10931,112,59,1,10935,117,101,59,1,8828,4,2,59,99,15264,15266,1,10927,4,6,59,97,99,101,110,115,15280,15282,15290,15299,15303,15329,1,8826,112,112,114,111,120,59,1,10935,117,114,108,121,101,113,59,1,8828,113,59,1,10927,4,3,97,101,115,15311,15319,15324,112,112,114,111,120,59,1,10937,113,113,59,1,10933,105,109,59,1,8936,105,109,59,1,8830,109,101,4,2,59,115,15342,15344,1,8242,59,1,8473,4,3,69,97,115,15355,15358,15362,59,1,10933,112,59,1,10937,105,109,59,1,8936,4,3,100,102,112,15375,15378,15404,59,1,8719,4,3,97,108,115,15386,15392,15398,108,97,114,59,1,9006,105,110,101,59,1,8978,117,114,102,59,1,8979,4,2,59,116,15410,15412,1,8733,111,59,1,8733,105,109,59,1,8830,114,101,108,59,1,8880,4,2,99,105,15433,15438,114,59,3,55349,56517,59,1,968,110,99,115,112,59,1,8200,4,6,102,105,111,112,115,117,15462,15467,15472,15478,15485,15491,114,59,3,55349,56622,110,116,59,1,10764,112,102,59,3,55349,56674,114,105,109,101,59,1,8279,99,114,59,3,55349,56518,4,3,97,101,111,15499,15520,15534,116,4,2,101,105,15506,15515,114,110,105,111,110,115,59,1,8461,110,116,59,1,10774,115,116,4,2,59,101,15528,15530,1,63,113,59,1,8799,116,5,34,1,59,15540,1,34,4,21,65,66,72,97,98,99,100,101,102,104,105,108,109,110,111,112,114,115,116,117,120,15586,15609,15615,15620,15796,15855,15893,15931,15977,16001,16039,16183,16204,16222,16228,16285,16312,16318,16363,16408,16416,4,3,97,114,116,15594,15599,15603,114,114,59,1,8667,114,59,1,8658,97,105,108,59,1,10524,97,114,114,59,1,10511,97,114,59,1,10596,4,7,99,100,101,110,113,114,116,15636,15651,15656,15664,15687,15696,15770,4,2,101,117,15642,15646,59,3,8765,817,116,101,59,1,341,105,99,59,1,8730,109,112,116,121,118,59,1,10675,103,4,4,59,100,101,108,15675,15677,15680,15683,1,10217,59,1,10642,59,1,10661,101,59,1,10217,117,111,5,187,1,59,15694,1,187,114,4,11,59,97,98,99,102,104,108,112,115,116,119,15721,15723,15727,15739,15742,15746,15750,15754,15758,15763,15767,1,8594,112,59,1,10613,4,2,59,102,15733,15735,1,8677,115,59,1,10528,59,1,10547,115,59,1,10526,107,59,1,8618,112,59,1,8620,108,59,1,10565,105,109,59,1,10612,108,59,1,8611,59,1,8605,4,2,97,105,15776,15781,105,108,59,1,10522,111,4,2,59,110,15788,15790,1,8758,97,108,115,59,1,8474,4,3,97,98,114,15804,15809,15814,114,114,59,1,10509,114,107,59,1,10099,4,2,97,107,15820,15833,99,4,2,101,107,15827,15830,59,1,125,59,1,93,4,2,101,115,15839,15842,59,1,10636,108,4,2,100,117,15849,15852,59,1,10638,59,1,10640,4,4,97,101,117,121,15865,15871,15886,15890,114,111,110,59,1,345,4,2,100,105,15877,15882,105,108,59,1,343,108,59,1,8969,98,59,1,125,59,1,1088,4,4,99,108,113,115,15903,15907,15914,15927,97,59,1,10551,100,104,97,114,59,1,10601,117,111,4,2,59,114,15922,15924,1,8221,59,1,8221,104,59,1,8627,4,3,97,99,103,15939,15966,15970,108,4,4,59,105,112,115,15950,15952,15957,15963,1,8476,110,101,59,1,8475,97,114,116,59,1,8476,59,1,8477,116,59,1,9645,5,174,1,59,15975,1,174,4,3,105,108,114,15985,15991,15997,115,104,116,59,1,10621,111,111,114,59,1,8971,59,3,55349,56623,4,2,97,111,16007,16028,114,4,2,100,117,16014,16017,59,1,8641,4,2,59,108,16023,16025,1,8640,59,1,10604,4,2,59,118,16034,16036,1,961,59,1,1009,4,3,103,110,115,16047,16167,16171,104,116,4,6,97,104,108,114,115,116,16063,16081,16103,16130,16143,16155,114,114,111,119,4,2,59,116,16073,16075,1,8594,97,105,108,59,1,8611,97,114,112,111,111,110,4,2,100,117,16093,16099,111,119,110,59,1,8641,112,59,1,8640,101,102,116,4,2,97,104,16112,16120,114,114,111,119,115,59,1,8644,97,114,112,111,111,110,115,59,1,8652,105,103,104,116,97,114,114,111,119,115,59,1,8649,113,117,105,103,97,114,114,111,119,59,1,8605,104,114,101,101,116,105,109,101,115,59,1,8908,103,59,1,730,105,110,103,100,111,116,115,101,113,59,1,8787,4,3,97,104,109,16191,16196,16201,114,114,59,1,8644,97,114,59,1,8652,59,1,8207,111,117,115,116,4,2,59,97,16214,16216,1,9137,99,104,101,59,1,9137,109,105,100,59,1,10990,4,4,97,98,112,116,16238,16252,16257,16278,4,2,110,114,16244,16248,103,59,1,10221,114,59,1,8702,114,107,59,1,10215,4,3,97,102,108,16265,16269,16273,114,59,1,10630,59,3,55349,56675,117,115,59,1,10798,105,109,101,115,59,1,10805,4,2,97,112,16291,16304,114,4,2,59,103,16298,16300,1,41,116,59,1,10644,111,108,105,110,116,59,1,10770,97,114,114,59,1,8649,4,4,97,99,104,113,16328,16334,16339,16342,113,117,111,59,1,8250,114,59,3,55349,56519,59,1,8625,4,2,98,117,16348,16351,59,1,93,111,4,2,59,114,16358,16360,1,8217,59,1,8217,4,3,104,105,114,16371,16377,16383,114,101,101,59,1,8908,109,101,115,59,1,8906,105,4,4,59,101,102,108,16394,16396,16399,16402,1,9657,59,1,8885,59,1,9656,116,114,105,59,1,10702,108,117,104,97,114,59,1,10600,59,1,8478,4,19,97,98,99,100,101,102,104,105,108,109,111,112,113,114,115,116,117,119,122,16459,16466,16472,16572,16590,16672,16687,16746,16844,16850,16924,16963,16988,17115,17121,17154,17206,17614,17656,99,117,116,101,59,1,347,113,117,111,59,1,8218,4,10,59,69,97,99,101,105,110,112,115,121,16494,16496,16499,16513,16518,16531,16536,16556,16564,16569,1,8827,59,1,10932,4,2,112,114,16505,16508,59,1,10936,111,110,59,1,353,117,101,59,1,8829,4,2,59,100,16524,16526,1,10928,105,108,59,1,351,114,99,59,1,349,4,3,69,97,115,16544,16547,16551,59,1,10934,112,59,1,10938,105,109,59,1,8937,111,108,105,110,116,59,1,10771,105,109,59,1,8831,59,1,1089,111,116,4,3,59,98,101,16582,16584,16587,1,8901,59,1,8865,59,1,10854,4,7,65,97,99,109,115,116,120,16606,16611,16634,16642,16646,16652,16668,114,114,59,1,8664,114,4,2,104,114,16618,16622,107,59,1,10533,4,2,59,111,16628,16630,1,8600,119,59,1,8600,116,5,167,1,59,16640,1,167,105,59,1,59,119,97,114,59,1,10537,109,4,2,105,110,16659,16665,110,117,115,59,1,8726,59,1,8726,116,59,1,10038,114,4,2,59,111,16679,16682,3,55349,56624,119,110,59,1,8994,4,4,97,99,111,121,16697,16702,16716,16739,114,112,59,1,9839,4,2,104,121,16708,16713,99,121,59,1,1097,59,1,1096,114,116,4,2,109,112,16724,16729,105,100,59,1,8739,97,114,97,108,108,101,108,59,1,8741,5,173,1,59,16744,1,173,4,2,103,109,16752,16770,109,97,4,3,59,102,118,16762,16764,16767,1,963,59,1,962,59,1,962,4,8,59,100,101,103,108,110,112,114,16788,16790,16795,16806,16817,16828,16832,16838,1,8764,111,116,59,1,10858,4,2,59,113,16801,16803,1,8771,59,1,8771,4,2,59,69,16812,16814,1,10910,59,1,10912,4,2,59,69,16823,16825,1,10909,59,1,10911,101,59,1,8774,108,117,115,59,1,10788,97,114,114,59,1,10610,97,114,114,59,1,8592,4,4,97,101,105,116,16860,16883,16891,16904,4,2,108,115,16866,16878,108,115,101,116,109,105,110,117,115,59,1,8726,104,112,59,1,10803,112,97,114,115,108,59,1,10724,4,2,100,108,16897,16900,59,1,8739,101,59,1,8995,4,2,59,101,16910,16912,1,10922,4,2,59,115,16918,16920,1,10924,59,3,10924,65024,4,3,102,108,112,16932,16938,16958,116,99,121,59,1,1100,4,2,59,98,16944,16946,1,47,4,2,59,97,16952,16954,1,10692,114,59,1,9023,102,59,3,55349,56676,97,4,2,100,114,16970,16985,101,115,4,2,59,117,16978,16980,1,9824,105,116,59,1,9824,59,1,8741,4,3,99,115,117,16996,17028,17089,4,2,97,117,17002,17015,112,4,2,59,115,17009,17011,1,8851,59,3,8851,65024,112,4,2,59,115,17022,17024,1,8852,59,3,8852,65024,117,4,2,98,112,17035,17062,4,3,59,101,115,17043,17045,17048,1,8847,59,1,8849,101,116,4,2,59,101,17056,17058,1,8847,113,59,1,8849,4,3,59,101,115,17070,17072,17075,1,8848,59,1,8850,101,116,4,2,59,101,17083,17085,1,8848,113,59,1,8850,4,3,59,97,102,17097,17099,17112,1,9633,114,4,2,101,102,17106,17109,59,1,9633,59,1,9642,59,1,9642,97,114,114,59,1,8594,4,4,99,101,109,116,17131,17136,17142,17148,114,59,3,55349,56520,116,109,110,59,1,8726,105,108,101,59,1,8995,97,114,102,59,1,8902,4,2,97,114,17160,17172,114,4,2,59,102,17167,17169,1,9734,59,1,9733,4,2,97,110,17178,17202,105,103,104,116,4,2,101,112,17188,17197,112,115,105,108,111,110,59,1,1013,104,105,59,1,981,115,59,1,175,4,5,98,99,109,110,112,17218,17351,17420,17423,17427,4,9,59,69,100,101,109,110,112,114,115,17238,17240,17243,17248,17261,17267,17279,17285,17291,1,8834,59,1,10949,111,116,59,1,10941,4,2,59,100,17254,17256,1,8838,111,116,59,1,10947,117,108,116,59,1,10945,4,2,69,101,17273,17276,59,1,10955,59,1,8842,108,117,115,59,1,10943,97,114,114,59,1,10617,4,3,101,105,117,17299,17335,17339,116,4,3,59,101,110,17308,17310,17322,1,8834,113,4,2,59,113,17317,17319,1,8838,59,1,10949,101,113,4,2,59,113,17330,17332,1,8842,59,1,10955,109,59,1,10951,4,2,98,112,17345,17348,59,1,10965,59,1,10963,99,4,6,59,97,99,101,110,115,17366,17368,17376,17385,17389,17415,1,8827,112,112,114,111,120,59,1,10936,117,114,108,121,101,113,59,1,8829,113,59,1,10928,4,3,97,101,115,17397,17405,17410,112,112,114,111,120,59,1,10938,113,113,59,1,10934,105,109,59,1,8937,105,109,59,1,8831,59,1,8721,103,59,1,9834,4,13,49,50,51,59,69,100,101,104,108,109,110,112,115,17455,17462,17469,17476,17478,17481,17496,17509,17524,17530,17536,17548,17554,5,185,1,59,17460,1,185,5,178,1,59,17467,1,178,5,179,1,59,17474,1,179,1,8835,59,1,10950,4,2,111,115,17487,17491,116,59,1,10942,117,98,59,1,10968,4,2,59,100,17502,17504,1,8839,111,116,59,1,10948,115,4,2,111,117,17516,17520,108,59,1,10185,98,59,1,10967,97,114,114,59,1,10619,117,108,116,59,1,10946,4,2,69,101,17542,17545,59,1,10956,59,1,8843,108,117,115,59,1,10944,4,3,101,105,117,17562,17598,17602,116,4,3,59,101,110,17571,17573,17585,1,8835,113,4,2,59,113,17580,17582,1,8839,59,1,10950,101,113,4,2,59,113,17593,17595,1,8843,59,1,10956,109,59,1,10952,4,2,98,112,17608,17611,59,1,10964,59,1,10966,4,3,65,97,110,17622,17627,17650,114,114,59,1,8665,114,4,2,104,114,17634,17638,107,59,1,10534,4,2,59,111,17644,17646,1,8601,119,59,1,8601,119,97,114,59,1,10538,108,105,103,5,223,1,59,17664,1,223,4,13,97,98,99,100,101,102,104,105,111,112,114,115,119,17694,17709,17714,17737,17742,17749,17754,17860,17905,17957,17964,18090,18122,4,2,114,117,17700,17706,103,101,116,59,1,8982,59,1,964,114,107,59,1,9140,4,3,97,101,121,17722,17728,17734,114,111,110,59,1,357,100,105,108,59,1,355,59,1,1090,111,116,59,1,8411,108,114,101,99,59,1,8981,114,59,3,55349,56625,4,4,101,105,107,111,17764,17805,17836,17851,4,2,114,116,17770,17786,101,4,2,52,102,17777,17780,59,1,8756,111,114,101,59,1,8756,97,4,3,59,115,118,17795,17797,17802,1,952,121,109,59,1,977,59,1,977,4,2,99,110,17811,17831,107,4,2,97,115,17818,17826,112,112,114,111,120,59,1,8776,105,109,59,1,8764,115,112,59,1,8201,4,2,97,115,17842,17846,112,59,1,8776,105,109,59,1,8764,114,110,5,254,1,59,17858,1,254,4,3,108,109,110,17868,17873,17901,100,101,59,1,732,101,115,5,215,3,59,98,100,17884,17886,17898,1,215,4,2,59,97,17892,17894,1,8864,114,59,1,10801,59,1,10800,116,59,1,8749,4,3,101,112,115,17913,17917,17953,97,59,1,10536,4,4,59,98,99,102,17927,17929,17934,17939,1,8868,111,116,59,1,9014,105,114,59,1,10993,4,2,59,111,17945,17948,3,55349,56677,114,107,59,1,10970,97,59,1,10537,114,105,109,101,59,1,8244,4,3,97,105,112,17972,17977,18082,100,101,59,1,8482,4,7,97,100,101,109,112,115,116,17993,18051,18056,18059,18066,18072,18076,110,103,108,101,4,5,59,100,108,113,114,18009,18011,18017,18032,18035,1,9653,111,119,110,59,1,9663,101,102,116,4,2,59,101,18026,18028,1,9667,113,59,1,8884,59,1,8796,105,103,104,116,4,2,59,101,18045,18047,1,9657,113,59,1,8885,111,116,59,1,9708,59,1,8796,105,110,117,115,59,1,10810,108,117,115,59,1,10809,98,59,1,10701,105,109,101,59,1,10811,101,122,105,117,109,59,1,9186,4,3,99,104,116,18098,18111,18116,4,2,114,121,18104,18108,59,3,55349,56521,59,1,1094,99,121,59,1,1115,114,111,107,59,1,359,4,2,105,111,18128,18133,120,116,59,1,8812,104,101,97,100,4,2,108,114,18143,18154,101,102,116,97,114,114,111,119,59,1,8606,105,103,104,116,97,114,114,111,119,59,1,8608,4,18,65,72,97,98,99,100,102,103,104,108,109,111,112,114,115,116,117,119,18204,18209,18214,18234,18250,18268,18292,18308,18319,18343,18379,18397,18413,18504,18547,18553,18584,18603,114,114,59,1,8657,97,114,59,1,10595,4,2,99,114,18220,18230,117,116,101,5,250,1,59,18228,1,250,114,59,1,8593,114,4,2,99,101,18241,18245,121,59,1,1118,118,101,59,1,365,4,2,105,121,18256,18265,114,99,5,251,1,59,18263,1,251,59,1,1091,4,3,97,98,104,18276,18281,18287,114,114,59,1,8645,108,97,99,59,1,369,97,114,59,1,10606,4,2,105,114,18298,18304,115,104,116,59,1,10622,59,3,55349,56626,114,97,118,101,5,249,1,59,18317,1,249,4,2,97,98,18325,18338,114,4,2,108,114,18332,18335,59,1,8639,59,1,8638,108,107,59,1,9600,4,2,99,116,18349,18374,4,2,111,114,18355,18369,114,110,4,2,59,101,18363,18365,1,8988,114,59,1,8988,111,112,59,1,8975,114,105,59,1,9720,4,2,97,108,18385,18390,99,114,59,1,363,5,168,1,59,18395,1,168,4,2,103,112,18403,18408,111,110,59,1,371,102,59,3,55349,56678,4,6,97,100,104,108,115,117,18427,18434,18445,18470,18475,18494,114,114,111,119,59,1,8593,111,119,110,97,114,114,111,119,59,1,8597,97,114,112,111,111,110,4,2,108,114,18457,18463,101,102,116,59,1,8639,105,103,104,116,59,1,8638,117,115,59,1,8846,105,4,3,59,104,108,18484,18486,18489,1,965,59,1,978,111,110,59,1,965,112,97,114,114,111,119,115,59,1,8648,4,3,99,105,116,18512,18537,18542,4,2,111,114,18518,18532,114,110,4,2,59,101,18526,18528,1,8989,114,59,1,8989,111,112,59,1,8974,110,103,59,1,367,114,105,59,1,9721,99,114,59,3,55349,56522,4,3,100,105,114,18561,18566,18572,111,116,59,1,8944,108,100,101,59,1,361,105,4,2,59,102,18579,18581,1,9653,59,1,9652,4,2,97,109,18590,18595,114,114,59,1,8648,108,5,252,1,59,18601,1,252,97,110,103,108,101,59,1,10663,4,15,65,66,68,97,99,100,101,102,108,110,111,112,114,115,122,18643,18648,18661,18667,18847,18851,18857,18904,18909,18915,18931,18937,18943,18949,18996,114,114,59,1,8661,97,114,4,2,59,118,18656,18658,1,10984,59,1,10985,97,115,104,59,1,8872,4,2,110,114,18673,18679,103,114,116,59,1,10652,4,7,101,107,110,112,114,115,116,18695,18704,18711,18720,18742,18754,18810,112,115,105,108,111,110,59,1,1013,97,112,112,97,59,1,1008,111,116,104,105,110,103,59,1,8709,4,3,104,105,114,18728,18732,18735,105,59,1,981,59,1,982,111,112,116,111,59,1,8733,4,2,59,104,18748,18750,1,8597,111,59,1,1009,4,2,105,117,18760,18766,103,109,97,59,1,962,4,2,98,112,18772,18791,115,101,116,110,101,113,4,2,59,113,18784,18787,3,8842,65024,59,3,10955,65024,115,101,116,110,101,113,4,2,59,113,18803,18806,3,8843,65024,59,3,10956,65024,4,2,104,114,18816,18822,101,116,97,59,1,977,105,97,110,103,108,101,4,2,108,114,18834,18840,101,102,116,59,1,8882,105,103,104,116,59,1,8883,121,59,1,1074,97,115,104,59,1,8866,4,3,101,108,114,18865,18884,18890,4,3,59,98,101,18873,18875,18880,1,8744,97,114,59,1,8891,113,59,1,8794,108,105,112,59,1,8942,4,2,98,116,18896,18901,97,114,59,1,124,59,1,124,114,59,3,55349,56627,116,114,105,59,1,8882,115,117,4,2,98,112,18923,18927,59,3,8834,8402,59,3,8835,8402,112,102,59,3,55349,56679,114,111,112,59,1,8733,116,114,105,59,1,8883,4,2,99,117,18955,18960,114,59,3,55349,56523,4,2,98,112,18966,18981,110,4,2,69,101,18973,18977,59,3,10955,65024,59,3,8842,65024,110,4,2,69,101,18988,18992,59,3,10956,65024,59,3,8843,65024,105,103,122,97,103,59,1,10650,4,7,99,101,102,111,112,114,115,19020,19026,19061,19066,19072,19075,19089,105,114,99,59,1,373,4,2,100,105,19032,19055,4,2,98,103,19038,19043,97,114,59,1,10847,101,4,2,59,113,19050,19052,1,8743,59,1,8793,101,114,112,59,1,8472,114,59,3,55349,56628,112,102,59,3,55349,56680,59,1,8472,4,2,59,101,19081,19083,1,8768,97,116,104,59,1,8768,99,114,59,3,55349,56524,4,14,99,100,102,104,105,108,109,110,111,114,115,117,118,119,19125,19146,19152,19157,19173,19176,19192,19197,19202,19236,19252,19269,19286,19291,4,3,97,105,117,19133,19137,19142,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,116,114,105,59,1,9661,114,59,3,55349,56629,4,2,65,97,19163,19168,114,114,59,1,10234,114,114,59,1,10231,59,1,958,4,2,65,97,19182,19187,114,114,59,1,10232,114,114,59,1,10229,97,112,59,1,10236,105,115,59,1,8955,4,3,100,112,116,19210,19215,19230,111,116,59,1,10752,4,2,102,108,19221,19225,59,3,55349,56681,117,115,59,1,10753,105,109,101,59,1,10754,4,2,65,97,19242,19247,114,114,59,1,10233,114,114,59,1,10230,4,2,99,113,19258,19263,114,59,3,55349,56525,99,117,112,59,1,10758,4,2,112,116,19275,19281,108,117,115,59,1,10756,114,105,59,1,9651,101,101,59,1,8897,101,100,103,101,59,1,8896,4,8,97,99,101,102,105,111,115,117,19316,19335,19349,19357,19362,19367,19373,19379,99,4,2,117,121,19323,19332,116,101,5,253,1,59,19330,1,253,59,1,1103,4,2,105,121,19341,19346,114,99,59,1,375,59,1,1099,110,5,165,1,59,19355,1,165,114,59,3,55349,56630,99,121,59,1,1111,112,102,59,3,55349,56682,99,114,59,3,55349,56526,4,2,99,109,19385,19389,121,59,1,1102,108,5,255,1,59,19395,1,255,4,10,97,99,100,101,102,104,105,111,115,119,19419,19426,19441,19446,19462,19467,19472,19480,19486,19492,99,117,116,101,59,1,378,4,2,97,121,19432,19438,114,111,110,59,1,382,59,1,1079,111,116,59,1,380,4,2,101,116,19452,19458,116,114,102,59,1,8488,97,59,1,950,114,59,3,55349,56631,99,121,59,1,1078,103,114,97,114,114,59,1,8669,112,102,59,3,55349,56683,99,114,59,3,55349,56527,4,2,106,110,19498,19501,59,1,8205,106,59,1,8204]);const Oe=s,Se=r,Ce={128:8364,130:8218,131:402,132:8222,133:8230,134:8224,135:8225,136:710,137:8240,138:352,139:8249,140:338,142:381,145:8216,146:8217,147:8220,148:8221,149:8226,150:8211,151:8212,152:732,153:8482,154:353,155:8250,156:339,158:382,159:376},de="DATA_STATE";function Re(e){return e===Oe.SPACE||e===Oe.LINE_FEED||e===Oe.TABULATION||e===Oe.FORM_FEED}function Ie(e){return e>=Oe.DIGIT_0&&e<=Oe.DIGIT_9}function fe(e){return e>=Oe.LATIN_CAPITAL_A&&e<=Oe.LATIN_CAPITAL_Z}function Me(e){return e>=Oe.LATIN_SMALL_A&&e<=Oe.LATIN_SMALL_Z}function Le(e){return Me(e)||fe(e)}function De(e){return Le(e)||Ie(e)}function ge(e){return e>=Oe.LATIN_CAPITAL_A&&e<=Oe.LATIN_CAPITAL_F}function Pe(e){return e>=Oe.LATIN_SMALL_A&&e<=Oe.LATIN_SMALL_F}function ke(e){return e+32}function He(e){return e<=65535?String.fromCharCode(e):(e-=65536,String.fromCharCode(e>>>10&1023|55296)+String.fromCharCode(56320|1023&e))}function Ue(e){return String.fromCharCode(ke(e))}function Fe(e,t){const n=ue[++e];let s=++e,r=s+n-1;for(;s<=r;){const e=s+r>>>1,i=ue[e];if(i<t)s=e+1;else{if(!(i>t))return ue[e+n];r=e-1;}}return -1}class Be{constructor(){this.preprocessor=new Ne,this.tokenQueue=[],this.allowCDATA=!1,this.state=de,this.returnState="",this.charRefCode=-1,this.tempBuff=[],this.lastStartTagName="",this.consumedAfterSnapshot=-1,this.active=!1,this.currentCharacterToken=null,this.currentToken=null,this.currentAttr=null;}_err(){}_errOnNextCodePoint(e){this._consume(),this._err(e),this._unconsume();}getNextToken(){for(;!this.tokenQueue.length&&this.active;){this.consumedAfterSnapshot=0;const e=this._consume();this._ensureHibernation()||this[this.state](e);}return this.tokenQueue.shift()}write(e,t){this.active=!0,this.preprocessor.write(e,t);}insertHtmlAtCurrentPos(e){this.active=!0,this.preprocessor.insertHtmlAtCurrentPos(e);}_ensureHibernation(){if(this.preprocessor.endOfChunkHit){for(;this.consumedAfterSnapshot>0;this.consumedAfterSnapshot--)this.preprocessor.retreat();return this.active=!1,this.tokenQueue.push({type:Be.HIBERNATION_TOKEN}),!0}return !1}_consume(){return this.consumedAfterSnapshot++,this.preprocessor.advance()}_unconsume(){this.consumedAfterSnapshot--,this.preprocessor.retreat();}_reconsumeInState(e){this.state=e,this._unconsume();}_consumeSequenceIfMatch(e,t,n){let s=0,r=!0;const i=e.length;let T=0,o=t,E=void 0;for(;T<i;T++){if(T>0&&(o=this._consume(),s++),o===Oe.EOF){r=!1;break}if(E=e[T],o!==E&&(n||o!==ke(E))){r=!1;break}}if(!r)for(;s--;)this._unconsume();return r}_isTempBufferEqualToScriptString(){if(this.tempBuff.length!==Se.SCRIPT_STRING.length)return !1;for(let e=0;e<this.tempBuff.length;e++)if(this.tempBuff[e]!==Se.SCRIPT_STRING[e])return !1;return !0}_createStartTagToken(){this.currentToken={type:Be.START_TAG_TOKEN,tagName:"",selfClosing:!1,ackSelfClosing:!1,attrs:[]};}_createEndTagToken(){this.currentToken={type:Be.END_TAG_TOKEN,tagName:"",selfClosing:!1,attrs:[]};}_createCommentToken(){this.currentToken={type:Be.COMMENT_TOKEN,data:""};}_createDoctypeToken(e){this.currentToken={type:Be.DOCTYPE_TOKEN,name:e,forceQuirks:!1,publicId:null,systemId:null};}_createCharacterToken(e,t){this.currentCharacterToken={type:e,chars:t};}_createEOFToken(){this.currentToken={type:Be.EOF_TOKEN};}_createAttr(e){this.currentAttr={name:e,value:""};}_leaveAttrName(e){null===Be.getTokenAttr(this.currentToken,this.currentAttr.name)?this.currentToken.attrs.push(this.currentAttr):this._err(re),this.state=e;}_leaveAttrValue(e){this.state=e;}_emitCurrentToken(){this._emitCurrentCharacterToken();const e=this.currentToken;this.currentToken=null,e.type===Be.START_TAG_TOKEN?this.lastStartTagName=e.tagName:e.type===Be.END_TAG_TOKEN&&(e.attrs.length>0&&this._err(l),e.selfClosing&&this._err(m)),this.tokenQueue.push(e);}_emitCurrentCharacterToken(){this.currentCharacterToken&&(this.tokenQueue.push(this.currentCharacterToken),this.currentCharacterToken=null);}_emitEOFToken(){this._createEOFToken(),this._emitCurrentToken();}_appendCharToCurrentCharacterToken(e,t){this.currentCharacterToken&&this.currentCharacterToken.type!==e&&this._emitCurrentCharacterToken(),this.currentCharacterToken?this.currentCharacterToken.chars+=t:this._createCharacterToken(e,t);}_emitCodePoint(e){let t=Be.CHARACTER_TOKEN;Re(e)?t=Be.WHITESPACE_CHARACTER_TOKEN:e===Oe.NULL&&(t=Be.NULL_CHARACTER_TOKEN),this._appendCharToCurrentCharacterToken(t,He(e));}_emitSeveralCodePoints(e){for(let t=0;t<e.length;t++)this._emitCodePoint(e[t]);}_emitChars(e){this._appendCharToCurrentCharacterToken(Be.CHARACTER_TOKEN,e);}_matchNamedCharacterReference(e){let t=null,n=1,s=Fe(0,e);for(this.tempBuff.push(e);s>-1;){const e=ue[s],r=e<7;r&&1&e&&(t=2&e?[ue[++s],ue[++s]]:[ue[++s]],n=0);const i=this._consume();if(this.tempBuff.push(i),n++,i===Oe.EOF)break;s=r?4&e?Fe(s,i):-1:i===e?++s:-1;}for(;n--;)this.tempBuff.pop(),this._unconsume();return t}_isCharacterReferenceInAttribute(){return "ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE"===this.returnState||"ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE"===this.returnState||"ATTRIBUTE_VALUE_UNQUOTED_STATE"===this.returnState}_isCharacterReferenceAttributeQuirk(e){if(!e&&this._isCharacterReferenceInAttribute()){const e=this._consume();return this._unconsume(),e===Oe.EQUALS_SIGN||De(e)}return !1}_flushCodePointsConsumedAsCharacterReference(){if(this._isCharacterReferenceInAttribute())for(let e=0;e<this.tempBuff.length;e++)this.currentAttr.value+=He(this.tempBuff[e]);else this._emitSeveralCodePoints(this.tempBuff);this.tempBuff=[];}[de](e){this.preprocessor.dropParsedChunk(),e===Oe.LESS_THAN_SIGN?this.state="TAG_OPEN_STATE":e===Oe.AMPERSAND?(this.returnState=de,this.state="CHARACTER_REFERENCE_STATE"):e===Oe.NULL?(this._err(N),this._emitCodePoint(e)):e===Oe.EOF?this._emitEOFToken():this._emitCodePoint(e);}RCDATA_STATE(e){this.preprocessor.dropParsedChunk(),e===Oe.AMPERSAND?(this.returnState="RCDATA_STATE",this.state="CHARACTER_REFERENCE_STATE"):e===Oe.LESS_THAN_SIGN?this.state="RCDATA_LESS_THAN_SIGN_STATE":e===Oe.NULL?(this._err(N),this._emitChars(n)):e===Oe.EOF?this._emitEOFToken():this._emitCodePoint(e);}RAWTEXT_STATE(e){this.preprocessor.dropParsedChunk(),e===Oe.LESS_THAN_SIGN?this.state="RAWTEXT_LESS_THAN_SIGN_STATE":e===Oe.NULL?(this._err(N),this._emitChars(n)):e===Oe.EOF?this._emitEOFToken():this._emitCodePoint(e);}SCRIPT_DATA_STATE(e){this.preprocessor.dropParsedChunk(),e===Oe.LESS_THAN_SIGN?this.state="SCRIPT_DATA_LESS_THAN_SIGN_STATE":e===Oe.NULL?(this._err(N),this._emitChars(n)):e===Oe.EOF?this._emitEOFToken():this._emitCodePoint(e);}PLAINTEXT_STATE(e){this.preprocessor.dropParsedChunk(),e===Oe.NULL?(this._err(N),this._emitChars(n)):e===Oe.EOF?this._emitEOFToken():this._emitCodePoint(e);}TAG_OPEN_STATE(e){e===Oe.EXCLAMATION_MARK?this.state="MARKUP_DECLARATION_OPEN_STATE":e===Oe.SOLIDUS?this.state="END_TAG_OPEN_STATE":Le(e)?(this._createStartTagToken(),this._reconsumeInState("TAG_NAME_STATE")):e===Oe.QUESTION_MARK?(this._err(u),this._createCommentToken(),this._reconsumeInState("BOGUS_COMMENT_STATE")):e===Oe.EOF?(this._err(L),this._emitChars("<"),this._emitEOFToken()):(this._err(O),this._emitChars("<"),this._reconsumeInState(de));}END_TAG_OPEN_STATE(e){Le(e)?(this._createEndTagToken(),this._reconsumeInState("TAG_NAME_STATE")):e===Oe.GREATER_THAN_SIGN?(this._err(C),this.state=de):e===Oe.EOF?(this._err(L),this._emitChars("</"),this._emitEOFToken()):(this._err(O),this._createCommentToken(),this._reconsumeInState("BOGUS_COMMENT_STATE"));}TAG_NAME_STATE(e){Re(e)?this.state="BEFORE_ATTRIBUTE_NAME_STATE":e===Oe.SOLIDUS?this.state="SELF_CLOSING_START_TAG_STATE":e===Oe.GREATER_THAN_SIGN?(this.state=de,this._emitCurrentToken()):fe(e)?this.currentToken.tagName+=Ue(e):e===Oe.NULL?(this._err(N),this.currentToken.tagName+=n):e===Oe.EOF?(this._err(D),this._emitEOFToken()):this.currentToken.tagName+=He(e);}RCDATA_LESS_THAN_SIGN_STATE(e){e===Oe.SOLIDUS?(this.tempBuff=[],this.state="RCDATA_END_TAG_OPEN_STATE"):(this._emitChars("<"),this._reconsumeInState("RCDATA_STATE"));}RCDATA_END_TAG_OPEN_STATE(e){Le(e)?(this._createEndTagToken(),this._reconsumeInState("RCDATA_END_TAG_NAME_STATE")):(this._emitChars("</"),this._reconsumeInState("RCDATA_STATE"));}RCDATA_END_TAG_NAME_STATE(e){if(fe(e))this.currentToken.tagName+=Ue(e),this.tempBuff.push(e);else if(Me(e))this.currentToken.tagName+=He(e),this.tempBuff.push(e);else{if(this.lastStartTagName===this.currentToken.tagName){if(Re(e))return void(this.state="BEFORE_ATTRIBUTE_NAME_STATE");if(e===Oe.SOLIDUS)return void(this.state="SELF_CLOSING_START_TAG_STATE");if(e===Oe.GREATER_THAN_SIGN)return this.state=de,void this._emitCurrentToken()}this._emitChars("</"),this._emitSeveralCodePoints(this.tempBuff),this._reconsumeInState("RCDATA_STATE");}}RAWTEXT_LESS_THAN_SIGN_STATE(e){e===Oe.SOLIDUS?(this.tempBuff=[],this.state="RAWTEXT_END_TAG_OPEN_STATE"):(this._emitChars("<"),this._reconsumeInState("RAWTEXT_STATE"));}RAWTEXT_END_TAG_OPEN_STATE(e){Le(e)?(this._createEndTagToken(),this._reconsumeInState("RAWTEXT_END_TAG_NAME_STATE")):(this._emitChars("</"),this._reconsumeInState("RAWTEXT_STATE"));}RAWTEXT_END_TAG_NAME_STATE(e){if(fe(e))this.currentToken.tagName+=Ue(e),this.tempBuff.push(e);else if(Me(e))this.currentToken.tagName+=He(e),this.tempBuff.push(e);else{if(this.lastStartTagName===this.currentToken.tagName){if(Re(e))return void(this.state="BEFORE_ATTRIBUTE_NAME_STATE");if(e===Oe.SOLIDUS)return void(this.state="SELF_CLOSING_START_TAG_STATE");if(e===Oe.GREATER_THAN_SIGN)return this._emitCurrentToken(),void(this.state=de)}this._emitChars("</"),this._emitSeveralCodePoints(this.tempBuff),this._reconsumeInState("RAWTEXT_STATE");}}SCRIPT_DATA_LESS_THAN_SIGN_STATE(e){e===Oe.SOLIDUS?(this.tempBuff=[],this.state="SCRIPT_DATA_END_TAG_OPEN_STATE"):e===Oe.EXCLAMATION_MARK?(this.state="SCRIPT_DATA_ESCAPE_START_STATE",this._emitChars("<!")):(this._emitChars("<"),this._reconsumeInState("SCRIPT_DATA_STATE"));}SCRIPT_DATA_END_TAG_OPEN_STATE(e){Le(e)?(this._createEndTagToken(),this._reconsumeInState("SCRIPT_DATA_END_TAG_NAME_STATE")):(this._emitChars("</"),this._reconsumeInState("SCRIPT_DATA_STATE"));}SCRIPT_DATA_END_TAG_NAME_STATE(e){if(fe(e))this.currentToken.tagName+=Ue(e),this.tempBuff.push(e);else if(Me(e))this.currentToken.tagName+=He(e),this.tempBuff.push(e);else{if(this.lastStartTagName===this.currentToken.tagName){if(Re(e))return void(this.state="BEFORE_ATTRIBUTE_NAME_STATE");if(e===Oe.SOLIDUS)return void(this.state="SELF_CLOSING_START_TAG_STATE");if(e===Oe.GREATER_THAN_SIGN)return this._emitCurrentToken(),void(this.state=de)}this._emitChars("</"),this._emitSeveralCodePoints(this.tempBuff),this._reconsumeInState("SCRIPT_DATA_STATE");}}SCRIPT_DATA_ESCAPE_START_STATE(e){e===Oe.HYPHEN_MINUS?(this.state="SCRIPT_DATA_ESCAPE_START_DASH_STATE",this._emitChars("-")):this._reconsumeInState("SCRIPT_DATA_STATE");}SCRIPT_DATA_ESCAPE_START_DASH_STATE(e){e===Oe.HYPHEN_MINUS?(this.state="SCRIPT_DATA_ESCAPED_DASH_DASH_STATE",this._emitChars("-")):this._reconsumeInState("SCRIPT_DATA_STATE");}SCRIPT_DATA_ESCAPED_STATE(e){e===Oe.HYPHEN_MINUS?(this.state="SCRIPT_DATA_ESCAPED_DASH_STATE",this._emitChars("-")):e===Oe.LESS_THAN_SIGN?this.state="SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE":e===Oe.NULL?(this._err(N),this._emitChars(n)):e===Oe.EOF?(this._err(v),this._emitEOFToken()):this._emitCodePoint(e);}SCRIPT_DATA_ESCAPED_DASH_STATE(e){e===Oe.HYPHEN_MINUS?(this.state="SCRIPT_DATA_ESCAPED_DASH_DASH_STATE",this._emitChars("-")):e===Oe.LESS_THAN_SIGN?this.state="SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE":e===Oe.NULL?(this._err(N),this.state="SCRIPT_DATA_ESCAPED_STATE",this._emitChars(n)):e===Oe.EOF?(this._err(v),this._emitEOFToken()):(this.state="SCRIPT_DATA_ESCAPED_STATE",this._emitCodePoint(e));}SCRIPT_DATA_ESCAPED_DASH_DASH_STATE(e){e===Oe.HYPHEN_MINUS?this._emitChars("-"):e===Oe.LESS_THAN_SIGN?this.state="SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE":e===Oe.GREATER_THAN_SIGN?(this.state="SCRIPT_DATA_STATE",this._emitChars(">")):e===Oe.NULL?(this._err(N),this.state="SCRIPT_DATA_ESCAPED_STATE",this._emitChars(n)):e===Oe.EOF?(this._err(v),this._emitEOFToken()):(this.state="SCRIPT_DATA_ESCAPED_STATE",this._emitCodePoint(e));}SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE(e){e===Oe.SOLIDUS?(this.tempBuff=[],this.state="SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE"):Le(e)?(this.tempBuff=[],this._emitChars("<"),this._reconsumeInState("SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE")):(this._emitChars("<"),this._reconsumeInState("SCRIPT_DATA_ESCAPED_STATE"));}SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE(e){Le(e)?(this._createEndTagToken(),this._reconsumeInState("SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE")):(this._emitChars("</"),this._reconsumeInState("SCRIPT_DATA_ESCAPED_STATE"));}SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE(e){if(fe(e))this.currentToken.tagName+=Ue(e),this.tempBuff.push(e);else if(Me(e))this.currentToken.tagName+=He(e),this.tempBuff.push(e);else{if(this.lastStartTagName===this.currentToken.tagName){if(Re(e))return void(this.state="BEFORE_ATTRIBUTE_NAME_STATE");if(e===Oe.SOLIDUS)return void(this.state="SELF_CLOSING_START_TAG_STATE");if(e===Oe.GREATER_THAN_SIGN)return this._emitCurrentToken(),void(this.state=de)}this._emitChars("</"),this._emitSeveralCodePoints(this.tempBuff),this._reconsumeInState("SCRIPT_DATA_ESCAPED_STATE");}}SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE(e){Re(e)||e===Oe.SOLIDUS||e===Oe.GREATER_THAN_SIGN?(this.state=this._isTempBufferEqualToScriptString()?"SCRIPT_DATA_DOUBLE_ESCAPED_STATE":"SCRIPT_DATA_ESCAPED_STATE",this._emitCodePoint(e)):fe(e)?(this.tempBuff.push(ke(e)),this._emitCodePoint(e)):Me(e)?(this.tempBuff.push(e),this._emitCodePoint(e)):this._reconsumeInState("SCRIPT_DATA_ESCAPED_STATE");}SCRIPT_DATA_DOUBLE_ESCAPED_STATE(e){e===Oe.HYPHEN_MINUS?(this.state="SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE",this._emitChars("-")):e===Oe.LESS_THAN_SIGN?(this.state="SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE",this._emitChars("<")):e===Oe.NULL?(this._err(N),this._emitChars(n)):e===Oe.EOF?(this._err(v),this._emitEOFToken()):this._emitCodePoint(e);}SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE(e){e===Oe.HYPHEN_MINUS?(this.state="SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE",this._emitChars("-")):e===Oe.LESS_THAN_SIGN?(this.state="SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE",this._emitChars("<")):e===Oe.NULL?(this._err(N),this.state="SCRIPT_DATA_DOUBLE_ESCAPED_STATE",this._emitChars(n)):e===Oe.EOF?(this._err(v),this._emitEOFToken()):(this.state="SCRIPT_DATA_DOUBLE_ESCAPED_STATE",this._emitCodePoint(e));}SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE(e){e===Oe.HYPHEN_MINUS?this._emitChars("-"):e===Oe.LESS_THAN_SIGN?(this.state="SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE",this._emitChars("<")):e===Oe.GREATER_THAN_SIGN?(this.state="SCRIPT_DATA_STATE",this._emitChars(">")):e===Oe.NULL?(this._err(N),this.state="SCRIPT_DATA_DOUBLE_ESCAPED_STATE",this._emitChars(n)):e===Oe.EOF?(this._err(v),this._emitEOFToken()):(this.state="SCRIPT_DATA_DOUBLE_ESCAPED_STATE",this._emitCodePoint(e));}SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE(e){e===Oe.SOLIDUS?(this.tempBuff=[],this.state="SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE",this._emitChars("/")):this._reconsumeInState("SCRIPT_DATA_DOUBLE_ESCAPED_STATE");}SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE(e){Re(e)||e===Oe.SOLIDUS||e===Oe.GREATER_THAN_SIGN?(this.state=this._isTempBufferEqualToScriptString()?"SCRIPT_DATA_ESCAPED_STATE":"SCRIPT_DATA_DOUBLE_ESCAPED_STATE",this._emitCodePoint(e)):fe(e)?(this.tempBuff.push(ke(e)),this._emitCodePoint(e)):Me(e)?(this.tempBuff.push(e),this._emitCodePoint(e)):this._reconsumeInState("SCRIPT_DATA_DOUBLE_ESCAPED_STATE");}BEFORE_ATTRIBUTE_NAME_STATE(e){Re(e)||(e===Oe.SOLIDUS||e===Oe.GREATER_THAN_SIGN||e===Oe.EOF?this._reconsumeInState("AFTER_ATTRIBUTE_NAME_STATE"):e===Oe.EQUALS_SIGN?(this._err(S),this._createAttr("="),this.state="ATTRIBUTE_NAME_STATE"):(this._createAttr(""),this._reconsumeInState("ATTRIBUTE_NAME_STATE")));}ATTRIBUTE_NAME_STATE(e){Re(e)||e===Oe.SOLIDUS||e===Oe.GREATER_THAN_SIGN||e===Oe.EOF?(this._leaveAttrName("AFTER_ATTRIBUTE_NAME_STATE"),this._unconsume()):e===Oe.EQUALS_SIGN?this._leaveAttrName("BEFORE_ATTRIBUTE_VALUE_STATE"):fe(e)?this.currentAttr.name+=Ue(e):e===Oe.QUOTATION_MARK||e===Oe.APOSTROPHE||e===Oe.LESS_THAN_SIGN?(this._err(d),this.currentAttr.name+=He(e)):e===Oe.NULL?(this._err(N),this.currentAttr.name+=n):this.currentAttr.name+=He(e);}AFTER_ATTRIBUTE_NAME_STATE(e){Re(e)||(e===Oe.SOLIDUS?this.state="SELF_CLOSING_START_TAG_STATE":e===Oe.EQUALS_SIGN?this.state="BEFORE_ATTRIBUTE_VALUE_STATE":e===Oe.GREATER_THAN_SIGN?(this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._err(D),this._emitEOFToken()):(this._createAttr(""),this._reconsumeInState("ATTRIBUTE_NAME_STATE")));}BEFORE_ATTRIBUTE_VALUE_STATE(e){Re(e)||(e===Oe.QUOTATION_MARK?this.state="ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE":e===Oe.APOSTROPHE?this.state="ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE":e===Oe.GREATER_THAN_SIGN?(this._err(g),this.state=de,this._emitCurrentToken()):this._reconsumeInState("ATTRIBUTE_VALUE_UNQUOTED_STATE"));}ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE(e){e===Oe.QUOTATION_MARK?this.state="AFTER_ATTRIBUTE_VALUE_QUOTED_STATE":e===Oe.AMPERSAND?(this.returnState="ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE",this.state="CHARACTER_REFERENCE_STATE"):e===Oe.NULL?(this._err(N),this.currentAttr.value+=n):e===Oe.EOF?(this._err(D),this._emitEOFToken()):this.currentAttr.value+=He(e);}ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE(e){e===Oe.APOSTROPHE?this.state="AFTER_ATTRIBUTE_VALUE_QUOTED_STATE":e===Oe.AMPERSAND?(this.returnState="ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE",this.state="CHARACTER_REFERENCE_STATE"):e===Oe.NULL?(this._err(N),this.currentAttr.value+=n):e===Oe.EOF?(this._err(D),this._emitEOFToken()):this.currentAttr.value+=He(e);}ATTRIBUTE_VALUE_UNQUOTED_STATE(e){Re(e)?this._leaveAttrValue("BEFORE_ATTRIBUTE_NAME_STATE"):e===Oe.AMPERSAND?(this.returnState="ATTRIBUTE_VALUE_UNQUOTED_STATE",this.state="CHARACTER_REFERENCE_STATE"):e===Oe.GREATER_THAN_SIGN?(this._leaveAttrValue(de),this._emitCurrentToken()):e===Oe.NULL?(this._err(N),this.currentAttr.value+=n):e===Oe.QUOTATION_MARK||e===Oe.APOSTROPHE||e===Oe.LESS_THAN_SIGN||e===Oe.EQUALS_SIGN||e===Oe.GRAVE_ACCENT?(this._err(M),this.currentAttr.value+=He(e)):e===Oe.EOF?(this._err(D),this._emitEOFToken()):this.currentAttr.value+=He(e);}AFTER_ATTRIBUTE_VALUE_QUOTED_STATE(e){Re(e)?this._leaveAttrValue("BEFORE_ATTRIBUTE_NAME_STATE"):e===Oe.SOLIDUS?this._leaveAttrValue("SELF_CLOSING_START_TAG_STATE"):e===Oe.GREATER_THAN_SIGN?(this._leaveAttrValue(de),this._emitCurrentToken()):e===Oe.EOF?(this._err(D),this._emitEOFToken()):(this._err(P),this._reconsumeInState("BEFORE_ATTRIBUTE_NAME_STATE"));}SELF_CLOSING_START_TAG_STATE(e){e===Oe.GREATER_THAN_SIGN?(this.currentToken.selfClosing=!0,this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._err(D),this._emitEOFToken()):(this._err(p),this._reconsumeInState("BEFORE_ATTRIBUTE_NAME_STATE"));}BOGUS_COMMENT_STATE(e){e===Oe.GREATER_THAN_SIGN?(this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._emitCurrentToken(),this._emitEOFToken()):e===Oe.NULL?(this._err(N),this.currentToken.data+=n):this.currentToken.data+=He(e);}MARKUP_DECLARATION_OPEN_STATE(e){this._consumeSequenceIfMatch(Se.DASH_DASH_STRING,e,!0)?(this._createCommentToken(),this.state="COMMENT_START_STATE"):this._consumeSequenceIfMatch(Se.DOCTYPE_STRING,e,!1)?this.state="DOCTYPE_STATE":this._consumeSequenceIfMatch(Se.CDATA_START_STRING,e,!0)?this.allowCDATA?this.state="CDATA_SECTION_STATE":(this._err(x),this._createCommentToken(),this.currentToken.data="[CDATA[",this.state="BOGUS_COMMENT_STATE"):this._ensureHibernation()||(this._err(y),this._createCommentToken(),this._reconsumeInState("BOGUS_COMMENT_STATE"));}COMMENT_START_STATE(e){e===Oe.HYPHEN_MINUS?this.state="COMMENT_START_DASH_STATE":e===Oe.GREATER_THAN_SIGN?(this._err(X),this.state=de,this._emitCurrentToken()):this._reconsumeInState("COMMENT_STATE");}COMMENT_START_DASH_STATE(e){e===Oe.HYPHEN_MINUS?this.state="COMMENT_END_STATE":e===Oe.GREATER_THAN_SIGN?(this._err(X),this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._err(W),this._emitCurrentToken(),this._emitEOFToken()):(this.currentToken.data+="-",this._reconsumeInState("COMMENT_STATE"));}COMMENT_STATE(e){e===Oe.HYPHEN_MINUS?this.state="COMMENT_END_DASH_STATE":e===Oe.LESS_THAN_SIGN?(this.currentToken.data+="<",this.state="COMMENT_LESS_THAN_SIGN_STATE"):e===Oe.NULL?(this._err(N),this.currentToken.data+=n):e===Oe.EOF?(this._err(W),this._emitCurrentToken(),this._emitEOFToken()):this.currentToken.data+=He(e);}COMMENT_LESS_THAN_SIGN_STATE(e){e===Oe.EXCLAMATION_MARK?(this.currentToken.data+="!",this.state="COMMENT_LESS_THAN_SIGN_BANG_STATE"):e===Oe.LESS_THAN_SIGN?this.currentToken.data+="!":this._reconsumeInState("COMMENT_STATE");}COMMENT_LESS_THAN_SIGN_BANG_STATE(e){e===Oe.HYPHEN_MINUS?this.state="COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE":this._reconsumeInState("COMMENT_STATE");}COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE(e){e===Oe.HYPHEN_MINUS?this.state="COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE":this._reconsumeInState("COMMENT_END_DASH_STATE");}COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE(e){e!==Oe.GREATER_THAN_SIGN&&e!==Oe.EOF&&this._err(Q),this._reconsumeInState("COMMENT_END_STATE");}COMMENT_END_DASH_STATE(e){e===Oe.HYPHEN_MINUS?this.state="COMMENT_END_STATE":e===Oe.EOF?(this._err(W),this._emitCurrentToken(),this._emitEOFToken()):(this.currentToken.data+="-",this._reconsumeInState("COMMENT_STATE"));}COMMENT_END_STATE(e){e===Oe.GREATER_THAN_SIGN?(this.state=de,this._emitCurrentToken()):e===Oe.EXCLAMATION_MARK?this.state="COMMENT_END_BANG_STATE":e===Oe.HYPHEN_MINUS?this.currentToken.data+="-":e===Oe.EOF?(this._err(W),this._emitCurrentToken(),this._emitEOFToken()):(this.currentToken.data+="--",this._reconsumeInState("COMMENT_STATE"));}COMMENT_END_BANG_STATE(e){e===Oe.HYPHEN_MINUS?(this.currentToken.data+="--!",this.state="COMMENT_END_DASH_STATE"):e===Oe.GREATER_THAN_SIGN?(this._err(V),this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._err(W),this._emitCurrentToken(),this._emitEOFToken()):(this.currentToken.data+="--!",this._reconsumeInState("COMMENT_STATE"));}DOCTYPE_STATE(e){Re(e)?this.state="BEFORE_DOCTYPE_NAME_STATE":e===Oe.GREATER_THAN_SIGN?this._reconsumeInState("BEFORE_DOCTYPE_NAME_STATE"):e===Oe.EOF?(this._err(w),this._createDoctypeToken(null),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):(this._err(te),this._reconsumeInState("BEFORE_DOCTYPE_NAME_STATE"));}BEFORE_DOCTYPE_NAME_STATE(e){Re(e)||(fe(e)?(this._createDoctypeToken(Ue(e)),this.state="DOCTYPE_NAME_STATE"):e===Oe.NULL?(this._err(N),this._createDoctypeToken(n),this.state="DOCTYPE_NAME_STATE"):e===Oe.GREATER_THAN_SIGN?(this._err(ne),this._createDoctypeToken(null),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this.state=de):e===Oe.EOF?(this._err(w),this._createDoctypeToken(null),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):(this._createDoctypeToken(He(e)),this.state="DOCTYPE_NAME_STATE"));}DOCTYPE_NAME_STATE(e){Re(e)?this.state="AFTER_DOCTYPE_NAME_STATE":e===Oe.GREATER_THAN_SIGN?(this.state=de,this._emitCurrentToken()):fe(e)?this.currentToken.name+=Ue(e):e===Oe.NULL?(this._err(N),this.currentToken.name+=n):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):this.currentToken.name+=He(e);}AFTER_DOCTYPE_NAME_STATE(e){Re(e)||(e===Oe.GREATER_THAN_SIGN?(this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):this._consumeSequenceIfMatch(Se.PUBLIC_STRING,e,!1)?this.state="AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE":this._consumeSequenceIfMatch(Se.SYSTEM_STRING,e,!1)?this.state="AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE":this._ensureHibernation()||(this._err(se),this.currentToken.forceQuirks=!0,this._reconsumeInState("BOGUS_DOCTYPE_STATE")));}AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE(e){Re(e)?this.state="BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE":e===Oe.QUOTATION_MARK?(this._err(k),this.currentToken.publicId="",this.state="DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE"):e===Oe.APOSTROPHE?(this._err(k),this.currentToken.publicId="",this.state="DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE"):e===Oe.GREATER_THAN_SIGN?(this._err(G),this.currentToken.forceQuirks=!0,this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):(this._err(F),this.currentToken.forceQuirks=!0,this._reconsumeInState("BOGUS_DOCTYPE_STATE"));}BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE(e){Re(e)||(e===Oe.QUOTATION_MARK?(this.currentToken.publicId="",this.state="DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE"):e===Oe.APOSTROPHE?(this.currentToken.publicId="",this.state="DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE"):e===Oe.GREATER_THAN_SIGN?(this._err(G),this.currentToken.forceQuirks=!0,this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):(this._err(F),this.currentToken.forceQuirks=!0,this._reconsumeInState("BOGUS_DOCTYPE_STATE")));}DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE(e){e===Oe.QUOTATION_MARK?this.state="AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE":e===Oe.NULL?(this._err(N),this.currentToken.publicId+=n):e===Oe.GREATER_THAN_SIGN?(this._err(b),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this.state=de):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):this.currentToken.publicId+=He(e);}DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE(e){e===Oe.APOSTROPHE?this.state="AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE":e===Oe.NULL?(this._err(N),this.currentToken.publicId+=n):e===Oe.GREATER_THAN_SIGN?(this._err(b),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this.state=de):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):this.currentToken.publicId+=He(e);}AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE(e){Re(e)?this.state="BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE":e===Oe.GREATER_THAN_SIGN?(this.state=de,this._emitCurrentToken()):e===Oe.QUOTATION_MARK?(this._err(H),this.currentToken.systemId="",this.state="DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE"):e===Oe.APOSTROPHE?(this._err(H),this.currentToken.systemId="",this.state="DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE"):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):(this._err(B),this.currentToken.forceQuirks=!0,this._reconsumeInState("BOGUS_DOCTYPE_STATE"));}BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE(e){Re(e)||(e===Oe.GREATER_THAN_SIGN?(this._emitCurrentToken(),this.state=de):e===Oe.QUOTATION_MARK?(this.currentToken.systemId="",this.state="DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE"):e===Oe.APOSTROPHE?(this.currentToken.systemId="",this.state="DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE"):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):(this._err(B),this.currentToken.forceQuirks=!0,this._reconsumeInState("BOGUS_DOCTYPE_STATE")));}AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE(e){Re(e)?this.state="BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE":e===Oe.QUOTATION_MARK?(this._err(U),this.currentToken.systemId="",this.state="DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE"):e===Oe.APOSTROPHE?(this._err(U),this.currentToken.systemId="",this.state="DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE"):e===Oe.GREATER_THAN_SIGN?(this._err(K),this.currentToken.forceQuirks=!0,this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):(this._err(B),this.currentToken.forceQuirks=!0,this._reconsumeInState("BOGUS_DOCTYPE_STATE"));}BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE(e){Re(e)||(e===Oe.QUOTATION_MARK?(this.currentToken.systemId="",this.state="DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE"):e===Oe.APOSTROPHE?(this.currentToken.systemId="",this.state="DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE"):e===Oe.GREATER_THAN_SIGN?(this._err(K),this.currentToken.forceQuirks=!0,this.state=de,this._emitCurrentToken()):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):(this._err(B),this.currentToken.forceQuirks=!0,this._reconsumeInState("BOGUS_DOCTYPE_STATE")));}DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE(e){e===Oe.QUOTATION_MARK?this.state="AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE":e===Oe.NULL?(this._err(N),this.currentToken.systemId+=n):e===Oe.GREATER_THAN_SIGN?(this._err(Y),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this.state=de):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):this.currentToken.systemId+=He(e);}DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE(e){e===Oe.APOSTROPHE?this.state="AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE":e===Oe.NULL?(this._err(N),this.currentToken.systemId+=n):e===Oe.GREATER_THAN_SIGN?(this._err(Y),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this.state=de):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):this.currentToken.systemId+=He(e);}AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE(e){Re(e)||(e===Oe.GREATER_THAN_SIGN?(this._emitCurrentToken(),this.state=de):e===Oe.EOF?(this._err(w),this.currentToken.forceQuirks=!0,this._emitCurrentToken(),this._emitEOFToken()):(this._err(f),this._reconsumeInState("BOGUS_DOCTYPE_STATE")));}BOGUS_DOCTYPE_STATE(e){e===Oe.GREATER_THAN_SIGN?(this._emitCurrentToken(),this.state=de):e===Oe.NULL?this._err(N):e===Oe.EOF&&(this._emitCurrentToken(),this._emitEOFToken());}CDATA_SECTION_STATE(e){e===Oe.RIGHT_SQUARE_BRACKET?this.state="CDATA_SECTION_BRACKET_STATE":e===Oe.EOF?(this._err(j),this._emitEOFToken()):this._emitCodePoint(e);}CDATA_SECTION_BRACKET_STATE(e){e===Oe.RIGHT_SQUARE_BRACKET?this.state="CDATA_SECTION_END_STATE":(this._emitChars("]"),this._reconsumeInState("CDATA_SECTION_STATE"));}CDATA_SECTION_END_STATE(e){e===Oe.GREATER_THAN_SIGN?this.state=de:e===Oe.RIGHT_SQUARE_BRACKET?this._emitChars("]"):(this._emitChars("]]"),this._reconsumeInState("CDATA_SECTION_STATE"));}CHARACTER_REFERENCE_STATE(e){this.tempBuff=[Oe.AMPERSAND],e===Oe.NUMBER_SIGN?(this.tempBuff.push(e),this.state="NUMERIC_CHARACTER_REFERENCE_STATE"):De(e)?this._reconsumeInState("NAMED_CHARACTER_REFERENCE_STATE"):(this._flushCodePointsConsumedAsCharacterReference(),this._reconsumeInState(this.returnState));}NAMED_CHARACTER_REFERENCE_STATE(e){const t=this._matchNamedCharacterReference(e);if(this._ensureHibernation())this.tempBuff=[Oe.AMPERSAND];else if(t){const e=this.tempBuff[this.tempBuff.length-1]===Oe.SEMICOLON;this._isCharacterReferenceAttributeQuirk(e)||(e||this._errOnNextCodePoint(I),this.tempBuff=t),this._flushCodePointsConsumedAsCharacterReference(),this.state=this.returnState;}else this._flushCodePointsConsumedAsCharacterReference(),this.state="AMBIGUOS_AMPERSAND_STATE";}AMBIGUOS_AMPERSAND_STATE(e){De(e)?this._isCharacterReferenceInAttribute()?this.currentAttr.value+=He(e):this._emitCodePoint(e):(e===Oe.SEMICOLON&&this._err(R),this._reconsumeInState(this.returnState));}NUMERIC_CHARACTER_REFERENCE_STATE(e){this.charRefCode=0,e===Oe.LATIN_SMALL_X||e===Oe.LATIN_CAPITAL_X?(this.tempBuff.push(e),this.state="HEXADEMICAL_CHARACTER_REFERENCE_START_STATE"):this._reconsumeInState("DECIMAL_CHARACTER_REFERENCE_START_STATE");}HEXADEMICAL_CHARACTER_REFERENCE_START_STATE(e){!function(e){return Ie(e)||ge(e)||Pe(e)}(e)?(this._err(z),this._flushCodePointsConsumedAsCharacterReference(),this._reconsumeInState(this.returnState)):this._reconsumeInState("HEXADEMICAL_CHARACTER_REFERENCE_STATE");}DECIMAL_CHARACTER_REFERENCE_START_STATE(e){Ie(e)?this._reconsumeInState("DECIMAL_CHARACTER_REFERENCE_STATE"):(this._err(z),this._flushCodePointsConsumedAsCharacterReference(),this._reconsumeInState(this.returnState));}HEXADEMICAL_CHARACTER_REFERENCE_STATE(e){ge(e)?this.charRefCode=16*this.charRefCode+e-55:Pe(e)?this.charRefCode=16*this.charRefCode+e-87:Ie(e)?this.charRefCode=16*this.charRefCode+e-48:e===Oe.SEMICOLON?this.state="NUMERIC_CHARACTER_REFERENCE_END_STATE":(this._err(I),this._reconsumeInState("NUMERIC_CHARACTER_REFERENCE_END_STATE"));}DECIMAL_CHARACTER_REFERENCE_STATE(e){Ie(e)?this.charRefCode=10*this.charRefCode+e-48:e===Oe.SEMICOLON?this.state="NUMERIC_CHARACTER_REFERENCE_END_STATE":(this._err(I),this._reconsumeInState("NUMERIC_CHARACTER_REFERENCE_END_STATE"));}NUMERIC_CHARACTER_REFERENCE_END_STATE(){if(this.charRefCode===Oe.NULL)this._err(q),this.charRefCode=Oe.REPLACEMENT_CHARACTER;else if(this.charRefCode>1114111)this._err(Z),this.charRefCode=Oe.REPLACEMENT_CHARACTER;else if(i(this.charRefCode))this._err(J),this.charRefCode=Oe.REPLACEMENT_CHARACTER;else if(a(this.charRefCode))this._err(ee);else if(E(this.charRefCode)||this.charRefCode===Oe.CARRIAGE_RETURN){this._err($);const e=Ce[this.charRefCode];e&&(this.charRefCode=e);}this.tempBuff=[this.charRefCode],this._flushCodePointsConsumedAsCharacterReference(),this._reconsumeInState(this.returnState);}}Be.CHARACTER_TOKEN="CHARACTER_TOKEN",Be.NULL_CHARACTER_TOKEN="NULL_CHARACTER_TOKEN",Be.WHITESPACE_CHARACTER_TOKEN="WHITESPACE_CHARACTER_TOKEN",Be.START_TAG_TOKEN="START_TAG_TOKEN",Be.END_TAG_TOKEN="END_TAG_TOKEN",Be.COMMENT_TOKEN="COMMENT_TOKEN",Be.DOCTYPE_TOKEN="DOCTYPE_TOKEN",Be.EOF_TOKEN="EOF_TOKEN",Be.HIBERNATION_TOKEN="HIBERNATION_TOKEN",Be.MODE={DATA:de,RCDATA:"RCDATA_STATE",RAWTEXT:"RAWTEXT_STATE",SCRIPT_DATA:"SCRIPT_DATA_STATE",PLAINTEXT:"PLAINTEXT_STATE"},Be.getTokenAttr=function(e,t){for(let n=e.attrs.length-1;n>=0;n--)if(e.attrs[n].name===t)return e.attrs[n].value;return null};var Ge=Be;function Ke(e,t){return e(t={exports:{}},t.exports),t.exports}var be=Ke((function(e,t){const n=t.NAMESPACES={HTML:"http://www.w3.org/1999/xhtml",MATHML:"http://www.w3.org/1998/Math/MathML",SVG:"http://www.w3.org/2000/svg",XLINK:"http://www.w3.org/1999/xlink",XML:"http://www.w3.org/XML/1998/namespace",XMLNS:"http://www.w3.org/2000/xmlns/"};t.ATTRS={TYPE:"type",ACTION:"action",ENCODING:"encoding",PROMPT:"prompt",NAME:"name",COLOR:"color",FACE:"face",SIZE:"size"},t.DOCUMENT_MODE={NO_QUIRKS:"no-quirks",QUIRKS:"quirks",LIMITED_QUIRKS:"limited-quirks"};const s=t.TAG_NAMES={A:"a",ADDRESS:"address",ANNOTATION_XML:"annotation-xml",APPLET:"applet",AREA:"area",ARTICLE:"article",ASIDE:"aside",B:"b",BASE:"base",BASEFONT:"basefont",BGSOUND:"bgsound",BIG:"big",BLOCKQUOTE:"blockquote",BODY:"body",BR:"br",BUTTON:"button",CAPTION:"caption",CENTER:"center",CODE:"code",COL:"col",COLGROUP:"colgroup",DD:"dd",DESC:"desc",DETAILS:"details",DIALOG:"dialog",DIR:"dir",DIV:"div",DL:"dl",DT:"dt",EM:"em",EMBED:"embed",FIELDSET:"fieldset",FIGCAPTION:"figcaption",FIGURE:"figure",FONT:"font",FOOTER:"footer",FOREIGN_OBJECT:"foreignObject",FORM:"form",FRAME:"frame",FRAMESET:"frameset",H1:"h1",H2:"h2",H3:"h3",H4:"h4",H5:"h5",H6:"h6",HEAD:"head",HEADER:"header",HGROUP:"hgroup",HR:"hr",HTML:"html",I:"i",IMG:"img",IMAGE:"image",INPUT:"input",IFRAME:"iframe",KEYGEN:"keygen",LABEL:"label",LI:"li",LINK:"link",LISTING:"listing",MAIN:"main",MALIGNMARK:"malignmark",MARQUEE:"marquee",MATH:"math",MENU:"menu",META:"meta",MGLYPH:"mglyph",MI:"mi",MO:"mo",MN:"mn",MS:"ms",MTEXT:"mtext",NAV:"nav",NOBR:"nobr",NOFRAMES:"noframes",NOEMBED:"noembed",NOSCRIPT:"noscript",OBJECT:"object",OL:"ol",OPTGROUP:"optgroup",OPTION:"option",P:"p",PARAM:"param",PLAINTEXT:"plaintext",PRE:"pre",RB:"rb",RP:"rp",RT:"rt",RTC:"rtc",RUBY:"ruby",S:"s",SCRIPT:"script",SECTION:"section",SELECT:"select",SOURCE:"source",SMALL:"small",SPAN:"span",STRIKE:"strike",STRONG:"strong",STYLE:"style",SUB:"sub",SUMMARY:"summary",SUP:"sup",TABLE:"table",TBODY:"tbody",TEMPLATE:"template",TEXTAREA:"textarea",TFOOT:"tfoot",TD:"td",TH:"th",THEAD:"thead",TITLE:"title",TR:"tr",TRACK:"track",TT:"tt",U:"u",UL:"ul",SVG:"svg",VAR:"var",WBR:"wbr",XMP:"xmp"};t.SPECIAL_ELEMENTS={[n.HTML]:{[s.ADDRESS]:!0,[s.APPLET]:!0,[s.AREA]:!0,[s.ARTICLE]:!0,[s.ASIDE]:!0,[s.BASE]:!0,[s.BASEFONT]:!0,[s.BGSOUND]:!0,[s.BLOCKQUOTE]:!0,[s.BODY]:!0,[s.BR]:!0,[s.BUTTON]:!0,[s.CAPTION]:!0,[s.CENTER]:!0,[s.COL]:!0,[s.COLGROUP]:!0,[s.DD]:!0,[s.DETAILS]:!0,[s.DIR]:!0,[s.DIV]:!0,[s.DL]:!0,[s.DT]:!0,[s.EMBED]:!0,[s.FIELDSET]:!0,[s.FIGCAPTION]:!0,[s.FIGURE]:!0,[s.FOOTER]:!0,[s.FORM]:!0,[s.FRAME]:!0,[s.FRAMESET]:!0,[s.H1]:!0,[s.H2]:!0,[s.H3]:!0,[s.H4]:!0,[s.H5]:!0,[s.H6]:!0,[s.HEAD]:!0,[s.HEADER]:!0,[s.HGROUP]:!0,[s.HR]:!0,[s.HTML]:!0,[s.IFRAME]:!0,[s.IMG]:!0,[s.INPUT]:!0,[s.LI]:!0,[s.LINK]:!0,[s.LISTING]:!0,[s.MAIN]:!0,[s.MARQUEE]:!0,[s.MENU]:!0,[s.META]:!0,[s.NAV]:!0,[s.NOEMBED]:!0,[s.NOFRAMES]:!0,[s.NOSCRIPT]:!0,[s.OBJECT]:!0,[s.OL]:!0,[s.P]:!0,[s.PARAM]:!0,[s.PLAINTEXT]:!0,[s.PRE]:!0,[s.SCRIPT]:!0,[s.SECTION]:!0,[s.SELECT]:!0,[s.SOURCE]:!0,[s.STYLE]:!0,[s.SUMMARY]:!0,[s.TABLE]:!0,[s.TBODY]:!0,[s.TD]:!0,[s.TEMPLATE]:!0,[s.TEXTAREA]:!0,[s.TFOOT]:!0,[s.TH]:!0,[s.THEAD]:!0,[s.TITLE]:!0,[s.TR]:!0,[s.TRACK]:!0,[s.UL]:!0,[s.WBR]:!0,[s.XMP]:!0},[n.MATHML]:{[s.MI]:!0,[s.MO]:!0,[s.MN]:!0,[s.MS]:!0,[s.MTEXT]:!0,[s.ANNOTATION_XML]:!0},[n.SVG]:{[s.TITLE]:!0,[s.FOREIGN_OBJECT]:!0,[s.DESC]:!0}};}));be.NAMESPACES,be.ATTRS,be.DOCUMENT_MODE,be.TAG_NAMES,be.SPECIAL_ELEMENTS;const Ye=be.TAG_NAMES,xe=be.NAMESPACES;function ye(e){switch(e.length){case 1:return e===Ye.P;case 2:return e===Ye.RB||e===Ye.RP||e===Ye.RT||e===Ye.DD||e===Ye.DT||e===Ye.LI;case 3:return e===Ye.RTC;case 6:return e===Ye.OPTION;case 8:return e===Ye.OPTGROUP}return !1}function ve(e){switch(e.length){case 1:return e===Ye.P;case 2:return e===Ye.RB||e===Ye.RP||e===Ye.RT||e===Ye.DD||e===Ye.DT||e===Ye.LI||e===Ye.TD||e===Ye.TH||e===Ye.TR;case 3:return e===Ye.RTC;case 5:return e===Ye.TBODY||e===Ye.TFOOT||e===Ye.THEAD;case 6:return e===Ye.OPTION;case 7:return e===Ye.CAPTION;case 8:return e===Ye.OPTGROUP||e===Ye.COLGROUP}return !1}function we(e,t){switch(e.length){case 2:if(e===Ye.TD||e===Ye.TH)return t===xe.HTML;if(e===Ye.MI||e===Ye.MO||e===Ye.MN||e===Ye.MS)return t===xe.MATHML;break;case 4:if(e===Ye.HTML)return t===xe.HTML;if(e===Ye.DESC)return t===xe.SVG;break;case 5:if(e===Ye.TABLE)return t===xe.HTML;if(e===Ye.MTEXT)return t===xe.MATHML;if(e===Ye.TITLE)return t===xe.SVG;break;case 6:return (e===Ye.APPLET||e===Ye.OBJECT)&&t===xe.HTML;case 7:return (e===Ye.CAPTION||e===Ye.MARQUEE)&&t===xe.HTML;case 8:return e===Ye.TEMPLATE&&t===xe.HTML;case 13:return e===Ye.FOREIGN_OBJECT&&t===xe.SVG;case 14:return e===Ye.ANNOTATION_XML&&t===xe.MATHML}return !1}var Qe=class{constructor(e,t){this.stackTop=-1,this.items=[],this.current=e,this.currentTagName=null,this.currentTmplContent=null,this.tmplCount=0,this.treeAdapter=t;}_indexOf(e){let t=-1;for(let n=this.stackTop;n>=0;n--)if(this.items[n]===e){t=n;break}return t}_isInTemplate(){return this.currentTagName===Ye.TEMPLATE&&this.treeAdapter.getNamespaceURI(this.current)===xe.HTML}_updateCurrentElement(){this.current=this.items[this.stackTop],this.currentTagName=this.current&&this.treeAdapter.getTagName(this.current),this.currentTmplContent=this._isInTemplate()?this.treeAdapter.getTemplateContent(this.current):null;}push(e){this.items[++this.stackTop]=e,this._updateCurrentElement(),this._isInTemplate()&&this.tmplCount++;}pop(){this.stackTop--,this.tmplCount>0&&this._isInTemplate()&&this.tmplCount--,this._updateCurrentElement();}replace(e,t){const n=this._indexOf(e);this.items[n]=t,n===this.stackTop&&this._updateCurrentElement();}insertAfter(e,t){const n=this._indexOf(e)+1;this.items.splice(n,0,t),n===++this.stackTop&&this._updateCurrentElement();}popUntilTagNamePopped(e){for(;this.stackTop>-1;){const t=this.currentTagName,n=this.treeAdapter.getNamespaceURI(this.current);if(this.pop(),t===e&&n===xe.HTML)break}}popUntilElementPopped(e){for(;this.stackTop>-1;){const t=this.current;if(this.pop(),t===e)break}}popUntilNumberedHeaderPopped(){for(;this.stackTop>-1;){const e=this.currentTagName,t=this.treeAdapter.getNamespaceURI(this.current);if(this.pop(),e===Ye.H1||e===Ye.H2||e===Ye.H3||e===Ye.H4||e===Ye.H5||e===Ye.H6&&t===xe.HTML)break}}popUntilTableCellPopped(){for(;this.stackTop>-1;){const e=this.currentTagName,t=this.treeAdapter.getNamespaceURI(this.current);if(this.pop(),e===Ye.TD||e===Ye.TH&&t===xe.HTML)break}}popAllUpToHtmlElement(){this.stackTop=0,this._updateCurrentElement();}clearBackToTableContext(){for(;this.currentTagName!==Ye.TABLE&&this.currentTagName!==Ye.TEMPLATE&&this.currentTagName!==Ye.HTML||this.treeAdapter.getNamespaceURI(this.current)!==xe.HTML;)this.pop();}clearBackToTableBodyContext(){for(;this.currentTagName!==Ye.TBODY&&this.currentTagName!==Ye.TFOOT&&this.currentTagName!==Ye.THEAD&&this.currentTagName!==Ye.TEMPLATE&&this.currentTagName!==Ye.HTML||this.treeAdapter.getNamespaceURI(this.current)!==xe.HTML;)this.pop();}clearBackToTableRowContext(){for(;this.currentTagName!==Ye.TR&&this.currentTagName!==Ye.TEMPLATE&&this.currentTagName!==Ye.HTML||this.treeAdapter.getNamespaceURI(this.current)!==xe.HTML;)this.pop();}remove(e){for(let t=this.stackTop;t>=0;t--)if(this.items[t]===e){this.items.splice(t,1),this.stackTop--,this._updateCurrentElement();break}}tryPeekProperlyNestedBodyElement(){const e=this.items[1];return e&&this.treeAdapter.getTagName(e)===Ye.BODY?e:null}contains(e){return this._indexOf(e)>-1}getCommonAncestor(e){let t=this._indexOf(e);return --t>=0?this.items[t]:null}isRootHtmlElementCurrent(){return 0===this.stackTop&&this.currentTagName===Ye.HTML}hasInScope(e){for(let t=this.stackTop;t>=0;t--){const n=this.treeAdapter.getTagName(this.items[t]),s=this.treeAdapter.getNamespaceURI(this.items[t]);if(n===e&&s===xe.HTML)return !0;if(we(n,s))return !1}return !0}hasNumberedHeaderInScope(){for(let e=this.stackTop;e>=0;e--){const t=this.treeAdapter.getTagName(this.items[e]),n=this.treeAdapter.getNamespaceURI(this.items[e]);if((t===Ye.H1||t===Ye.H2||t===Ye.H3||t===Ye.H4||t===Ye.H5||t===Ye.H6)&&n===xe.HTML)return !0;if(we(t,n))return !1}return !0}hasInListItemScope(e){for(let t=this.stackTop;t>=0;t--){const n=this.treeAdapter.getTagName(this.items[t]),s=this.treeAdapter.getNamespaceURI(this.items[t]);if(n===e&&s===xe.HTML)return !0;if((n===Ye.UL||n===Ye.OL)&&s===xe.HTML||we(n,s))return !1}return !0}hasInButtonScope(e){for(let t=this.stackTop;t>=0;t--){const n=this.treeAdapter.getTagName(this.items[t]),s=this.treeAdapter.getNamespaceURI(this.items[t]);if(n===e&&s===xe.HTML)return !0;if(n===Ye.BUTTON&&s===xe.HTML||we(n,s))return !1}return !0}hasInTableScope(e){for(let t=this.stackTop;t>=0;t--){const n=this.treeAdapter.getTagName(this.items[t]);if(this.treeAdapter.getNamespaceURI(this.items[t])===xe.HTML){if(n===e)return !0;if(n===Ye.TABLE||n===Ye.TEMPLATE||n===Ye.HTML)return !1}}return !0}hasTableBodyContextInTableScope(){for(let e=this.stackTop;e>=0;e--){const t=this.treeAdapter.getTagName(this.items[e]);if(this.treeAdapter.getNamespaceURI(this.items[e])===xe.HTML){if(t===Ye.TBODY||t===Ye.THEAD||t===Ye.TFOOT)return !0;if(t===Ye.TABLE||t===Ye.HTML)return !1}}return !0}hasInSelectScope(e){for(let t=this.stackTop;t>=0;t--){const n=this.treeAdapter.getTagName(this.items[t]);if(this.treeAdapter.getNamespaceURI(this.items[t])===xe.HTML){if(n===e)return !0;if(n!==Ye.OPTION&&n!==Ye.OPTGROUP)return !1}}return !0}generateImpliedEndTags(){for(;ye(this.currentTagName);)this.pop();}generateImpliedEndTagsThoroughly(){for(;ve(this.currentTagName);)this.pop();}generateImpliedEndTagsWithExclusion(e){for(;ye(this.currentTagName)&&this.currentTagName!==e;)this.pop();}};class Xe{constructor(e){this.length=0,this.entries=[],this.treeAdapter=e,this.bookmark=null;}_getNoahArkConditionCandidates(e){const t=[];if(this.length>=3){const n=this.treeAdapter.getAttrList(e).length,s=this.treeAdapter.getTagName(e),r=this.treeAdapter.getNamespaceURI(e);for(let e=this.length-1;e>=0;e--){const i=this.entries[e];if(i.type===Xe.MARKER_ENTRY)break;const T=i.element,o=this.treeAdapter.getAttrList(T);this.treeAdapter.getTagName(T)===s&&this.treeAdapter.getNamespaceURI(T)===r&&o.length===n&&t.push({idx:e,attrs:o});}}return t.length<3?[]:t}_ensureNoahArkCondition(e){const t=this._getNoahArkConditionCandidates(e);let n=t.length;if(n){const s=this.treeAdapter.getAttrList(e),r=s.length,i=Object.create(null);for(let e=0;e<r;e++){const t=s[e];i[t.name]=t.value;}for(let e=0;e<r;e++)for(let s=0;s<n;s++){const r=t[s].attrs[e];if(i[r.name]!==r.value&&(t.splice(s,1),n--),t.length<3)return}for(let e=n-1;e>=2;e--)this.entries.splice(t[e].idx,1),this.length--;}}insertMarker(){this.entries.push({type:Xe.MARKER_ENTRY}),this.length++;}pushElement(e,t){this._ensureNoahArkCondition(e),this.entries.push({type:Xe.ELEMENT_ENTRY,element:e,token:t}),this.length++;}insertElementAfterBookmark(e,t){let n=this.length-1;for(;n>=0&&this.entries[n]!==this.bookmark;n--);this.entries.splice(n+1,0,{type:Xe.ELEMENT_ENTRY,element:e,token:t}),this.length++;}removeEntry(e){for(let t=this.length-1;t>=0;t--)if(this.entries[t]===e){this.entries.splice(t,1),this.length--;break}}clearToLastMarker(){for(;this.length;){const e=this.entries.pop();if(this.length--,e.type===Xe.MARKER_ENTRY)break}}getElementEntryInScopeWithTagName(e){for(let t=this.length-1;t>=0;t--){const n=this.entries[t];if(n.type===Xe.MARKER_ENTRY)return null;if(this.treeAdapter.getTagName(n.element)===e)return n}return null}getElementEntry(e){for(let t=this.length-1;t>=0;t--){const n=this.entries[t];if(n.type===Xe.ELEMENT_ENTRY&&n.element===e)return n}return null}}Xe.MARKER_ENTRY="MARKER_ENTRY",Xe.ELEMENT_ENTRY="ELEMENT_ENTRY";var We=Xe;class Ve{constructor(e){const t={},n=this._getOverriddenMethods(this,t);for(const s of Object.keys(n))"function"==typeof n[s]&&(t[s]=e[s],e[s]=n[s]);}_getOverriddenMethods(){throw new Error("Not implemented")}}Ve.install=function(e,t,n){e.__mixins||(e.__mixins=[]);for(let n=0;n<e.__mixins.length;n++)if(e.__mixins[n].constructor===t)return e.__mixins[n];const s=new t(e,n);return e.__mixins.push(s),s};var je=Ve;var ze=class extends je{constructor(e){super(e),this.preprocessor=e,this.isEol=!1,this.lineStartPos=0,this.droppedBufferSize=0,this.offset=0,this.col=0,this.line=1;}_getOverriddenMethods(e,t){return {advance(){const n=this.pos+1,s=this.html[n];return e.isEol&&(e.isEol=!1,e.line++,e.lineStartPos=n),("\n"===s||"\r"===s&&"\n"!==this.html[n+1])&&(e.isEol=!0),e.col=n-e.lineStartPos+1,e.offset=e.droppedBufferSize+n,t.advance.call(this)},retreat(){t.retreat.call(this),e.isEol=!1,e.col=this.pos-e.lineStartPos+1;},dropParsedChunk(){const n=this.pos;t.dropParsedChunk.call(this);const s=n-this.pos;e.lineStartPos-=s,e.droppedBufferSize+=s,e.offset=e.droppedBufferSize+this.pos;}}}};var qe=class extends je{constructor(e){super(e),this.tokenizer=e,this.posTracker=je.install(e.preprocessor,ze),this.currentAttrLocation=null,this.ctLoc=null;}_getCurrentLocation(){return {startLine:this.posTracker.line,startCol:this.posTracker.col,startOffset:this.posTracker.offset,endLine:-1,endCol:-1,endOffset:-1}}_attachCurrentAttrLocationInfo(){this.currentAttrLocation.endLine=this.posTracker.line,this.currentAttrLocation.endCol=this.posTracker.col,this.currentAttrLocation.endOffset=this.posTracker.offset;const e=this.tokenizer.currentToken,t=this.tokenizer.currentAttr;e.location.attrs||(e.location.attrs=Object.create(null)),e.location.attrs[t.name]=this.currentAttrLocation;}_getOverriddenMethods(e,t){const n={_createStartTagToken(){t._createStartTagToken.call(this),this.currentToken.location=e.ctLoc;},_createEndTagToken(){t._createEndTagToken.call(this),this.currentToken.location=e.ctLoc;},_createCommentToken(){t._createCommentToken.call(this),this.currentToken.location=e.ctLoc;},_createDoctypeToken(n){t._createDoctypeToken.call(this,n),this.currentToken.location=e.ctLoc;},_createCharacterToken(n,s){t._createCharacterToken.call(this,n,s),this.currentCharacterToken.location=e.ctLoc;},_createEOFToken(){t._createEOFToken.call(this),this.currentToken.location=e._getCurrentLocation();},_createAttr(n){t._createAttr.call(this,n),e.currentAttrLocation=e._getCurrentLocation();},_leaveAttrName(n){t._leaveAttrName.call(this,n),e._attachCurrentAttrLocationInfo();},_leaveAttrValue(n){t._leaveAttrValue.call(this,n),e._attachCurrentAttrLocationInfo();},_emitCurrentToken(){const n=this.currentToken.location;this.currentCharacterToken&&(this.currentCharacterToken.location.endLine=n.startLine,this.currentCharacterToken.location.endCol=n.startCol,this.currentCharacterToken.location.endOffset=n.startOffset),this.currentToken.type===Ge.EOF_TOKEN?(n.endLine=n.startLine,n.endCol=n.startCol,n.endOffset=n.startOffset):(n.endLine=e.posTracker.line,n.endCol=e.posTracker.col+1,n.endOffset=e.posTracker.offset+1),t._emitCurrentToken.call(this);},_emitCurrentCharacterToken(){const n=this.currentCharacterToken&&this.currentCharacterToken.location;n&&-1===n.endOffset&&(n.endLine=e.posTracker.line,n.endCol=e.posTracker.col,n.endOffset=e.posTracker.offset),t._emitCurrentCharacterToken.call(this);}};return Object.keys(Ge.MODE).forEach(s=>{const r=Ge.MODE[s];n[r]=function(n){e.ctLoc=e._getCurrentLocation(),t[r].call(this,n);};}),n}};var Je=class extends je{constructor(e,t){super(e),this.onItemPop=t.onItemPop;}_getOverriddenMethods(e,t){return {pop(){e.onItemPop(this.current),t.pop.call(this);},popAllUpToHtmlElement(){for(let t=this.stackTop;t>0;t--)e.onItemPop(this.items[t]);t.popAllUpToHtmlElement.call(this);},remove(n){e.onItemPop(this.current),t.remove.call(this,n);}}}};const Ze=be.TAG_NAMES;var $e=class extends je{constructor(e){super(e),this.parser=e,this.treeAdapter=this.parser.treeAdapter,this.posTracker=null,this.lastStartTagToken=null,this.lastFosterParentingLocation=null,this.currentToken=null;}_setStartLocation(e){let t=null;this.lastStartTagToken&&(t=Object.assign({},this.lastStartTagToken.location),t.startTag=this.lastStartTagToken.location),this.treeAdapter.setNodeSourceCodeLocation(e,t);}_setEndLocation(e,t){const n=this.treeAdapter.getNodeSourceCodeLocation(e);if(n&&t.location){const s=t.location,r=this.treeAdapter.getTagName(e);t.type===Ge.END_TAG_TOKEN&&r===t.tagName?(n.endTag=Object.assign({},s),n.endLine=s.endLine,n.endCol=s.endCol,n.endOffset=s.endOffset):(n.endLine=s.startLine,n.endCol=s.startCol,n.endOffset=s.startOffset);}}_getOverriddenMethods(e,t){return {_bootstrap(n,s){t._bootstrap.call(this,n,s),e.lastStartTagToken=null,e.lastFosterParentingLocation=null,e.currentToken=null;const r=je.install(this.tokenizer,qe);e.posTracker=r.posTracker,je.install(this.openElements,Je,{onItemPop:function(t){e._setEndLocation(t,e.currentToken);}});},_runParsingLoop(n){t._runParsingLoop.call(this,n);for(let t=this.openElements.stackTop;t>=0;t--)e._setEndLocation(this.openElements.items[t],e.currentToken);},_processTokenInForeignContent(n){e.currentToken=n,t._processTokenInForeignContent.call(this,n);},_processToken(n){if(e.currentToken=n,t._processToken.call(this,n),n.type===Ge.END_TAG_TOKEN&&(n.tagName===Ze.HTML||n.tagName===Ze.BODY&&this.openElements.hasInScope(Ze.BODY)))for(let t=this.openElements.stackTop;t>=0;t--){const s=this.openElements.items[t];if(this.treeAdapter.getTagName(s)===n.tagName){e._setEndLocation(s,n);break}}},_setDocumentType(e){t._setDocumentType.call(this,e);const n=this.treeAdapter.getChildNodes(this.document),s=n.length;for(let t=0;t<s;t++){const s=n[t];if(this.treeAdapter.isDocumentTypeNode(s)){this.treeAdapter.setNodeSourceCodeLocation(s,e.location);break}}},_attachElementToTree(n){e._setStartLocation(n),e.lastStartTagToken=null,t._attachElementToTree.call(this,n);},_appendElement(n,s){e.lastStartTagToken=n,t._appendElement.call(this,n,s);},_insertElement(n,s){e.lastStartTagToken=n,t._insertElement.call(this,n,s);},_insertTemplate(n){e.lastStartTagToken=n,t._insertTemplate.call(this,n);const s=this.treeAdapter.getTemplateContent(this.openElements.current);this.treeAdapter.setNodeSourceCodeLocation(s,null);},_insertFakeRootElement(){t._insertFakeRootElement.call(this),this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current,null);},_appendCommentNode(e,n){t._appendCommentNode.call(this,e,n);const s=this.treeAdapter.getChildNodes(n),r=s[s.length-1];this.treeAdapter.setNodeSourceCodeLocation(r,e.location);},_findFosterParentingLocation(){return e.lastFosterParentingLocation=t._findFosterParentingLocation.call(this),e.lastFosterParentingLocation},_insertCharacters(n){t._insertCharacters.call(this,n);const s=this._shouldFosterParentOnInsertion(),r=s&&e.lastFosterParentingLocation.parent||this.openElements.currentTmplContent||this.openElements.current,i=this.treeAdapter.getChildNodes(r),T=s&&e.lastFosterParentingLocation.beforeElement?i.indexOf(e.lastFosterParentingLocation.beforeElement)-1:i.length-1,o=i[T],E=this.treeAdapter.getNodeSourceCodeLocation(o);E?(E.endLine=n.location.endLine,E.endCol=n.location.endCol,E.endOffset=n.location.endOffset):this.treeAdapter.setNodeSourceCodeLocation(o,n.location);}}}};var et=class extends je{constructor(e,t){super(e),this.posTracker=null,this.onParseError=t.onParseError;}_setErrorLocation(e){e.startLine=e.endLine=this.posTracker.line,e.startCol=e.endCol=this.posTracker.col,e.startOffset=e.endOffset=this.posTracker.offset;}_reportError(e){const t={code:e,startLine:-1,startCol:-1,startOffset:-1,endLine:-1,endCol:-1,endOffset:-1};this._setErrorLocation(t),this.onParseError(t);}_getOverriddenMethods(e){return {_err(t){e._reportError(t);}}}};var tt=class extends et{constructor(e,t){super(e,t),this.posTracker=je.install(e,ze),this.lastErrOffset=-1;}_reportError(e){this.lastErrOffset!==this.posTracker.offset&&(this.lastErrOffset=this.posTracker.offset,super._reportError(e));}};var nt=class extends et{constructor(e,t){super(e,t);const n=je.install(e.preprocessor,tt,t);this.posTracker=n.posTracker;}};var st=class extends et{constructor(e,t){super(e,t),this.opts=t,this.ctLoc=null,this.locBeforeToken=!1;}_setErrorLocation(e){this.ctLoc&&(e.startLine=this.ctLoc.startLine,e.startCol=this.ctLoc.startCol,e.startOffset=this.ctLoc.startOffset,e.endLine=this.locBeforeToken?this.ctLoc.startLine:this.ctLoc.endLine,e.endCol=this.locBeforeToken?this.ctLoc.startCol:this.ctLoc.endCol,e.endOffset=this.locBeforeToken?this.ctLoc.startOffset:this.ctLoc.endOffset);}_getOverriddenMethods(e,t){return {_bootstrap(n,s){t._bootstrap.call(this,n,s),je.install(this.tokenizer,nt,e.opts),je.install(this.tokenizer,qe);},_processInputToken(n){e.ctLoc=n.location,t._processInputToken.call(this,n);},_err(t,n){e.locBeforeToken=n&&n.beforeToken,e._reportError(t);}}}},rt=Ke((function(e,t){const{DOCUMENT_MODE:n}=be;t.createDocument=function(){return {nodeName:"#document",mode:n.NO_QUIRKS,childNodes:[]}},t.createDocumentFragment=function(){return {nodeName:"#document-fragment",childNodes:[]}},t.createElement=function(e,t,n){return {nodeName:e,tagName:e,attrs:n,namespaceURI:t,childNodes:[],parentNode:null}},t.createCommentNode=function(e){return {nodeName:"#comment",data:e,parentNode:null}};const s=function(e){return {nodeName:"#text",value:e,parentNode:null}},r=t.appendChild=function(e,t){e.childNodes.push(t),t.parentNode=e;},i=t.insertBefore=function(e,t,n){const s=e.childNodes.indexOf(n);e.childNodes.splice(s,0,t),t.parentNode=e;};t.setTemplateContent=function(e,t){e.content=t;},t.getTemplateContent=function(e){return e.content},t.setDocumentType=function(e,t,n,s){let i=null;for(let t=0;t<e.childNodes.length;t++)if("#documentType"===e.childNodes[t].nodeName){i=e.childNodes[t];break}i?(i.name=t,i.publicId=n,i.systemId=s):r(e,{nodeName:"#documentType",name:t,publicId:n,systemId:s});},t.setDocumentMode=function(e,t){e.mode=t;},t.getDocumentMode=function(e){return e.mode},t.detachNode=function(e){if(e.parentNode){const t=e.parentNode.childNodes.indexOf(e);e.parentNode.childNodes.splice(t,1),e.parentNode=null;}},t.insertText=function(e,t){if(e.childNodes.length){const n=e.childNodes[e.childNodes.length-1];if("#text"===n.nodeName)return void(n.value+=t)}r(e,s(t));},t.insertTextBefore=function(e,t,n){const r=e.childNodes[e.childNodes.indexOf(n)-1];r&&"#text"===r.nodeName?r.value+=t:i(e,s(t),n);},t.adoptAttributes=function(e,t){const n=[];for(let t=0;t<e.attrs.length;t++)n.push(e.attrs[t].name);for(let s=0;s<t.length;s++)-1===n.indexOf(t[s].name)&&e.attrs.push(t[s]);},t.getFirstChild=function(e){return e.childNodes[0]},t.getChildNodes=function(e){return e.childNodes},t.getParentNode=function(e){return e.parentNode},t.getAttrList=function(e){return e.attrs},t.getTagName=function(e){return e.tagName},t.getNamespaceURI=function(e){return e.namespaceURI},t.getTextNodeContent=function(e){return e.value},t.getCommentNodeContent=function(e){return e.data},t.getDocumentTypeNodeName=function(e){return e.name},t.getDocumentTypeNodePublicId=function(e){return e.publicId},t.getDocumentTypeNodeSystemId=function(e){return e.systemId},t.isTextNode=function(e){return "#text"===e.nodeName},t.isCommentNode=function(e){return "#comment"===e.nodeName},t.isDocumentTypeNode=function(e){return "#documentType"===e.nodeName},t.isElementNode=function(e){return !!e.tagName},t.setNodeSourceCodeLocation=function(e,t){e.sourceCodeLocation=t;},t.getNodeSourceCodeLocation=function(e){return e.sourceCodeLocation};}));rt.createDocument,rt.createDocumentFragment,rt.createElement,rt.createCommentNode,rt.appendChild,rt.insertBefore,rt.setTemplateContent,rt.getTemplateContent,rt.setDocumentType,rt.setDocumentMode,rt.getDocumentMode,rt.detachNode,rt.insertText,rt.insertTextBefore,rt.adoptAttributes,rt.getFirstChild,rt.getChildNodes,rt.getParentNode,rt.getAttrList,rt.getTagName,rt.getNamespaceURI,rt.getTextNodeContent,rt.getCommentNodeContent,rt.getDocumentTypeNodeName,rt.getDocumentTypeNodePublicId,rt.getDocumentTypeNodeSystemId,rt.isTextNode,rt.isCommentNode,rt.isDocumentTypeNode,rt.isElementNode,rt.setNodeSourceCodeLocation,rt.getNodeSourceCodeLocation;const{DOCUMENT_MODE:it}=be,Tt=["+//silmaril//dtd html pro v0r11 19970101//","-//as//dtd html 3.0 aswedit + extensions//","-//advasoft ltd//dtd html 3.0 aswedit + extensions//","-//ietf//dtd html 2.0 level 1//","-//ietf//dtd html 2.0 level 2//","-//ietf//dtd html 2.0 strict level 1//","-//ietf//dtd html 2.0 strict level 2//","-//ietf//dtd html 2.0 strict//","-//ietf//dtd html 2.0//","-//ietf//dtd html 2.1e//","-//ietf//dtd html 3.0//","-//ietf//dtd html 3.2 final//","-//ietf//dtd html 3.2//","-//ietf//dtd html 3//","-//ietf//dtd html level 0//","-//ietf//dtd html level 1//","-//ietf//dtd html level 2//","-//ietf//dtd html level 3//","-//ietf//dtd html strict level 0//","-//ietf//dtd html strict level 1//","-//ietf//dtd html strict level 2//","-//ietf//dtd html strict level 3//","-//ietf//dtd html strict//","-//ietf//dtd html//","-//metrius//dtd metrius presentational//","-//microsoft//dtd internet explorer 2.0 html strict//","-//microsoft//dtd internet explorer 2.0 html//","-//microsoft//dtd internet explorer 2.0 tables//","-//microsoft//dtd internet explorer 3.0 html strict//","-//microsoft//dtd internet explorer 3.0 html//","-//microsoft//dtd internet explorer 3.0 tables//","-//netscape comm. corp.//dtd html//","-//netscape comm. corp.//dtd strict html//","-//o'reilly and associates//dtd html 2.0//","-//o'reilly and associates//dtd html extended 1.0//","-//o'reilly and associates//dtd html extended relaxed 1.0//","-//sq//dtd html 2.0 hotmetal + extensions//","-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//","-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//","-//spyglass//dtd html 2.0 extended//","-//sun microsystems corp.//dtd hotjava html//","-//sun microsystems corp.//dtd hotjava strict html//","-//w3c//dtd html 3 1995-03-24//","-//w3c//dtd html 3.2 draft//","-//w3c//dtd html 3.2 final//","-//w3c//dtd html 3.2//","-//w3c//dtd html 3.2s draft//","-//w3c//dtd html 4.0 frameset//","-//w3c//dtd html 4.0 transitional//","-//w3c//dtd html experimental 19960712//","-//w3c//dtd html experimental 970421//","-//w3c//dtd w3 html//","-//w3o//dtd w3 html 3.0//","-//webtechs//dtd mozilla html 2.0//","-//webtechs//dtd mozilla html//"],ot=Tt.concat(["-//w3c//dtd html 4.01 frameset//","-//w3c//dtd html 4.01 transitional//"]),Et=["-//w3o//dtd w3 html strict 3.0//en//","-/w3c/dtd html 4.0 transitional/en","html"],at=["-//w3c//dtd xhtml 1.0 frameset//","-//w3c//dtd xhtml 1.0 transitional//"],_t=at.concat(["-//w3c//dtd html 4.01 frameset//","-//w3c//dtd html 4.01 transitional//"]);function At(e,t){for(let n=0;n<t.length;n++)if(0===e.indexOf(t[n]))return !0;return !1}var ht=function(e){return "html"===e.name&&null===e.publicId&&(null===e.systemId||"about:legacy-compat"===e.systemId)},ct=function(e){if("html"!==e.name)return it.QUIRKS;const t=e.systemId;if(t&&"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"===t.toLowerCase())return it.QUIRKS;let n=e.publicId;if(null!==n){if(n=n.toLowerCase(),Et.indexOf(n)>-1)return it.QUIRKS;let e=null===t?ot:Tt;if(At(n,e))return it.QUIRKS;if(e=null===t?at:_t,At(n,e))return it.LIMITED_QUIRKS}return it.NO_QUIRKS},lt=Ke((function(e,t){const n=be.TAG_NAMES,s=be.NAMESPACES,r=be.ATTRS,i="text/html",T="application/xhtml+xml",o={attributename:"attributeName",attributetype:"attributeType",basefrequency:"baseFrequency",baseprofile:"baseProfile",calcmode:"calcMode",clippathunits:"clipPathUnits",diffuseconstant:"diffuseConstant",edgemode:"edgeMode",filterunits:"filterUnits",glyphref:"glyphRef",gradienttransform:"gradientTransform",gradientunits:"gradientUnits",kernelmatrix:"kernelMatrix",kernelunitlength:"kernelUnitLength",keypoints:"keyPoints",keysplines:"keySplines",keytimes:"keyTimes",lengthadjust:"lengthAdjust",limitingconeangle:"limitingConeAngle",markerheight:"markerHeight",markerunits:"markerUnits",markerwidth:"markerWidth",maskcontentunits:"maskContentUnits",maskunits:"maskUnits",numoctaves:"numOctaves",pathlength:"pathLength",patterncontentunits:"patternContentUnits",patterntransform:"patternTransform",patternunits:"patternUnits",pointsatx:"pointsAtX",pointsaty:"pointsAtY",pointsatz:"pointsAtZ",preservealpha:"preserveAlpha",preserveaspectratio:"preserveAspectRatio",primitiveunits:"primitiveUnits",refx:"refX",refy:"refY",repeatcount:"repeatCount",repeatdur:"repeatDur",requiredextensions:"requiredExtensions",requiredfeatures:"requiredFeatures",specularconstant:"specularConstant",specularexponent:"specularExponent",spreadmethod:"spreadMethod",startoffset:"startOffset",stddeviation:"stdDeviation",stitchtiles:"stitchTiles",surfacescale:"surfaceScale",systemlanguage:"systemLanguage",tablevalues:"tableValues",targetx:"targetX",targety:"targetY",textlength:"textLength",viewbox:"viewBox",viewtarget:"viewTarget",xchannelselector:"xChannelSelector",ychannelselector:"yChannelSelector",zoomandpan:"zoomAndPan"},E={"xlink:actuate":{prefix:"xlink",name:"actuate",namespace:s.XLINK},"xlink:arcrole":{prefix:"xlink",name:"arcrole",namespace:s.XLINK},"xlink:href":{prefix:"xlink",name:"href",namespace:s.XLINK},"xlink:role":{prefix:"xlink",name:"role",namespace:s.XLINK},"xlink:show":{prefix:"xlink",name:"show",namespace:s.XLINK},"xlink:title":{prefix:"xlink",name:"title",namespace:s.XLINK},"xlink:type":{prefix:"xlink",name:"type",namespace:s.XLINK},"xml:base":{prefix:"xml",name:"base",namespace:s.XML},"xml:lang":{prefix:"xml",name:"lang",namespace:s.XML},"xml:space":{prefix:"xml",name:"space",namespace:s.XML},xmlns:{prefix:"",name:"xmlns",namespace:s.XMLNS},"xmlns:xlink":{prefix:"xmlns",name:"xlink",namespace:s.XMLNS}},a=t.SVG_TAG_NAMES_ADJUSTMENT_MAP={altglyph:"altGlyph",altglyphdef:"altGlyphDef",altglyphitem:"altGlyphItem",animatecolor:"animateColor",animatemotion:"animateMotion",animatetransform:"animateTransform",clippath:"clipPath",feblend:"feBlend",fecolormatrix:"feColorMatrix",fecomponenttransfer:"feComponentTransfer",fecomposite:"feComposite",feconvolvematrix:"feConvolveMatrix",fediffuselighting:"feDiffuseLighting",fedisplacementmap:"feDisplacementMap",fedistantlight:"feDistantLight",feflood:"feFlood",fefunca:"feFuncA",fefuncb:"feFuncB",fefuncg:"feFuncG",fefuncr:"feFuncR",fegaussianblur:"feGaussianBlur",feimage:"feImage",femerge:"feMerge",femergenode:"feMergeNode",femorphology:"feMorphology",feoffset:"feOffset",fepointlight:"fePointLight",fespecularlighting:"feSpecularLighting",fespotlight:"feSpotLight",fetile:"feTile",feturbulence:"feTurbulence",foreignobject:"foreignObject",glyphref:"glyphRef",lineargradient:"linearGradient",radialgradient:"radialGradient",textpath:"textPath"},_={[n.B]:!0,[n.BIG]:!0,[n.BLOCKQUOTE]:!0,[n.BODY]:!0,[n.BR]:!0,[n.CENTER]:!0,[n.CODE]:!0,[n.DD]:!0,[n.DIV]:!0,[n.DL]:!0,[n.DT]:!0,[n.EM]:!0,[n.EMBED]:!0,[n.H1]:!0,[n.H2]:!0,[n.H3]:!0,[n.H4]:!0,[n.H5]:!0,[n.H6]:!0,[n.HEAD]:!0,[n.HR]:!0,[n.I]:!0,[n.IMG]:!0,[n.LI]:!0,[n.LISTING]:!0,[n.MENU]:!0,[n.META]:!0,[n.NOBR]:!0,[n.OL]:!0,[n.P]:!0,[n.PRE]:!0,[n.RUBY]:!0,[n.S]:!0,[n.SMALL]:!0,[n.SPAN]:!0,[n.STRONG]:!0,[n.STRIKE]:!0,[n.SUB]:!0,[n.SUP]:!0,[n.TABLE]:!0,[n.TT]:!0,[n.U]:!0,[n.UL]:!0,[n.VAR]:!0};t.causesExit=function(e){const t=e.tagName;return !!(t===n.FONT&&(null!==Ge.getTokenAttr(e,r.COLOR)||null!==Ge.getTokenAttr(e,r.SIZE)||null!==Ge.getTokenAttr(e,r.FACE)))||_[t]},t.adjustTokenMathMLAttrs=function(e){for(let t=0;t<e.attrs.length;t++)if("definitionurl"===e.attrs[t].name){e.attrs[t].name="definitionURL";break}},t.adjustTokenSVGAttrs=function(e){for(let t=0;t<e.attrs.length;t++){const n=o[e.attrs[t].name];n&&(e.attrs[t].name=n);}},t.adjustTokenXMLAttrs=function(e){for(let t=0;t<e.attrs.length;t++){const n=E[e.attrs[t].name];n&&(e.attrs[t].prefix=n.prefix,e.attrs[t].name=n.name,e.attrs[t].namespace=n.namespace);}},t.adjustTokenSVGTagName=function(e){const t=a[e.tagName];t&&(e.tagName=t);},t.isIntegrationPoint=function(e,t,o,E){return !(E&&E!==s.HTML||!function(e,t,o){if(t===s.MATHML&&e===n.ANNOTATION_XML)for(let e=0;e<o.length;e++)if(o[e].name===r.ENCODING){const t=o[e].value.toLowerCase();return t===i||t===T}return t===s.SVG&&(e===n.FOREIGN_OBJECT||e===n.DESC||e===n.TITLE)}(e,t,o))||!(E&&E!==s.MATHML||!function(e,t){return t===s.MATHML&&(e===n.MI||e===n.MO||e===n.MN||e===n.MS||e===n.MTEXT)}(e,t))};}));lt.SVG_TAG_NAMES_ADJUSTMENT_MAP,lt.causesExit,lt.adjustTokenMathMLAttrs,lt.adjustTokenSVGAttrs,lt.adjustTokenXMLAttrs,lt.adjustTokenSVGTagName,lt.isIntegrationPoint;const mt=be.TAG_NAMES,pt=be.NAMESPACES,Nt=be.ATTRS,ut={scriptingEnabled:!0,sourceCodeLocationInfo:!1,onParseError:null,treeAdapter:rt},Ot="IN_TABLE_MODE",St={[mt.TR]:"IN_ROW_MODE",[mt.TBODY]:"IN_TABLE_BODY_MODE",[mt.THEAD]:"IN_TABLE_BODY_MODE",[mt.TFOOT]:"IN_TABLE_BODY_MODE",[mt.CAPTION]:"IN_CAPTION_MODE",[mt.COLGROUP]:"IN_COLUMN_GROUP_MODE",[mt.TABLE]:Ot,[mt.BODY]:"IN_BODY_MODE",[mt.FRAMESET]:"IN_FRAMESET_MODE"},Ct={[mt.CAPTION]:Ot,[mt.COLGROUP]:Ot,[mt.TBODY]:Ot,[mt.TFOOT]:Ot,[mt.THEAD]:Ot,[mt.COL]:"IN_COLUMN_GROUP_MODE",[mt.TR]:"IN_TABLE_BODY_MODE",[mt.TD]:"IN_ROW_MODE",[mt.TH]:"IN_ROW_MODE"},dt={INITIAL_MODE:{[Ge.CHARACTER_TOKEN]:Kt,[Ge.NULL_CHARACTER_TOKEN]:Kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:kt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:function(e,t){e._setDocumentType(t);const n=t.forceQuirks?be.DOCUMENT_MODE.QUIRKS:ct(t);ht(t)||e._err(ie);e.treeAdapter.setDocumentMode(e.document,n),e.insertionMode="BEFORE_HTML_MODE";},[Ge.START_TAG_TOKEN]:Kt,[Ge.END_TAG_TOKEN]:Kt,[Ge.EOF_TOKEN]:Kt},BEFORE_HTML_MODE:{[Ge.CHARACTER_TOKEN]:bt,[Ge.NULL_CHARACTER_TOKEN]:bt,[Ge.WHITESPACE_CHARACTER_TOKEN]:kt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){t.tagName===mt.HTML?(e._insertElement(t,pt.HTML),e.insertionMode="BEFORE_HEAD_MODE"):bt(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n!==mt.HTML&&n!==mt.HEAD&&n!==mt.BODY&&n!==mt.BR||bt(e,t);},[Ge.EOF_TOKEN]:bt},BEFORE_HEAD_MODE:{[Ge.CHARACTER_TOKEN]:Yt,[Ge.NULL_CHARACTER_TOKEN]:Yt,[Ge.WHITESPACE_CHARACTER_TOKEN]:kt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:Ht,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.HTML?sn(e,t):n===mt.HEAD?(e._insertElement(t,pt.HTML),e.headElement=e.openElements.current,e.insertionMode="IN_HEAD_MODE"):Yt(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.HEAD||n===mt.BODY||n===mt.HTML||n===mt.BR?Yt(e,t):e._err(Ee);},[Ge.EOF_TOKEN]:Yt},IN_HEAD_MODE:{[Ge.CHARACTER_TOKEN]:vt,[Ge.NULL_CHARACTER_TOKEN]:vt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Bt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:Ht,[Ge.START_TAG_TOKEN]:xt,[Ge.END_TAG_TOKEN]:yt,[Ge.EOF_TOKEN]:vt},IN_HEAD_NO_SCRIPT_MODE:{[Ge.CHARACTER_TOKEN]:wt,[Ge.NULL_CHARACTER_TOKEN]:wt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Bt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:Ht,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.HTML?sn(e,t):n===mt.BASEFONT||n===mt.BGSOUND||n===mt.HEAD||n===mt.LINK||n===mt.META||n===mt.NOFRAMES||n===mt.STYLE?xt(e,t):n===mt.NOSCRIPT?e._err(le):wt(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.NOSCRIPT?(e.openElements.pop(),e.insertionMode="IN_HEAD_MODE"):n===mt.BR?wt(e,t):e._err(Ee);},[Ge.EOF_TOKEN]:wt},AFTER_HEAD_MODE:{[Ge.CHARACTER_TOKEN]:Qt,[Ge.NULL_CHARACTER_TOKEN]:Qt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Bt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:Ht,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.HTML?sn(e,t):n===mt.BODY?(e._insertElement(t,pt.HTML),e.framesetOk=!1,e.insertionMode="IN_BODY_MODE"):n===mt.FRAMESET?(e._insertElement(t,pt.HTML),e.insertionMode="IN_FRAMESET_MODE"):n===mt.BASE||n===mt.BASEFONT||n===mt.BGSOUND||n===mt.LINK||n===mt.META||n===mt.NOFRAMES||n===mt.SCRIPT||n===mt.STYLE||n===mt.TEMPLATE||n===mt.TITLE?(e._err(he),e.openElements.push(e.headElement),xt(e,t),e.openElements.remove(e.headElement)):n===mt.HEAD?e._err(ce):Qt(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.BODY||n===mt.HTML||n===mt.BR?Qt(e,t):n===mt.TEMPLATE?yt(e,t):e._err(Ee);},[Ge.EOF_TOKEN]:Qt},IN_BODY_MODE:{[Ge.CHARACTER_TOKEN]:Wt,[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Xt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:sn,[Ge.END_TAG_TOKEN]:En,[Ge.EOF_TOKEN]:an},TEXT_MODE:{[Ge.CHARACTER_TOKEN]:Bt,[Ge.NULL_CHARACTER_TOKEN]:Bt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Bt,[Ge.COMMENT_TOKEN]:kt,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:kt,[Ge.END_TAG_TOKEN]:function(e,t){t.tagName===mt.SCRIPT&&(e.pendingScript=e.openElements.current);e.openElements.pop(),e.insertionMode=e.originalInsertionMode;},[Ge.EOF_TOKEN]:function(e,t){e._err(me),e.openElements.pop(),e.insertionMode=e.originalInsertionMode,e._processToken(t);}},[Ot]:{[Ge.CHARACTER_TOKEN]:_n,[Ge.NULL_CHARACTER_TOKEN]:_n,[Ge.WHITESPACE_CHARACTER_TOKEN]:_n,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:An,[Ge.END_TAG_TOKEN]:hn,[Ge.EOF_TOKEN]:an},IN_TABLE_TEXT_MODE:{[Ge.CHARACTER_TOKEN]:function(e,t){e.pendingCharacterTokens.push(t),e.hasNonWhitespacePendingCharacterToken=!0;},[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:function(e,t){e.pendingCharacterTokens.push(t);},[Ge.COMMENT_TOKEN]:ln,[Ge.DOCTYPE_TOKEN]:ln,[Ge.START_TAG_TOKEN]:ln,[Ge.END_TAG_TOKEN]:ln,[Ge.EOF_TOKEN]:ln},IN_CAPTION_MODE:{[Ge.CHARACTER_TOKEN]:Wt,[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Xt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.CAPTION||n===mt.COL||n===mt.COLGROUP||n===mt.TBODY||n===mt.TD||n===mt.TFOOT||n===mt.TH||n===mt.THEAD||n===mt.TR?e.openElements.hasInTableScope(mt.CAPTION)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(mt.CAPTION),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=Ot,e._processToken(t)):sn(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.CAPTION||n===mt.TABLE?e.openElements.hasInTableScope(mt.CAPTION)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(mt.CAPTION),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=Ot,n===mt.TABLE&&e._processToken(t)):n!==mt.BODY&&n!==mt.COL&&n!==mt.COLGROUP&&n!==mt.HTML&&n!==mt.TBODY&&n!==mt.TD&&n!==mt.TFOOT&&n!==mt.TH&&n!==mt.THEAD&&n!==mt.TR&&En(e,t);},[Ge.EOF_TOKEN]:an},IN_COLUMN_GROUP_MODE:{[Ge.CHARACTER_TOKEN]:mn,[Ge.NULL_CHARACTER_TOKEN]:mn,[Ge.WHITESPACE_CHARACTER_TOKEN]:Bt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.HTML?sn(e,t):n===mt.COL?(e._appendElement(t,pt.HTML),t.ackSelfClosing=!0):n===mt.TEMPLATE?xt(e,t):mn(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.COLGROUP?e.openElements.currentTagName===mt.COLGROUP&&(e.openElements.pop(),e.insertionMode=Ot):n===mt.TEMPLATE?yt(e,t):n!==mt.COL&&mn(e,t);},[Ge.EOF_TOKEN]:an},IN_TABLE_BODY_MODE:{[Ge.CHARACTER_TOKEN]:_n,[Ge.NULL_CHARACTER_TOKEN]:_n,[Ge.WHITESPACE_CHARACTER_TOKEN]:_n,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.TR?(e.openElements.clearBackToTableBodyContext(),e._insertElement(t,pt.HTML),e.insertionMode="IN_ROW_MODE"):n===mt.TH||n===mt.TD?(e.openElements.clearBackToTableBodyContext(),e._insertFakeElement(mt.TR),e.insertionMode="IN_ROW_MODE",e._processToken(t)):n===mt.CAPTION||n===mt.COL||n===mt.COLGROUP||n===mt.TBODY||n===mt.TFOOT||n===mt.THEAD?e.openElements.hasTableBodyContextInTableScope()&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=Ot,e._processToken(t)):An(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.TBODY||n===mt.TFOOT||n===mt.THEAD?e.openElements.hasInTableScope(n)&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=Ot):n===mt.TABLE?e.openElements.hasTableBodyContextInTableScope()&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=Ot,e._processToken(t)):(n!==mt.BODY&&n!==mt.CAPTION&&n!==mt.COL&&n!==mt.COLGROUP||n!==mt.HTML&&n!==mt.TD&&n!==mt.TH&&n!==mt.TR)&&hn(e,t);},[Ge.EOF_TOKEN]:an},IN_ROW_MODE:{[Ge.CHARACTER_TOKEN]:_n,[Ge.NULL_CHARACTER_TOKEN]:_n,[Ge.WHITESPACE_CHARACTER_TOKEN]:_n,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.TH||n===mt.TD?(e.openElements.clearBackToTableRowContext(),e._insertElement(t,pt.HTML),e.insertionMode="IN_CELL_MODE",e.activeFormattingElements.insertMarker()):n===mt.CAPTION||n===mt.COL||n===mt.COLGROUP||n===mt.TBODY||n===mt.TFOOT||n===mt.THEAD||n===mt.TR?e.openElements.hasInTableScope(mt.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode="IN_TABLE_BODY_MODE",e._processToken(t)):An(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.TR?e.openElements.hasInTableScope(mt.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode="IN_TABLE_BODY_MODE"):n===mt.TABLE?e.openElements.hasInTableScope(mt.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode="IN_TABLE_BODY_MODE",e._processToken(t)):n===mt.TBODY||n===mt.TFOOT||n===mt.THEAD?(e.openElements.hasInTableScope(n)||e.openElements.hasInTableScope(mt.TR))&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode="IN_TABLE_BODY_MODE",e._processToken(t)):(n!==mt.BODY&&n!==mt.CAPTION&&n!==mt.COL&&n!==mt.COLGROUP||n!==mt.HTML&&n!==mt.TD&&n!==mt.TH)&&hn(e,t);},[Ge.EOF_TOKEN]:an},IN_CELL_MODE:{[Ge.CHARACTER_TOKEN]:Wt,[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Xt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.CAPTION||n===mt.COL||n===mt.COLGROUP||n===mt.TBODY||n===mt.TD||n===mt.TFOOT||n===mt.TH||n===mt.THEAD||n===mt.TR?(e.openElements.hasInTableScope(mt.TD)||e.openElements.hasInTableScope(mt.TH))&&(e._closeTableCell(),e._processToken(t)):sn(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.TD||n===mt.TH?e.openElements.hasInTableScope(n)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(n),e.activeFormattingElements.clearToLastMarker(),e.insertionMode="IN_ROW_MODE"):n===mt.TABLE||n===mt.TBODY||n===mt.TFOOT||n===mt.THEAD||n===mt.TR?e.openElements.hasInTableScope(n)&&(e._closeTableCell(),e._processToken(t)):n!==mt.BODY&&n!==mt.CAPTION&&n!==mt.COL&&n!==mt.COLGROUP&&n!==mt.HTML&&En(e,t);},[Ge.EOF_TOKEN]:an},IN_SELECT_MODE:{[Ge.CHARACTER_TOKEN]:Bt,[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Bt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:pn,[Ge.END_TAG_TOKEN]:Nn,[Ge.EOF_TOKEN]:an},IN_SELECT_IN_TABLE_MODE:{[Ge.CHARACTER_TOKEN]:Bt,[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Bt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.CAPTION||n===mt.TABLE||n===mt.TBODY||n===mt.TFOOT||n===mt.THEAD||n===mt.TR||n===mt.TD||n===mt.TH?(e.openElements.popUntilTagNamePopped(mt.SELECT),e._resetInsertionMode(),e._processToken(t)):pn(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.CAPTION||n===mt.TABLE||n===mt.TBODY||n===mt.TFOOT||n===mt.THEAD||n===mt.TR||n===mt.TD||n===mt.TH?e.openElements.hasInTableScope(n)&&(e.openElements.popUntilTagNamePopped(mt.SELECT),e._resetInsertionMode(),e._processToken(t)):Nn(e,t);},[Ge.EOF_TOKEN]:an},IN_TEMPLATE_MODE:{[Ge.CHARACTER_TOKEN]:Wt,[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Xt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;if(n===mt.BASE||n===mt.BASEFONT||n===mt.BGSOUND||n===mt.LINK||n===mt.META||n===mt.NOFRAMES||n===mt.SCRIPT||n===mt.STYLE||n===mt.TEMPLATE||n===mt.TITLE)xt(e,t);else{const s=Ct[n]||"IN_BODY_MODE";e._popTmplInsertionMode(),e._pushTmplInsertionMode(s),e.insertionMode=s,e._processToken(t);}},[Ge.END_TAG_TOKEN]:function(e,t){t.tagName===mt.TEMPLATE&&yt(e,t);},[Ge.EOF_TOKEN]:un},AFTER_BODY_MODE:{[Ge.CHARACTER_TOKEN]:On,[Ge.NULL_CHARACTER_TOKEN]:On,[Ge.WHITESPACE_CHARACTER_TOKEN]:Xt,[Ge.COMMENT_TOKEN]:function(e,t){e._appendCommentNode(t,e.openElements.items[0]);},[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){t.tagName===mt.HTML?sn(e,t):On(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){t.tagName===mt.HTML?e.fragmentContext||(e.insertionMode="AFTER_AFTER_BODY_MODE"):On(e,t);},[Ge.EOF_TOKEN]:Gt},IN_FRAMESET_MODE:{[Ge.CHARACTER_TOKEN]:kt,[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Bt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.HTML?sn(e,t):n===mt.FRAMESET?e._insertElement(t,pt.HTML):n===mt.FRAME?(e._appendElement(t,pt.HTML),t.ackSelfClosing=!0):n===mt.NOFRAMES&&xt(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){t.tagName!==mt.FRAMESET||e.openElements.isRootHtmlElementCurrent()||(e.openElements.pop(),e.fragmentContext||e.openElements.currentTagName===mt.FRAMESET||(e.insertionMode="AFTER_FRAMESET_MODE"));},[Ge.EOF_TOKEN]:Gt},AFTER_FRAMESET_MODE:{[Ge.CHARACTER_TOKEN]:kt,[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Bt,[Ge.COMMENT_TOKEN]:Ut,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.HTML?sn(e,t):n===mt.NOFRAMES&&xt(e,t);},[Ge.END_TAG_TOKEN]:function(e,t){t.tagName===mt.HTML&&(e.insertionMode="AFTER_AFTER_FRAMESET_MODE");},[Ge.EOF_TOKEN]:Gt},AFTER_AFTER_BODY_MODE:{[Ge.CHARACTER_TOKEN]:Sn,[Ge.NULL_CHARACTER_TOKEN]:Sn,[Ge.WHITESPACE_CHARACTER_TOKEN]:Xt,[Ge.COMMENT_TOKEN]:Ft,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){t.tagName===mt.HTML?sn(e,t):Sn(e,t);},[Ge.END_TAG_TOKEN]:Sn,[Ge.EOF_TOKEN]:Gt},AFTER_AFTER_FRAMESET_MODE:{[Ge.CHARACTER_TOKEN]:kt,[Ge.NULL_CHARACTER_TOKEN]:kt,[Ge.WHITESPACE_CHARACTER_TOKEN]:Xt,[Ge.COMMENT_TOKEN]:Ft,[Ge.DOCTYPE_TOKEN]:kt,[Ge.START_TAG_TOKEN]:function(e,t){const n=t.tagName;n===mt.HTML?sn(e,t):n===mt.NOFRAMES&&xt(e,t);},[Ge.END_TAG_TOKEN]:kt,[Ge.EOF_TOKEN]:Gt}};var Rt=class{constructor(e){this.options=function(e,t){return [e,t=t||Object.create(null)].reduce((e,t)=>(Object.keys(t).forEach(n=>{e[n]=t[n];}),e),Object.create(null))}(ut,e),this.treeAdapter=this.options.treeAdapter,this.pendingScript=null,this.options.sourceCodeLocationInfo&&je.install(this,$e),this.options.onParseError&&je.install(this,st,{onParseError:this.options.onParseError});}parse(e){const t=this.treeAdapter.createDocument();return this._bootstrap(t,null),this.tokenizer.write(e,!0),this._runParsingLoop(null),t}parseFragment(e,t){t||(t=this.treeAdapter.createElement(mt.TEMPLATE,pt.HTML,[]));const n=this.treeAdapter.createElement("documentmock",pt.HTML,[]);this._bootstrap(n,t),this.treeAdapter.getTagName(t)===mt.TEMPLATE&&this._pushTmplInsertionMode("IN_TEMPLATE_MODE"),this._initTokenizerForFragmentParsing(),this._insertFakeRootElement(),this._resetInsertionMode(),this._findFormInFragmentContext(),this.tokenizer.write(e,!0),this._runParsingLoop(null);const s=this.treeAdapter.getFirstChild(n),r=this.treeAdapter.createDocumentFragment();return this._adoptNodes(s,r),r}_bootstrap(e,t){this.tokenizer=new Ge(this.options),this.stopped=!1,this.insertionMode="INITIAL_MODE",this.originalInsertionMode="",this.document=e,this.fragmentContext=t,this.headElement=null,this.formElement=null,this.openElements=new Qe(this.document,this.treeAdapter),this.activeFormattingElements=new We(this.treeAdapter),this.tmplInsertionModeStack=[],this.tmplInsertionModeStackTop=-1,this.currentTmplInsertionMode=null,this.pendingCharacterTokens=[],this.hasNonWhitespacePendingCharacterToken=!1,this.framesetOk=!0,this.skipNextNewLine=!1,this.fosterParentingEnabled=!1;}_err(){}_runParsingLoop(e){for(;!this.stopped;){this._setupTokenizerCDATAMode();const t=this.tokenizer.getNextToken();if(t.type===Ge.HIBERNATION_TOKEN)break;if(this.skipNextNewLine&&(this.skipNextNewLine=!1,t.type===Ge.WHITESPACE_CHARACTER_TOKEN&&"\n"===t.chars[0])){if(1===t.chars.length)continue;t.chars=t.chars.substr(1);}if(this._processInputToken(t),e&&this.pendingScript)break}}runParsingLoopForCurrentChunk(e,t){if(this._runParsingLoop(t),t&&this.pendingScript){const e=this.pendingScript;return this.pendingScript=null,void t(e)}e&&e();}_setupTokenizerCDATAMode(){const e=this._getAdjustedCurrentElement();this.tokenizer.allowCDATA=e&&e!==this.document&&this.treeAdapter.getNamespaceURI(e)!==pt.HTML&&!this._isIntegrationPoint(e);}_switchToTextParsing(e,t){this._insertElement(e,pt.HTML),this.tokenizer.state=t,this.originalInsertionMode=this.insertionMode,this.insertionMode="TEXT_MODE";}switchToPlaintextParsing(){this.insertionMode="TEXT_MODE",this.originalInsertionMode="IN_BODY_MODE",this.tokenizer.state=Ge.MODE.PLAINTEXT;}_getAdjustedCurrentElement(){return 0===this.openElements.stackTop&&this.fragmentContext?this.fragmentContext:this.openElements.current}_findFormInFragmentContext(){let e=this.fragmentContext;do{if(this.treeAdapter.getTagName(e)===mt.FORM){this.formElement=e;break}e=this.treeAdapter.getParentNode(e);}while(e)}_initTokenizerForFragmentParsing(){if(this.treeAdapter.getNamespaceURI(this.fragmentContext)===pt.HTML){const e=this.treeAdapter.getTagName(this.fragmentContext);e===mt.TITLE||e===mt.TEXTAREA?this.tokenizer.state=Ge.MODE.RCDATA:e===mt.STYLE||e===mt.XMP||e===mt.IFRAME||e===mt.NOEMBED||e===mt.NOFRAMES||e===mt.NOSCRIPT?this.tokenizer.state=Ge.MODE.RAWTEXT:e===mt.SCRIPT?this.tokenizer.state=Ge.MODE.SCRIPT_DATA:e===mt.PLAINTEXT&&(this.tokenizer.state=Ge.MODE.PLAINTEXT);}}_setDocumentType(e){const t=e.name||"",n=e.publicId||"",s=e.systemId||"";this.treeAdapter.setDocumentType(this.document,t,n,s);}_attachElementToTree(e){if(this._shouldFosterParentOnInsertion())this._fosterParentElement(e);else{const t=this.openElements.currentTmplContent||this.openElements.current;this.treeAdapter.appendChild(t,e);}}_appendElement(e,t){const n=this.treeAdapter.createElement(e.tagName,t,e.attrs);this._attachElementToTree(n);}_insertElement(e,t){const n=this.treeAdapter.createElement(e.tagName,t,e.attrs);this._attachElementToTree(n),this.openElements.push(n);}_insertFakeElement(e){const t=this.treeAdapter.createElement(e,pt.HTML,[]);this._attachElementToTree(t),this.openElements.push(t);}_insertTemplate(e){const t=this.treeAdapter.createElement(e.tagName,pt.HTML,e.attrs),n=this.treeAdapter.createDocumentFragment();this.treeAdapter.setTemplateContent(t,n),this._attachElementToTree(t),this.openElements.push(t);}_insertFakeRootElement(){const e=this.treeAdapter.createElement(mt.HTML,pt.HTML,[]);this.treeAdapter.appendChild(this.openElements.current,e),this.openElements.push(e);}_appendCommentNode(e,t){const n=this.treeAdapter.createCommentNode(e.data);this.treeAdapter.appendChild(t,n);}_insertCharacters(e){if(this._shouldFosterParentOnInsertion())this._fosterParentText(e.chars);else{const t=this.openElements.currentTmplContent||this.openElements.current;this.treeAdapter.insertText(t,e.chars);}}_adoptNodes(e,t){for(let n=this.treeAdapter.getFirstChild(e);n;n=this.treeAdapter.getFirstChild(e))this.treeAdapter.detachNode(n),this.treeAdapter.appendChild(t,n);}_shouldProcessTokenInForeignContent(e){const t=this._getAdjustedCurrentElement();if(!t||t===this.document)return !1;const n=this.treeAdapter.getNamespaceURI(t);if(n===pt.HTML)return !1;if(this.treeAdapter.getTagName(t)===mt.ANNOTATION_XML&&n===pt.MATHML&&e.type===Ge.START_TAG_TOKEN&&e.tagName===mt.SVG)return !1;const s=e.type===Ge.CHARACTER_TOKEN||e.type===Ge.NULL_CHARACTER_TOKEN||e.type===Ge.WHITESPACE_CHARACTER_TOKEN;return (!(e.type===Ge.START_TAG_TOKEN&&e.tagName!==mt.MGLYPH&&e.tagName!==mt.MALIGNMARK)&&!s||!this._isIntegrationPoint(t,pt.MATHML))&&((e.type!==Ge.START_TAG_TOKEN&&!s||!this._isIntegrationPoint(t,pt.HTML))&&e.type!==Ge.EOF_TOKEN)}_processToken(e){dt[this.insertionMode][e.type](this,e);}_processTokenInBodyMode(e){dt.IN_BODY_MODE[e.type](this,e);}_processTokenInForeignContent(e){e.type===Ge.CHARACTER_TOKEN?function(e,t){e._insertCharacters(t),e.framesetOk=!1;}(this,e):e.type===Ge.NULL_CHARACTER_TOKEN?function(e,t){t.chars=n,e._insertCharacters(t);}(this,e):e.type===Ge.WHITESPACE_CHARACTER_TOKEN?Bt(this,e):e.type===Ge.COMMENT_TOKEN?Ut(this,e):e.type===Ge.START_TAG_TOKEN?function(e,t){if(lt.causesExit(t)&&!e.fragmentContext){for(;e.treeAdapter.getNamespaceURI(e.openElements.current)!==pt.HTML&&!e._isIntegrationPoint(e.openElements.current);)e.openElements.pop();e._processToken(t);}else{const n=e._getAdjustedCurrentElement(),s=e.treeAdapter.getNamespaceURI(n);s===pt.MATHML?lt.adjustTokenMathMLAttrs(t):s===pt.SVG&&(lt.adjustTokenSVGTagName(t),lt.adjustTokenSVGAttrs(t)),lt.adjustTokenXMLAttrs(t),t.selfClosing?e._appendElement(t,s):e._insertElement(t,s),t.ackSelfClosing=!0;}}(this,e):e.type===Ge.END_TAG_TOKEN&&function(e,t){for(let n=e.openElements.stackTop;n>0;n--){const s=e.openElements.items[n];if(e.treeAdapter.getNamespaceURI(s)===pt.HTML){e._processToken(t);break}if(e.treeAdapter.getTagName(s).toLowerCase()===t.tagName){e.openElements.popUntilElementPopped(s);break}}}(this,e);}_processInputToken(e){this._shouldProcessTokenInForeignContent(e)?this._processTokenInForeignContent(e):this._processToken(e),e.type===Ge.START_TAG_TOKEN&&e.selfClosing&&!e.ackSelfClosing&&this._err(c);}_isIntegrationPoint(e,t){const n=this.treeAdapter.getTagName(e),s=this.treeAdapter.getNamespaceURI(e),r=this.treeAdapter.getAttrList(e);return lt.isIntegrationPoint(n,s,r,t)}_reconstructActiveFormattingElements(){const e=this.activeFormattingElements.length;if(e){let t=e,n=null;do{if(t--,n=this.activeFormattingElements.entries[t],n.type===We.MARKER_ENTRY||this.openElements.contains(n.element)){t++;break}}while(t>0);for(let s=t;s<e;s++)n=this.activeFormattingElements.entries[s],this._insertElement(n.token,this.treeAdapter.getNamespaceURI(n.element)),n.element=this.openElements.current;}}_closeTableCell(){this.openElements.generateImpliedEndTags(),this.openElements.popUntilTableCellPopped(),this.activeFormattingElements.clearToLastMarker(),this.insertionMode="IN_ROW_MODE";}_closePElement(){this.openElements.generateImpliedEndTagsWithExclusion(mt.P),this.openElements.popUntilTagNamePopped(mt.P);}_resetInsertionMode(){for(let e=this.openElements.stackTop,t=!1;e>=0;e--){let n=this.openElements.items[e];0===e&&(t=!0,this.fragmentContext&&(n=this.fragmentContext));const s=this.treeAdapter.getTagName(n),r=St[s];if(r){this.insertionMode=r;break}if(!(t||s!==mt.TD&&s!==mt.TH)){this.insertionMode="IN_CELL_MODE";break}if(!t&&s===mt.HEAD){this.insertionMode="IN_HEAD_MODE";break}if(s===mt.SELECT){this._resetInsertionModeForSelect(e);break}if(s===mt.TEMPLATE){this.insertionMode=this.currentTmplInsertionMode;break}if(s===mt.HTML){this.insertionMode=this.headElement?"AFTER_HEAD_MODE":"BEFORE_HEAD_MODE";break}if(t){this.insertionMode="IN_BODY_MODE";break}}}_resetInsertionModeForSelect(e){if(e>0)for(let t=e-1;t>0;t--){const e=this.openElements.items[t],n=this.treeAdapter.getTagName(e);if(n===mt.TEMPLATE)break;if(n===mt.TABLE)return void(this.insertionMode="IN_SELECT_IN_TABLE_MODE")}this.insertionMode="IN_SELECT_MODE";}_pushTmplInsertionMode(e){this.tmplInsertionModeStack.push(e),this.tmplInsertionModeStackTop++,this.currentTmplInsertionMode=e;}_popTmplInsertionMode(){this.tmplInsertionModeStack.pop(),this.tmplInsertionModeStackTop--,this.currentTmplInsertionMode=this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];}_isElementCausesFosterParenting(e){const t=this.treeAdapter.getTagName(e);return t===mt.TABLE||t===mt.TBODY||t===mt.TFOOT||t===mt.THEAD||t===mt.TR}_shouldFosterParentOnInsertion(){return this.fosterParentingEnabled&&this._isElementCausesFosterParenting(this.openElements.current)}_findFosterParentingLocation(){const e={parent:null,beforeElement:null};for(let t=this.openElements.stackTop;t>=0;t--){const n=this.openElements.items[t],s=this.treeAdapter.getTagName(n),r=this.treeAdapter.getNamespaceURI(n);if(s===mt.TEMPLATE&&r===pt.HTML){e.parent=this.treeAdapter.getTemplateContent(n);break}if(s===mt.TABLE){e.parent=this.treeAdapter.getParentNode(n),e.parent?e.beforeElement=n:e.parent=this.openElements.items[t-1];break}}return e.parent||(e.parent=this.openElements.items[0]),e}_fosterParentElement(e){const t=this._findFosterParentingLocation();t.beforeElement?this.treeAdapter.insertBefore(t.parent,e,t.beforeElement):this.treeAdapter.appendChild(t.parent,e);}_fosterParentText(e){const t=this._findFosterParentingLocation();t.beforeElement?this.treeAdapter.insertTextBefore(t.parent,e,t.beforeElement):this.treeAdapter.insertText(t.parent,e);}_isSpecialElement(e){const t=this.treeAdapter.getTagName(e),n=this.treeAdapter.getNamespaceURI(e);return be.SPECIAL_ELEMENTS[n][t]}};function It(e,t){let n=e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);return n?e.openElements.contains(n.element)?e.openElements.hasInScope(t.tagName)||(n=null):(e.activeFormattingElements.removeEntry(n),n=null):on(e,t),n}function ft(e,t){let n=null;for(let s=e.openElements.stackTop;s>=0;s--){const r=e.openElements.items[s];if(r===t.element)break;e._isSpecialElement(r)&&(n=r);}return n||(e.openElements.popUntilElementPopped(t.element),e.activeFormattingElements.removeEntry(t)),n}function Mt(e,t,n){let s=t,r=e.openElements.getCommonAncestor(t);for(let i=0,T=r;T!==n;i++,T=r){r=e.openElements.getCommonAncestor(T);const n=e.activeFormattingElements.getElementEntry(T),o=n&&i>=3;!n||o?(o&&e.activeFormattingElements.removeEntry(n),e.openElements.remove(T)):(T=Lt(e,n),s===t&&(e.activeFormattingElements.bookmark=n),e.treeAdapter.detachNode(s),e.treeAdapter.appendChild(T,s),s=T);}return s}function Lt(e,t){const n=e.treeAdapter.getNamespaceURI(t.element),s=e.treeAdapter.createElement(t.token.tagName,n,t.token.attrs);return e.openElements.replace(t.element,s),t.element=s,s}function Dt(e,t,n){if(e._isElementCausesFosterParenting(t))e._fosterParentElement(n);else{const s=e.treeAdapter.getTagName(t),r=e.treeAdapter.getNamespaceURI(t);s===mt.TEMPLATE&&r===pt.HTML&&(t=e.treeAdapter.getTemplateContent(t)),e.treeAdapter.appendChild(t,n);}}function gt(e,t,n){const s=e.treeAdapter.getNamespaceURI(n.element),r=n.token,i=e.treeAdapter.createElement(r.tagName,s,r.attrs);e._adoptNodes(t,i),e.treeAdapter.appendChild(t,i),e.activeFormattingElements.insertElementAfterBookmark(i,n.token),e.activeFormattingElements.removeEntry(n),e.openElements.remove(n.element),e.openElements.insertAfter(t,i);}function Pt(e,t){let n;for(let s=0;s<8&&(n=It(e,t),n);s++){const t=ft(e,n);if(!t)break;e.activeFormattingElements.bookmark=n;const s=Mt(e,t,n.element),r=e.openElements.getCommonAncestor(n.element);e.treeAdapter.detachNode(s),Dt(e,r,s),gt(e,t,n);}}function kt(){}function Ht(e){e._err(oe);}function Ut(e,t){e._appendCommentNode(t,e.openElements.currentTmplContent||e.openElements.current);}function Ft(e,t){e._appendCommentNode(t,e.document);}function Bt(e,t){e._insertCharacters(t);}function Gt(e){e.stopped=!0;}function Kt(e,t){e._err(Te,{beforeToken:!0}),e.treeAdapter.setDocumentMode(e.document,be.DOCUMENT_MODE.QUIRKS),e.insertionMode="BEFORE_HTML_MODE",e._processToken(t);}function bt(e,t){e._insertFakeRootElement(),e.insertionMode="BEFORE_HEAD_MODE",e._processToken(t);}function Yt(e,t){e._insertFakeElement(mt.HEAD),e.headElement=e.openElements.current,e.insertionMode="IN_HEAD_MODE",e._processToken(t);}function xt(e,t){const n=t.tagName;n===mt.HTML?sn(e,t):n===mt.BASE||n===mt.BASEFONT||n===mt.BGSOUND||n===mt.LINK||n===mt.META?(e._appendElement(t,pt.HTML),t.ackSelfClosing=!0):n===mt.TITLE?e._switchToTextParsing(t,Ge.MODE.RCDATA):n===mt.NOSCRIPT?e.options.scriptingEnabled?e._switchToTextParsing(t,Ge.MODE.RAWTEXT):(e._insertElement(t,pt.HTML),e.insertionMode="IN_HEAD_NO_SCRIPT_MODE"):n===mt.NOFRAMES||n===mt.STYLE?e._switchToTextParsing(t,Ge.MODE.RAWTEXT):n===mt.SCRIPT?e._switchToTextParsing(t,Ge.MODE.SCRIPT_DATA):n===mt.TEMPLATE?(e._insertTemplate(t,pt.HTML),e.activeFormattingElements.insertMarker(),e.framesetOk=!1,e.insertionMode="IN_TEMPLATE_MODE",e._pushTmplInsertionMode("IN_TEMPLATE_MODE")):n===mt.HEAD?e._err(ce):vt(e,t);}function yt(e,t){const n=t.tagName;n===mt.HEAD?(e.openElements.pop(),e.insertionMode="AFTER_HEAD_MODE"):n===mt.BODY||n===mt.BR||n===mt.HTML?vt(e,t):n===mt.TEMPLATE&&e.openElements.tmplCount>0?(e.openElements.generateImpliedEndTagsThoroughly(),e.openElements.currentTagName!==mt.TEMPLATE&&e._err(ae),e.openElements.popUntilTagNamePopped(mt.TEMPLATE),e.activeFormattingElements.clearToLastMarker(),e._popTmplInsertionMode(),e._resetInsertionMode()):e._err(Ee);}function vt(e,t){e.openElements.pop(),e.insertionMode="AFTER_HEAD_MODE",e._processToken(t);}function wt(e,t){const n=t.type===Ge.EOF_TOKEN?Ae:_e;e._err(n),e.openElements.pop(),e.insertionMode="IN_HEAD_MODE",e._processToken(t);}function Qt(e,t){e._insertFakeElement(mt.BODY),e.insertionMode="IN_BODY_MODE",e._processToken(t);}function Xt(e,t){e._reconstructActiveFormattingElements(),e._insertCharacters(t);}function Wt(e,t){e._reconstructActiveFormattingElements(),e._insertCharacters(t),e.framesetOk=!1;}function Vt(e,t){e.openElements.hasInButtonScope(mt.P)&&e._closePElement(),e._insertElement(t,pt.HTML);}function jt(e,t){e.openElements.hasInButtonScope(mt.P)&&e._closePElement(),e._insertElement(t,pt.HTML),e.skipNextNewLine=!0,e.framesetOk=!1;}function zt(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,pt.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}function qt(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,pt.HTML),e.activeFormattingElements.insertMarker(),e.framesetOk=!1;}function Jt(e,t){e._reconstructActiveFormattingElements(),e._appendElement(t,pt.HTML),e.framesetOk=!1,t.ackSelfClosing=!0;}function Zt(e,t){e._appendElement(t,pt.HTML),t.ackSelfClosing=!0;}function $t(e,t){e._switchToTextParsing(t,Ge.MODE.RAWTEXT);}function en(e,t){e.openElements.currentTagName===mt.OPTION&&e.openElements.pop(),e._reconstructActiveFormattingElements(),e._insertElement(t,pt.HTML);}function tn(e,t){e.openElements.hasInScope(mt.RUBY)&&e.openElements.generateImpliedEndTags(),e._insertElement(t,pt.HTML);}function nn(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,pt.HTML);}function sn(e,t){const n=t.tagName;switch(n.length){case 1:n===mt.I||n===mt.S||n===mt.B||n===mt.U?zt(e,t):n===mt.P?Vt(e,t):n===mt.A?function(e,t){const n=e.activeFormattingElements.getElementEntryInScopeWithTagName(mt.A);n&&(Pt(e,t),e.openElements.remove(n.element),e.activeFormattingElements.removeEntry(n)),e._reconstructActiveFormattingElements(),e._insertElement(t,pt.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t):nn(e,t);break;case 2:n===mt.DL||n===mt.OL||n===mt.UL?Vt(e,t):n===mt.H1||n===mt.H2||n===mt.H3||n===mt.H4||n===mt.H5||n===mt.H6?function(e,t){e.openElements.hasInButtonScope(mt.P)&&e._closePElement();const n=e.openElements.currentTagName;n!==mt.H1&&n!==mt.H2&&n!==mt.H3&&n!==mt.H4&&n!==mt.H5&&n!==mt.H6||e.openElements.pop(),e._insertElement(t,pt.HTML);}(e,t):n===mt.LI||n===mt.DD||n===mt.DT?function(e,t){e.framesetOk=!1;const n=t.tagName;for(let t=e.openElements.stackTop;t>=0;t--){const s=e.openElements.items[t],r=e.treeAdapter.getTagName(s);let i=null;if(n===mt.LI&&r===mt.LI?i=mt.LI:n!==mt.DD&&n!==mt.DT||r!==mt.DD&&r!==mt.DT||(i=r),i){e.openElements.generateImpliedEndTagsWithExclusion(i),e.openElements.popUntilTagNamePopped(i);break}if(r!==mt.ADDRESS&&r!==mt.DIV&&r!==mt.P&&e._isSpecialElement(s))break}e.openElements.hasInButtonScope(mt.P)&&e._closePElement(),e._insertElement(t,pt.HTML);}(e,t):n===mt.EM||n===mt.TT?zt(e,t):n===mt.BR?Jt(e,t):n===mt.HR?function(e,t){e.openElements.hasInButtonScope(mt.P)&&e._closePElement(),e._appendElement(t,pt.HTML),e.framesetOk=!1,e.ackSelfClosing=!0;}(e,t):n===mt.RB?tn(e,t):n===mt.RT||n===mt.RP?function(e,t){e.openElements.hasInScope(mt.RUBY)&&e.openElements.generateImpliedEndTagsWithExclusion(mt.RTC),e._insertElement(t,pt.HTML);}(e,t):n!==mt.TH&&n!==mt.TD&&n!==mt.TR&&nn(e,t);break;case 3:n===mt.DIV||n===mt.DIR||n===mt.NAV?Vt(e,t):n===mt.PRE?jt(e,t):n===mt.BIG?zt(e,t):n===mt.IMG||n===mt.WBR?Jt(e,t):n===mt.XMP?function(e,t){e.openElements.hasInButtonScope(mt.P)&&e._closePElement(),e._reconstructActiveFormattingElements(),e.framesetOk=!1,e._switchToTextParsing(t,Ge.MODE.RAWTEXT);}(e,t):n===mt.SVG?function(e,t){e._reconstructActiveFormattingElements(),lt.adjustTokenSVGAttrs(t),lt.adjustTokenXMLAttrs(t),t.selfClosing?e._appendElement(t,pt.SVG):e._insertElement(t,pt.SVG),t.ackSelfClosing=!0;}(e,t):n===mt.RTC?tn(e,t):n!==mt.COL&&nn(e,t);break;case 4:n===mt.HTML?function(e,t){0===e.openElements.tmplCount&&e.treeAdapter.adoptAttributes(e.openElements.items[0],t.attrs);}(e,t):n===mt.BASE||n===mt.LINK||n===mt.META?xt(e,t):n===mt.BODY?function(e,t){const n=e.openElements.tryPeekProperlyNestedBodyElement();n&&0===e.openElements.tmplCount&&(e.framesetOk=!1,e.treeAdapter.adoptAttributes(n,t.attrs));}(e,t):n===mt.MAIN||n===mt.MENU?Vt(e,t):n===mt.FORM?function(e,t){const n=e.openElements.tmplCount>0;e.formElement&&!n||(e.openElements.hasInButtonScope(mt.P)&&e._closePElement(),e._insertElement(t,pt.HTML),n||(e.formElement=e.openElements.current));}(e,t):n===mt.CODE||n===mt.FONT?zt(e,t):n===mt.NOBR?function(e,t){e._reconstructActiveFormattingElements(),e.openElements.hasInScope(mt.NOBR)&&(Pt(e,t),e._reconstructActiveFormattingElements()),e._insertElement(t,pt.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t):n===mt.AREA?Jt(e,t):n===mt.MATH?function(e,t){e._reconstructActiveFormattingElements(),lt.adjustTokenMathMLAttrs(t),lt.adjustTokenXMLAttrs(t),t.selfClosing?e._appendElement(t,pt.MATHML):e._insertElement(t,pt.MATHML),t.ackSelfClosing=!0;}(e,t):n===mt.MENU?function(e,t){e.openElements.hasInButtonScope(mt.P)&&e._closePElement(),e._insertElement(t,pt.HTML);}(e,t):n!==mt.HEAD&&nn(e,t);break;case 5:n===mt.STYLE||n===mt.TITLE?xt(e,t):n===mt.ASIDE?Vt(e,t):n===mt.SMALL?zt(e,t):n===mt.TABLE?function(e,t){e.treeAdapter.getDocumentMode(e.document)!==be.DOCUMENT_MODE.QUIRKS&&e.openElements.hasInButtonScope(mt.P)&&e._closePElement(),e._insertElement(t,pt.HTML),e.framesetOk=!1,e.insertionMode=Ot;}(e,t):n===mt.EMBED?Jt(e,t):n===mt.INPUT?function(e,t){e._reconstructActiveFormattingElements(),e._appendElement(t,pt.HTML);const n=Ge.getTokenAttr(t,Nt.TYPE);n&&"hidden"===n.toLowerCase()||(e.framesetOk=!1),t.ackSelfClosing=!0;}(e,t):n===mt.PARAM||n===mt.TRACK?Zt(e,t):n===mt.IMAGE?function(e,t){t.tagName=mt.IMG,Jt(e,t);}(e,t):n!==mt.FRAME&&n!==mt.TBODY&&n!==mt.TFOOT&&n!==mt.THEAD&&nn(e,t);break;case 6:n===mt.SCRIPT?xt(e,t):n===mt.CENTER||n===mt.FIGURE||n===mt.FOOTER||n===mt.HEADER||n===mt.HGROUP||n===mt.DIALOG?Vt(e,t):n===mt.BUTTON?function(e,t){e.openElements.hasInScope(mt.BUTTON)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(mt.BUTTON)),e._reconstructActiveFormattingElements(),e._insertElement(t,pt.HTML),e.framesetOk=!1;}(e,t):n===mt.STRIKE||n===mt.STRONG?zt(e,t):n===mt.APPLET||n===mt.OBJECT?qt(e,t):n===mt.KEYGEN?Jt(e,t):n===mt.SOURCE?Zt(e,t):n===mt.IFRAME?function(e,t){e.framesetOk=!1,e._switchToTextParsing(t,Ge.MODE.RAWTEXT);}(e,t):n===mt.SELECT?function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,pt.HTML),e.framesetOk=!1,e.insertionMode===Ot||"IN_CAPTION_MODE"===e.insertionMode||"IN_TABLE_BODY_MODE"===e.insertionMode||"IN_ROW_MODE"===e.insertionMode||"IN_CELL_MODE"===e.insertionMode?e.insertionMode="IN_SELECT_IN_TABLE_MODE":e.insertionMode="IN_SELECT_MODE";}(e,t):n===mt.OPTION?en(e,t):nn(e,t);break;case 7:n===mt.BGSOUND?xt(e,t):n===mt.DETAILS||n===mt.ADDRESS||n===mt.ARTICLE||n===mt.SECTION||n===mt.SUMMARY?Vt(e,t):n===mt.LISTING?jt(e,t):n===mt.MARQUEE?qt(e,t):n===mt.NOEMBED?$t(e,t):n!==mt.CAPTION&&nn(e,t);break;case 8:n===mt.BASEFONT?xt(e,t):n===mt.FRAMESET?function(e,t){const n=e.openElements.tryPeekProperlyNestedBodyElement();e.framesetOk&&n&&(e.treeAdapter.detachNode(n),e.openElements.popAllUpToHtmlElement(),e._insertElement(t,pt.HTML),e.insertionMode="IN_FRAMESET_MODE");}(e,t):n===mt.FIELDSET?Vt(e,t):n===mt.TEXTAREA?function(e,t){e._insertElement(t,pt.HTML),e.skipNextNewLine=!0,e.tokenizer.state=Ge.MODE.RCDATA,e.originalInsertionMode=e.insertionMode,e.framesetOk=!1,e.insertionMode="TEXT_MODE";}(e,t):n===mt.TEMPLATE?xt(e,t):n===mt.NOSCRIPT?e.options.scriptingEnabled?$t(e,t):nn(e,t):n===mt.OPTGROUP?en(e,t):n!==mt.COLGROUP&&nn(e,t);break;case 9:n===mt.PLAINTEXT?function(e,t){e.openElements.hasInButtonScope(mt.P)&&e._closePElement(),e._insertElement(t,pt.HTML),e.tokenizer.state=Ge.MODE.PLAINTEXT;}(e,t):nn(e,t);break;case 10:n===mt.BLOCKQUOTE||n===mt.FIGCAPTION?Vt(e,t):nn(e,t);break;default:nn(e,t);}}function rn(e,t){const n=t.tagName;e.openElements.hasInScope(n)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(n));}function Tn(e,t){const n=t.tagName;e.openElements.hasInScope(n)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(n),e.activeFormattingElements.clearToLastMarker());}function on(e,t){const n=t.tagName;for(let t=e.openElements.stackTop;t>0;t--){const s=e.openElements.items[t];if(e.treeAdapter.getTagName(s)===n){e.openElements.generateImpliedEndTagsWithExclusion(n),e.openElements.popUntilElementPopped(s);break}if(e._isSpecialElement(s))break}}function En(e,t){const n=t.tagName;switch(n.length){case 1:n===mt.A||n===mt.B||n===mt.I||n===mt.S||n===mt.U?Pt(e,t):n===mt.P?function(e){e.openElements.hasInButtonScope(mt.P)||e._insertFakeElement(mt.P),e._closePElement();}(e):on(e,t);break;case 2:n===mt.DL||n===mt.UL||n===mt.OL?rn(e,t):n===mt.LI?function(e){e.openElements.hasInListItemScope(mt.LI)&&(e.openElements.generateImpliedEndTagsWithExclusion(mt.LI),e.openElements.popUntilTagNamePopped(mt.LI));}(e):n===mt.DD||n===mt.DT?function(e,t){const n=t.tagName;e.openElements.hasInScope(n)&&(e.openElements.generateImpliedEndTagsWithExclusion(n),e.openElements.popUntilTagNamePopped(n));}(e,t):n===mt.H1||n===mt.H2||n===mt.H3||n===mt.H4||n===mt.H5||n===mt.H6?function(e){e.openElements.hasNumberedHeaderInScope()&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilNumberedHeaderPopped());}(e):n===mt.BR?function(e){e._reconstructActiveFormattingElements(),e._insertFakeElement(mt.BR),e.openElements.pop(),e.framesetOk=!1;}(e):n===mt.EM||n===mt.TT?Pt(e,t):on(e,t);break;case 3:n===mt.BIG?Pt(e,t):n===mt.DIR||n===mt.DIV||n===mt.NAV||n===mt.PRE?rn(e,t):on(e,t);break;case 4:n===mt.BODY?function(e){e.openElements.hasInScope(mt.BODY)&&(e.insertionMode="AFTER_BODY_MODE");}(e):n===mt.HTML?function(e,t){e.openElements.hasInScope(mt.BODY)&&(e.insertionMode="AFTER_BODY_MODE",e._processToken(t));}(e,t):n===mt.FORM?function(e){const t=e.openElements.tmplCount>0,n=e.formElement;t||(e.formElement=null),(n||t)&&e.openElements.hasInScope(mt.FORM)&&(e.openElements.generateImpliedEndTags(),t?e.openElements.popUntilTagNamePopped(mt.FORM):e.openElements.remove(n));}(e):n===mt.CODE||n===mt.FONT||n===mt.NOBR?Pt(e,t):n===mt.MAIN||n===mt.MENU?rn(e,t):on(e,t);break;case 5:n===mt.ASIDE?rn(e,t):n===mt.SMALL?Pt(e,t):on(e,t);break;case 6:n===mt.CENTER||n===mt.FIGURE||n===mt.FOOTER||n===mt.HEADER||n===mt.HGROUP||n===mt.DIALOG?rn(e,t):n===mt.APPLET||n===mt.OBJECT?Tn(e,t):n===mt.STRIKE||n===mt.STRONG?Pt(e,t):on(e,t);break;case 7:n===mt.ADDRESS||n===mt.ARTICLE||n===mt.DETAILS||n===mt.SECTION||n===mt.SUMMARY||n===mt.LISTING?rn(e,t):n===mt.MARQUEE?Tn(e,t):on(e,t);break;case 8:n===mt.FIELDSET?rn(e,t):n===mt.TEMPLATE?yt(e,t):on(e,t);break;case 10:n===mt.BLOCKQUOTE||n===mt.FIGCAPTION?rn(e,t):on(e,t);break;default:on(e,t);}}function an(e,t){e.tmplInsertionModeStackTop>-1?un(e,t):e.stopped=!0;}function _n(e,t){const n=e.openElements.currentTagName;n===mt.TABLE||n===mt.TBODY||n===mt.TFOOT||n===mt.THEAD||n===mt.TR?(e.pendingCharacterTokens=[],e.hasNonWhitespacePendingCharacterToken=!1,e.originalInsertionMode=e.insertionMode,e.insertionMode="IN_TABLE_TEXT_MODE",e._processToken(t)):cn(e,t);}function An(e,t){const n=t.tagName;switch(n.length){case 2:n===mt.TD||n===mt.TH||n===mt.TR?function(e,t){e.openElements.clearBackToTableContext(),e._insertFakeElement(mt.TBODY),e.insertionMode="IN_TABLE_BODY_MODE",e._processToken(t);}(e,t):cn(e,t);break;case 3:n===mt.COL?function(e,t){e.openElements.clearBackToTableContext(),e._insertFakeElement(mt.COLGROUP),e.insertionMode="IN_COLUMN_GROUP_MODE",e._processToken(t);}(e,t):cn(e,t);break;case 4:n===mt.FORM?function(e,t){e.formElement||0!==e.openElements.tmplCount||(e._insertElement(t,pt.HTML),e.formElement=e.openElements.current,e.openElements.pop());}(e,t):cn(e,t);break;case 5:n===mt.TABLE?function(e,t){e.openElements.hasInTableScope(mt.TABLE)&&(e.openElements.popUntilTagNamePopped(mt.TABLE),e._resetInsertionMode(),e._processToken(t));}(e,t):n===mt.STYLE?xt(e,t):n===mt.TBODY||n===mt.TFOOT||n===mt.THEAD?function(e,t){e.openElements.clearBackToTableContext(),e._insertElement(t,pt.HTML),e.insertionMode="IN_TABLE_BODY_MODE";}(e,t):n===mt.INPUT?function(e,t){const n=Ge.getTokenAttr(t,Nt.TYPE);n&&"hidden"===n.toLowerCase()?e._appendElement(t,pt.HTML):cn(e,t),t.ackSelfClosing=!0;}(e,t):cn(e,t);break;case 6:n===mt.SCRIPT?xt(e,t):cn(e,t);break;case 7:n===mt.CAPTION?function(e,t){e.openElements.clearBackToTableContext(),e.activeFormattingElements.insertMarker(),e._insertElement(t,pt.HTML),e.insertionMode="IN_CAPTION_MODE";}(e,t):cn(e,t);break;case 8:n===mt.COLGROUP?function(e,t){e.openElements.clearBackToTableContext(),e._insertElement(t,pt.HTML),e.insertionMode="IN_COLUMN_GROUP_MODE";}(e,t):n===mt.TEMPLATE?xt(e,t):cn(e,t);break;default:cn(e,t);}}function hn(e,t){const n=t.tagName;n===mt.TABLE?e.openElements.hasInTableScope(mt.TABLE)&&(e.openElements.popUntilTagNamePopped(mt.TABLE),e._resetInsertionMode()):n===mt.TEMPLATE?yt(e,t):n!==mt.BODY&&n!==mt.CAPTION&&n!==mt.COL&&n!==mt.COLGROUP&&n!==mt.HTML&&n!==mt.TBODY&&n!==mt.TD&&n!==mt.TFOOT&&n!==mt.TH&&n!==mt.THEAD&&n!==mt.TR&&cn(e,t);}function cn(e,t){const n=e.fosterParentingEnabled;e.fosterParentingEnabled=!0,e._processTokenInBodyMode(t),e.fosterParentingEnabled=n;}function ln(e,t){let n=0;if(e.hasNonWhitespacePendingCharacterToken)for(;n<e.pendingCharacterTokens.length;n++)cn(e,e.pendingCharacterTokens[n]);else for(;n<e.pendingCharacterTokens.length;n++)e._insertCharacters(e.pendingCharacterTokens[n]);e.insertionMode=e.originalInsertionMode,e._processToken(t);}function mn(e,t){e.openElements.currentTagName===mt.COLGROUP&&(e.openElements.pop(),e.insertionMode=Ot,e._processToken(t));}function pn(e,t){const n=t.tagName;n===mt.HTML?sn(e,t):n===mt.OPTION?(e.openElements.currentTagName===mt.OPTION&&e.openElements.pop(),e._insertElement(t,pt.HTML)):n===mt.OPTGROUP?(e.openElements.currentTagName===mt.OPTION&&e.openElements.pop(),e.openElements.currentTagName===mt.OPTGROUP&&e.openElements.pop(),e._insertElement(t,pt.HTML)):n===mt.INPUT||n===mt.KEYGEN||n===mt.TEXTAREA||n===mt.SELECT?e.openElements.hasInSelectScope(mt.SELECT)&&(e.openElements.popUntilTagNamePopped(mt.SELECT),e._resetInsertionMode(),n!==mt.SELECT&&e._processToken(t)):n!==mt.SCRIPT&&n!==mt.TEMPLATE||xt(e,t);}function Nn(e,t){const n=t.tagName;if(n===mt.OPTGROUP){const t=e.openElements.items[e.openElements.stackTop-1],n=t&&e.treeAdapter.getTagName(t);e.openElements.currentTagName===mt.OPTION&&n===mt.OPTGROUP&&e.openElements.pop(),e.openElements.currentTagName===mt.OPTGROUP&&e.openElements.pop();}else n===mt.OPTION?e.openElements.currentTagName===mt.OPTION&&e.openElements.pop():n===mt.SELECT&&e.openElements.hasInSelectScope(mt.SELECT)?(e.openElements.popUntilTagNamePopped(mt.SELECT),e._resetInsertionMode()):n===mt.TEMPLATE&&yt(e,t);}function un(e,t){e.openElements.tmplCount>0?(e.openElements.popUntilTagNamePopped(mt.TEMPLATE),e.activeFormattingElements.clearToLastMarker(),e._popTmplInsertionMode(),e._resetInsertionMode(),e._processToken(t)):e.stopped=!0;}function On(e,t){e.insertionMode="IN_BODY_MODE",e._processToken(t);}function Sn(e,t){e.insertionMode="IN_BODY_MODE",e._processToken(t);}be.TAG_NAMES,be.NAMESPACES;return e.parse=function(e,t){return new Rt(t).parse(e)},e.parseFragment=function(e,t,n){return "string"==typeof e&&(n=t,t=e,e=null),new Rt(n).parseFragment(t,e)},e}({});function parse$3(e,t){return parse5.parse(e,t)}function parseFragment(e,t){return parse5.parseFragment(e,t)}

// MODULE: mock-doc/parse-util.js
const docParser = new WeakMap();
function parseDocumentUtil(ownerDocument, html) {
  const doc = parse$3(html.trim(), getParser(ownerDocument));
  doc.documentElement = doc.firstElementChild;
  doc.head = doc.documentElement.firstElementChild;
  doc.body = doc.head.nextElementSibling;
  return doc;
}
function parseFragmentUtil(ownerDocument, html) {
  if (typeof html === 'string') {
    html = html.trim();
  }
  else {
    html = '';
  }
  const frag = parseFragment(html, getParser(ownerDocument));
  return frag;
}
function getParser(ownerDocument) {
  let parseOptions = docParser.get(ownerDocument);
  if (parseOptions != null) {
    return parseOptions;
  }
  const treeAdapter = {
    createDocument() {
      const doc = ownerDocument.createElement("#document" /* DOCUMENT_NODE */);
      doc['x-mode'] = 'no-quirks';
      return doc;
    },
    createDocumentFragment() {
      return ownerDocument.createDocumentFragment();
    },
    createElement(tagName, namespaceURI, attrs) {
      const elm = ownerDocument.createElementNS(namespaceURI, tagName);
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (attr.namespace == null || attr.namespace === 'http://www.w3.org/1999/xhtml') {
          elm.setAttribute(attr.name, attr.value);
        }
        else {
          elm.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
      return elm;
    },
    createCommentNode(data) {
      return ownerDocument.createComment(data);
    },
    appendChild(parentNode, newNode) {
      parentNode.appendChild(newNode);
    },
    insertBefore(parentNode, newNode, referenceNode) {
      parentNode.insertBefore(newNode, referenceNode);
    },
    setTemplateContent(templateElement, contentElement) {
      templateElement.content = contentElement;
    },
    getTemplateContent(templateElement) {
      return templateElement.content;
    },
    setDocumentType(doc, name, publicId, systemId) {
      let doctypeNode = doc.childNodes.find(n => n.nodeType === 10 /* DOCUMENT_TYPE_NODE */);
      if (doctypeNode == null) {
        doctypeNode = ownerDocument.createDocumentTypeNode();
        doc.insertBefore(doctypeNode, doc.firstChild);
      }
      doctypeNode.nodeValue = '!DOCTYPE';
      doctypeNode['x-name'] = name;
      doctypeNode['x-publicId'] = publicId;
      doctypeNode['x-systemId'] = systemId;
    },
    setDocumentMode(doc, mode) {
      doc['x-mode'] = mode;
    },
    getDocumentMode(doc) {
      return doc['x-mode'];
    },
    detachNode(node) {
      node.remove();
    },
    insertText(parentNode, text) {
      const lastChild = parentNode.lastChild;
      if (lastChild != null && lastChild.nodeType === 3 /* TEXT_NODE */) {
        lastChild.nodeValue += text;
      }
      else {
        parentNode.appendChild(ownerDocument.createTextNode(text));
      }
    },
    insertTextBefore(parentNode, text, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode != null && prevNode.nodeType === 3 /* TEXT_NODE */) {
        prevNode.nodeValue += text;
      }
      else {
        parentNode.insertBefore(ownerDocument.createTextNode(text), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (recipient.hasAttributeNS(attr.namespace, attr.name) === false) {
          recipient.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
    },
    getFirstChild(node) {
      return node.childNodes[0];
    },
    getChildNodes(node) {
      return node.childNodes;
    },
    getParentNode(node) {
      return node.parentNode;
    },
    getAttrList(element) {
      const attrs = element.attributes.__items.map(attr => {
        return {
          name: attr.name,
          value: attr.value,
          namespace: attr.namespaceURI,
          prefix: null,
        };
      });
      return attrs;
    },
    getTagName(element) {
      if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
        return element.nodeName.toLowerCase();
      }
      else {
        return element.nodeName;
      }
    },
    getNamespaceURI(element) {
      return element.namespaceURI;
    },
    getTextNodeContent(textNode) {
      return textNode.nodeValue;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.nodeValue;
    },
    getDocumentTypeNodeName(doctypeNode) {
      return doctypeNode['x-name'];
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      return doctypeNode['x-publicId'];
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      return doctypeNode['x-systemId'];
    },
    isTextNode(node) {
      return node.nodeType === 3 /* TEXT_NODE */;
    },
    isCommentNode(node) {
      return node.nodeType === 8 /* COMMENT_NODE */;
    },
    isDocumentTypeNode(node) {
      return node.nodeType === 10 /* DOCUMENT_TYPE_NODE */;
    },
    isElementNode(node) {
      return node.nodeType === 1 /* ELEMENT_NODE */;
    },
  };
  parseOptions = {
    treeAdapter: treeAdapter,
  };
  docParser.set(ownerDocument, parseOptions);
  return parseOptions;
}

// MODULE: mock-doc/node.js
class MockNode {
  constructor(ownerDocument, nodeType, nodeName, nodeValue) {
    this.ownerDocument = ownerDocument;
    this.nodeType = nodeType;
    this.nodeName = nodeName;
    this.nodeValue = nodeValue;
    this.parentNode = null;
    this.childNodes = [];
  }
  appendChild(newNode) {
    if (newNode.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
      const nodes = newNode.childNodes.slice();
      for (const child of nodes) {
        this.appendChild(child);
      }
    }
    else {
      newNode.remove();
      newNode.parentNode = this;
      this.childNodes.push(newNode);
      connectNode(this.ownerDocument, newNode);
    }
    return newNode;
  }
  append(...items) {
    items.forEach(item => {
      const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
      this.appendChild(isNode ? item : this.ownerDocument.createTextNode(String(item)));
    });
  }
  prepend(...items) {
    const firstChild = this.firstChild;
    items.forEach(item => {
      const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
      this.insertBefore(isNode ? item : this.ownerDocument.createTextNode(String(item)), firstChild);
    });
  }
  cloneNode(deep) {
    throw new Error(`invalid node type to clone: ${this.nodeType}, deep: ${deep}`);
  }
  compareDocumentPosition(_other) {
    // unimplemented
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
    return -1;
  }
  get firstChild() {
    return this.childNodes[0] || null;
  }
  insertBefore(newNode, referenceNode) {
    if (newNode.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
      for (let i = 0, ii = newNode.childNodes.length; i < ii; i++) {
        insertBefore(this, newNode.childNodes[i], referenceNode);
      }
    }
    else {
      insertBefore(this, newNode, referenceNode);
    }
    return newNode;
  }
  get isConnected() {
    let node = this;
    while (node != null) {
      if (node.nodeType === 9 /* DOCUMENT_NODE */) {
        return true;
      }
      node = node.parentNode;
      if (node != null && node.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
        node = node.host;
      }
    }
    return false;
  }
  isSameNode(node) {
    return this === node;
  }
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  get nextSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) + 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  get parentElement() {
    return this.parentNode || null;
  }
  set parentElement(value) {
    this.parentNode = value;
  }
  get previousSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) - 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  contains(otherNode) {
    return this.childNodes.includes(otherNode);
  }
  removeChild(childNode) {
    const index = this.childNodes.indexOf(childNode);
    if (index > -1) {
      this.childNodes.splice(index, 1);
      if (this.nodeType === 1 /* ELEMENT_NODE */) {
        const wasConnected = this.isConnected;
        childNode.parentNode = null;
        if (wasConnected === true) {
          disconnectNode(childNode);
        }
      }
      else {
        childNode.parentNode = null;
      }
    }
    else {
      throw new Error(`node not found within childNodes during removeChild`);
    }
    return childNode;
  }
  remove() {
    if (this.parentNode != null) {
      this.parentNode.removeChild(this);
    }
  }
  replaceChild(newChild, oldChild) {
    if (oldChild.parentNode === this) {
      this.insertBefore(newChild, oldChild);
      oldChild.remove();
      return newChild;
    }
    return null;
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(value) {
    this.nodeValue = String(value);
  }
}
MockNode.ELEMENT_NODE = 1;
MockNode.TEXT_NODE = 3;
MockNode.PROCESSING_INSTRUCTION_NODE = 7;
MockNode.COMMENT_NODE = 8;
MockNode.DOCUMENT_NODE = 9;
MockNode.DOCUMENT_TYPE_NODE = 10;
MockNode.DOCUMENT_FRAGMENT_NODE = 11;
class MockNodeList {
  constructor(ownerDocument, childNodes, length) {
    this.ownerDocument = ownerDocument;
    this.childNodes = childNodes;
    this.length = length;
  }
}
class MockElement extends MockNode {
  constructor(ownerDocument, nodeName) {
    super(ownerDocument, 1 /* ELEMENT_NODE */, typeof nodeName === 'string' ? nodeName : null, null);
    this.namespaceURI = null;
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  attachShadow(_opts) {
    const shadowRoot = this.ownerDocument.createDocumentFragment();
    this.shadowRoot = shadowRoot;
    return shadowRoot;
  }
  get shadowRoot() {
    return this.__shadowRoot || null;
  }
  set shadowRoot(shadowRoot) {
    if (shadowRoot != null) {
      shadowRoot.host = this;
      this.__shadowRoot = shadowRoot;
    }
    else {
      delete this.__shadowRoot;
    }
  }
  get attributes() {
    if (this.__attributeMap == null) {
      this.__attributeMap = createAttributeProxy(false);
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
  get children() {
    return this.childNodes.filter(n => n.nodeType === 1 /* ELEMENT_NODE */);
  }
  get childElementCount() {
    return this.childNodes.filter(n => n.nodeType === 1 /* ELEMENT_NODE */).length;
  }
  get className() {
    return this.getAttributeNS(null, 'class') || '';
  }
  set className(value) {
    this.setAttributeNS(null, 'class', value);
  }
  get classList() {
    return new MockClassList(this);
  }
  click() {
    dispatchEvent(this, new MockEvent('click', { bubbles: true, cancelable: true, composed: true }));
  }
  cloneNode(_deep) {
    // implemented on MockElement.prototype from within element.ts
    return null;
  }
  closest(selector) {
    let elm = this;
    while (elm != null) {
      if (elm.matches(selector)) {
        return elm;
      }
      elm = elm.parentNode;
    }
    return null;
  }
  get dataset() {
    return dataset(this);
  }
  get dir() {
    return this.getAttributeNS(null, 'dir') || '';
  }
  set dir(value) {
    this.setAttributeNS(null, 'dir', value);
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get firstElementChild() {
    return this.children[0] || null;
  }
  getAttribute(attrName) {
    if (attrName === 'style') {
      if (this.__style != null && this.__style.length > 0) {
        return this.style.cssText;
      }
      return null;
    }
    const attr = this.attributes.getNamedItem(attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getBoundingClientRect() {
    return { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 };
  }
  getRootNode(opts) {
    const isComposed = opts != null && opts.composed === true;
    let node = this;
    while (node.parentNode != null) {
      node = node.parentNode;
      if (isComposed === true && node.parentNode == null && node.host != null) {
        node = node.host;
      }
    }
    return node;
  }
  hasChildNodes() {
    return this.childNodes.length > 0;
  }
  get id() {
    return this.getAttributeNS(null, 'id') || '';
  }
  set id(value) {
    this.setAttributeNS(null, 'id', value);
  }
  get innerHTML() {
    if (this.childNodes.length === 0) {
      return '';
    }
    return serializeNodeToHtml(this, {
      newLines: false,
      indentSpaces: 0,
    });
  }
  set innerHTML(html) {
    if (NON_ESCAPABLE_CONTENT.has(this.nodeName) === true) {
      setTextContent(this, html);
    }
    else {
      for (let i = this.childNodes.length - 1; i >= 0; i--) {
        this.removeChild(this.childNodes[i]);
      }
      if (typeof html === 'string') {
        const frag = parseFragmentUtil(this.ownerDocument, html);
        while (frag.childNodes.length > 0) {
          this.appendChild(frag.childNodes[0]);
        }
      }
    }
  }
  get innerText() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join('');
  }
  set innerText(value) {
    setTextContent(this, value);
  }
  insertAdjacentElement(position, elm) {
    if (position === 'beforebegin') {
      insertBefore(this.parentNode, elm, this);
    }
    else if (position === 'afterbegin') {
      this.prepend(elm);
    }
    else if (position === 'beforeend') {
      this.appendChild(elm);
    }
    else if (position === 'afterend') {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
    return elm;
  }
  insertAdjacentHTML(position, html) {
    const frag = parseFragmentUtil(this.ownerDocument, html);
    if (position === 'beforebegin') {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[0], this);
      }
    }
    else if (position === 'afterbegin') {
      while (frag.childNodes.length > 0) {
        this.prepend(frag.childNodes[frag.childNodes.length - 1]);
      }
    }
    else if (position === 'beforeend') {
      while (frag.childNodes.length > 0) {
        this.appendChild(frag.childNodes[0]);
      }
    }
    else if (position === 'afterend') {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[frag.childNodes.length - 1], this.nextSibling);
      }
    }
  }
  insertAdjacentText(position, text) {
    const elm = this.ownerDocument.createTextNode(text);
    if (position === 'beforebegin') {
      insertBefore(this.parentNode, elm, this);
    }
    else if (position === 'afterbegin') {
      this.prepend(elm);
    }
    else if (position === 'beforeend') {
      this.appendChild(elm);
    }
    else if (position === 'afterend') {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
  }
  hasAttribute(attrName) {
    if (attrName === 'style') {
      return this.__style != null && this.__style.length > 0;
    }
    return this.getAttribute(attrName) !== null;
  }
  hasAttributeNS(namespaceURI, name) {
    return this.getAttributeNS(namespaceURI, name) !== null;
  }
  get hidden() {
    return this.hasAttributeNS(null, 'hidden');
  }
  set hidden(isHidden) {
    if (isHidden === true) {
      this.setAttributeNS(null, 'hidden', '');
    }
    else {
      this.removeAttributeNS(null, 'hidden');
    }
  }
  get lang() {
    return this.getAttributeNS(null, 'lang') || '';
  }
  set lang(value) {
    this.setAttributeNS(null, 'lang', value);
  }
  get lastElementChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  matches(selector) {
    return matches(selector, this);
  }
  get nextElementSibling() {
    const parentElement = this.parentElement;
    if (parentElement != null &&
      (parentElement.nodeType === 1 /* ELEMENT_NODE */ || parentElement.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */ || parentElement.nodeType === 9 /* DOCUMENT_NODE */)) {
      const children = parentElement.children;
      const index = children.indexOf(this) + 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  get outerHTML() {
    return serializeNodeToHtml(this, {
      newLines: false,
      outerHtml: true,
      indentSpaces: 0,
    });
  }
  get previousElementSibling() {
    const parentElement = this.parentElement;
    if (parentElement != null &&
      (parentElement.nodeType === 1 /* ELEMENT_NODE */ || parentElement.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */ || parentElement.nodeType === 9 /* DOCUMENT_NODE */)) {
      const children = parentElement.children;
      const index = children.indexOf(this) - 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  getElementsByClassName(classNames) {
    const classes = classNames
      .trim()
      .split(' ')
      .filter(c => c.length > 0);
    const results = [];
    getElementsByClassName(this, classes, results);
    return results;
  }
  getElementsByTagName(tagName) {
    const results = [];
    getElementsByTagName(this, tagName.toLowerCase(), results);
    return results;
  }
  querySelector(selector) {
    return selectOne(selector, this);
  }
  querySelectorAll(selector) {
    return selectAll(selector, this);
  }
  removeAttribute(attrName) {
    if (attrName === 'style') {
      delete this.__style;
    }
    else {
      const attr = this.attributes.getNamedItem(attrName);
      if (attr != null) {
        this.attributes.removeNamedItemNS(attr);
        if (checkAttributeChanged(this) === true) {
          attributeChanged(this, attrName, attr.value, null);
        }
      }
    }
  }
  removeAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      this.attributes.removeNamedItemNS(attr);
      if (checkAttributeChanged(this) === true) {
        attributeChanged(this, attrName, attr.value, null);
      }
    }
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  setAttribute(attrName, value) {
    if (attrName === 'style') {
      this.style = value;
    }
    else {
      const attributes = this.attributes;
      let attr = attributes.getNamedItem(attrName);
      const checkAttrChanged = checkAttributeChanged(this);
      if (attr != null) {
        if (checkAttrChanged === true) {
          const oldValue = attr.value;
          attr.value = value;
          if (oldValue !== attr.value) {
            attributeChanged(this, attr.name, oldValue, attr.value);
          }
        }
        else {
          attr.value = value;
        }
      }
      else {
        if (attributes.caseInsensitive) {
          attrName = attrName.toLowerCase();
        }
        attr = new MockAttr(attrName, value);
        attributes.__items.push(attr);
        if (checkAttrChanged === true) {
          attributeChanged(this, attrName, null, attr.value);
        }
      }
    }
  }
  setAttributeNS(namespaceURI, attrName, value) {
    const attributes = this.attributes;
    let attr = attributes.getNamedItemNS(namespaceURI, attrName);
    const checkAttrChanged = checkAttributeChanged(this);
    if (attr != null) {
      if (checkAttrChanged === true) {
        const oldValue = attr.value;
        attr.value = value;
        if (oldValue !== attr.value) {
          attributeChanged(this, attr.name, oldValue, attr.value);
        }
      }
      else {
        attr.value = value;
      }
    }
    else {
      attr = new MockAttr(attrName, value, namespaceURI);
      attributes.__items.push(attr);
      if (checkAttrChanged === true) {
        attributeChanged(this, attrName, null, attr.value);
      }
    }
  }
  get style() {
    if (this.__style == null) {
      this.__style = createCSSStyleDeclaration();
    }
    return this.__style;
  }
  set style(val) {
    if (typeof val === 'string') {
      if (this.__style == null) {
        this.__style = createCSSStyleDeclaration();
      }
      this.__style.cssText = val;
    }
    else {
      this.__style = val;
    }
  }
  get tabIndex() {
    return parseInt(this.getAttributeNS(null, 'tabindex') || '-1', 10);
  }
  set tabIndex(value) {
    this.setAttributeNS(null, 'tabindex', value);
  }
  get tagName() {
    return this.nodeName;
  }
  set tagName(value) {
    this.nodeName = value;
  }
  get textContent() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join('');
  }
  set textContent(value) {
    setTextContent(this, value);
  }
  get title() {
    return this.getAttributeNS(null, 'title') || '';
  }
  set title(value) {
    this.setAttributeNS(null, 'title', value);
  }
  onanimationstart() {
    /**/
  }
  onanimationend() {
    /**/
  }
  onanimationiteration() {
    /**/
  }
  onabort() {
    /**/
  }
  onauxclick() {
    /**/
  }
  onbeforecopy() {
    /**/
  }
  onbeforecut() {
    /**/
  }
  onbeforepaste() {
    /**/
  }
  onblur() {
    /**/
  }
  oncancel() {
    /**/
  }
  oncanplay() {
    /**/
  }
  oncanplaythrough() {
    /**/
  }
  onchange() {
    /**/
  }
  onclick() {
    /**/
  }
  onclose() {
    /**/
  }
  oncontextmenu() {
    /**/
  }
  oncopy() {
    /**/
  }
  oncuechange() {
    /**/
  }
  oncut() {
    /**/
  }
  ondblclick() {
    /**/
  }
  ondrag() {
    /**/
  }
  ondragend() {
    /**/
  }
  ondragenter() {
    /**/
  }
  ondragleave() {
    /**/
  }
  ondragover() {
    /**/
  }
  ondragstart() {
    /**/
  }
  ondrop() {
    /**/
  }
  ondurationchange() {
    /**/
  }
  onemptied() {
    /**/
  }
  onended() {
    /**/
  }
  onerror() {
    /**/
  }
  onfocus() {
    /**/
  }
  onformdata() {
    /**/
  }
  onfullscreenchange() {
    /**/
  }
  onfullscreenerror() {
    /**/
  }
  ongotpointercapture() {
    /**/
  }
  oninput() {
    /**/
  }
  oninvalid() {
    /**/
  }
  onkeydown() {
    /**/
  }
  onkeypress() {
    /**/
  }
  onkeyup() {
    /**/
  }
  onload() {
    /**/
  }
  onloadeddata() {
    /**/
  }
  onloadedmetadata() {
    /**/
  }
  onloadstart() {
    /**/
  }
  onlostpointercapture() {
    /**/
  }
  onmousedown() {
    /**/
  }
  onmouseenter() {
    /**/
  }
  onmouseleave() {
    /**/
  }
  onmousemove() {
    /**/
  }
  onmouseout() {
    /**/
  }
  onmouseover() {
    /**/
  }
  onmouseup() {
    /**/
  }
  onmousewheel() {
    /**/
  }
  onpaste() {
    /**/
  }
  onpause() {
    /**/
  }
  onplay() {
    /**/
  }
  onplaying() {
    /**/
  }
  onpointercancel() {
    /**/
  }
  onpointerdown() {
    /**/
  }
  onpointerenter() {
    /**/
  }
  onpointerleave() {
    /**/
  }
  onpointermove() {
    /**/
  }
  onpointerout() {
    /**/
  }
  onpointerover() {
    /**/
  }
  onpointerup() {
    /**/
  }
  onprogress() {
    /**/
  }
  onratechange() {
    /**/
  }
  onreset() {
    /**/
  }
  onresize() {
    /**/
  }
  onscroll() {
    /**/
  }
  onsearch() {
    /**/
  }
  onseeked() {
    /**/
  }
  onseeking() {
    /**/
  }
  onselect() {
    /**/
  }
  onselectstart() {
    /**/
  }
  onstalled() {
    /**/
  }
  onsubmit() {
    /**/
  }
  onsuspend() {
    /**/
  }
  ontimeupdate() {
    /**/
  }
  ontoggle() {
    /**/
  }
  onvolumechange() {
    /**/
  }
  onwaiting() {
    /**/
  }
  onwebkitfullscreenchange() {
    /**/
  }
  onwebkitfullscreenerror() {
    /**/
  }
  onwheel() {
    /**/
  }
  toString(opts) {
    return serializeNodeToHtml(this, opts);
  }
}
function getElementsByClassName(elm, classNames, foundElms) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    for (let j = 0, jj = classNames.length; j < jj; j++) {
      if (childElm.classList.contains(classNames[j])) {
        foundElms.push(childElm);
      }
    }
    getElementsByClassName(childElm, classNames, foundElms);
  }
}
function getElementsByTagName(elm, tagName, foundElms) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (tagName === '*' || childElm.nodeName.toLowerCase() === tagName) {
      foundElms.push(childElm);
    }
    getElementsByTagName(childElm, tagName, foundElms);
  }
}
function resetElement(elm) {
  resetEventListeners(elm);
  delete elm.__attributeMap;
  delete elm.__shadowRoot;
  delete elm.__style;
}
function insertBefore(parentNode, newNode, referenceNode) {
  if (newNode !== referenceNode) {
    newNode.remove();
    newNode.parentNode = parentNode;
    newNode.ownerDocument = parentNode.ownerDocument;
    if (referenceNode != null) {
      const index = parentNode.childNodes.indexOf(referenceNode);
      if (index > -1) {
        parentNode.childNodes.splice(index, 0, newNode);
      }
      else {
        throw new Error(`referenceNode not found in parentNode.childNodes`);
      }
    }
    else {
      parentNode.childNodes.push(newNode);
    }
    connectNode(parentNode.ownerDocument, newNode);
  }
  return newNode;
}
class MockHTMLElement extends MockElement {
  constructor(ownerDocument, nodeName) {
    super(ownerDocument, typeof nodeName === 'string' ? nodeName.toUpperCase() : null);
    this.namespaceURI = 'http://www.w3.org/1999/xhtml';
  }
  get tagName() {
    return this.nodeName;
  }
  set tagName(value) {
    this.nodeName = value;
  }
  get attributes() {
    if (this.__attributeMap == null) {
      this.__attributeMap = createAttributeProxy(true);
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
}
class MockTextNode extends MockNode {
  constructor(ownerDocument, text) {
    super(ownerDocument, 3 /* TEXT_NODE */, "#text" /* TEXT_NODE */, text);
  }
  cloneNode(_deep) {
    return new MockTextNode(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
  get data() {
    return this.nodeValue;
  }
  set data(text) {
    this.nodeValue = text;
  }
  get wholeText() {
    if (this.parentNode != null) {
      const text = [];
      for (let i = 0, ii = this.parentNode.childNodes.length; i < ii; i++) {
        const childNode = this.parentNode.childNodes[i];
        if (childNode.nodeType === 3 /* TEXT_NODE */) {
          text.push(childNode.nodeValue);
        }
      }
      return text.join('');
    }
    return this.nodeValue;
  }
}
function getTextContent(childNodes, text) {
  for (let i = 0, ii = childNodes.length; i < ii; i++) {
    const childNode = childNodes[i];
    if (childNode.nodeType === 3 /* TEXT_NODE */) {
      text.push(childNode.nodeValue);
    }
    else if (childNode.nodeType === 1 /* ELEMENT_NODE */) {
      getTextContent(childNode.childNodes, text);
    }
  }
}
function setTextContent(elm, text) {
  for (let i = elm.childNodes.length - 1; i >= 0; i--) {
    elm.removeChild(elm.childNodes[i]);
  }
  const textNode = new MockTextNode(elm.ownerDocument, text);
  elm.appendChild(textNode);
}

// MODULE: mock-doc/comment-node.js
class MockComment extends MockNode {
  constructor(ownerDocument, data) {
    super(ownerDocument, 8 /* COMMENT_NODE */, "#comment" /* COMMENT_NODE */, data);
  }
  cloneNode(_deep) {
    return new MockComment(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
}

// MODULE: mock-doc/document-fragment.js
class MockDocumentFragment extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, null);
    this.nodeName = "#document-fragment" /* DOCUMENT_FRAGMENT_NODE */;
    this.nodeType = 11 /* DOCUMENT_FRAGMENT_NODE */;
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  cloneNode(deep) {
    const cloned = new MockDocumentFragment(null);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const childNode = this.childNodes[i];
        if (childNode.nodeType === 1 /* ELEMENT_NODE */ || childNode.nodeType === 3 /* TEXT_NODE */ || childNode.nodeType === 8 /* COMMENT_NODE */) {
          const clonedChildNode = this.childNodes[i].cloneNode(true);
          cloned.appendChild(clonedChildNode);
        }
      }
    }
    return cloned;
  }
}

// MODULE: mock-doc/document-type-node.js
class MockDocumentTypeNode extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, '!DOCTYPE');
    this.nodeType = 10 /* DOCUMENT_TYPE_NODE */;
    this.setAttribute('html', '');
  }
}

// MODULE: mock-doc/css-style-sheet.js
class MockCSSRule {
  constructor(parentStyleSheet) {
    this.parentStyleSheet = parentStyleSheet;
    this.cssText = '';
    this.type = 0;
  }
}
class MockCSSStyleSheet {
  constructor(ownerNode) {
    this.type = 'text/css';
    this.parentStyleSheet = null;
    this.cssRules = [];
    this.ownerNode = ownerNode;
  }
  get rules() {
    return this.cssRules;
  }
  set rules(rules) {
    this.cssRules = rules;
  }
  deleteRule(index) {
    if (index >= 0 && index < this.cssRules.length) {
      this.cssRules.splice(index, 1);
      updateStyleTextNode(this.ownerNode);
    }
  }
  insertRule(rule, index = 0) {
    if (typeof index !== 'number') {
      index = 0;
    }
    if (index < 0) {
      index = 0;
    }
    if (index > this.cssRules.length) {
      index = this.cssRules.length;
    }
    const cssRule = new MockCSSRule(this);
    cssRule.cssText = rule;
    this.cssRules.splice(index, 0, cssRule);
    updateStyleTextNode(this.ownerNode);
    return index;
  }
}
function getStyleElementText(styleElm) {
  const output = [];
  for (let i = 0; i < styleElm.childNodes.length; i++) {
    output.push(styleElm.childNodes[i].nodeValue);
  }
  return output.join('');
}
function setStyleElementText(styleElm, text) {
  // keeping the innerHTML and the sheet.cssRules connected
  // is not technically correct, but since we're doing
  // SSR we'll need to turn any assigned cssRules into
  // real text, not just properties that aren't rendered
  const sheet = styleElm.sheet;
  sheet.cssRules.length = 0;
  sheet.insertRule(text);
  updateStyleTextNode(styleElm);
}
function updateStyleTextNode(styleElm) {
  const childNodeLen = styleElm.childNodes.length;
  if (childNodeLen > 1) {
    for (let i = childNodeLen - 1; i >= 1; i--) {
      styleElm.removeChild(styleElm.childNodes[i]);
    }
  }
  else if (childNodeLen < 1) {
    styleElm.appendChild(styleElm.ownerDocument.createTextNode(''));
  }
  const textNode = styleElm.childNodes[0];
  textNode.nodeValue = styleElm.sheet.cssRules.map(r => r.cssText).join('\n');
}

// MODULE: mock-doc/element.js
function createElement(ownerDocument, tagName) {
  if (typeof tagName !== 'string' || tagName === '' || !/^[a-z0-9-_:]+$/i.test(tagName)) {
    throw new Error(`The tag name provided (${tagName}) is not a valid name.`);
  }
  tagName = tagName.toLowerCase();
  switch (tagName) {
    case 'a':
      return new MockAnchorElement(ownerDocument);
    case 'base':
      return new MockBaseElement(ownerDocument);
    case 'button':
      return new MockButtonElement(ownerDocument);
    case 'canvas':
      return new MockCanvasElement(ownerDocument);
    case 'form':
      return new MockFormElement(ownerDocument);
    case 'img':
      return new MockImageElement(ownerDocument);
    case 'input':
      return new MockInputElement(ownerDocument);
    case 'link':
      return new MockLinkElement(ownerDocument);
    case 'meta':
      return new MockMetaElement(ownerDocument);
    case 'script':
      return new MockScriptElement(ownerDocument);
    case 'style':
      return new MockStyleElement(ownerDocument);
    case 'template':
      return new MockTemplateElement(ownerDocument);
    case 'title':
      return new MockTitleElement(ownerDocument);
  }
  if (ownerDocument != null && tagName.includes('-')) {
    const win = ownerDocument.defaultView;
    if (win != null && win.customElements != null) {
      return createCustomElement(win.customElements, ownerDocument, tagName);
    }
  }
  return new MockHTMLElement(ownerDocument, tagName);
}
function createElementNS(ownerDocument, namespaceURI, tagName) {
  if (namespaceURI === 'http://www.w3.org/1999/xhtml') {
    return createElement(ownerDocument, tagName);
  }
  else if (namespaceURI === 'http://www.w3.org/2000/svg') {
    return new MockSVGElement(ownerDocument, tagName);
  }
  else {
    return new MockElement(ownerDocument, tagName);
  }
}
class MockAnchorElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'a');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
}
class MockButtonElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'button');
  }
}
patchPropAttributes(MockButtonElement.prototype, {
  type: String,
}, {
  type: 'submit',
});
class MockImageElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'img');
  }
  get src() {
    return fullUrl(this, 'src');
  }
  set src(value) {
    this.setAttribute('src', value);
  }
}
patchPropAttributes(MockImageElement.prototype, {
  height: Number,
  width: Number,
});
class MockInputElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'input');
  }
  get list() {
    const listId = this.getAttribute('list');
    if (listId) {
      return this.ownerDocument.getElementById(listId);
    }
    return null;
  }
}
patchPropAttributes(MockInputElement.prototype, {
  accept: String,
  autocomplete: String,
  autofocus: Boolean,
  capture: String,
  checked: Boolean,
  disabled: Boolean,
  form: String,
  formaction: String,
  formenctype: String,
  formmethod: String,
  formnovalidate: String,
  formtarget: String,
  height: Number,
  inputmode: String,
  max: String,
  maxLength: Number,
  min: String,
  minLength: Number,
  multiple: Boolean,
  name: String,
  pattern: String,
  placeholder: String,
  required: Boolean,
  readOnly: Boolean,
  size: Number,
  spellCheck: Boolean,
  src: String,
  step: String,
  type: String,
  value: String,
  width: Number,
}, {
  type: 'text',
});
class MockFormElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'form');
  }
}
patchPropAttributes(MockFormElement.prototype, {
  name: String,
});
class MockLinkElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'link');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
}
patchPropAttributes(MockLinkElement.prototype, {
  crossorigin: String,
  media: String,
  rel: String,
  type: String,
});
class MockMetaElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'meta');
  }
}
patchPropAttributes(MockMetaElement.prototype, {
  charset: String,
  content: String,
  name: String,
});
class MockScriptElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'script');
  }
  get src() {
    return fullUrl(this, 'src');
  }
  set src(value) {
    this.setAttribute('src', value);
  }
}
patchPropAttributes(MockScriptElement.prototype, {
  type: String,
});
class MockStyleElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'style');
    this.sheet = new MockCSSStyleSheet(this);
  }
  get innerHTML() {
    return getStyleElementText(this);
  }
  set innerHTML(value) {
    setStyleElementText(this, value);
  }
  get innerText() {
    return getStyleElementText(this);
  }
  set innerText(value) {
    setStyleElementText(this, value);
  }
  get textContent() {
    return getStyleElementText(this);
  }
  set textContent(value) {
    setStyleElementText(this, value);
  }
}
class MockSVGElement extends MockElement {
  // SVGElement properties and methods
  get ownerSVGElement() {
    return null;
  }
  get viewportElement() {
    return null;
  }
  focus() {
    /**/
  }
  onunload() {
    /**/
  }
  // SVGGeometryElement properties and methods
  get pathLength() {
    return 0;
  }
  isPointInFill(_pt) {
    return false;
  }
  isPointInStroke(_pt) {
    return false;
  }
  getTotalLength() {
    return 0;
  }
}
class MockBaseElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'base');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
}
class MockTemplateElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'template');
    this.content = new MockDocumentFragment(ownerDocument);
  }
  get innerHTML() {
    return this.content.innerHTML;
  }
  set innerHTML(html) {
    this.content.innerHTML = html;
  }
  cloneNode(deep) {
    const cloned = new MockTemplateElement(null);
    cloned.attributes = cloneAttributes(this.attributes);
    const styleCssText = this.getAttribute('style');
    if (styleCssText != null && styleCssText.length > 0) {
      cloned.setAttribute('style', styleCssText);
    }
    cloned.content = this.content.cloneNode(deep);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const clonedChildNode = this.childNodes[i].cloneNode(true);
        cloned.appendChild(clonedChildNode);
      }
    }
    return cloned;
  }
}
class MockTitleElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'title');
  }
  get text() {
    return this.textContent;
  }
  set text(value) {
    this.textContent = value;
  }
}
class MockCanvasElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'canvas');
  }
  getContext() {
    return {
      fillRect: function () {
        return;
      },
      clearRect: function () {
        return;
      },
      getImageData: function (_, __, w, h) {
        return {
          data: new Array(w * h * 4),
        };
      },
      putImageData: function () {
        return;
      },
      createImageData: function () {
        return [];
      },
      setTransform: function () {
        return;
      },
      drawImage: function () {
        return;
      },
      save: function () {
        return;
      },
      fillText: function () {
        return;
      },
      restore: function () {
        return;
      },
      beginPath: function () {
        return;
      },
      moveTo: function () {
        return;
      },
      lineTo: function () {
        return;
      },
      closePath: function () {
        return;
      },
      stroke: function () {
        return;
      },
      translate: function () {
        return;
      },
      scale: function () {
        return;
      },
      rotate: function () {
        return;
      },
      arc: function () {
        return;
      },
      fill: function () {
        return;
      },
      measureText: function () {
        return { width: 0 };
      },
      transform: function () {
        return;
      },
      rect: function () {
        return;
      },
      clip: function () {
        return;
      },
    };
  }
}
function fullUrl(elm, attrName) {
  const val = elm.getAttribute(attrName) || '';
  if (elm.ownerDocument != null) {
    const win = elm.ownerDocument.defaultView;
    if (win != null) {
      const loc = win.location;
      if (loc != null) {
        const url = new URL(val, loc.href);
        return url.href;
      }
    }
  }
  return val.replace(/\'|\"/g, '').trim();
}
function patchPropAttributes(prototype, attrs, defaults = {}) {
  Object.keys(attrs).forEach(propName => {
    const attr = attrs[propName];
    const defaultValue = defaults[propName];
    if (attr === Boolean) {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName);
        },
        set(value) {
          if (value) {
            this.setAttribute(propName, '');
          }
          else {
            this.removeAttribute(propName);
          }
        },
      });
    }
    else if (attr === Number) {
      Object.defineProperty(prototype, propName, {
        get() {
          const value = this.getAttribute(propName);
          return value ? parseInt(value, 10) : defaultValue === undefined ? 0 : defaultValue;
        },
        set(value) {
          this.setAttribute(propName, value);
        },
      });
    }
    else {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName) ? this.getAttribute(propName) : defaultValue || '';
        },
        set(value) {
          this.setAttribute(propName, value);
        },
      });
    }
  });
}
MockElement.prototype.cloneNode = function (deep) {
  // because we're creating elements, which extending specific HTML base classes there
  // is a MockElement circular reference that bundling has trouble dealing with so
  // the fix is to add cloneNode() to MockElement's prototype after the HTML classes
  const cloned = createElement(this.ownerDocument, this.nodeName);
  cloned.attributes = cloneAttributes(this.attributes);
  const styleCssText = this.getAttribute('style');
  if (styleCssText != null && styleCssText.length > 0) {
    cloned.setAttribute('style', styleCssText);
  }
  if (deep) {
    for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
      const clonedChildNode = this.childNodes[i].cloneNode(true);
      cloned.appendChild(clonedChildNode);
    }
  }
  return cloned;
};

// MODULE: mock-doc/headers.js
class MockHeaders {
  constructor(init) {
    this._values = [];
    if (typeof init === 'object') {
      if (typeof init[Symbol.iterator] === 'function') {
        const kvs = [];
        for (const kv of init) {
          if (typeof kv[Symbol.iterator] === 'function') {
            kvs.push([...kv]);
          }
        }
        for (const kv of kvs) {
          this.append(kv[0], kv[1]);
        }
      }
      else {
        for (const key in init) {
          this.append(key, init[key]);
        }
      }
    }
  }
  append(key, value) {
    this._values.push([key, value + '']);
  }
  delete(key) {
    key = key.toLowerCase();
    for (let i = this._values.length - 1; i >= 0; i--) {
      if (this._values[i][0].toLowerCase() === key) {
        this._values.splice(i, 1);
      }
    }
  }
  entries() {
    const entries = [];
    for (const kv of this.keys()) {
      entries.push([kv, this.get(kv)]);
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: entries[index],
          done: !entries[index],
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  forEach(cb) {
    for (const kv of this.entries()) {
      cb(kv[1], kv[0]);
    }
  }
  get(key) {
    const rtn = [];
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        rtn.push(kv[1]);
      }
    }
    return rtn.length > 0 ? rtn.join(', ') : null;
  }
  has(key) {
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        return true;
      }
    }
    return false;
  }
  keys() {
    const keys = [];
    for (const kv of this._values) {
      const key = kv[0].toLowerCase();
      if (!keys.includes(key)) {
        keys.push(key);
      }
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: keys[index],
          done: !keys[index],
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  set(key, value) {
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key.toLowerCase()) {
        kv[1] = value + '';
        return;
      }
    }
    this.append(key, value);
  }
  values() {
    const values = this._values;
    let index = -1;
    return {
      next() {
        index++;
        const done = !values[index];
        return {
          value: done ? undefined : values[index][1],
          done,
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  [Symbol.iterator]() {
    return this.entries();
  }
}

// MODULE: mock-doc/request-response.js
class MockRequest {
  constructor(input, init = {}) {
    this._method = 'GET';
    this._url = '/';
    this.bodyUsed = false;
    this.cache = 'default';
    this.credentials = 'same-origin';
    this.integrity = '';
    this.keepalive = false;
    this.mode = 'cors';
    this.redirect = 'follow';
    this.referrer = 'about:client';
    this.referrerPolicy = '';
    if (typeof input === 'string') {
      this.url = input;
    }
    else if (input) {
      Object.assign(this, input);
      this.headers = new MockHeaders(input.headers);
    }
    Object.assign(this, init);
    if (init.headers) {
      this.headers = new MockHeaders(init.headers);
    }
    if (!this.headers) {
      this.headers = new MockHeaders();
    }
  }
  get url() {
    if (typeof this._url === 'string') {
      return new URL(this._url, location.href).href;
    }
    return new URL('/', location.href).href;
  }
  set url(value) {
    this._url = value;
  }
  get method() {
    if (typeof this._method === 'string') {
      return this._method.toUpperCase();
    }
    return 'GET';
  }
  set method(value) {
    this._method = value;
  }
  clone() {
    const clone = Object.assign({}, this);
    clone.headers = new MockHeaders(this.headers);
    return new MockRequest(clone);
  }
}
class MockResponse {
  constructor(body, init = {}) {
    this.ok = true;
    this.status = 200;
    this.statusText = '';
    this.type = 'default';
    this.url = '';
    this._body = body;
    if (init) {
      Object.assign(this, init);
    }
    this.headers = new MockHeaders(init.headers);
  }
  async json() {
    return JSON.parse(this._body);
  }
  async text() {
    return this._body;
  }
  clone() {
    const initClone = Object.assign({}, this);
    initClone.headers = new MockHeaders(this.headers);
    return new MockResponse(this._body, initClone);
  }
}

// MODULE: mock-doc/global.js
function addGlobalsToWindowPrototype(mockWinPrototype) {
  GLOBAL_CONSTRUCTORS.forEach(([cstrName, Cstr]) => {
    Object.defineProperty(mockWinPrototype, cstrName, {
      get() {
        return this['__' + cstrName] || Cstr;
      },
      set(cstr) {
        this['__' + cstrName] = cstr;
      },
      configurable: true,
      enumerable: true,
    });
  });
}
const GLOBAL_CONSTRUCTORS = [
  ['CustomEvent', MockCustomEvent],
  ['Event', MockEvent],
  ['Headers', MockHeaders],
  ['KeyboardEvent', MockKeyboardEvent],
  ['MouseEvent', MockMouseEvent],
  ['Request', MockRequest],
  ['Response', MockResponse],
  ['HTMLAnchorElement', MockAnchorElement],
  ['HTMLBaseElement', MockBaseElement],
  ['HTMLButtonElement', MockButtonElement],
  ['HTMLCanvasElement', MockCanvasElement],
  ['HTMLFormElement', MockFormElement],
  ['HTMLImageElement', MockImageElement],
  ['HTMLInputElement', MockInputElement],
  ['HTMLLinkElement', MockLinkElement],
  ['HTMLMetaElement', MockMetaElement],
  ['HTMLScriptElement', MockScriptElement],
  ['HTMLStyleElement', MockStyleElement],
  ['HTMLTemplateElement', MockTemplateElement],
  ['HTMLTitleElement', MockTitleElement],
];

// MODULE: mock-doc/console.js
const consoleNoop = () => {
  /**/
};
function createConsole() {
  return {
    debug: consoleNoop,
    error: consoleNoop,
    info: consoleNoop,
    log: consoleNoop,
    warn: consoleNoop,
    dir: consoleNoop,
    dirxml: consoleNoop,
    table: consoleNoop,
    trace: consoleNoop,
    group: consoleNoop,
    groupCollapsed: consoleNoop,
    groupEnd: consoleNoop,
    clear: consoleNoop,
    count: consoleNoop,
    countReset: consoleNoop,
    assert: consoleNoop,
    profile: consoleNoop,
    profileEnd: consoleNoop,
    time: consoleNoop,
    timeLog: consoleNoop,
    timeEnd: consoleNoop,
    timeStamp: consoleNoop,
    context: consoleNoop,
    memory: consoleNoop,
  };
}

// MODULE: mock-doc/history.js
class MockHistory {
  constructor() {
    this.items = [];
  }
  get length() {
    return this.items.length;
  }
  back() {
    this.go(-1);
  }
  forward() {
    this.go(1);
  }
  go(_value) {
    //
  }
  pushState(_state, _title, _url) {
    //
  }
  replaceState(_state, _title, _url) {
    //
  }
}

// MODULE: mock-doc/intersection-observer.js
class MockIntersectionObserver {
  constructor() {
    /**/
  }
  disconnect() {
    /**/
  }
  observe() {
    /**/
  }
  takeRecords() {
    return [];
  }
  unobserve() {
    /**/
  }
}

// MODULE: mock-doc/location.js
class MockLocation {
  constructor() {
    this.ancestorOrigins = null;
    this.protocol = '';
    this.host = '';
    this.hostname = '';
    this.port = '';
    this.pathname = '';
    this.search = '';
    this.hash = '';
    this.username = '';
    this.password = '';
    this.origin = '';
    this._href = '';
  }
  get href() {
    return this._href;
  }
  set href(value) {
    const url = new URL(value, 'http://mockdoc.stenciljs.com');
    this._href = url.href;
    this.protocol = url.protocol;
    this.host = url.host;
    this.port = url.port;
    this.pathname = url.pathname;
    this.search = url.search;
    this.hash = url.hash;
    this.username = url.username;
    this.password = url.password;
    this.origin = url.origin;
  }
  assign(_url) {
    //
  }
  reload(_forcedReload) {
    //
  }
  replace(_url) {
    //
  }
  toString() {
    return this.href;
  }
}

// MODULE: mock-doc/navigator.js
class MockNavigator {
  constructor() {
    this.appCodeName = 'MockNavigator';
    this.appName = 'MockNavigator';
    this.appVersion = 'MockNavigator';
    this.platform = 'MockNavigator';
    this.userAgent = 'MockNavigator';
  }
}

// MODULE: mock-doc/performance.js
/**
 * https://developer.mozilla.org/en-US/docs/Web/API/Performance
 */
class MockPerformance {
  constructor() {
    this.timeOrigin = Date.now();
  }
  addEventListener() {
    //
  }
  clearMarks() {
    //
  }
  clearMeasures() {
    //
  }
  clearResourceTimings() {
    //
  }
  dispatchEvent() {
    return true;
  }
  getEntries() {
    return [];
  }
  getEntriesByName() {
    return [];
  }
  getEntriesByType() {
    return [];
  }
  mark() {
    //
  }
  measure() {
    //
  }
  get navigation() {
    return {};
  }
  now() {
    return Date.now() - this.timeOrigin;
  }
  get onresourcetimingbufferfull() {
    return null;
  }
  removeEventListener() {
    //
  }
  setResourceTimingBufferSize() {
    //
  }
  get timing() {
    return {};
  }
  toJSON() {
    //
  }
}
function resetPerformance(perf) {
  if (perf != null) {
    try {
      perf.timeOrigin = Date.now();
    }
    catch (e) { }
  }
}

// MODULE: mock-doc/storage.js
class MockStorage {
  constructor() {
    this.items = new Map();
  }
  key(_value) {
    //
  }
  getItem(key) {
    key = String(key);
    if (this.items.has(key)) {
      return this.items.get(key);
    }
    return null;
  }
  setItem(key, value) {
    if (value == null) {
      value = 'null';
    }
    this.items.set(String(key), String(value));
  }
  removeItem(key) {
    this.items.delete(String(key));
  }
  clear() {
    this.items.clear();
  }
}

// MODULE: mock-doc/window.js
const nativeClearInterval = clearInterval;
const nativeClearTimeout = clearTimeout;
const nativeSetInterval = setInterval;
const nativeSetTimeout = setTimeout;
const nativeURL = URL;
class MockWindow {
  constructor(html = null) {
    if (html !== false) {
      this.document = new MockDocument(html, this);
    }
    else {
      this.document = null;
    }
    this.performance = new MockPerformance();
    this.customElements = new MockCustomElementRegistry(this);
    this.console = createConsole();
    resetWindowDefaults(this);
    resetWindowDimensions(this);
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  alert(msg) {
    if (this.console) {
      this.console.debug(msg);
    }
    else {
      console.debug(msg);
    }
  }
  blur() {
    /**/
  }
  cancelAnimationFrame(id) {
    this.__clearTimeout(id);
  }
  cancelIdleCallback(id) {
    this.__clearTimeout(id);
  }
  get CharacterData() {
    if (this.__charDataCstr == null) {
      const ownerDocument = this.document;
      this.__charDataCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct CharacterData');
        }
      };
    }
    return this.__charDataCstr;
  }
  set CharacterData(charDataCstr) {
    this.__charDataCstr = charDataCstr;
  }
  clearInterval(id) {
    this.__clearInterval(id);
  }
  clearTimeout(id) {
    this.__clearTimeout(id);
  }
  close() {
    resetWindow(this);
  }
  confirm() {
    return false;
  }
  get CSS() {
    return {
      supports: () => true,
    };
  }
  get Document() {
    if (this.__docCstr == null) {
      const win = this;
      this.__docCstr = class extends MockDocument {
        constructor() {
          super(false, win);
          throw new Error('Illegal constructor: cannot construct Document');
        }
      };
    }
    return this.__docCstr;
  }
  set Document(docCstr) {
    this.__docCstr = docCstr;
  }
  get DocumentFragment() {
    if (this.__docFragCstr == null) {
      const ownerDocument = this.document;
      this.__docFragCstr = class extends MockDocumentFragment {
        constructor() {
          super(ownerDocument);
          throw new Error('Illegal constructor: cannot construct DocumentFragment');
        }
      };
    }
    return this.__docFragCstr;
  }
  set DocumentFragment(docFragCstr) {
    this.__docFragCstr = docFragCstr;
  }
  get DocumentType() {
    if (this.__docTypeCstr == null) {
      const ownerDocument = this.document;
      this.__docTypeCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct DocumentType');
        }
      };
    }
    return this.__docTypeCstr;
  }
  set DocumentType(docTypeCstr) {
    this.__docTypeCstr = docTypeCstr;
  }
  get DOMTokenList() {
    if (this.__domTokenListCstr == null) {
      this.__domTokenListCstr = class MockDOMTokenList {
      };
    }
    return this.__domTokenListCstr;
  }
  set DOMTokenList(domTokenListCstr) {
    this.__domTokenListCstr = domTokenListCstr;
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get Element() {
    if (this.__elementCstr == null) {
      const ownerDocument = this.document;
      this.__elementCstr = class extends MockElement {
        constructor() {
          super(ownerDocument, '');
          throw new Error('Illegal constructor: cannot construct Element');
        }
      };
    }
    return this.__elementCstr;
  }
  focus() {
    /**/
  }
  getComputedStyle(_) {
    return {
      cssText: '',
      length: 0,
      parentRule: null,
      getPropertyPriority() {
        return null;
      },
      getPropertyValue() {
        return '';
      },
      item() {
        return null;
      },
      removeProperty() {
        return null;
      },
      setProperty() {
        return null;
      },
    };
  }
  get globalThis() {
    return this;
  }
  get history() {
    if (this.__history == null) {
      this.__history = new MockHistory();
    }
    return this.__history;
  }
  set history(hsty) {
    this.__history = hsty;
  }
  get JSON() {
    return JSON;
  }
  get HTMLElement() {
    if (this.__htmlElementCstr == null) {
      const ownerDocument = this.document;
      this.__htmlElementCstr = class extends MockHTMLElement {
        constructor() {
          super(ownerDocument, '');
          const observedAttributes = this.constructor.observedAttributes;
          if (Array.isArray(observedAttributes) && typeof this.attributeChangedCallback === 'function') {
            observedAttributes.forEach(attrName => {
              const attrValue = this.getAttribute(attrName);
              if (attrValue != null) {
                this.attributeChangedCallback(attrName, null, attrValue);
              }
            });
          }
        }
      };
    }
    return this.__htmlElementCstr;
  }
  set HTMLElement(htmlElementCstr) {
    this.__htmlElementCstr = htmlElementCstr;
  }
  get IntersectionObserver() {
    return MockIntersectionObserver;
  }
  get localStorage() {
    if (this.__localStorage == null) {
      this.__localStorage = new MockStorage();
    }
    return this.__localStorage;
  }
  set localStorage(locStorage) {
    this.__localStorage = locStorage;
  }
  get location() {
    if (this.__location == null) {
      this.__location = new MockLocation();
    }
    return this.__location;
  }
  set location(val) {
    if (typeof val === 'string') {
      if (this.__location == null) {
        this.__location = new MockLocation();
      }
      this.__location.href = val;
    }
    else {
      this.__location = val;
    }
  }
  matchMedia() {
    return {
      matches: false,
    };
  }
  get Node() {
    if (this.__nodeCstr == null) {
      const ownerDocument = this.document;
      this.__nodeCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct Node');
        }
      };
    }
    return this.__nodeCstr;
  }
  get NodeList() {
    if (this.__nodeListCstr == null) {
      const ownerDocument = this.document;
      this.__nodeListCstr = class extends MockNodeList {
        constructor() {
          super(ownerDocument, [], 0);
          throw new Error('Illegal constructor: cannot construct NodeList');
        }
      };
    }
    return this.__nodeListCstr;
  }
  get navigator() {
    if (this.__navigator == null) {
      this.__navigator = new MockNavigator();
    }
    return this.__navigator;
  }
  set navigator(nav) {
    this.__navigator = nav;
  }
  get parent() {
    return null;
  }
  prompt() {
    return '';
  }
  open() {
    return null;
  }
  get origin() {
    return this.location.origin;
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  requestAnimationFrame(callback) {
    return this.setTimeout(() => {
      callback(Date.now());
    }, 0);
  }
  requestIdleCallback(callback) {
    return this.setTimeout(() => {
      callback({
        didTimeout: false,
        timeRemaining: () => 0,
      });
    }, 0);
  }
  scroll(_x, _y) {
    /**/
  }
  scrollBy(_x, _y) {
    /**/
  }
  scrollTo(_x, _y) {
    /**/
  }
  get self() {
    return this;
  }
  get sessionStorage() {
    if (this.__sessionStorage == null) {
      this.__sessionStorage = new MockStorage();
    }
    return this.__sessionStorage;
  }
  set sessionStorage(locStorage) {
    this.__sessionStorage = locStorage;
  }
  setInterval(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    if (this.__allowInterval) {
      const intervalId = this.__setInterval(() => {
        this.__timeouts.delete(intervalId);
        try {
          callback(...args);
        }
        catch (e) {
          if (this.console) {
            this.console.error(e);
          }
          else {
            console.error(e);
          }
        }
      }, ms);
      this.__timeouts.add(intervalId);
      return intervalId;
    }
    const timeoutId = this.__setTimeout(() => {
      this.__timeouts.delete(timeoutId);
      try {
        callback(...args);
      }
      catch (e) {
        if (this.console) {
          this.console.error(e);
        }
        else {
          console.error(e);
        }
      }
    }, ms);
    this.__timeouts.add(timeoutId);
    return timeoutId;
  }
  setTimeout(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    const timeoutId = this.__setTimeout(() => {
      this.__timeouts.delete(timeoutId);
      try {
        callback(...args);
      }
      catch (e) {
        if (this.console) {
          this.console.error(e);
        }
        else {
          console.error(e);
        }
      }
    }, ms);
    this.__timeouts.add(timeoutId);
    return timeoutId;
  }
  get top() {
    return this;
  }
  get window() {
    return this;
  }
  onanimationstart() {
    /**/
  }
  onanimationend() {
    /**/
  }
  onanimationiteration() {
    /**/
  }
  onabort() {
    /**/
  }
  onauxclick() {
    /**/
  }
  onbeforecopy() {
    /**/
  }
  onbeforecut() {
    /**/
  }
  onbeforepaste() {
    /**/
  }
  onblur() {
    /**/
  }
  oncancel() {
    /**/
  }
  oncanplay() {
    /**/
  }
  oncanplaythrough() {
    /**/
  }
  onchange() {
    /**/
  }
  onclick() {
    /**/
  }
  onclose() {
    /**/
  }
  oncontextmenu() {
    /**/
  }
  oncopy() {
    /**/
  }
  oncuechange() {
    /**/
  }
  oncut() {
    /**/
  }
  ondblclick() {
    /**/
  }
  ondrag() {
    /**/
  }
  ondragend() {
    /**/
  }
  ondragenter() {
    /**/
  }
  ondragleave() {
    /**/
  }
  ondragover() {
    /**/
  }
  ondragstart() {
    /**/
  }
  ondrop() {
    /**/
  }
  ondurationchange() {
    /**/
  }
  onemptied() {
    /**/
  }
  onended() {
    /**/
  }
  onerror() {
    /**/
  }
  onfocus() {
    /**/
  }
  onformdata() {
    /**/
  }
  onfullscreenchange() {
    /**/
  }
  onfullscreenerror() {
    /**/
  }
  ongotpointercapture() {
    /**/
  }
  oninput() {
    /**/
  }
  oninvalid() {
    /**/
  }
  onkeydown() {
    /**/
  }
  onkeypress() {
    /**/
  }
  onkeyup() {
    /**/
  }
  onload() {
    /**/
  }
  onloadeddata() {
    /**/
  }
  onloadedmetadata() {
    /**/
  }
  onloadstart() {
    /**/
  }
  onlostpointercapture() {
    /**/
  }
  onmousedown() {
    /**/
  }
  onmouseenter() {
    /**/
  }
  onmouseleave() {
    /**/
  }
  onmousemove() {
    /**/
  }
  onmouseout() {
    /**/
  }
  onmouseover() {
    /**/
  }
  onmouseup() {
    /**/
  }
  onmousewheel() {
    /**/
  }
  onpaste() {
    /**/
  }
  onpause() {
    /**/
  }
  onplay() {
    /**/
  }
  onplaying() {
    /**/
  }
  onpointercancel() {
    /**/
  }
  onpointerdown() {
    /**/
  }
  onpointerenter() {
    /**/
  }
  onpointerleave() {
    /**/
  }
  onpointermove() {
    /**/
  }
  onpointerout() {
    /**/
  }
  onpointerover() {
    /**/
  }
  onpointerup() {
    /**/
  }
  onprogress() {
    /**/
  }
  onratechange() {
    /**/
  }
  onreset() {
    /**/
  }
  onresize() {
    /**/
  }
  onscroll() {
    /**/
  }
  onsearch() {
    /**/
  }
  onseeked() {
    /**/
  }
  onseeking() {
    /**/
  }
  onselect() {
    /**/
  }
  onselectstart() {
    /**/
  }
  onstalled() {
    /**/
  }
  onsubmit() {
    /**/
  }
  onsuspend() {
    /**/
  }
  ontimeupdate() {
    /**/
  }
  ontoggle() {
    /**/
  }
  onvolumechange() {
    /**/
  }
  onwaiting() {
    /**/
  }
  onwebkitfullscreenchange() {
    /**/
  }
  onwebkitfullscreenerror() {
    /**/
  }
  onwheel() {
    /**/
  }
}
addGlobalsToWindowPrototype(MockWindow.prototype);
function resetWindowDefaults(win) {
  win.__clearInterval = nativeClearInterval;
  win.__clearTimeout = nativeClearTimeout;
  win.__setInterval = nativeSetInterval;
  win.__setTimeout = nativeSetTimeout;
  win.__maxTimeout = 30000;
  win.__allowInterval = true;
  win.URL = nativeURL;
}
function cloneWindow(srcWin, opts = {}) {
  if (srcWin == null) {
    return null;
  }
  const clonedWin = new MockWindow(false);
  if (!opts.customElementProxy) {
    srcWin.customElements = null;
  }
  if (srcWin.document != null) {
    const clonedDoc = new MockDocument(false, clonedWin);
    clonedWin.document = clonedDoc;
    clonedDoc.documentElement = srcWin.document.documentElement.cloneNode(true);
  }
  else {
    clonedWin.document = new MockDocument(null, clonedWin);
  }
  return clonedWin;
}
function cloneDocument(srcDoc) {
  if (srcDoc == null) {
    return null;
  }
  const dstWin = cloneWindow(srcDoc.defaultView);
  return dstWin.document;
}
function resetWindow(win) {
  if (win != null) {
    if (win.__timeouts) {
      win.__timeouts.forEach(timeoutId => {
        nativeClearInterval(timeoutId);
        nativeClearTimeout(timeoutId);
      });
      win.__timeouts.clear();
    }
    if (win.customElements && win.customElements.clear) {
      win.customElements.clear();
    }
    resetDocument(win.document);
    resetPerformance(win.performance);
    for (const key in win) {
      if (win.hasOwnProperty(key) && key !== 'document' && key !== 'performance' && key !== 'customElements') {
        delete win[key];
      }
    }
    resetWindowDefaults(win);
    resetWindowDimensions(win);
    resetEventListeners(win);
    if (win.document != null) {
      try {
        win.document.defaultView = win;
      }
      catch (e) { }
    }
  }
}
function resetWindowDimensions(win) {
  try {
    win.devicePixelRatio = 1;
    win.innerHeight = 768;
    win.innerWidth = 1366;
    win.pageXOffset = 0;
    win.pageYOffset = 0;
    win.screenLeft = 0;
    win.screenTop = 0;
    win.screenX = 0;
    win.screenY = 0;
    win.scrollX = 0;
    win.scrollY = 0;
    win.screen = {
      availHeight: win.innerHeight,
      availLeft: 0,
      availTop: 0,
      availWidth: win.innerWidth,
      colorDepth: 24,
      height: win.innerHeight,
      keepAwake: false,
      orientation: {
        angle: 0,
        type: 'portrait-primary',
      },
      pixelDepth: 24,
      width: win.innerWidth,
    };
  }
  catch (e) { }
}

// MODULE: mock-doc/document.js
class MockDocument extends MockHTMLElement {
  constructor(html = null, win = null) {
    super(null, null);
    this.nodeName = "#document" /* DOCUMENT_NODE */;
    this.nodeType = 9 /* DOCUMENT_NODE */;
    this.defaultView = win;
    this.cookie = '';
    this.referrer = '';
    this.appendChild(this.createDocumentTypeNode());
    if (typeof html === 'string') {
      const parsedDoc = parseDocumentUtil(this, html);
      const documentElement = parsedDoc.children.find(elm => elm.nodeName === 'HTML');
      if (documentElement != null) {
        this.appendChild(documentElement);
        setOwnerDocument(documentElement, this);
      }
    }
    else if (html !== false) {
      const documentElement = new MockHTMLElement(this, 'html');
      this.appendChild(documentElement);
      documentElement.appendChild(new MockHTMLElement(this, 'head'));
      documentElement.appendChild(new MockHTMLElement(this, 'body'));
    }
  }
  get location() {
    if (this.defaultView != null) {
      return this.defaultView.location;
    }
    return null;
  }
  set location(val) {
    if (this.defaultView != null) {
      this.defaultView.location = val;
    }
  }
  get baseURI() {
    const baseNode = this.head.childNodes.find(node => node.nodeName === 'BASE');
    if (baseNode) {
      return baseNode.href;
    }
    return this.URL;
  }
  get URL() {
    return this.location.href;
  }
  get styleSheets() {
    return this.querySelectorAll('style');
  }
  get scripts() {
    return this.querySelectorAll('script');
  }
  get forms() {
    return this.querySelectorAll('form');
  }
  get images() {
    return this.querySelectorAll('img');
  }
  get scrollingElement() {
    return this.documentElement;
  }
  get documentElement() {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeName === 'HTML') {
        return this.childNodes[i];
      }
    }
    const documentElement = new MockHTMLElement(this, 'html');
    this.appendChild(documentElement);
    return documentElement;
  }
  set documentElement(documentElement) {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeType !== 10 /* DOCUMENT_TYPE_NODE */) {
        this.childNodes[i].remove();
      }
    }
    if (documentElement != null) {
      this.appendChild(documentElement);
      setOwnerDocument(documentElement, this);
    }
  }
  get head() {
    const documentElement = this.documentElement;
    for (let i = 0; i < documentElement.childNodes.length; i++) {
      if (documentElement.childNodes[i].nodeName === 'HEAD') {
        return documentElement.childNodes[i];
      }
    }
    const head = new MockHTMLElement(this, 'head');
    documentElement.insertBefore(head, documentElement.firstChild);
    return head;
  }
  set head(head) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'HEAD') {
        documentElement.childNodes[i].remove();
      }
    }
    if (head != null) {
      documentElement.insertBefore(head, documentElement.firstChild);
      setOwnerDocument(head, this);
    }
  }
  get body() {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'BODY') {
        return documentElement.childNodes[i];
      }
    }
    const body = new MockHTMLElement(this, 'body');
    documentElement.appendChild(body);
    return body;
  }
  set body(body) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'BODY') {
        documentElement.childNodes[i].remove();
      }
    }
    if (body != null) {
      documentElement.appendChild(body);
      setOwnerDocument(body, this);
    }
  }
  appendChild(newNode) {
    newNode.remove();
    newNode.parentNode = this;
    this.childNodes.push(newNode);
    return newNode;
  }
  createComment(data) {
    return new MockComment(this, data);
  }
  createAttribute(attrName) {
    return new MockAttr(attrName.toLowerCase(), '');
  }
  createAttributeNS(namespaceURI, attrName) {
    return new MockAttr(attrName, '', namespaceURI);
  }
  createElement(tagName) {
    if (tagName === "#document" /* DOCUMENT_NODE */) {
      const doc = new MockDocument(false);
      doc.nodeName = tagName;
      doc.parentNode = null;
      return doc;
    }
    return createElement(this, tagName);
  }
  createElementNS(namespaceURI, tagName) {
    const elmNs = createElementNS(this, namespaceURI, tagName);
    elmNs.namespaceURI = namespaceURI;
    return elmNs;
  }
  createTextNode(text) {
    return new MockTextNode(this, text);
  }
  createDocumentFragment() {
    return new MockDocumentFragment(this);
  }
  createDocumentTypeNode() {
    return new MockDocumentTypeNode(this);
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  getElementsByName(elmName) {
    return getElementsByName(this, elmName.toLowerCase());
  }
  get title() {
    const title = this.head.childNodes.find(elm => elm.nodeName === 'TITLE');
    if (title != null) {
      return title.textContent;
    }
    return '';
  }
  set title(value) {
    const head = this.head;
    let title = head.childNodes.find(elm => elm.nodeName === 'TITLE');
    if (title == null) {
      title = this.createElement('title');
      head.appendChild(title);
    }
    title.textContent = value;
  }
}
function createDocument(html = null) {
  return new MockWindow(html).document;
}
function resetDocument(doc) {
  if (doc != null) {
    resetEventListeners(doc);
    const documentElement = doc.documentElement;
    if (documentElement != null) {
      resetElement(documentElement);
      for (let i = 0, ii = documentElement.childNodes.length; i < ii; i++) {
        const childNode = documentElement.childNodes[i];
        resetElement(childNode);
        childNode.childNodes.length = 0;
      }
    }
    for (const key in doc) {
      if (doc.hasOwnProperty(key) && !DOC_KEY_KEEPERS.has(key)) {
        delete doc[key];
      }
    }
    try {
      doc.nodeName = "#document" /* DOCUMENT_NODE */;
    }
    catch (e) { }
    try {
      doc.nodeType = 9 /* DOCUMENT_NODE */;
    }
    catch (e) { }
    try {
      doc.cookie = '';
    }
    catch (e) { }
    try {
      doc.referrer = '';
    }
    catch (e) { }
  }
}
const DOC_KEY_KEEPERS = new Set(['nodeName', 'nodeType', 'nodeValue', 'ownerDocument', 'parentNode', 'childNodes', '_shadowRoot']);
function getElementById(elm, id) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.id === id) {
      return childElm;
    }
    const childElmFound = getElementById(childElm, id);
    if (childElmFound != null) {
      return childElmFound;
    }
  }
  return null;
}
function getElementsByName(elm, elmName, foundElms = []) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.name && childElm.name.toLowerCase() === elmName) {
      foundElms.push(childElm);
    }
    getElementsByName(childElm, elmName, foundElms);
  }
  return foundElms;
}
function setOwnerDocument(elm, ownerDocument) {
  for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
    elm.childNodes[i].ownerDocument = ownerDocument;
    if (elm.childNodes[i].nodeType === 1 /* ELEMENT_NODE */) {
      setOwnerDocument(elm.childNodes[i], ownerDocument);
    }
  }
}

// MODULE: compiler/output-targets/empty-dir.js
const isEmptable = (o) => isOutputTargetDist(o) ||
  isOutputTargetDistCustomElements(o) ||
  isOutputTargetWww(o) ||
  isOutputTargetDistLazy(o) ||
  isOutputTargetDistLazyLoader(o) ||
  isOutputTargetDistSelfContained(o) ||
  isOutputTargetHydrate(o);
const emptyOutputTargets = async (config, compilerCtx, buildCtx) => {
  if (buildCtx.isRebuild || config.logLevel === 'debug') {
    return;
  }
  const cleanDirs = config.outputTargets
    .filter(isEmptable)
    .filter(o => o.empty === true)
    .map(o => o.dir || o.esmDir)
    .filter(isString)
    .reduce((dirs, dir) => {
    if (!dirs.includes(dir)) {
      dirs.push(dir);
    }
    return dirs;
  }, []);
  if (cleanDirs.length === 0) {
    return;
  }
  const timeSpan = buildCtx.createTimeSpan(`cleaning ${cleanDirs.length} dirs`, true);
  await Promise.all(cleanDirs.map(dir => emptyDir(compilerCtx, buildCtx, dir)));
  timeSpan.finish('cleaning dirs finished');
};
const emptyDir = async (compilerCtx, buildCtx, dir) => {
  buildCtx.debug(`empty dir: ${dir}`);
  // Check if there is a .gitkeep file
  // We want to keep it so people don't have to readd manually
  // to their projects each time.
  const gitkeepPath = join(dir, '.gitkeep');
  const existsGitkeep = await compilerCtx.fs.access(gitkeepPath);
  await compilerCtx.fs.emptyDir(dir);
  // If there was a .gitkeep file, add it again.
  if (existsGitkeep) {
    await compilerCtx.fs.writeFile(gitkeepPath, '', { immediateWrite: true });
  }
};

// MODULE: compiler/sys/fetch/fetch-module-async.js
const fetchModuleAsync = async (sys, inMemoryFs, pkgVersions, url, filePath) => {
  if (skipFilePathFetch(filePath) || known404Urls.has(url) || skipUrlFetch(url)) {
    return undefined;
  }
  try {
    const rsp = await httpFetch(sys, url);
    if (rsp) {
      if (rsp.ok) {
        const content = await rsp.clone().text();
        await writeFetchSuccessAsync(sys, inMemoryFs, url, filePath, content, pkgVersions);
        return content;
      }
      if (rsp.status === 404) {
        known404Urls.add(url);
      }
    }
  }
  catch (e) {
    console.error(e);
  }
  return undefined;
};

// MODULE: compiler/sys/resolve/resolve-module-async.js
const resolveModuleIdAsync = (sys, inMemoryFs, opts) => {
  const resolverOpts = createCustomResolverAsync(sys, inMemoryFs, opts.exts);
  resolverOpts.basedir = dirname(opts.containingFile);
  if (opts.packageFilter) {
    resolverOpts.packageFilter = opts.packageFilter;
  }
  else if (opts.packageFilter !== null) {
    resolverOpts.packageFilter = pkg => {
      if (!isString(pkg.main) || pkg.main === '') {
        pkg.main = 'package.json';
      }
      return pkg;
    };
  }
  return new Promise((resolvePromise, rejectPromise) => {
    resolve$1(opts.moduleId, resolverOpts, (err, resolveId, pkgData) => {
      if (err) {
        rejectPromise(err);
      }
      else {
        resolveId = normalizePath(resolveId);
        const results = {
          moduleId: opts.moduleId,
          resolveId,
          pkgData,
          pkgDirPath: getPackageDirPath(resolveId, opts.moduleId),
        };
        resolvePromise(results);
      }
    });
  });
};
const createCustomResolverAsync = (sys, inMemoryFs, exts) => {
  return {
    async isFile(filePath, cb) {
      const fsFilePath = normalizeFsPath(filePath);
      const stat = await inMemoryFs.stat(fsFilePath);
      if (stat.isFile) {
        cb(null, true);
        return;
      }
      if (shouldFetchModule(fsFilePath)) {
        const endsWithExt = exts.some(ext => fsFilePath.endsWith(ext));
        if (endsWithExt) {
          const url = getNodeModuleFetchUrl(sys, packageVersions, fsFilePath);
          const content = await fetchModuleAsync(sys, inMemoryFs, packageVersions, url, fsFilePath);
          const checkFileExists = typeof content === 'string';
          cb(null, checkFileExists);
          return;
        }
      }
      cb(null, false);
    },
    async isDirectory(dirPath, cb) {
      const fsDirPath = normalizeFsPath(dirPath);
      const stat = await inMemoryFs.stat(fsDirPath);
      if (stat.isDirectory) {
        cb(null, true);
        return;
      }
      if (shouldFetchModule(fsDirPath)) {
        if (basename(fsDirPath) === 'node_modules') {
          // just the /node_modules directory
          inMemoryFs.sys.mkdirSync(fsDirPath);
          inMemoryFs.clearFileCache(fsDirPath);
          cb(null, true);
          return;
        }
        if (isCommonDirModuleFile(fsDirPath)) {
          // don't bother seeing if it's a directory if it has a common file extension
          cb(null, false);
          return;
        }
        for (const fileName of COMMON_DIR_FILENAMES) {
          const url = getCommonDirUrl(sys, packageVersions, fsDirPath, fileName);
          const filePath = getCommonDirName(fsDirPath, fileName);
          const content = await fetchModuleAsync(sys, inMemoryFs, packageVersions, url, filePath);
          if (isString(content)) {
            cb(null, true);
            return;
          }
        }
      }
      cb(null, false);
    },
    async readFile(p, cb) {
      const fsFilePath = normalizeFsPath(p);
      const data = await inMemoryFs.readFile(fsFilePath);
      if (isString(data)) {
        return cb(null, data);
      }
      return cb(`readFile not found: ${p}`, undefined);
    },
    extensions: exts,
  };
};

// MODULE: compiler/style/css-imports.js
const parseCssImports = async (config, compilerCtx, buildCtx, srcFilePath, resolvedFilePath, styleText, styleDocs) => {
  const isCssEntry = resolvedFilePath.toLowerCase().endsWith('.css');
  return cssImports(config, compilerCtx, buildCtx, isCssEntry, srcFilePath, resolvedFilePath, styleText, new Set(), styleDocs);
};
const cssImports = async (config, compilerCtx, buildCtx, isCssEntry, srcFilePath, resolvedFilePath, styleText, noLoop, styleDocs) => {
  if (noLoop.has(resolvedFilePath)) {
    return styleText;
  }
  noLoop.add(resolvedFilePath);
  if (styleDocs != null) {
    parseStyleDocs(styleDocs, styleText);
  }
  const cssImports = await getCssImports(config, compilerCtx, buildCtx, resolvedFilePath, styleText);
  if (cssImports.length === 0) {
    return styleText;
  }
  await Promise.all(cssImports.map(async (cssImportData) => {
    await concatCssImport(config, compilerCtx, buildCtx, isCssEntry, srcFilePath, cssImportData, noLoop, styleDocs);
  }));
  return replaceImportDeclarations(styleText, cssImports, isCssEntry);
};
const concatCssImport = async (config, compilerCtx, buildCtx, isCssEntry, srcFilePath, cssImportData, noLoop, styleDocs) => {
  cssImportData.styleText = await loadStyleText(compilerCtx, cssImportData);
  if (typeof cssImportData.styleText === 'string') {
    cssImportData.styleText = await cssImports(config, compilerCtx, buildCtx, isCssEntry, cssImportData.filePath, cssImportData.filePath, cssImportData.styleText, noLoop, styleDocs);
  }
  else {
    const err = buildError(buildCtx.diagnostics);
    err.messageText = `Unable to read css import: ${cssImportData.srcImport}`;
    err.absFilePath = srcFilePath;
  }
};
const loadStyleText = async (compilerCtx, cssImportData) => {
  let styleText = null;
  try {
    styleText = await compilerCtx.fs.readFile(cssImportData.filePath);
  }
  catch (e) {
    if (cssImportData.altFilePath) {
      try {
        styleText = await compilerCtx.fs.readFile(cssImportData.filePath);
      }
      catch (e) { }
    }
  }
  return styleText;
};
const getCssImports = async (config, compilerCtx, buildCtx, filePath, styleText) => {
  const imports = [];
  if (!styleText.includes('@import')) {
    // no @import at all, so don't bother
    return imports;
  }
  styleText = stripCssComments(styleText);
  const dir = dirname(filePath);
  const importeeExt = filePath
    .split('.')
    .pop()
    .toLowerCase();
  let r;
  while ((r = IMPORT_RE.exec(styleText))) {
    const cssImportData = {
      srcImport: r[0],
      url: r[4].replace(/[\"\'\)]/g, ''),
    };
    if (!isLocalCssImport$1(cssImportData.srcImport)) {
      // do nothing for @import url(http://external.css)
      config.logger.debug(`did not resolve external css @import: ${cssImportData.srcImport}`);
      continue;
    }
    if (isCssNodeModule$1(cssImportData.url)) {
      // node resolve this path cuz it starts with ~
      await resolveCssNodeModule(config, compilerCtx, buildCtx.diagnostics, filePath, cssImportData);
    }
    else if (isAbsolute(cssImportData.url)) {
      // absolute path already
      cssImportData.filePath = normalizePath(cssImportData.url);
    }
    else {
      // relative path
      cssImportData.filePath = normalizePath(join(dir, cssImportData.url));
    }
    if (importeeExt !== 'css' && !cssImportData.filePath.toLowerCase().endsWith('.css')) {
      cssImportData.filePath += `.${importeeExt}`;
      if (importeeExt === 'scss') {
        const fileName = '_' + basename(cssImportData.filePath);
        const dirPath = dirname(cssImportData.filePath);
        cssImportData.altFilePath = normalizePath(join(dirPath, fileName));
      }
    }
    if (typeof cssImportData.filePath === 'string') {
      imports.push(cssImportData);
    }
  }
  return imports;
};
const IMPORT_RE = /(@import)\s+(url\()?\s?(.*?)\s?\)?([^;]*);?/gi;
const isCssNodeModule$1 = (url) => url.startsWith('~');
const resolveCssNodeModule = async (config, compilerCtx, diagnostics, filePath, cssImportData) => {
  try {
    const m = getModuleId(cssImportData.url);
    const resolved = await resolveModuleIdAsync(config.sys, compilerCtx.fs, {
      moduleId: m.moduleId,
      containingFile: filePath,
      exts: [],
      packageFilter: pkg => {
        if (m.filePath !== '') {
          pkg.main = m.filePath;
        }
        return pkg;
      },
    });
    cssImportData.filePath = resolved.resolveId;
    cssImportData.updatedImport = `@import "${cssImportData.filePath}";`;
  }
  catch (e) {
    const d = buildError(diagnostics);
    d.messageText = `Unable to resolve node module for CSS @import: ${cssImportData.url}`;
    d.absFilePath = filePath;
  }
};
const isLocalCssImport$1 = (srcImport) => {
  srcImport = srcImport.toLowerCase();
  if (srcImport.includes('url(')) {
    srcImport = srcImport.replace(/\"/g, '');
    srcImport = srcImport.replace(/\'/g, '');
    srcImport = srcImport.replace(/\s/g, '');
    if (srcImport.includes('url(http') || srcImport.includes('url(//')) {
      return false;
    }
  }
  return true;
};
const getModuleId = (orgImport) => {
  if (orgImport.startsWith('~')) {
    orgImport = orgImport.substring(1);
  }
  const splt = orgImport.split('/');
  const m = {
    moduleId: null,
    filePath: null,
  };
  if (orgImport.startsWith('@') && splt.length > 1) {
    m.moduleId = splt.slice(0, 2).join('/');
    m.filePath = splt.slice(2).join('/');
  }
  else {
    m.moduleId = splt[0];
    m.filePath = splt.slice(1).join('/');
  }
  return m;
};
const replaceImportDeclarations = (styleText, cssImports, isCssEntry) => {
  cssImports.forEach(cssImportData => {
    if (isCssEntry) {
      if (typeof cssImportData.styleText === 'string') {
        styleText = styleText.replace(cssImportData.srcImport, cssImportData.styleText);
      }
    }
    else if (typeof cssImportData.updatedImport === 'string') {
      styleText = styleText.replace(cssImportData.srcImport, cssImportData.updatedImport);
    }
  });
  return styleText;
};

// MODULE: compiler/style/optimize-css.js
const optimizeCss$1 = async (config, compilerCtx, diagnostics, styleText, filePath) => {
  if (typeof styleText !== 'string' || !styleText.length) {
    //  don't bother with invalid data
    return styleText;
  }
  if ((config.autoprefixCss === false || config.autoprefixCss === null) && !config.minifyCss) {
    // don't wanna autoprefix or minify, so just skip this
    return styleText;
  }
  if (typeof filePath === 'string') {
    filePath = normalizePath(filePath);
  }
  const opts = {
    input: styleText,
    filePath: filePath,
    autoprefixer: config.autoprefixCss,
    minify: config.minifyCss,
  };
  const cacheKey = await compilerCtx.cache.createKey('optimizeCss', optimizeCssId, opts);
  const cachedContent = await compilerCtx.cache.get(cacheKey);
  if (cachedContent != null) {
    // let's use the cached data we already figured out
    return cachedContent;
  }
  const minifyResults = await compilerCtx.worker.optimizeCss(opts);
  minifyResults.diagnostics.forEach(d => {
    // collect up any diagnostics from minifying
    diagnostics.push(d);
  });
  if (typeof minifyResults.output === 'string' && !hasError(diagnostics)) {
    // cool, we got valid minified output
    // only cache if we got a cache key, if not it probably has an @import
    await compilerCtx.cache.put(cacheKey, minifyResults.output);
    return minifyResults.output;
  }
  return styleText;
};

// MODULE: compiler/plugin/plugin.js
const runPluginResolveId = async (pluginCtx, importee) => {
  for (const plugin of pluginCtx.config.plugins) {
    if (isFunction(plugin.resolveId)) {
      try {
        const results = plugin.resolveId(importee, null, pluginCtx);
        if (results != null) {
          if (isFunction(results.then)) {
            const promiseResults = await results;
            if (promiseResults != null) {
              return promiseResults;
            }
          }
          else if (isString(results)) {
            return results;
          }
        }
      }
      catch (e) {
        catchError(pluginCtx.diagnostics, e);
      }
    }
  }
  // default resolvedId
  return importee;
};
const runPluginLoad = async (pluginCtx, id) => {
  for (const plugin of pluginCtx.config.plugins) {
    if (isFunction(plugin.load)) {
      try {
        const results = plugin.load(id, pluginCtx);
        if (results != null) {
          if (isFunction(results.then)) {
            const promiseResults = await results;
            if (promiseResults != null) {
              return promiseResults;
            }
          }
          else if (isString(results)) {
            return results;
          }
        }
      }
      catch (e) {
        catchError(pluginCtx.diagnostics, e);
      }
    }
  }
  // default load()
  return pluginCtx.fs.readFile(id);
};
const runPluginTransforms = async (config, compilerCtx, buildCtx, id, cmp) => {
  const pluginCtx = {
    config: config,
    sys: config.sys,
    fs: compilerCtx.fs,
    cache: compilerCtx.cache,
    diagnostics: [],
  };
  const resolvedId = await runPluginResolveId(pluginCtx, id);
  const sourceText = await runPluginLoad(pluginCtx, resolvedId);
  if (!isString(sourceText)) {
    const diagnostic = buildError(buildCtx.diagnostics);
    diagnostic.header = `Unable to find "${basename(id)}"`;
    diagnostic.messageText = `The file "${relative(config.rootDir, id)}" was unable to load.`;
    return null;
  }
  const transformResults = {
    code: sourceText,
    id: id,
  };
  const isRawCssFile = transformResults.id.toLowerCase().endsWith('.css');
  const shouldParseCssDocs = cmp != null && config.outputTargets.some(isOutputTargetDocs);
  if (isRawCssFile) {
    // concat all css @imports into one file
    // when the entry file is a .css file (not .scss)
    // do this BEFORE transformations on css files
    if (shouldParseCssDocs && cmp != null) {
      cmp.styleDocs = cmp.styleDocs || [];
      transformResults.code = await parseCssImports(config, compilerCtx, buildCtx, id, id, transformResults.code, cmp.styleDocs);
    }
    else {
      transformResults.code = await parseCssImports(config, compilerCtx, buildCtx, id, id, transformResults.code);
    }
  }
  for (const plugin of pluginCtx.config.plugins) {
    if (isFunction(plugin.transform)) {
      try {
        let pluginTransformResults;
        const results = plugin.transform(transformResults.code, transformResults.id, pluginCtx);
        if (results != null) {
          if (isFunction(results.then)) {
            pluginTransformResults = await results;
          }
          else {
            pluginTransformResults = results;
          }
          if (pluginTransformResults != null) {
            if (isString(pluginTransformResults)) {
              transformResults.code = pluginTransformResults;
            }
            else {
              if (isString(pluginTransformResults.code)) {
                transformResults.code = pluginTransformResults.code;
              }
              if (isString(pluginTransformResults.id)) {
                transformResults.id = pluginTransformResults.id;
              }
            }
          }
        }
      }
      catch (e) {
        catchError(buildCtx.diagnostics, e);
      }
    }
  }
  buildCtx.diagnostics.push(...pluginCtx.diagnostics);
  if (!isRawCssFile) {
    // sass precompiler just ran and converted @import "my.css" into @import url("my.css")
    // because of the ".css" extension. Sass did NOT concat the ".css" files into the output
    // but only updated it to use url() instead. Let's go ahead and concat the url() css
    // files into one file like we did for raw .css files.
    // do this AFTER transformations on non-css files
    if (shouldParseCssDocs && cmp != null) {
      cmp.styleDocs = cmp.styleDocs || [];
      transformResults.code = await parseCssImports(config, compilerCtx, buildCtx, id, transformResults.id, transformResults.code, cmp.styleDocs);
    }
    else {
      transformResults.code = await parseCssImports(config, compilerCtx, buildCtx, id, transformResults.id, transformResults.code);
    }
  }
  return transformResults;
};
const runPluginTransformsEsmImports = async (config, compilerCtx, buildCtx, code, id) => {
  const pluginCtx = {
    config: config,
    sys: config.sys,
    fs: compilerCtx.fs,
    cache: compilerCtx.cache,
    diagnostics: [],
  };
  const transformResults = {
    code,
    id,
    map: null,
    diagnostics: [],
    dependencies: [],
  };
  const isRawCssFile = id.toLowerCase().endsWith('.css');
  if (isRawCssFile) {
    // concat all css @imports into one file
    // when the entry file is a .css file (not .scss)
    // do this BEFORE transformations on css files
    transformResults.code = await parseCssImports(config, compilerCtx, buildCtx, id, id, transformResults.code);
  }
  for (const plugin of pluginCtx.config.plugins) {
    if (isFunction(plugin.transform)) {
      try {
        let pluginTransformResults;
        const results = plugin.transform(transformResults.code, transformResults.id, pluginCtx);
        if (results != null) {
          if (isFunction(results.then)) {
            pluginTransformResults = await results;
          }
          else {
            pluginTransformResults = results;
          }
          if (pluginTransformResults != null) {
            if (isString(pluginTransformResults)) {
              transformResults.code = pluginTransformResults;
            }
            else {
              if (isString(pluginTransformResults.code)) {
                transformResults.code = pluginTransformResults.code;
              }
              if (isString(pluginTransformResults.id)) {
                transformResults.id = pluginTransformResults.id;
              }
              if (Array.isArray(pluginTransformResults.dependencies)) {
                transformResults.dependencies.push(...pluginTransformResults.dependencies);
              }
            }
          }
        }
      }
      catch (e) {
        catchError(transformResults.diagnostics, e);
      }
    }
  }
  transformResults.diagnostics.push(...pluginCtx.diagnostics);
  if (!isRawCssFile) {
    // precompilers just ran and converted @import "my.css" into @import url("my.css")
    // because of the ".css" extension. Precompilers did NOT concat the ".css" files into
    // the output but only updated it to use url() instead. Let's go ahead and concat
    // the url() css files into one file like we did for raw .css files. Do this
    // AFTER transformations on non-css files
    transformResults.code = await parseCssImports(config, compilerCtx, buildCtx, id, transformResults.id, transformResults.code);
  }
  return transformResults;
};

// MODULE: compiler/style/global-styles.js
const generateGlobalStyles = async (config, compilerCtx, buildCtx) => {
  const outputTargets = config.outputTargets.filter(isOutputTargetDistGlobalStyles);
  if (outputTargets.length === 0) {
    return;
  }
  const globalStyles = await buildGlobalStyles(config, compilerCtx, buildCtx);
  if (globalStyles) {
    await Promise.all(outputTargets.map(o => compilerCtx.fs.writeFile(o.file, globalStyles)));
  }
};
const buildGlobalStyles = async (config, compilerCtx, buildCtx) => {
  let globalStylePath = config.globalStyle;
  if (!globalStylePath) {
    return null;
  }
  const canSkip = await canSkipGlobalStyles(config, compilerCtx, buildCtx);
  if (canSkip) {
    return compilerCtx.cachedGlobalStyle;
  }
  try {
    globalStylePath = normalizePath(globalStylePath);
    const transformResults = await runPluginTransforms(config, compilerCtx, buildCtx, globalStylePath);
    if (transformResults) {
      const optimizedCss = await optimizeCss$1(config, compilerCtx, buildCtx.diagnostics, transformResults.code, globalStylePath);
      compilerCtx.cachedGlobalStyle = optimizedCss;
      return optimizedCss;
    }
  }
  catch (e) {
    const d = catchError(buildCtx.diagnostics, e);
    d.absFilePath = globalStylePath;
  }
  compilerCtx.cachedGlobalStyle = null;
  return null;
};
const canSkipGlobalStyles = async (config, compilerCtx, buildCtx) => {
  if (!compilerCtx.cachedGlobalStyle) {
    return false;
  }
  if (buildCtx.requiresFullBuild) {
    return false;
  }
  if (buildCtx.isRebuild && !buildCtx.hasStyleChanges) {
    return true;
  }
  if (buildCtx.filesChanged.includes(config.globalStyle)) {
    // changed file IS the global entry style
    return false;
  }
  const hasChangedImports = await hasChangedImportFile(config, compilerCtx, buildCtx, config.globalStyle, []);
  if (hasChangedImports) {
    return false;
  }
  return true;
};
const hasChangedImportFile = async (config, compilerCtx, buildCtx, filePath, noLoop) => {
  if (noLoop.includes(filePath)) {
    return false;
  }
  noLoop.push(filePath);
  let rtn = false;
  try {
    const content = await compilerCtx.fs.readFile(filePath);
    rtn = await hasChangedImportContent(config, compilerCtx, buildCtx, filePath, content, noLoop);
  }
  catch (e) { }
  return rtn;
};
const hasChangedImportContent = async (config, compilerCtx, buildCtx, filePath, content, checkedFiles) => {
  const cssImports = await getCssImports(config, compilerCtx, buildCtx, filePath, content);
  if (cssImports.length === 0) {
    // don't bother
    return false;
  }
  const isChangedImport = buildCtx.filesChanged.some(changedFilePath => {
    return cssImports.some(c => c.filePath === changedFilePath);
  });
  if (isChangedImport) {
    // one of the changed files is an import of this file
    return true;
  }
  // keep diggin'
  const promises = cssImports.map(cssImportData => {
    return hasChangedImportFile(config, compilerCtx, buildCtx, cssImportData.filePath, checkedFiles);
  });
  const results = await Promise.all(promises);
  return results.includes(true);
};

// MODULE: compiler/output-targets/output-angular.js
const outputAngular = async (config, compilerCtx, buildCtx) => {
  if (!config.buildDist) {
    return;
  }
  const angularOutputTargets = config.outputTargets.filter(isOutputTargetAngular);
  if (angularOutputTargets.length === 0) {
    return;
  }
  const timespan = buildCtx.createTimeSpan(`generate angular proxies started`, true);
  await Promise.all(angularOutputTargets.map(outputTarget => angularDirectiveProxyOutput(config, compilerCtx, buildCtx, outputTarget)));
  timespan.finish(`generate angular proxies finished`);
};
const angularDirectiveProxyOutput = (config, compilerCtx, buildCtx, outputTarget) => {
  const filteredComponents = getFilteredComponents(outputTarget.excludeComponents, buildCtx.components);
  return Promise.all([
    generateProxies(config, compilerCtx, buildCtx, filteredComponents, outputTarget),
    generateAngularArray(compilerCtx, filteredComponents, outputTarget),
    generateAngularUtils(compilerCtx, outputTarget),
  ]);
};
const getFilteredComponents = (excludeComponents = [], cmps) => {
  return sortBy(cmps, cmp => cmp.tagName).filter(c => !excludeComponents.includes(c.tagName) && !c.internal);
};
const generateProxies = async (config, compilerCtx, buildCtx, components, outputTarget) => {
  const proxies = getProxies(components);
  const distTypesDir = dirname(buildCtx.packageJson.types);
  const dtsFilePath = join(config.rootDir, distTypesDir, GENERATED_DTS$1);
  const componentsTypeFile = relativeImport(outputTarget.directivesProxyFile, dtsFilePath, '.d.ts');
  const imports = `/* eslint-disable */
/* tslint:disable */
/* auto-generated angular directive proxies */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, NgZone } from '@angular/core';`;
  const sourceImports = !outputTarget.componentCorePackage
    ? `import { Components } from '${componentsTypeFile}';`
    : `import { Components } from '${outputTarget.componentCorePackage}';`;
  const final = [imports, getProxyUtils(outputTarget), sourceImports, proxies];
  const finalText = final.join('\n') + '\n';
  const tsSourceFile = ts.createSourceFile(GENERATED_DTS$1, finalText, ts.ScriptTarget.Latest, false);
  const tsPrinter = ts.createPrinter({
    newLine: ts.NewLineKind.LineFeed,
  });
  const formattedCode = tsPrinter.printFile(tsSourceFile);
  return compilerCtx.fs.writeFile(outputTarget.directivesProxyFile, formattedCode);
};
const getProxies = (components) => {
  return components.map(getProxy).join('\n');
};
const getProxyCmp = (inputs, methods) => {
  const hasInputs = inputs.length > 0;
  const hasMethods = methods.length > 0;
  const proxMeta = [];
  if (!hasInputs && !hasMethods) {
    return '';
  }
  if (hasInputs)
    proxMeta.push(`inputs: ['${inputs.join(`', '`)}']`);
  if (hasMethods)
    proxMeta.push(`'methods': ['${methods.join(`', '`)}']`);
  return `@ProxyCmp({${proxMeta.join(', ')}})`;
};
const getProxy = (cmpMeta) => {
  // Collect component meta
  const inputs = getInputs(cmpMeta);
  const outputs = getOutputs(cmpMeta);
  const methods = getMethods(cmpMeta);
  const hasOutputs = outputs.length > 0;
  // Generate Angular @Directive
  const directiveOpts = [`selector: \'${cmpMeta.tagName}\'`, `changeDetection: ChangeDetectionStrategy.OnPush`, `template: '<ng-content></ng-content>'`];
  if (inputs.length > 0) {
    directiveOpts.push(`inputs: ['${inputs.join(`', '`)}']`);
  }
  const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
  const lines = [
    `
export declare interface ${tagNameAsPascal} extends Components.${tagNameAsPascal} {}
${getProxyCmp(inputs, methods)}
@Component({ ${directiveOpts.join(', ')} })
export class ${tagNameAsPascal} {`,
  ];
  // Generate outputs
  outputs.forEach(output => {
    lines.push(`  ${output}!: EventEmitter<CustomEvent>;`);
  });
  lines.push('  protected el: HTMLElement;');
  lines.push(`  constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {
  c.detach();
  this.el = r.nativeElement;`);
  if (hasOutputs) {
    lines.push(`  proxyOutputs(this, this.el, ['${outputs.join(`', '`)}']);`);
  }
  lines.push(`  }`);
  lines.push(`}`);
  return lines.join('\n');
};
const getInputs = (cmpMeta) => {
  return [...cmpMeta.properties.filter(prop => !prop.internal).map(prop => prop.name), ...cmpMeta.virtualProperties.map(prop => prop.name)].sort();
};
const getOutputs = (cmpMeta) => {
  return cmpMeta.events.filter(ev => !ev.internal).map(prop => prop.name);
};
const getMethods = (cmpMeta) => {
  return cmpMeta.methods.filter(method => !method.internal).map(prop => prop.name);
};
const getProxyUtils = (outputTarget) => {
  if (!outputTarget.directivesUtilsFile) {
    return PROXY_UTILS.replace(/export function/g, 'function');
  }
  else {
    const utilsPath = relativeImport(outputTarget.directivesProxyFile, outputTarget.directivesUtilsFile, '.ts');
    return `import { ProxyCmp, proxyOutputs } from '${utilsPath}';\n`;
  }
};
const generateAngularArray = (compilerCtx, components, outputTarget) => {
  if (!outputTarget.directivesArrayFile) {
    return Promise.resolve();
  }
  const proxyPath = relativeImport(outputTarget.directivesArrayFile, outputTarget.directivesProxyFile, '.ts');
  const directives = components
    .map(cmpMeta => dashToPascalCase(cmpMeta.tagName))
    .map(className => `  d.${className}`)
    .join(',\n');
  const c = `
import * as d from '${proxyPath}';

export const DIRECTIVES = [
${directives}
];
`;
  return compilerCtx.fs.writeFile(outputTarget.directivesArrayFile, c);
};
const generateAngularUtils = async (compilerCtx, outputTarget) => {
  if (outputTarget.directivesUtilsFile) {
    await compilerCtx.fs.writeFile(outputTarget.directivesUtilsFile, '/* eslint-disable */\n/* tslint:disable */\n' + PROXY_UTILS);
  }
};
const PROXY_UTILS = `import { fromEvent } from 'rxjs';

export const proxyInputs = (Cmp: any, inputs: string[]) => {
  const Prototype = Cmp.prototype;
  inputs.forEach(item => {
  Object.defineProperty(Prototype, item, {
    get() {
    return this.el[item];
    },
    set(val: any) {
    this.z.runOutsideAngular(() => (this.el[item] = val));
    }
  });
  });
};

export const proxyMethods = (Cmp: any, methods: string[]) => {
  const Prototype = Cmp.prototype;
  methods.forEach(methodName => {
  Prototype[methodName] = function () {
    const args = arguments;
    return this.z.runOutsideAngular(() =>
    this.el[methodName].apply(this.el, args)
    );
  };
  });
};

export const proxyOutputs = (instance: any, el: any, events: string[]) => {
  events.forEach(eventName => instance[eventName] = fromEvent(el, eventName));
}

export function ProxyCmp(opts: { inputs?: any; methods?: any }) {
  const decorator =  function(cls: any){
  if (opts.inputs) {
    proxyInputs(cls, opts.inputs);
  }
  if (opts.methods) {
    proxyMethods(cls, opts.methods);
  }
  return cls;
  };
  return decorator;
}
`;
const GENERATED_DTS$1 = 'components.d.ts';

// MODULE: compiler/output-targets/copy/assets-copy-tasks.js
const getComponentAssetsCopyTasks = (config, buildCtx, dest, collectionsPath) => {
  if (!dest) {
    return [];
  }
  // get a list of all the directories to copy
  // these paths should be absolute
  const copyTasks = [];
  const cmps = buildCtx.components;
  cmps
    .filter(cmp => cmp.assetsDirs != null && cmp.assetsDirs.length > 0)
    .forEach(cmp => {
    if (!collectionsPath) {
      cmp.assetsDirs.forEach(assetsMeta => {
        copyTasks.push({
          src: assetsMeta.absolutePath,
          dest: join(dest, assetsMeta.cmpRelativePath),
          warn: false,
          keepDirStructure: false,
        });
      });
    }
    else if (!cmp.excludeFromCollection && !cmp.isCollectionDependency) {
      cmp.assetsDirs.forEach(assetsMeta => {
        const collectionDirDestination = join(dest, relative(config.srcDir, assetsMeta.absolutePath));
        copyTasks.push({
          src: assetsMeta.absolutePath,
          dest: collectionDirDestination,
          warn: false,
          keepDirStructure: false,
        });
      });
    }
  });
  buildCtx.debug(`getComponentAssetsCopyTasks: ${copyTasks.length}`);
  return copyTasks;
};
const canSkipAssetsCopy = (compilerCtx, entryModules, filesChanged) => {
  if (!compilerCtx.hasSuccessfulBuild) {
    // always copy assets if we haven't had a successful build yet
    // cannot skip build
    return false;
  }
  // assume we want to skip copying assets again
  let shouldSkipAssetsCopy = true;
  // loop through each of the changed files
  filesChanged.forEach(changedFile => {
    // get the directory of where the changed file is in
    const changedFileDirPath = normalizePath(dirname(changedFile));
    // loop through all the possible asset directories
    entryModules.forEach(entryModule => {
      entryModule.cmps.forEach(cmp => {
        if (cmp.assetsDirs != null) {
          // loop through each of the asset directories of each component
          cmp.assetsDirs.forEach(assetsDir => {
            // get the absolute of the asset directory
            const assetDirPath = normalizePath(assetsDir.absolutePath);
            // if the changed file directory is this asset directory
            // then we should recopy everything over again
            if (changedFileDirPath === assetDirPath) {
              shouldSkipAssetsCopy = false;
              return;
            }
          });
        }
      });
    });
  });
  return shouldSkipAssetsCopy;
};

// MODULE: compiler/output-targets/copy/local-copy-tasks.js
const getSrcAbsPath = (config, src) => {
  if (isAbsolute(src)) {
    return src;
  }
  return join(config.srcDir, src);
};
const getDestAbsPath = (src, destAbsPath, destRelPath) => {
  if (destRelPath) {
    if (isAbsolute(destRelPath)) {
      return destRelPath;
    }
    else {
      return join(destAbsPath, destRelPath);
    }
  }
  if (isAbsolute(src)) {
    throw new Error(`copy task, "dest" property must exist if "src" property is an absolute path: ${src}`);
  }
  return destAbsPath;
};

// MODULE: compiler/output-targets/copy/output-copy.js
const outputCopy = async (config, compilerCtx, buildCtx) => {
  const outputTargets = config.outputTargets.filter(isOutputTargetCopy);
  if (outputTargets.length === 0) {
    return;
  }
  const changedFiles = [...buildCtx.filesUpdated, ...buildCtx.filesAdded, ...buildCtx.dirsAdded];
  const copyTasks = [];
  const needsCopyAssets = !canSkipAssetsCopy(compilerCtx, buildCtx.entryModules, buildCtx.filesChanged);
  outputTargets.forEach(o => {
    if (needsCopyAssets && o.copyAssets) {
      copyTasks.push(...getComponentAssetsCopyTasks(config, buildCtx, o.dir, o.copyAssets === 'collection'));
    }
    copyTasks.push(...getCopyTasks(config, buildCtx, o, changedFiles));
  });
  if (copyTasks.length > 0) {
    const timespan = buildCtx.createTimeSpan(`copy started`);
    let copiedFiles = 0;
    try {
      const copyResults = await config.sys.copy(copyTasks, config.srcDir);
      if (copyResults != null) {
        buildCtx.diagnostics.push(...copyResults.diagnostics);
        compilerCtx.fs.cancelDeleteDirectoriesFromDisk(copyResults.dirPaths);
        compilerCtx.fs.cancelDeleteFilesFromDisk(copyResults.filePaths);
        copiedFiles = copyResults.filePaths.length;
      }
    }
    catch (e) {
      const err = buildError(buildCtx.diagnostics);
      err.messageText = e.message;
    }
    timespan.finish(`copy finished (${copiedFiles} file${copiedFiles === 1 ? '' : 's'})`);
  }
};
const getCopyTasks = (config, buildCtx, o, changedFiles) => {
  if (!Array.isArray(o.copy)) {
    return [];
  }
  const copyTasks = !buildCtx.isRebuild || buildCtx.requiresFullBuild ? o.copy : filterCopyTasks(config, o.copy, changedFiles);
  return copyTasks.map(t => transformToAbs(t, o.dir));
};
const filterCopyTasks = (config, tasks, changedFiles) => {
  if (Array.isArray(tasks)) {
    return tasks.filter(copy => {
      let copySrc = copy.src;
      if (isGlob(copySrc)) {
        // test the glob
        copySrc = join(config.srcDir, copySrc);
        if (changedFiles.some(minimatch_1.filter(copySrc))) {
          return true;
        }
      }
      else {
        copySrc = normalizePath(getSrcAbsPath(config, copySrc + '/'));
        if (changedFiles.some(f => f.startsWith(copySrc))) {
          return true;
        }
      }
      return false;
    });
  }
  return [];
};
const transformToAbs = (copyTask, dest) => {
  return {
    src: copyTask.src,
    dest: getDestAbsPath(copyTask.src, dest, copyTask.dest),
    keepDirStructure: typeof copyTask.keepDirStructure === 'boolean' ? copyTask.keepDirStructure : copyTask.dest == null,
    warn: copyTask.warn !== false,
  };
};

// MODULE: compiler/transformers/remove-collection-imports.js
const removeCollectionImports = (compilerCtx) => {
  /*
    // remove side effect collection imports like:
    import 'ionicons';
  
    // do not remove collection imports with importClauses:
    import * as asdf 'ionicons';
    import { asdf } '@ionic/core';
  */
  return () => {
    return tsSourceFile => {
      let madeUpdates = false;
      const statements = tsSourceFile.statements.slice();
      for (let i = statements.length - 1; i >= 0; i--) {
        const n = statements[i];
        if (ts.isImportDeclaration(n)) {
          if (!n.importClause && n.moduleSpecifier && ts.isStringLiteral(n.moduleSpecifier)) {
            // must not have an import clause
            // must have a module specifier and
            // the module specifier must be a string literal
            const importPath = n.moduleSpecifier.text;
            // test if this side effect import is a collection
            const isCollectionImport = compilerCtx.collections.some(c => {
              return c.collectionName === importPath || c.moduleId === importPath;
            });
            if (isCollectionImport) {
              // turns out this is a side effect import is a collection,
              // we actually don't want to include this in the JS output
              // we've already gather the types we needed, kthxbai
              madeUpdates = true;
              statements.splice(i, 1);
            }
          }
        }
      }
      if (madeUpdates) {
        return ts.updateSourceFileNode(tsSourceFile, statements);
      }
      return tsSourceFile;
    };
  };
};

// MODULE: compiler/output-targets/dist-custom-elements/index.js
const outputCustomElements = async (config, compilerCtx, buildCtx, changedModuleFiles) => {
  const outputTargets = config.outputTargets.filter(isOutputTargetDistCustomElements);
  if (outputTargets.length === 0) {
    return;
  }
  const timespan = buildCtx.createTimeSpan(`generate custom elements started`, true);
  const printer = ts.createPrinter();
  try {
    await Promise.all(changedModuleFiles.map(async (mod) => {
      const transformResults = ts.transform(mod.staticSourceFile, getCustomElementTransformer(config, compilerCtx));
      const transformed = transformResults.transformed[0];
      const code = printer.printFile(transformed);
      await Promise.all(outputTargets.map(async (o) => {
        const relPath = relative(config.srcDir, mod.jsFilePath);
        const filePath = join(o.dir, relPath);
        await compilerCtx.fs.writeFile(filePath, code, { outputTargetType: o.type });
      }));
    }));
  }
  catch (e) {
    catchError(buildCtx.diagnostics, e);
  }
  timespan.finish(`generate custom elements finished`);
};
const getCustomElementTransformer = (config, compilerCtx) => {
  const transformOpts = {
    coreImportPath: STENCIL_INTERNAL_CLIENT_ID,
    componentExport: null,
    componentMetadata: null,
    currentDirectory: config.cwd,
    module: 'esm',
    proxy: null,
    style: 'static',
  };
  return [updateStencilCoreImports(transformOpts.coreImportPath), nativeComponentTransform(compilerCtx, transformOpts), removeCollectionImports(compilerCtx)];
};

// MODULE: compiler/bundle/app-data-plugin.js
const appDataPlugin = (config, compilerCtx, buildCtx, build, platform) => {
  if (!platform) {
    return {
      name: 'appDataPlugin',
    };
  }
  const globalScripts = getGlobalScriptData(config, compilerCtx);
  return {
    name: 'appDataPlugin',
    resolveId(id) {
      if (id === STENCIL_APP_DATA_ID || id === STENCIL_APP_GLOBALS_ID) {
        if (platform === 'worker') {
          this.error('@stencil/core packages cannot be imported from a worker.');
        }
        return id;
      }
      return null;
    },
    load(id) {
      if (id === STENCIL_APP_GLOBALS_ID) {
        const s = new MagicString$1(``);
        appendGlobalScripts(globalScripts, s);
        return s.toString();
      }
      if (id === STENCIL_APP_DATA_ID) {
        const s = new MagicString$1(``);
        appendNamespace(config, s);
        appendBuildConditionals(config, build, s);
        return s.toString();
      }
      return null;
    },
    transform(code, id) {
      id = normalizePath(id);
      if (globalScripts.some(s => s.path === id)) {
        const program = this.parse(code, {});
        const needsDefault = !program.body.some(s => s.type === 'ExportDefaultDeclaration');
        const defaultExport = needsDefault ? '\nexport const globalFn = () => {};\nexport default globalFn;' : '';
        code = getContextImport(platform) + code + defaultExport;
        const compilerOptions = Object.assign({}, config.tsCompilerOptions);
        compilerOptions.module = ts.ModuleKind.ESNext;
        const results = ts.transpileModule(code, {
          compilerOptions,
          fileName: id,
          transformers: {
            after: [removeCollectionImports(compilerCtx)],
          },
        });
        buildCtx.diagnostics.push(...loadTypeScriptDiagnostics(results.diagnostics));
        return results.outputText;
      }
      return null;
    },
  };
};
const getGlobalScriptData = (config, compilerCtx) => {
  const globalScripts = [];
  if (isString(config.globalScript)) {
    const mod = compilerCtx.moduleMap.get(config.globalScript);
    const globalScript = compilerCtx.version === 2 ? config.globalScript : mod && mod.jsFilePath;
    if (globalScript) {
      globalScripts.push({
        defaultName: createJsVarName(config.namespace + 'GlobalScript'),
        path: normalizePath(globalScript),
      });
    }
  }
  compilerCtx.collections.forEach(collection => {
    if (collection.global != null && isString(collection.global.sourceFilePath)) {
      let defaultName = createJsVarName(collection.collectionName + 'GlobalScript');
      if (globalScripts.some(s => s.defaultName === defaultName)) {
        defaultName += globalScripts.length;
      }
      globalScripts.push({
        defaultName,
        path: normalizePath(collection.global.sourceFilePath),
      });
    }
  });
  return globalScripts;
};
const appendGlobalScripts = (globalScripts, s) => {
  if (globalScripts.length === 1) {
    s.prepend(`import appGlobalScript from '${globalScripts[0].path}';\n`);
    s.append(`export const globalScripts = appGlobalScript;\n`);
  }
  else if (globalScripts.length > 1) {
    globalScripts.forEach(globalScript => {
      s.prepend(`import ${globalScript.defaultName} from '${globalScript.path}';\n`);
    });
    s.append(`export const globalScripts = () => {\n`);
    globalScripts.forEach(globalScript => {
      s.append(`  ${globalScript.defaultName}();\n`);
    });
    s.append(`};\n`);
  }
  else {
    s.append(`export const globalScripts = () => {};\n`);
  }
};
const appendBuildConditionals = (config, build, s) => {
  const builData = Object.keys(build)
    .sort()
    .map(key => key + ': ' + (build[key] ? 'true' : 'false'))
    .join(', ');
  s.append(`export const BUILD = /* ${config.fsNamespace} */ { ${builData} };\n`);
};
const appendNamespace = (config, s) => {
  s.append(`export const NAMESPACE = '${config.fsNamespace}';\n`);
};
const getContextImport = (platform) => {
  return `import { Context } from '${platform === 'hydrate' ? STENCIL_INTERNAL_HYDRATE_ID : STENCIL_INTERNAL_CLIENT_ID}';\n`;
};

// MODULE: compiler/bundle/core-resolve-plugin.js
const coreResolvePlugin = (config, compilerCtx, platform) => {
  if (platform === 'worker') {
    return {
      name: 'coreResolvePlugin',
      resolveId(id) {
        if (id === STENCIL_CORE_ID || id === STENCIL_INTERNAL_CLIENT_ID || id === STENCIL_INTERNAL_HYDRATE_ID) {
          this.error(`${id} cannot be imported from a worker`);
        }
        return null;
      },
    };
  }
  const compilerExe = config.sys.getCompilerExecutingPath();
  const internalClient = getStencilInternalModule(config.rootDir, compilerExe, 'client');
  const internalHydrate = getStencilInternalModule(config.rootDir, compilerExe, 'hydrate');
  return {
    name: 'coreResolvePlugin',
    resolveId(id) {
      if (id === STENCIL_CORE_ID || id === STENCIL_INTERNAL_ID) {
        if (platform === 'client') {
          return internalClient;
        }
        if (platform === 'hydrate') {
          return internalHydrate;
        }
      }
      if (id === STENCIL_INTERNAL_CLIENT_ID) {
        return internalClient;
      }
      if (id === STENCIL_INTERNAL_HYDRATE_ID) {
        return internalHydrate;
      }
      return null;
    },
    async load(filePath) {
      if (filePath === internalClient || filePath === internalHydrate) {
        if (isExternalUrl(compilerExe)) {
          const url = getStencilModuleUrl(compilerExe, filePath);
          return fetchModuleAsync(config.sys, compilerCtx.fs, packageVersions, url, filePath);
        }
        let code = await compilerCtx.fs.readFile(normalizeFsPath(filePath));
        const hydratedFlag = config.hydratedFlag;
        if (hydratedFlag) {
          const hydratedFlagHead = getHydratedFlagHead(hydratedFlag);
          if (HYDRATED_CSS !== hydratedFlagHead) {
            code = code.replace(HYDRATED_CSS, hydratedFlagHead);
            if (hydratedFlag.name !== 'hydrated') {
              code = code.replace(`.classList.add("hydrated")`, `.classList.add("${hydratedFlag.name}")`);
              code = code.replace(`.classList.add('hydrated')`, `.classList.add('${hydratedFlag.name}')`);
              code = code.replace(`.setAttribute("hydrated",`, `.setAttribute("${hydratedFlag.name}",`);
              code = code.replace(`.setAttribute('hydrated',`, `.setAttribute('${hydratedFlag.name}',`);
            }
          }
        }
        else {
          code = code.replace(HYDRATED_CSS, '{}');
        }
        return code;
      }
      return null;
    },
    resolveImportMeta(prop, { format }) {
      if (config.extras.dynamicImportShim && prop === 'url' && format === 'es') {
        return '""';
      }
      return null;
    },
  };
};
const getStencilInternalModule = (rootDir, compilerExe, internalModule) => {
  if (isExternalUrl(compilerExe)) {
    return getNodeModulePath(rootDir, '@stencil', 'core', 'internal', internalModule, 'index.mjs');
  }
  const compilerExeDir = dirname(compilerExe);
  return normalizePath(join(compilerExeDir, '..', 'internal', internalModule, 'index.mjs'));
};
const getHydratedFlagHead = (h) => {
  // {visibility:hidden}.hydrated{visibility:inherit}
  let initial;
  let hydrated;
  if (!String(h.initialValue) || h.initialValue === '' || h.initialValue == null) {
    initial = '';
  }
  else {
    initial = `{${h.property}:${h.initialValue}}`;
  }
  const selector = h.selector === 'attribute' ? `[${h.name}]` : `.${h.name}`;
  if (!String(h.hydratedValue) || h.hydratedValue === '' || h.hydratedValue == null) {
    hydrated = '';
  }
  else {
    hydrated = `${selector}{${h.property}:${h.hydratedValue}}`;
  }
  return initial + hydrated;
};

// MODULE: ../node_modules/rollup/node_modules/acorn/dist/acorn.mjs
// Reserved word lists for various dialects of the language

var reservedWords$1 = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
  pos += set[i];
  if (pos > code) { return false }
  pos += set[i + 1];
  if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString$2 = ref.toString;

// Checks if an object has a property.

function has$1(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray$2 = Array.isArray || (function (obj) { return (
  toString$2.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
  lineBreakG.lastIndex = cur;
  var match = lineBreakG.exec(input);
  if (match && match.index < offset) {
    ++line;
    cur = match.index + match[0].length;
  } else {
    return new Position(line, offset - cur)
  }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 10.
  ecmaVersion: 10,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
  { options[opt] = opts && has$1(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
  { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
  { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray$2(options.onToken)) {
  var tokens = options.onToken;
  options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray$2(options.onComment))
  { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
  var comment = {
    type: block ? "Block" : "Line",
    value: text,
    start: start,
    end: end
  };
  if (options.locations)
    { comment.loc = new SourceLocation(this, startLoc, endLoc); }
  if (options.ranges)
    { comment.range = [start, end]; }
  array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
  SCOPE_TOP = 1,
  SCOPE_FUNCTION = 2,
  SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
  SCOPE_ASYNC = 4,
  SCOPE_GENERATOR = 8,
  SCOPE_ARROW = 16,
  SCOPE_SIMPLE_CATCH = 32,
  SCOPE_SUPER = 64,
  SCOPE_DIRECT_SUPER = 128;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal and declareName to determine the type of a binding
var
  BIND_NONE = 0, // Not a binding
  BIND_VAR = 1, // Var-style binding
  BIND_LEXICAL = 2, // Let- or const-style binding
  BIND_FUNCTION = 3, // Function declaration
  BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
  BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
  for (var v = options.ecmaVersion;; v--)
    { if (reserved = reservedWords$1[v]) { break } }
  if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords$1.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords$1.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
  this.pos = startPos;
  this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
  this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
  this.pos = this.lineStart = 0;
  this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
  { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

Parser.extend = function extend () {
  var plugins = [], len = arguments.length;
  while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
pp.strictDirective = function(start) {
  for (;;) {
  // Try to find string literal.
  skipWhiteSpace.lastIndex = start;
  start += skipWhiteSpace.exec(this.input)[0].length;
  var match = literal.exec(this.input.slice(start));
  if (!match) { return false }
  if ((match[1] || match[2]) === "use strict") { return true }
  start += match[0].length;

  // Skip semicolon, if any.
  skipWhiteSpace.lastIndex = start;
  start += skipWhiteSpace.exec(this.input)[0].length;
  if (this.input[start] === ";")
    { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
  this.next();
  return true
  } else {
  return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
  this.type === types.braceR ||
  lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
  if (this.options.onInsertedSemicolon)
    { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
  return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
  if (this.options.onTrailingComma)
    { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
  if (!notNext)
    { this.next(); }
  return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
  -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
  { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
  { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
  { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
  { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
  { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
  { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
  var stmt = this.parseStatement(null, true, exports);
  node.body.push(stmt);
  }
  if (this.inModule)
  { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
    {
    var name = list[i];

    this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
    } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // '['
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
  var pos = next + 1;
  while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
  var ident = this.input.slice(next, pos);
  if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
  { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
  this.input.slice(next, next + 8) === "function" &&
  (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
  starttype = types._var;
  kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
  case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
  kind = kind || this.value;
  if (context && kind !== "var") { this.unexpected(); }
  return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
  if (this.options.ecmaVersion > 10 && starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 40) // '('
    { return this.parseExpressionStatement(node, this.parseExpression()) }
  }

  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
    { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
    if (!this.inModule)
    { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
  }
  return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

  // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  default:
  if (this.isAsyncFunction()) {
    if (context) { this.unexpected(); }
    this.next();
    return this.parseFunctionStatement(node, true, !context)
  }

  var maybeName = this.value, expr = this.parseExpression();
  if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
    { return this.parseLabeledStatement(node, maybeName, expr, context) }
  else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
  node.label = this.parseIdent();
  this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
  var lab = this.labels[i];
  if (node.label == null || lab.name === node.label.name) {
    if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
    if (node.label && isBreak) { break }
  }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
  { this.eat(types.semi); }
  else
  { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
  this.next();
  this.parseVar(init$1, true, kind);
  this.finishNode(init$1, "VariableDeclaration");
  if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
    if (this.type === types._in) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
    } else { node.await = awaitAt > -1; }
    }
    return this.parseForIn(node, init$1)
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
  if (this.options.ecmaVersion >= 9) {
    if (this.type === types._in) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    } else { node.await = awaitAt > -1; }
  }
  this.toAssignable(init, false, refDestructuringErrors);
  this.checkLVal(init);
  return this.parseForIn(node, init)
  } else {
  this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
  { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
  if (this.type === types._case || this.type === types._default) {
    var isCase = this.type === types._case;
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    node.cases.push(cur = this.startNode());
    cur.consequent = [];
    this.next();
    if (isCase) {
    cur.test = this.parseExpression();
    } else {
    if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
    sawDefault = true;
    cur.test = null;
    }
    this.expect(types.colon);
  } else {
    if (!cur) { this.unexpected(); }
    cur.consequent.push(this.parseStatement(null));
  }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
  { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
  var clause = this.startNode();
  this.next();
  if (this.eat(types.parenL)) {
    clause.param = this.parseBindingAtom();
    var simple = clause.param.type === "Identifier";
    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
    this.expect(types.parenR);
  } else {
    if (this.options.ecmaVersion < 10) { this.unexpected(); }
    clause.param = null;
    this.enterScope(0);
  }
  clause.body = this.parseBlock(false);
  this.exitScope();
  node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
  { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
  {
  var label = list[i$1];

  if (label.name === maybeName)
    { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
  var label$1 = this.labels[i];
  if (label$1.statementStart === node.start) {
    // Update information about previous labels on this node
    label$1.statementStart = this.start;
    label$1.kind = kind;
  } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope, node) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
  var stmt = this.parseStatement(null);
  node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
  init.type === "VariableDeclaration" &&
  init.declarations[0].init != null &&
  (
    !isForIn ||
    this.options.ecmaVersion < 8 ||
    this.strict ||
    init.kind !== "var" ||
    init.declarations[0].id.type !== "Identifier"
  )
  ) {
  this.raise(
    init.start,
    ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
  );
  } else if (init.type === "AssignmentPattern") {
  this.raise(init.start, "Invalid left-hand side in for-loop");
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
  var decl = this.startNode();
  this.parseVarId(decl, kind);
  if (this.eat(types.eq)) {
    decl.init = this.parseMaybeAssign(isFor);
  } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
    this.unexpected();
  } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
    this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
  } else {
    decl.init = null;
  }
  node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  if (!this.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
  if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
    { this.unexpected(); }
  node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8)
  { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
  node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
  if (node.id && !(statement & FUNC_HANGING_STATEMENT))
    // If it is a regular function declaration in sloppy mode, then it is
    // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
    // mode depends on properties of the current scope (see
    // treatFunctionsAsVar).
    { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
  { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
  var element = this.parseClassElement(node.superClass !== null);
  if (element) {
    classBody.body.push(element);
    if (element.type === "MethodDefinition" && element.kind === "constructor") {
    if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
    hadConstructor = true;
    }
  }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassElement = function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
  if ( noLineBreak === void 0 ) noLineBreak = false;

  var start = this$1.start, startLoc = this$1.startLoc;
  if (!this$1.eatContextual(k)) { return false }
  if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
  if (method.key) { this$1.unexpected(); }
  method.computed = false;
  method.key = this$1.startNodeAt(start, startLoc);
  method.key.name = k;
  this$1.finishNode(method.key, "Identifier");
  return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
  if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
  } else if (tryContextual("get")) {
    method.kind = "get";
  } else if (tryContextual("set")) {
    method.kind = "set";
  }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
    key.type === "Literal" && key.value === "constructor")) {
  if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
  if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
  if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
  method.kind = "constructor";
  allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
  this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && method.value.params.length !== 0)
  { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
  { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
  { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, "MethodDefinition")
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
  node.id = this.parseIdent();
  if (isStatement)
    { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
  if (isStatement === true)
    { this.unexpected(); }
  node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
  this.expectContextual("from");
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
  this.checkExport(exports, "default", this.lastTokStart);
  var isAsync;
  if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) { this.next(); }
    node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types._class) {
    var cNode = this.startNode();
    node.declaration = this.parseClass(cNode, "nullableID");
  } else {
    node.declaration = this.parseMaybeAssign();
    this.semicolon();
  }
  return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
  node.declaration = this.parseStatement(null);
  if (node.declaration.type === "VariableDeclaration")
    { this.checkVariableExport(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
  } else { // export { x, y as z } [from '...']
  node.declaration = null;
  node.specifiers = this.parseExportSpecifiers(exports);
  if (this.eatContextual("from")) {
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
  } else {
    for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
    // check for keywords used as local names
    var spec = list[i];

    this.checkUnreserved(spec.local);
    // check if export is defined
    this.checkLocalExport(spec.local);
    }

    node.source = null;
  }
  this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has$1(exports, name))
  { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
  { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
  { for (var i = 0, list = pat.properties; i < list.length; i += 1)
    {
    var prop = list[i];

    this.checkPatternExport(exports, prop);
    } }
  else if (type === "ArrayPattern")
  { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
    var elt = list$1[i$1];

    if (elt) { this.checkPatternExport(exports, elt); }
  } }
  else if (type === "Property")
  { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
  { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
  { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
  { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
  {
  var decl = list[i];

  this.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
  this.type.keyword === "const" ||
  this.type.keyword === "class" ||
  this.type.keyword === "function" ||
  this.isLet() ||
  this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
  if (!first) {
    this.expect(types.comma);
    if (this.afterTrailingComma(types.braceR)) { break }
  } else { first = false; }

  var node = this.startNode();
  node.local = this.parseIdent(true);
  node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
  this.checkExport(exports, node.exported.name, node.exported.start);
  nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
  node.specifiers = empty;
  node.source = this.parseExprAtom();
  } else {
  node.specifiers = this.parseImportSpecifiers();
  this.expectContextual("from");
  node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
  // import defaultObj, { x, y as z } from '...'
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLVal(node.local, BIND_LEXICAL);
  nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
  if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
  var node$1 = this.startNode();
  this.next();
  this.expectContextual("as");
  node$1.local = this.parseIdent();
  this.checkLVal(node$1.local, BIND_LEXICAL);
  nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
  return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
  if (!first) {
    this.expect(types.comma);
    if (this.afterTrailingComma(types.braceR)) { break }
  } else { first = false; }

  var node$2 = this.startNode();
  node$2.imported = this.parseIdent(true);
  if (this.eatContextual("as")) {
    node$2.local = this.parseIdent();
  } else {
    this.checkUnreserved(node$2.imported);
    node$2.local = node$2.imported;
  }
  this.checkLVal(node$2.local, BIND_LEXICAL);
  nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
  statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
  statement.type === "ExpressionStatement" &&
  statement.expression.type === "Literal" &&
  typeof statement.expression.value === "string" &&
  // Reject parenthesized strings.
  (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
  switch (node.type) {
  case "Identifier":
    if (this.inAsync && node.name === "await")
    { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
    break

  case "ObjectPattern":
  case "ArrayPattern":
  case "RestElement":
    break

  case "ObjectExpression":
    node.type = "ObjectPattern";
    if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    for (var i = 0, list = node.properties; i < list.length; i += 1) {
    var prop = list[i];

    this.toAssignable(prop, isBinding);
    // Early error:
    //   AssignmentRestProperty[Yield, Await] :
    //   `...` DestructuringAssignmentTarget[Yield, Await]
    //
    //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
    if (
      prop.type === "RestElement" &&
      (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
    ) {
      this.raise(prop.argument.start, "Unexpected token");
    }
    }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
    this.toAssignable(node.value, isBinding);
    break

  case "ArrayExpression":
    node.type = "ArrayPattern";
    if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    this.toAssignableList(node.elements, isBinding);
    break

  case "SpreadElement":
    node.type = "RestElement";
    this.toAssignable(node.argument, isBinding);
    if (node.argument.type === "AssignmentPattern")
    { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
    break

  case "AssignmentExpression":
    if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
    node.type = "AssignmentPattern";
    delete node.operator;
    this.toAssignable(node.left, isBinding);
    // falls through to AssignmentPattern

  case "AssignmentPattern":
    break

  case "ParenthesizedExpression":
    this.toAssignable(node.expression, isBinding, refDestructuringErrors);
    break

  case "MemberExpression":
    if (!isBinding) { break }

  default:
    this.raise(node.start, "Assigning to rvalue");
  }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
  var elt = exprList[i];
  if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
  var last = exprList[end - 1];
  if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
    { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
  { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
  switch (this.type) {
  case types.bracketL:
    var node = this.startNode();
    this.next();
    node.elements = this.parseBindingList(types.bracketR, true, true);
    return this.finishNode(node, "ArrayPattern")

  case types.braceL:
    return this.parseObj(true)
  }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
  if (first) { first = false; }
  else { this.expect(types.comma); }
  if (allowEmpty && this.type === types.comma) {
    elts.push(null);
  } else if (allowTrailingComma && this.afterTrailingComma(close)) {
    break
  } else if (this.type === types.ellipsis) {
    var rest = this.parseRestBinding();
    this.parseBindingListItem(rest);
    elts.push(rest);
    if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
    this.expect(close);
    break
  } else {
    var elem = this.parseMaybeDefault(this.start, this.startLoc);
    this.parseBindingListItem(elem);
    elts.push(elem);
  }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Identifier":
  if (bindingType === BIND_LEXICAL && expr.name === "let")
    { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
  if (this.strict && this.reservedWordsStrictBind.test(expr.name))
    { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
  if (checkClashes) {
    if (has$1(checkClashes, expr.name))
    { this.raiseRecoverable(expr.start, "Argument name clash"); }
    checkClashes[expr.name] = true;
  }
  if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
  break

  case "MemberExpression":
  if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
  break

  case "ObjectPattern":
  for (var i = 0, list = expr.properties; i < list.length; i += 1)
    {
  var prop = list[i];

  this.checkLVal(prop, bindingType, checkClashes);
  }
  break

  case "Property":
  // AssignmentProperty has type === "Property"
  this.checkLVal(expr.value, bindingType, checkClashes);
  break

  case "ArrayPattern":
  for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
    var elem = list$1[i$1];

  if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
  }
  break

  case "AssignmentPattern":
  this.checkLVal(expr.left, bindingType, checkClashes);
  break

  case "RestElement":
  this.checkLVal(expr.argument, bindingType, checkClashes);
  break

  case "ParenthesizedExpression":
  this.checkLVal(expr.expression, bindingType, checkClashes);
  break

  default:
  this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
  { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
  { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
  if (name === "__proto__" && kind === "init") {
    if (propHash.proto) {
    if (refDestructuringErrors) {
      if (refDestructuringErrors.doubleProto < 0)
      { refDestructuringErrors.doubleProto = key.start; }
      // Backwards-compat kludge. Can be removed in version 6.0
    } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
    }
    propHash.proto = true;
  }
  return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
  var redefinition;
  if (kind === "init") {
    redefinition = this.strict && other.init || other.get || other.set;
  } else {
    redefinition = other.init || other[kind];
  }
  if (redefinition)
    { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
  other = propHash[name] = {
    init: false,
    get: false,
    set: false
  };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
  var node = this.startNodeAt(startPos, startLoc);
  node.expressions = [expr];
  while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
  return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
  if (this.inGenerator) { return this.parseYield(noIn) }
  // The tokenizer will assume an expression is allowed after
  // `yield`, but this isn't that kind of yield
  else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
  if (refDestructuringErrors) {
  oldParenAssign = refDestructuringErrors.parenthesizedAssign;
  oldTrailingComma = refDestructuringErrors.trailingComma;
  refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
  refDestructuringErrors = new DestructuringErrors;
  ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
  { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
  var node = this.startNodeAt(startPos, startLoc);
  node.operator = this.value;
  node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
  if (!ownDestructuringErrors) {
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
  }
  if (refDestructuringErrors.shorthandAssign >= node.left.start)
    { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
  this.checkLVal(left);
  this.next();
  node.right = this.parseMaybeAssign(noIn);
  return this.finishNode(node, "AssignmentExpression")
  } else {
  if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
  var node = this.startNodeAt(startPos, startLoc);
  node.test = expr;
  node.consequent = this.parseMaybeAssign();
  this.expect(types.colon);
  node.alternate = this.parseMaybeAssign(noIn);
  return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
  if (prec > minPrec) {
    var logical = this.type === types.logicalOR || this.type === types.logicalAND;
    var op = this.value;
    this.next();
    var startPos = this.start, startLoc = this.startLoc;
    var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
    var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
    return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
  }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
  expr = this.parseAwait();
  sawUnary = true;
  } else if (this.type.prefix) {
  var node = this.startNode(), update = this.type === types.incDec;
  node.operator = this.value;
  node.prefix = true;
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  this.checkExpressionErrors(refDestructuringErrors, true);
  if (update) { this.checkLVal(node.argument); }
  else if (this.strict && node.operator === "delete" &&
       node.argument.type === "Identifier")
    { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
  else { sawUnary = true; }
  expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
  expr = this.parseExprSubscripts(refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  while (this.type.postfix && !this.canInsertSemicolon()) {
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.operator = this.value;
    node$1.prefix = false;
    node$1.argument = expr;
    this.checkLVal(expr);
    this.next();
    expr = this.finishNode(node$1, "UpdateExpression");
  }
  }

  if (!sawUnary && this.eat(types.starstar))
  { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
  { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
  { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
  if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
  if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
    this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
  while (true) {
  var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
  if (element === base || element.type === "ArrowFunctionExpression") { return element }
  base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
  if (computed || this.eat(types.dot)) {
  var node = this.startNodeAt(startPos, startLoc);
  node.object = base;
  node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
  node.computed = !!computed;
  if (computed) { this.expect(types.bracketR); }
  base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types.parenL)) {
  var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
  if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
    this.checkPatternErrors(refDestructuringErrors, false);
    this.checkYieldAwaitInDefaultParams();
    if (this.awaitIdentPos > 0)
    { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
  }
  this.checkExpressionErrors(refDestructuringErrors, true);
  this.yieldPos = oldYieldPos || this.yieldPos;
  this.awaitPos = oldAwaitPos || this.awaitPos;
  this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
  var node$1 = this.startNodeAt(startPos, startLoc);
  node$1.callee = base;
  node$1.arguments = exprList;
  base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types.backQuote) {
  var node$2 = this.startNodeAt(startPos, startLoc);
  node$2.tag = base;
  node$2.quasi = this.parseTemplate({isTagged: true});
  base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
  if (!this.allowSuper)
    { this.raise(this.start, "'super' keyword outside a method"); }
  node = this.startNode();
  this.next();
  if (this.type === types.parenL && !this.allowDirectSuper)
    { this.raise(node.start, "super() call outside constructor of a subclass"); }
  // The `super` keyword can appear at below:
  // SuperProperty:
  //   super [ Expression ]
  //   super . IdentifierName
  // SuperCall:
  //   super ( Arguments )
  if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
    { this.unexpected(); }
  return this.finishNode(node, "Super")

  case types._this:
  node = this.startNode();
  this.next();
  return this.finishNode(node, "ThisExpression")

  case types.name:
  var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
  var id = this.parseIdent(false);
  if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
    { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
  if (canBeArrow && !this.canInsertSemicolon()) {
    if (this.eat(types.arrow))
    { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
    if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
    id = this.parseIdent(false);
    if (this.canInsertSemicolon() || !this.eat(types.arrow))
      { this.unexpected(); }
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
    }
  }
  return id

  case types.regexp:
  var value = this.value;
  node = this.parseLiteral(value.value);
  node.regex = {pattern: value.pattern, flags: value.flags};
  return node

  case types.num: case types.string:
  return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
  node = this.startNode();
  node.value = this.type === types._null ? null : this.type === types._true;
  node.raw = this.type.keyword;
  this.next();
  return this.finishNode(node, "Literal")

  case types.parenL:
  var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
  if (refDestructuringErrors) {
    if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
    { refDestructuringErrors.parenthesizedAssign = start; }
    if (refDestructuringErrors.parenthesizedBind < 0)
    { refDestructuringErrors.parenthesizedBind = start; }
  }
  return expr

  case types.bracketL:
  node = this.startNode();
  this.next();
  node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
  return this.finishNode(node, "ArrayExpression")

  case types.braceL:
  return this.parseObj(false, refDestructuringErrors)

  case types._function:
  node = this.startNode();
  this.next();
  return this.parseFunction(node, 0)

  case types._class:
  return this.parseClass(this.startNode(), false)

  case types._new:
  return this.parseNew()

  case types.backQuote:
  return this.parseTemplate()

  case types._import:
  if (this.options.ecmaVersion >= 11) {
    return this.parseExprImport()
  } else {
    return this.unexpected()
  }

  default:
  this.unexpected();
  }
};

pp$3.parseExprImport = function() {
  var node = this.startNode();
  this.next(); // skip `import`
  switch (this.type) {
  case types.parenL:
  return this.parseDynamicImport(node)
  default:
  this.unexpected();
  }
};

pp$3.parseDynamicImport = function(node) {
  this.next(); // skip `(`

  // Parse node.source.
  node.source = this.parseMaybeAssign();

  // Verify ending.
  if (!this.eat(types.parenR)) {
  var errorPos = this.start;
  if (this.eat(types.comma) && this.eat(types.parenR)) {
    this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
  } else {
    this.unexpected(errorPos);
  }
  }

  return this.finishNode(node, "ImportExpression")
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
  this.next();

  var innerStartPos = this.start, innerStartLoc = this.startLoc;
  var exprList = [], first = true, lastIsComma = false;
  var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
  this.yieldPos = 0;
  this.awaitPos = 0;
  // Do not save awaitIdentPos to allow checking awaits nested in parameters
  while (this.type !== types.parenR) {
    first ? first = false : this.expect(types.comma);
    if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
    lastIsComma = true;
    break
    } else if (this.type === types.ellipsis) {
    spreadStart = this.start;
    exprList.push(this.parseParenItem(this.parseRestBinding()));
    if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
    break
    } else {
    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
    }
  }
  var innerEndPos = this.start, innerEndLoc = this.startLoc;
  this.expect(types.parenR);

  if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
    this.checkPatternErrors(refDestructuringErrors, false);
    this.checkYieldAwaitInDefaultParams();
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    return this.parseParenArrowList(startPos, startLoc, exprList)
  }

  if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
  if (spreadStart) { this.unexpected(spreadStart); }
  this.checkExpressionErrors(refDestructuringErrors, true);
  this.yieldPos = oldYieldPos || this.yieldPos;
  this.awaitPos = oldAwaitPos || this.awaitPos;

  if (exprList.length > 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc);
    val.expressions = exprList;
    this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
  } else {
    val = exprList[0];
  }
  } else {
  val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
  var par = this.startNodeAt(startPos, startLoc);
  par.expression = val;
  return this.finishNode(par, "ParenthesizedExpression")
  } else {
  return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
  node.meta = meta;
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "target" || containsEsc)
    { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
  if (!this.inNonArrowFunction())
    { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
  return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (isImport && node.callee.type === "ImportExpression") {
  this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
  if (!isTagged) {
    this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
  }
  elem.value = {
    raw: this.value,
    cooked: null
  };
  } else {
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
    cooked: this.value
  };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
  if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
  this.expect(types.dollarBraceL);
  node.expressions.push(this.parseExpression());
  this.expect(types.braceR);
  node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
  (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
  !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
  if (!first) {
    this.expect(types.comma);
    if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
  } else { first = false; }

  var prop = this.parseProperty(isPattern, refDestructuringErrors);
  if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
  node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
  if (isPattern) {
    prop.argument = this.parseIdent(false);
    if (this.type === types.comma) {
    this.raise(this.start, "Comma is not permitted after the rest element");
    }
    return this.finishNode(prop, "RestElement")
  }
  // To disallow parenthesized identifier via `this.toAssignable()`.
  if (this.type === types.parenL && refDestructuringErrors) {
    if (refDestructuringErrors.parenthesizedAssign < 0) {
    refDestructuringErrors.parenthesizedAssign = this.start;
    }
    if (refDestructuringErrors.parenthesizedBind < 0) {
    refDestructuringErrors.parenthesizedBind = this.start;
    }
  }
  // Parse argument.
  prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  // To disallow trailing comma via `this.toAssignable()`.
  if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
    refDestructuringErrors.trailingComma = this.start;
  }
  // Finish
  return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
  prop.method = false;
  prop.shorthand = false;
  if (isPattern || refDestructuringErrors) {
    startPos = this.start;
    startLoc = this.startLoc;
  }
  if (!isPattern)
    { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
  isAsync = true;
  isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
  this.parsePropertyName(prop, refDestructuringErrors);
  } else {
  isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
  { this.unexpected(); }

  if (this.eat(types.colon)) {
  prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
  prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
  if (isPattern) { this.unexpected(); }
  prop.kind = "init";
  prop.method = true;
  prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
       this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
       (prop.key.name === "get" || prop.key.name === "set") &&
       (this.type !== types.comma && this.type !== types.braceR)) {
  if (isGenerator || isAsync) { this.unexpected(); }
  prop.kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get")
    { this.raiseRecoverable(start, "getter should have no params"); }
    else
    { this.raiseRecoverable(start, "setter should have exactly one param"); }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
    { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
  }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
  if (isGenerator || isAsync) { this.unexpected(); }
  this.checkUnreserved(prop.key);
  if (prop.key.name === "await" && !this.awaitIdentPos)
    { this.awaitIdentPos = startPos; }
  prop.kind = "init";
  if (isPattern) {
    prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
  } else if (this.type === types.eq && refDestructuringErrors) {
    if (refDestructuringErrors.shorthandAssign < 0)
    { refDestructuringErrors.shorthandAssign = this.start; }
    prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
  } else {
    prop.value = prop.key;
  }
  prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
  if (this.eat(types.bracketL)) {
    prop.computed = true;
    prop.key = this.parseMaybeAssign();
    this.expect(types.bracketR);
    return prop.key
  } else {
    prop.computed = false;
  }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
  { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
  { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
  node.body = this.parseMaybeAssign();
  node.expression = true;
  this.checkParams(node, false);
  } else {
  var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
  if (!oldStrict || nonSimple) {
    useStrict = this.strictDirective(this.end);
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (useStrict && nonSimple)
    { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
  }
  // Start a new scope with regard to labels and the `inFunction`
  // flag (restore them to their old value afterwards).
  var oldLabels = this.labels;
  this.labels = [];
  if (useStrict) { this.strict = true; }

  // Add the params to varDeclaredNames to ensure that an error is thrown
  // if a let/const declaration in the function clashes with one of the params.
  this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
  node.body = this.parseBlock(false);
  node.expression = false;
  this.adaptDirectivePrologue(node.body.body);
  this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
  {
  var param = list[i];

  if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
  {
  var param = list[i];

  this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
  if (!first) {
    this.expect(types.comma);
    if (allowTrailingComma && this.afterTrailingComma(close)) { break }
  } else { first = false; }

  var elt = (void 0);
  if (allowEmpty && this.type === types.comma)
    { elt = null; }
  else if (this.type === types.ellipsis) {
    elt = this.parseSpread(refDestructuringErrors);
    if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
    { refDestructuringErrors.trailingComma = this.start; }
  } else {
    elt = this.parseMaybeAssign(false, refDestructuringErrors);
  }
  elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
  { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
  { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.keywords.test(name))
  { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
  this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
  if (!this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
  this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
  node.name = this.value;
  } else if (this.type.keyword) {
  node.name = this.type.keyword;

  // To fix https://github.com/acornjs/acorn/issues/575
  // `class` and `function` keywords push new context into this.context.
  // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
  // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
  if ((node.name === "class" || node.name === "function") &&
    (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
    this.context.pop();
  }
  } else {
  this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
  this.checkUnreserved(node);
  if (node.name === "await" && !this.awaitIdentPos)
    { this.awaitIdentPos = node.start; }
  }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
  node.delegate = false;
  node.argument = null;
  } else {
  node.delegate = this.eat(types.star);
  node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, false);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
  return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

var Scope$1 = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterScope = function(flags) {
  this.scopeStack.push(new Scope$1(flags));
};

pp$5.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$5.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
  var scope = this.currentScope();
  redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
  scope.lexical.push(name);
  if (this.inModule && (scope.flags & SCOPE_TOP))
    { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
  var scope$1 = this.currentScope();
  scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
  var scope$2 = this.currentScope();
  if (this.treatFunctionsAsVar)
    { redeclared = scope$2.lexical.indexOf(name) > -1; }
  else
    { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
  scope$2.functions.push(name);
  } else {
  for (var i = this.scopeStack.length - 1; i >= 0; --i) {
    var scope$3 = this.scopeStack[i];
    if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
      !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
    redeclared = true;
    break
    }
    scope$3.var.push(name);
    if (this.inModule && (scope$3.flags & SCOPE_TOP))
    { delete this.undefinedExports[name]; }
    if (scope$3.flags & SCOPE_VAR) { break }
  }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$5.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
    this.scopeStack[0].var.indexOf(id.name) === -1) {
  this.undefinedExports[id.name] = id;
  }
};

pp$5.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$5.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
  var scope = this.scopeStack[i];
  if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
  var scope = this.scopeStack[i];
  if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
  { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
  { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
  { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
  { node.loc.end = loc; }
  if (this.options.ranges)
  { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
  { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
  { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
  { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
  { return true }
  if (prevType === types.braceL)
  { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
  { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
  var context = this.context[i];
  if (context.token === "function")
    { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
  { this.exprAllowed = false; }
  else if (update = type.updateContext)
  { update.call(this, prevType); }
  else
  { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
  this.exprAllowed = true;
  return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
  out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
    !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
    !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
  { this.context.push(types$1.f_expr); }
  else
  { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
  { this.context.pop(); }
  else
  { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
  var index = this.context.length - 1;
  if (this.context[index] === types$1.f_expr)
    { this.context[index] = types$1.f_expr_gen; }
  else
    { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
  if (this.value === "of" && !this.exprAllowed ||
    this.value === "yield" && this.inGeneratorContext())
    { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues
};

var data$2 = {};
function buildUnicodeData(ecmaVersion) {
  var d = data$2[ecmaVersion] = {
  binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
  nonBinary: {
    General_Category: wordsRegexp(unicodeGeneralCategoryValues),
    Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
  }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);

var pp$8 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.unicodeProperties = data$2[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
  return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
  return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
  return l
  }
  var c = s.charCodeAt(i), next;
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
    (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
  return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
  this.advance();
  return true
  }
  return false
};

function codePointToString(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
  var flag = flags.charAt(i);
  if (validFlags.indexOf(flag) === -1) {
    this.raise(state.start, "Invalid regular expression flag");
  }
  if (flags.indexOf(flag, i + 1) > -1) {
    this.raise(state.start, "Duplicate regular expression flag");
  }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
  state.switchN = true;
  this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$8.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
  // Make the same messages as V8.
  if (state.eat(0x29 /* ) */)) {
    state.raise("Unmatched ')'");
  }
  if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
    state.raise("Lone quantifier brackets");
  }
  }
  if (state.maxBackReference > state.numCapturingParens) {
  state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
  var name = list[i];

  if (state.groupNames.indexOf(name) === -1) {
    state.raise("Invalid named capture referenced");
  }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
  this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
  state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
  state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
  { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
  // Handle `QuantifiableAssertion Quantifier` alternative.
  // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
  // is a QuantifiableAssertion.
  if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
    // Make the same message as V8.
    if (state.switchU) {
    state.raise("Invalid quantifier");
    }
  }
  return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
  this.regexp_eatQuantifier(state);
  return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$8.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
  return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
  if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
    return true
  }
  state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
  var lookbehind = false;
  if (this.options.ecmaVersion >= 9) {
    lookbehind = state.eat(0x3C /* < */);
  }
  if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
    this.regexp_disjunction(state);
    if (!state.eat(0x29 /* ) */)) {
    state.raise("Unterminated group");
    }
    state.lastAssertionIsQuantifiable = !lookbehind;
    return true
  }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
  state.eat(0x3F /* ? */);
  return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
  state.eat(0x2A /* * */) ||
  state.eat(0x2B /* + */) ||
  state.eat(0x3F /* ? */) ||
  this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
  var min = 0, max = -1;
  if (this.regexp_eatDecimalDigits(state)) {
    min = state.lastIntValue;
    if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
    max = state.lastIntValue;
    }
    if (state.eat(0x7D /* } */)) {
    // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
    if (max !== -1 && max < min && !noError) {
      state.raise("numbers out of order in {} quantifier");
    }
    return true
    }
  }
  if (state.switchU && !noError) {
    state.raise("Incomplete quantifier");
  }
  state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
  this.regexp_eatPatternCharacters(state) ||
  state.eat(0x2E /* . */) ||
  this.regexp_eatReverseSolidusAtomEscape(state) ||
  this.regexp_eatCharacterClass(state) ||
  this.regexp_eatUncapturingGroup(state) ||
  this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
  if (this.regexp_eatAtomEscape(state)) {
    return true
  }
  state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
  if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
    return true
    }
    state.raise("Unterminated group");
  }
  state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
  if (this.options.ecmaVersion >= 9) {
    this.regexp_groupSpecifier(state);
  } else if (state.current() === 0x3F /* ? */) {
    state.raise("Invalid group");
  }
  this.regexp_disjunction(state);
  if (state.eat(0x29 /* ) */)) {
    state.numCapturingParens += 1;
    return true
  }
  state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
  state.eat(0x2E /* . */) ||
  this.regexp_eatReverseSolidusAtomEscape(state) ||
  this.regexp_eatCharacterClass(state) ||
  this.regexp_eatUncapturingGroup(state) ||
  this.regexp_eatCapturingGroup(state) ||
  this.regexp_eatInvalidBracedQuantifier(state) ||
  this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
  state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$8.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
  state.lastIntValue = ch;
  state.advance();
  return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
  ch === 0x24 /* $ */ ||
  ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
  ch === 0x2E /* . */ ||
  ch === 0x3F /* ? */ ||
  ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
  ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$8.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
  state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$8.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
  ch !== -1 &&
  ch !== 0x24 /* $ */ &&
  !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
  ch !== 0x2E /* . */ &&
  ch !== 0x3F /* ? */ &&
  ch !== 0x5B /* [ */ &&
  ch !== 0x5E /* ^ */ &&
  ch !== 0x7C /* | */
  ) {
  state.advance();
  return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
  if (this.regexp_eatGroupName(state)) {
    if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
    state.raise("Duplicate capture group name");
    }
    state.groupNames.push(state.lastStringValue);
    return
  }
  state.raise("Invalid group");
  }
};

// GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
  if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
    return true
  }
  state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
  state.lastStringValue += codePointToString(state.lastIntValue);
  while (this.regexp_eatRegExpIdentifierPart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
  }
  return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$8.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
  ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
  state.lastIntValue = ch;
  return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>
pp$8.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
  ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
  state.lastIntValue = ch;
  return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
  this.regexp_eatBackReference(state) ||
  this.regexp_eatCharacterClassEscape(state) ||
  this.regexp_eatCharacterEscape(state) ||
  (state.switchN && this.regexp_eatKGroupName(state))
  ) {
  return true
  }
  if (state.switchU) {
  // Make the same message as V8.
  if (state.current() === 0x63 /* c */) {
    state.raise("Invalid unicode escape");
  }
  state.raise("Invalid escape");
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
  var n = state.lastIntValue;
  if (state.switchU) {
    // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
    if (n > state.maxBackReference) {
    state.maxBackReference = n;
    }
    return true
  }
  if (n <= state.numCapturingParens) {
    return true
  }
  state.pos = start;
  }
  return false
};
pp$8.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
  if (this.regexp_eatGroupName(state)) {
    state.backReferenceNames.push(state.lastStringValue);
    return true
  }
  state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
  this.regexp_eatControlEscape(state) ||
  this.regexp_eatCControlLetter(state) ||
  this.regexp_eatZero(state) ||
  this.regexp_eatHexEscapeSequence(state) ||
  this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
  (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
  this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
  if (this.regexp_eatControlLetter(state)) {
    return true
  }
  state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
  state.lastIntValue = 0;
  state.advance();
  return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$8.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
  state.lastIntValue = 0x09; /* \t */
  state.advance();
  return true
  }
  if (ch === 0x6E /* n */) {
  state.lastIntValue = 0x0A; /* \n */
  state.advance();
  return true
  }
  if (ch === 0x76 /* v */) {
  state.lastIntValue = 0x0B; /* \v */
  state.advance();
  return true
  }
  if (ch === 0x66 /* f */) {
  state.lastIntValue = 0x0C; /* \f */
  state.advance();
  return true
  }
  if (ch === 0x72 /* r */) {
  state.lastIntValue = 0x0D; /* \r */
  state.advance();
  return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$8.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
  state.lastIntValue = ch % 0x20;
  state.advance();
  return true
  }
  return false
};
function isControlLetter(ch) {
  return (
  (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
  (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
  if (this.regexp_eatFixedHexDigits(state, 4)) {
    var lead = state.lastIntValue;
    if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
    var leadSurrogateEnd = state.pos;
    if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
      var trail = state.lastIntValue;
      if (trail >= 0xDC00 && trail <= 0xDFFF) {
      state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
      return true
      }
    }
    state.pos = leadSurrogateEnd;
    state.lastIntValue = lead;
    }
    return true
  }
  if (
    state.switchU &&
    state.eat(0x7B /* { */) &&
    this.regexp_eatHexDigits(state) &&
    state.eat(0x7D /* } */) &&
    isValidUnicode(state.lastIntValue)
  ) {
    return true
  }
  if (state.switchU) {
    state.raise("Invalid unicode escape");
  }
  state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
  if (this.regexp_eatSyntaxCharacter(state)) {
    return true
  }
  if (state.eat(0x2F /* / */)) {
    state.lastIntValue = 0x2F; /* / */
    return true
  }
  return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
  state.lastIntValue = ch;
  state.advance();
  return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$8.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
  do {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
  return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$8.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
  state.lastIntValue = -1;
  state.advance();
  return true
  }

  if (
  state.switchU &&
  this.options.ecmaVersion >= 9 &&
  (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
  state.lastIntValue = -1;
  state.advance();
  if (
    state.eat(0x7B /* { */) &&
    this.regexp_eatUnicodePropertyValueExpression(state) &&
    state.eat(0x7D /* } */)
  ) {
    return true
  }
  state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
  ch === 0x64 /* d */ ||
  ch === 0x44 /* D */ ||
  ch === 0x73 /* s */ ||
  ch === 0x53 /* S */ ||
  ch === 0x77 /* w */ ||
  ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.regexp_eatUnicodePropertyValue(state)) {
    var value = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
    return true
  }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
  var nameOrValue = state.lastStringValue;
  this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has$1(state.unicodeProperties.nonBinary, name))
  { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
  { state.raise("Invalid property value"); }
};
pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
  { state.raise("Invalid property name"); }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$8.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
  state.lastStringValue += codePointToString(ch);
  state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
  state.lastStringValue += codePointToString(ch);
  state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
  state.eat(0x5E /* ^ */);
  this.regexp_classRanges(state);
  if (state.eat(0x5D /* ] */)) {
    return true
  }
  // Unreachable since it threw "unterminated regular expression" error before.
  state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
  var left = state.lastIntValue;
  if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
    var right = state.lastIntValue;
    if (state.switchU && (left === -1 || right === -1)) {
    state.raise("Invalid character class");
    }
    if (left !== -1 && right !== -1 && left > right) {
    state.raise("Range out of order in character class");
    }
  }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$8.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
  if (this.regexp_eatClassEscape(state)) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    var ch$1 = state.current();
    if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
    state.raise("Invalid class escape");
    }
    state.raise("Invalid escape");
  }
  state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* ] */) {
  state.lastIntValue = ch;
  state.advance();
  return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$8.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
  state.lastIntValue = 0x08; /* <BS> */
  return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
  state.lastIntValue = 0x2D; /* - */
  return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
  if (this.regexp_eatClassControlLetter(state)) {
    return true
  }
  state.pos = start;
  }

  return (
  this.regexp_eatCharacterClassEscape(state) ||
  this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$8.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
  state.lastIntValue = ch % 0x20;
  state.advance();
  return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
  if (this.regexp_eatFixedHexDigits(state, 2)) {
    return true
  }
  if (state.switchU) {
    state.raise("Invalid escape");
  }
  state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$8.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
  state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
  state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$8.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
  state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
  state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
  (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
  (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
  (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
  return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
  return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
  var n1 = state.lastIntValue;
  if (this.regexp_eatOctalDigit(state)) {
    var n2 = state.lastIntValue;
    if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
    state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
    } else {
    state.lastIntValue = n1 * 8 + n2;
    }
  } else {
    state.lastIntValue = n1;
  }
  return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$8.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
  state.lastIntValue = ch - 0x30; /* 0 */
  state.advance();
  return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
  var ch = state.current();
  if (!isHexDigit(ch)) {
    state.pos = start;
    return false
  }
  state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
  state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
  { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
  { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$9 = Parser.prototype;

// Move to the next token

pp$9.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
  { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
  if (this.options.onToken)
  { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$9.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$9[Symbol.iterator] = function() {
  var this$1 = this;

  return {
    next: function () {
    var token = this$1.getToken();
    return {
      done: token.type === types.eof,
      value: token
    }
    }
  }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$9.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
  { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$9.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
  lineBreakG.lastIndex = start;
  var match;
  while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
    ++this.curLine;
    this.lineStart = match.index + match[0].length;
  }
  }
  if (this.options.onComment)
  { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
               startLoc, this.curPosition()); }
};

pp$9.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
  ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
  { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
               startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$9.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
  var ch = this.input.charCodeAt(this.pos);
  switch (ch) {
  case 32: case 160: // ' '
    ++this.pos;
    break
  case 13:
    if (this.input.charCodeAt(this.pos + 1) === 10) {
    ++this.pos;
    }
  case 10: case 8232: case 8233:
    ++this.pos;
    if (this.options.locations) {
    ++this.curLine;
    this.lineStart = this.pos;
    }
    break
  case 47: // '/'
    switch (this.input.charCodeAt(this.pos + 1)) {
    case 42: // '*'
    this.skipBlockComment();
    break
    case 47:
    this.skipLineComment(2);
    break
    default:
    break loop
    }
    break
  default:
    if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
    ++this.pos;
    } else {
    break loop
    }
  }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
  this.pos += 3;
  return this.finishToken(types.ellipsis)
  } else {
  ++this.pos;
  return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
  ++size;
  tokentype = types.starstar;
  next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$9.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$9.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$9.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
  if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
    (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
    // A `-->` line comment
    this.skipLineComment(3);
    this.skipSpace();
    return this.nextToken()
  }
  return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$9.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
  size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
  if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
    this.input.charCodeAt(this.pos + 3) === 45) {
  // `<!--`, an XML-style comment that should be interpreted as a line comment
  this.skipLineComment(4);
  this.skipSpace();
  return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$9.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
  this.pos += 2;
  return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$9.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
  return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
  if (this.options.ecmaVersion < 6) { break }
  ++this.pos;
  return this.finishToken(types.backQuote)

  case 48: // '0'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
  if (this.options.ecmaVersion >= 6) {
    if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
    if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
  }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
  return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
  return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
  return this.readToken_slash()

  case 37: case 42: // '%*'
  return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
  return this.readToken_pipe_amp(code)

  case 94: // '^'
  return this.readToken_caret()

  case 43: case 45: // '+-'
  return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
  return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
  return this.readToken_eq_excl(code)

  case 126: // '~'
  return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};

pp$9.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$9.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
  if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
  var ch = this.input.charAt(this.pos);
  if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
  if (!escaped) {
    if (ch === "[") { inClass = true; }
    else if (ch === "]" && inClass) { inClass = false; }
    else if (ch === "/" && !inClass) { break }
    escaped = ch === "\\";
  } else { escaped = false; }
  ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
  value = new RegExp(pattern, flags);
  } catch (e) {
  // ESTree requires null if it failed to instantiate RegExp object.
  // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$9.readInt = function(radix, len) {
  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
  var code = this.input.charCodeAt(this.pos), val = (void 0);
  if (code >= 97) { val = code - 97 + 10; } // a
  else if (code >= 65) { val = code - 65 + 10; } // A
  else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
  else { val = Infinity; }
  if (val >= radix) { break }
  ++this.pos;
  total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
  val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
  ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$9.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
  var str$1 = this.input.slice(start, this.pos);
  var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
  ++this.pos;
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val$1)
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  if (next === 46 && !octal) { // '.'
  ++this.pos;
  this.readInt(10);
  next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
  next = this.input.charCodeAt(++this.pos);
  if (next === 43 || next === 45) { ++this.pos; } // '+-'
  if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
  if (this.options.ecmaVersion < 6) { this.unexpected(); }
  var codePos = ++this.pos;
  code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
  ++this.pos;
  if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
  code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$9.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
  if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
  var ch = this.input.charCodeAt(this.pos);
  if (ch === quote) { break }
  if (ch === 92) { // '\'
    out += this.input.slice(chunkStart, this.pos);
    out += this.readEscapedChar(false);
    chunkStart = this.pos;
  } else {
    if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
    ++this.pos;
  }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
  this.readTmplToken();
  } catch (err) {
  if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
    this.readInvalidTemplateToken();
  } else {
    throw err
  }
  }

  this.inTemplateElement = false;
};

pp$9.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
  throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
  this.raise(position, message);
  }
};

pp$9.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
  if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
  var ch = this.input.charCodeAt(this.pos);
  if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
    if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
    if (ch === 36) {
      this.pos += 2;
      return this.finishToken(types.dollarBraceL)
    } else {
      ++this.pos;
      return this.finishToken(types.backQuote)
    }
    }
    out += this.input.slice(chunkStart, this.pos);
    return this.finishToken(types.template, out)
  }
  if (ch === 92) { // '\'
    out += this.input.slice(chunkStart, this.pos);
    out += this.readEscapedChar(true);
    chunkStart = this.pos;
  } else if (isNewLine(ch)) {
    out += this.input.slice(chunkStart, this.pos);
    ++this.pos;
    switch (ch) {
    case 13:
    if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
    case 10:
    out += "\n";
    break
    default:
    out += String.fromCharCode(ch);
    break
    }
    if (this.options.locations) {
    ++this.curLine;
    this.lineStart = this.pos;
    }
    chunkStart = this.pos;
  } else {
    ++this.pos;
  }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$9.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
  switch (this.input[this.pos]) {
  case "\\":
    ++this.pos;
    break

  case "$":
    if (this.input[this.pos + 1] !== "{") {
    break
    }
  // falls through

  case "`":
    return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

  // no default
  }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$9.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString$1(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
  if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
  return ""
  case 56:
  case 57:
  if (inTemplate) {
    var codePos = this.pos - 1;

    this.invalidStringToken(
    codePos,
    "Invalid escape sequence in template string"
    );

    return null
  }
  default:
  if (ch >= 48 && ch <= 55) {
    var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
    var octal = parseInt(octalStr, 8);
    if (octal > 255) {
    octalStr = octalStr.slice(0, -1);
    octal = parseInt(octalStr, 8);
    }
    this.pos += octalStr.length - 1;
    ch = this.input.charCodeAt(this.pos);
    if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
    this.invalidStringToken(
      this.pos - 1 - octalStr.length,
      inTemplate
      ? "Octal literal in template string"
      : "Octal literal in strict mode"
    );
    }
    return String.fromCharCode(octal)
  }
  if (isNewLine(ch)) {
    // Unicode new line characters after \ get removed from output in both
    // template literals and strings
    return ""
  }
  return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$9.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$9.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
  var ch = this.fullCharCodeAtPos();
  if (isIdentifierChar(ch, astral)) {
    this.pos += ch <= 0xffff ? 1 : 2;
  } else if (ch === 92) { // "\"
    this.containsEsc = true;
    word += this.input.slice(chunkStart, this.pos);
    var escStart = this.pos;
    if (this.input.charCodeAt(++this.pos) !== 117) // "u"
    { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
    ++this.pos;
    var esc = this.readCodePoint();
    if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
    { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
    word += codePointToString$1(esc);
    chunkStart = this.pos;
  } else {
    break
  }
  first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$9.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
  type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.

var version$1 = "7.1.0";

Parser.acorn = {
  Parser: Parser,
  version: version$1,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types,
  keywordTypes: keywords$1,
  TokContext: TokContext,
  tokContexts: types$1,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

// MODULE: ../node_modules/minimalistic-assert/index.js
var minimalisticAssert = assert$2;

function assert$2(val, msg) {
  if (!val)
  throw new Error(msg || 'Assertion failed');
}

assert$2.equal = function assertEqual(l, r, msg) {
  if (l != r)
  throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

// MODULE: ../node_modules/inherits/inherits_browser.js

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
  if (superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
    });
  }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
  if (superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }
  };
}
});

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/inherits/inherits_browser.js?commonjs-proxy

// MODULE: ../node_modules/inherits/inherits.js

var inherits$1 = createCommonjsModule(function (module) {
try {
  var util$1 = util;
  /* istanbul ignore next */
  if (typeof util$1.inherits !== 'function') throw '';
  module.exports = util$1.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = inherits_browser;
}
});

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/minimalistic-assert/index.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/inherits/inherits.js?commonjs-proxy

// MODULE: ../node_modules/hash.js/lib/hash/utils.js




var inherits_1 = inherits$1;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
  return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
  return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
  return msg.slice();
  if (!msg)
  return [];
  var res = [];
  if (typeof msg === 'string') {
  if (!enc) {
    // Inspired by stringToUtf8ByteArray() in closure-library by Google
    // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
    // Apache License 2.0
    // https://github.com/google/closure-library/blob/master/LICENSE
    var p = 0;
    for (var i = 0; i < msg.length; i++) {
    var c = msg.charCodeAt(i);
    if (c < 128) {
      res[p++] = c;
    } else if (c < 2048) {
      res[p++] = (c >> 6) | 192;
      res[p++] = (c & 63) | 128;
    } else if (isSurrogatePair(msg, i)) {
      c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
      res[p++] = (c >> 18) | 240;
      res[p++] = ((c >> 12) & 63) | 128;
      res[p++] = ((c >> 6) & 63) | 128;
      res[p++] = (c & 63) | 128;
    } else {
      res[p++] = (c >> 12) | 224;
      res[p++] = ((c >> 6) & 63) | 128;
      res[p++] = (c & 63) | 128;
    }
    }
  } else if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
    msg = '0' + msg;
    for (i = 0; i < msg.length; i += 2)
    res.push(parseInt(msg[i] + msg[i + 1], 16));
  }
  } else {
  for (i = 0; i < msg.length; i++)
    res[i] = msg[i] | 0;
  }
  return res;
}
var toArray_1 = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
  res += zero2(msg[i].toString(16));
  return res;
}
var toHex_1 = toHex;

function htonl(w) {
  var res = (w >>> 24) |
      ((w >>> 8) & 0xff00) |
      ((w << 8) & 0xff0000) |
      ((w & 0xff) << 24);
  return res >>> 0;
}
var htonl_1 = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
  var w = msg[i];
  if (endian === 'little')
    w = htonl(w);
  res += zero8(w.toString(16));
  }
  return res;
}
var toHex32_1 = toHex32;

function zero2(word) {
  if (word.length === 1)
  return '0' + word;
  else
  return word;
}
var zero2_1 = zero2;

function zero8(word) {
  if (word.length === 7)
  return '0' + word;
  else if (word.length === 6)
  return '00' + word;
  else if (word.length === 5)
  return '000' + word;
  else if (word.length === 4)
  return '0000' + word;
  else if (word.length === 3)
  return '00000' + word;
  else if (word.length === 2)
  return '000000' + word;
  else if (word.length === 1)
  return '0000000' + word;
  else
  return word;
}
var zero8_1 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  minimalisticAssert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
  var w;
  if (endian === 'big')
    w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
  else
    w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
  res[i] = w >>> 0;
  }
  return res;
}
var join32_1 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
  var m = msg[i];
  if (endian === 'big') {
    res[k] = m >>> 24;
    res[k + 1] = (m >>> 16) & 0xff;
    res[k + 2] = (m >>> 8) & 0xff;
    res[k + 3] = m & 0xff;
  } else {
    res[k + 3] = m >>> 24;
    res[k + 2] = (m >>> 16) & 0xff;
    res[k + 1] = (m >>> 8) & 0xff;
    res[k] = m & 0xff;
  }
  }
  return res;
}
var split32_1 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
var rotr32_1 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
var rotl32_1 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
var sum32_1 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
var sum32_3_1 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
var sum32_4_1 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
var sum32_5_1 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
var sum64_1 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
var sum64_hi_1 = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
var sum64_lo_1 = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
var sum64_4_hi_1 = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
var sum64_4_lo_1 = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
var sum64_5_hi_1 = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
var sum64_5_lo_1 = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
var rotr64_hi_1 = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
var rotr64_lo_1 = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
var shr64_hi_1 = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
var shr64_lo_1 = shr64_lo;

var utils$2 = {
	inherits: inherits_1,
	toArray: toArray_1,
	toHex: toHex_1,
	htonl: htonl_1,
	toHex32: toHex32_1,
	zero2: zero2_1,
	zero8: zero8_1,
	join32: join32_1,
	split32: split32_1,
	rotr32: rotr32_1,
	rotl32: rotl32_1,
	sum32: sum32_1,
	sum32_3: sum32_3_1,
	sum32_4: sum32_4_1,
	sum32_5: sum32_5_1,
	sum64: sum64_1,
	sum64_hi: sum64_hi_1,
	sum64_lo: sum64_lo_1,
	sum64_4_hi: sum64_4_hi_1,
	sum64_4_lo: sum64_4_lo_1,
	sum64_5_hi: sum64_5_hi_1,
	sum64_5_lo: sum64_5_lo_1,
	rotr64_hi: rotr64_hi_1,
	rotr64_lo: rotr64_lo_1,
	shr64_hi: shr64_hi_1,
	shr64_lo: shr64_lo_1
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/hash.js/lib/hash/utils.js?commonjs-proxy

// MODULE: ../node_modules/hash.js/lib/hash/common.js




function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
var BlockHash_1 = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils$2.toArray(msg, enc);
  if (!this.pending)
  this.pending = msg;
  else
  this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
  msg = this.pending;

  // Process pending data in blocks
  var r = msg.length % this._delta8;
  this.pending = msg.slice(msg.length - r, msg.length);
  if (this.pending.length === 0)
    this.pending = null;

  msg = utils$2.join32(msg, 0, msg.length - r, this.endian);
  for (var i = 0; i < msg.length; i += this._delta32)
    this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  minimalisticAssert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
  res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
  for (var t = 8; t < this.padLength; t++)
    res[i++] = 0;

  res[i++] = 0;
  res[i++] = 0;
  res[i++] = 0;
  res[i++] = 0;
  res[i++] = (len >>> 24) & 0xff;
  res[i++] = (len >>> 16) & 0xff;
  res[i++] = (len >>> 8) & 0xff;
  res[i++] = len & 0xff;
  } else {
  res[i++] = len & 0xff;
  res[i++] = (len >>> 8) & 0xff;
  res[i++] = (len >>> 16) & 0xff;
  res[i++] = (len >>> 24) & 0xff;
  res[i++] = 0;
  res[i++] = 0;
  res[i++] = 0;
  res[i++] = 0;

  for (t = 8; t < this.padLength; t++)
    res[i++] = 0;
  }

  return res;
};

var common = {
	BlockHash: BlockHash_1
};

// MODULE: ../node_modules/hash.js/lib/hash/sha/common.js


var rotr32$1 = utils$2.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
  return ch32(x, y, z);
  if (s === 1 || s === 3)
  return p32(x, y, z);
  if (s === 2)
  return maj32(x, y, z);
}
var ft_1_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
var ch32_1 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
var maj32_1 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
var p32_1 = p32;

function s0_256(x) {
  return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);
}
var s0_256_1 = s0_256;

function s1_256(x) {
  return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);
}
var s1_256_1 = s1_256;

function g0_256(x) {
  return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ (x >>> 3);
}
var g0_256_1 = g0_256;

function g1_256(x) {
  return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ (x >>> 10);
}
var g1_256_1 = g1_256;

var common$1 = {
	ft_1: ft_1_1,
	ch32: ch32_1,
	maj32: maj32_1,
	p32: p32_1,
	s0_256: s0_256_1,
	s1_256: s1_256_1,
	g0_256: g0_256_1,
	g1_256: g1_256_1
};

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/hash.js/lib/hash/common.js?commonjs-proxy

// MODULE: ../ /Users/manualmeida/repos/ionic/stencil/node_modules/hash.js/lib/hash/sha/common.js?commonjs-proxy

// MODULE: ../node_modules/hash.js/lib/hash/sha/256.js






var sum32$1 = utils$2.sum32;
var sum32_4$1 = utils$2.sum32_4;
var sum32_5$1 = utils$2.sum32_5;
var ch32$1 = common$1.ch32;
var maj32$1 = common$1.maj32;
var s0_256$1 = common$1.s0_256;
var s1_256$1 = common$1.s1_256;
var g0_256$1 = common$1.g0_256;
var g1_256$1 = common$1.g1_256;

var BlockHash$1 = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
  return new SHA256();

  BlockHash$1.call(this);
  this.h = [
  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
  0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$2.inherits(SHA256, BlockHash$1);
var _256 = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
  W[i] = msg[start + i];
  for (; i < W.length; i++)
  W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  minimalisticAssert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
  var T1 = sum32_5$1(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);
  var T2 = sum32$1(s0_256$1(a), maj32$1(a, b, c));
  h = g;
  g = f;
  f = e;
  e = sum32$1(d, T1);
  d = c;
  c = b;
  b = a;
  a = sum32$1(T1, T2);
  }

  this.h[0] = sum32$1(this.h[0], a);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c);
  this.h[3] = sum32$1(this.h[3], d);
  this.h[4] = sum32$1(this.h[4], e);
  this.h[5] = sum32$1(this.h[5], f);
  this.h[6] = sum32$1(this.h[6], g);
  this.h[7] = sum32$1(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
  return utils$2.toHex32(this.h, 'big');
  else
  return utils$2.split32(this.h, 'big');
};

// MODULE: compiler/sys/modules/crypto.js
const createHash = () => _256();

// MODULE: ../node_modules/rollup/dist/rollup.es.js

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) { try {
      step(generator.next(value));
    }
    catch (e) {
      reject(e);
    } }
    function rejected(value) { try {
      step(generator["throw"](value));
    }
    catch (e) {
      reject(e);
    } }
    function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

var version$2 = "1.32.0";

var charToInteger = {};
var chars$2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
for (var i = 0; i < chars$2.length; i++) {
  charToInteger[chars$2.charCodeAt(i)] = i;
}
function decode$2(mappings) {
  var decoded = [];
  var line = [];
  var segment = [
    0,
    0,
    0,
    0,
    0,
  ];
  var j = 0;
  for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {
    var c = mappings.charCodeAt(i);
    if (c === 44) { // ","
      segmentify(line, segment, j);
      j = 0;
    }
    else if (c === 59) { // ";"
      segmentify(line, segment, j);
      j = 0;
      decoded.push(line);
      line = [];
      segment[0] = 0;
    }
    else {
      var integer = charToInteger[c];
      if (integer === undefined) {
        throw new Error('Invalid character (' + String.fromCharCode(c) + ')');
      }
      var hasContinuationBit = integer & 32;
      integer &= 31;
      value += integer << shift;
      if (hasContinuationBit) {
        shift += 5;
      }
      else {
        var shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = value === 0 ? -0x80000000 : -value;
        }
        segment[j] += value;
        j++;
        value = shift = 0; // reset
      }
    }
  }
  segmentify(line, segment, j);
  decoded.push(line);
  return decoded;
}
function segmentify(line, segment, j) {
  // This looks ugly, but we're creating specialized arrays with a specific
  // length. This is much faster than creating a new array (which v8 expands to
  // a capacity of 17 after pushing the first item), or slicing out a subarray
  // (which is slow). Length 4 is assumed to be the most frequent, followed by
  // length 5 (since not everything will have an associated name), followed by
  // length 1 (it's probably rare for a source substring to not have an
  // associated segment data).
  if (j === 4)
    line.push([segment[0], segment[1], segment[2], segment[3]]);
  else if (j === 5)
    line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
  else if (j === 1)
    line.push([segment[0]]);
}
function encode$4(decoded) {
  var sourceFileIndex = 0; // second field
  var sourceCodeLine = 0; // third field
  var sourceCodeColumn = 0; // fourth field
  var nameIndex = 0; // fifth field
  var mappings = '';
  for (var i = 0; i < decoded.length; i++) {
    var line = decoded[i];
    if (i > 0)
      mappings += ';';
    if (line.length === 0)
      continue;
    var generatedCodeColumn = 0; // first field
    var lineMappings = [];
    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
      var segment = line_1[_i];
      var segmentMappings = encodeInteger$2(segment[0] - generatedCodeColumn);
      generatedCodeColumn = segment[0];
      if (segment.length > 1) {
        segmentMappings +=
          encodeInteger$2(segment[1] - sourceFileIndex) +
            encodeInteger$2(segment[2] - sourceCodeLine) +
            encodeInteger$2(segment[3] - sourceCodeColumn);
        sourceFileIndex = segment[1];
        sourceCodeLine = segment[2];
        sourceCodeColumn = segment[3];
      }
      if (segment.length === 5) {
        segmentMappings += encodeInteger$2(segment[4] - nameIndex);
        nameIndex = segment[4];
      }
      lineMappings.push(segmentMappings);
    }
    mappings += lineMappings.join(',');
  }
  return mappings;
}
function encodeInteger$2(num) {
  var result = '';
  num = num < 0 ? (-num << 1) | 1 : num << 1;
  do {
    var clamped = num & 31;
    num >>>= 5;
    if (num > 0) {
      clamped |= 32;
    }
    result += chars$2[clamped];
  } while (num > 0);
  return result;
}

var BitSet$2 = function BitSet(arg) {
  this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
};
BitSet$2.prototype.add = function add(n) {
  this.bits[n >> 5] |= 1 << (n & 31);
};
BitSet$2.prototype.has = function has(n) {
  return !!(this.bits[n >> 5] & (1 << (n & 31)));
};
var Chunk$2 = function Chunk(start, end, content) {
  this.start = start;
  this.end = end;
  this.original = content;
  this.intro = '';
  this.outro = '';
  this.content = content;
  this.storeName = false;
  this.edited = false;
  // we make these non-enumerable, for sanity while debugging
  Object.defineProperties(this, {
    previous: { writable: true, value: null },
    next: { writable: true, value: null }
  });
};
Chunk$2.prototype.appendLeft = function appendLeft(content) {
  this.outro += content;
};
Chunk$2.prototype.appendRight = function appendRight(content) {
  this.intro = this.intro + content;
};
Chunk$2.prototype.clone = function clone() {
  var chunk = new Chunk$2(this.start, this.end, this.original);
  chunk.intro = this.intro;
  chunk.outro = this.outro;
  chunk.content = this.content;
  chunk.storeName = this.storeName;
  chunk.edited = this.edited;
  return chunk;
};
Chunk$2.prototype.contains = function contains(index) {
  return this.start < index && index < this.end;
};
Chunk$2.prototype.eachNext = function eachNext(fn) {
  var chunk = this;
  while (chunk) {
    fn(chunk);
    chunk = chunk.next;
  }
};
Chunk$2.prototype.eachPrevious = function eachPrevious(fn) {
  var chunk = this;
  while (chunk) {
    fn(chunk);
    chunk = chunk.previous;
  }
};
Chunk$2.prototype.edit = function edit(content, storeName, contentOnly) {
  this.content = content;
  if (!contentOnly) {
    this.intro = '';
    this.outro = '';
  }
  this.storeName = storeName;
  this.edited = true;
  return this;
};
Chunk$2.prototype.prependLeft = function prependLeft(content) {
  this.outro = content + this.outro;
};
Chunk$2.prototype.prependRight = function prependRight(content) {
  this.intro = content + this.intro;
};
Chunk$2.prototype.split = function split(index) {
  var sliceIndex = index - this.start;
  var originalBefore = this.original.slice(0, sliceIndex);
  var originalAfter = this.original.slice(sliceIndex);
  this.original = originalBefore;
  var newChunk = new Chunk$2(index, this.end, originalAfter);
  newChunk.outro = this.outro;
  this.outro = '';
  this.end = index;
  if (this.edited) {
    // TODO is this block necessary?...
    newChunk.edit('', false);
    this.content = '';
  }
  else {
    this.content = originalBefore;
  }
  newChunk.next = this.next;
  if (newChunk.next) {
    newChunk.next.previous = newChunk;
  }
  newChunk.previous = this;
  this.next = newChunk;
  return newChunk;
};
Chunk$2.prototype.toString = function toString() {
  return this.intro + this.content + this.outro;
};
Chunk$2.prototype.trimEnd = function trimEnd(rx) {
  this.outro = this.outro.replace(rx, '');
  if (this.outro.length) {
    return true;
  }
  var trimmed = this.content.replace(rx, '');
  if (trimmed.length) {
    if (trimmed !== this.content) {
      this.split(this.start + trimmed.length).edit('', undefined, true);
    }
    return true;
  }
  else {
    this.edit('', undefined, true);
    this.intro = this.intro.replace(rx, '');
    if (this.intro.length) {
      return true;
    }
  }
};
Chunk$2.prototype.trimStart = function trimStart(rx) {
  this.intro = this.intro.replace(rx, '');
  if (this.intro.length) {
    return true;
  }
  var trimmed = this.content.replace(rx, '');
  if (trimmed.length) {
    if (trimmed !== this.content) {
      this.split(this.end - trimmed.length);
      this.edit('', undefined, true);
    }
    return true;
  }
  else {
    this.edit('', undefined, true);
    this.outro = this.outro.replace(rx, '');
    if (this.outro.length) {
      return true;
    }
  }
};
var btoa$3 = function () {
  throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
  btoa$3 = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
}
else if (typeof Buffer === 'function') {
  btoa$3 = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
}
var SourceMap$2 = function SourceMap(properties) {
  this.version = 3;
  this.file = properties.file;
  this.sources = properties.sources;
  this.sourcesContent = properties.sourcesContent;
  this.names = properties.names;
  this.mappings = encode$4(properties.mappings);
};
SourceMap$2.prototype.toString = function toString() {
  return JSON.stringify(this);
};
SourceMap$2.prototype.toUrl = function toUrl() {
  return 'data:application/json;charset=utf-8;base64,' + btoa$3(this.toString());
};
function guessIndent$2(code) {
  var lines = code.split('\n');
  var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
  var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  // More lines tabbed than spaced? Assume tabs, and
  // default to tabs in the case of a tie (or nothing
  // to go on)
  if (tabbed.length >= spaced.length) {
    return '\t';
  }
  // Otherwise, we need to guess the multiple
  var min = spaced.reduce(function (previous, current) {
    var numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(' ');
}
function getRelativePath$2(from, to) {
  var fromParts = from.split(/[/\\]/);
  var toParts = to.split(/[/\\]/);
  fromParts.pop(); // get dirname
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    var i = fromParts.length;
    while (i--) {
      fromParts[i] = '..';
    }
  }
  return fromParts.concat(toParts).join('/');
}
var toString$3 = Object.prototype.toString;
function isObject$4(thing) {
  return toString$3.call(thing) === '[object Object]';
}
function getLocator$2(source) {
  var originalLines = source.split('\n');
  var lineOffsets = [];
  for (var i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    var i = 0;
    var j = lineOffsets.length;
    while (i < j) {
      var m = (i + j) >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      }
      else {
        i = m + 1;
      }
    }
    var line = i - 1;
    var column = index - lineOffsets[line];
    return { line: line, column: column };
  };
}
var Mappings$2 = function Mappings(hires) {
  this.hires = hires;
  this.generatedCodeLine = 0;
  this.generatedCodeColumn = 0;
  this.raw = [];
  this.rawSegments = this.raw[this.generatedCodeLine] = [];
  this.pending = null;
};
Mappings$2.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
  if (content.length) {
    var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
    if (nameIndex >= 0) {
      segment.push(nameIndex);
    }
    this.rawSegments.push(segment);
  }
  else if (this.pending) {
    this.rawSegments.push(this.pending);
  }
  this.advance(content);
  this.pending = null;
};
Mappings$2.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
  var originalCharIndex = chunk.start;
  var first = true;
  while (originalCharIndex < chunk.end) {
    if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
      this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
    }
    if (original[originalCharIndex] === '\n') {
      loc.line += 1;
      loc.column = 0;
      this.generatedCodeLine += 1;
      this.raw[this.generatedCodeLine] = this.rawSegments = [];
      this.generatedCodeColumn = 0;
      first = true;
    }
    else {
      loc.column += 1;
      this.generatedCodeColumn += 1;
      first = false;
    }
    originalCharIndex += 1;
  }
  this.pending = sourceIndex > 0
    ? [this.generatedCodeColumn, sourceIndex, loc.line, loc.column]
    : null;
};
Mappings$2.prototype.advance = function advance(str) {
  if (!str) {
    return;
  }
  var lines = str.split('\n');
  if (lines.length > 1) {
    for (var i = 0; i < lines.length - 1; i++) {
      this.generatedCodeLine++;
      this.raw[this.generatedCodeLine] = this.rawSegments = [];
    }
    this.generatedCodeColumn = 0;
  }
  this.generatedCodeColumn += lines[lines.length - 1].length;
};
var n$2 = '\n';
var warned$2 = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString$2 = function MagicString(string, options) {
  if (options === void 0)
    options = {};
  var chunk = new Chunk$2(0, string.length, string);
  Object.defineProperties(this, {
    original: { writable: true, value: string },
    outro: { writable: true, value: '' },
    intro: { writable: true, value: '' },
    firstChunk: { writable: true, value: chunk },
    lastChunk: { writable: true, value: chunk },
    lastSearchedChunk: { writable: true, value: chunk },
    byStart: { writable: true, value: {} },
    byEnd: { writable: true, value: {} },
    filename: { writable: true, value: options.filename },
    indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
    sourcemapLocations: { writable: true, value: new BitSet$2() },
    storedNames: { writable: true, value: {} },
    indentStr: { writable: true, value: guessIndent$2(string) }
  });
  this.byStart[0] = chunk;
  this.byEnd[string.length] = chunk;
};
MagicString$2.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
  this.sourcemapLocations.add(char);
};
MagicString$2.prototype.append = function append(content) {
  if (typeof content !== 'string') {
    throw new TypeError('outro content must be a string');
  }
  this.outro += content;
  return this;
};
MagicString$2.prototype.appendLeft = function appendLeft(index, content) {
  if (typeof content !== 'string') {
    throw new TypeError('inserted content must be a string');
  }
  this._split(index);
  var chunk = this.byEnd[index];
  if (chunk) {
    chunk.appendLeft(content);
  }
  else {
    this.intro += content;
  }
  return this;
};
MagicString$2.prototype.appendRight = function appendRight(index, content) {
  if (typeof content !== 'string') {
    throw new TypeError('inserted content must be a string');
  }
  this._split(index);
  var chunk = this.byStart[index];
  if (chunk) {
    chunk.appendRight(content);
  }
  else {
    this.outro += content;
  }
  return this;
};
MagicString$2.prototype.clone = function clone() {
  var cloned = new MagicString$2(this.original, { filename: this.filename });
  var originalChunk = this.firstChunk;
  var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());
  while (originalChunk) {
    cloned.byStart[clonedChunk.start] = clonedChunk;
    cloned.byEnd[clonedChunk.end] = clonedChunk;
    var nextOriginalChunk = originalChunk.next;
    var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
    if (nextClonedChunk) {
      clonedChunk.next = nextClonedChunk;
      nextClonedChunk.previous = clonedChunk;
      clonedChunk = nextClonedChunk;
    }
    originalChunk = nextOriginalChunk;
  }
  cloned.lastChunk = clonedChunk;
  if (this.indentExclusionRanges) {
    cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
  }
  cloned.sourcemapLocations = new BitSet$2(this.sourcemapLocations);
  cloned.intro = this.intro;
  cloned.outro = this.outro;
  return cloned;
};
MagicString$2.prototype.generateDecodedMap = function generateDecodedMap(options) {
  var this$1 = this;
  options = options || {};
  var sourceIndex = 0;
  var names = Object.keys(this.storedNames);
  var mappings = new Mappings$2(options.hires);
  var locate = getLocator$2(this.original);
  if (this.intro) {
    mappings.advance(this.intro);
  }
  this.firstChunk.eachNext(function (chunk) {
    var loc = locate(chunk.start);
    if (chunk.intro.length) {
      mappings.advance(chunk.intro);
    }
    if (chunk.edited) {
      mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
    }
    else {
      mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
    }
    if (chunk.outro.length) {
      mappings.advance(chunk.outro);
    }
  });
  return {
    file: options.file ? options.file.split(/[/\\]/).pop() : null,
    sources: [options.source ? getRelativePath$2(options.file || '', options.source) : null],
    sourcesContent: options.includeContent ? [this.original] : [null],
    names: names,
    mappings: mappings.raw
  };
};
MagicString$2.prototype.generateMap = function generateMap(options) {
  return new SourceMap$2(this.generateDecodedMap(options));
};
MagicString$2.prototype.getIndentString = function getIndentString() {
  return this.indentStr === null ? '\t' : this.indentStr;
};
MagicString$2.prototype.indent = function indent(indentStr, options) {
  var pattern = /^[^\r\n]/gm;
  if (isObject$4(indentStr)) {
    options = indentStr;
    indentStr = undefined;
  }
  indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';
  if (indentStr === '') {
    return this;
  } // noop
  options = options || {};
  // Process exclusion ranges
  var isExcluded = {};
  if (options.exclude) {
    var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
    exclusions.forEach(function (exclusion) {
      for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
        isExcluded[i] = true;
      }
    });
  }
  var shouldIndentNextCharacter = options.indentStart !== false;
  var replacer = function (match) {
    if (shouldIndentNextCharacter) {
      return ("" + indentStr + match);
    }
    shouldIndentNextCharacter = true;
    return match;
  };
  this.intro = this.intro.replace(pattern, replacer);
  var charIndex = 0;
  var chunk = this.firstChunk;
  while (chunk) {
    var end = chunk.end;
    if (chunk.edited) {
      if (!isExcluded[charIndex]) {
        chunk.content = chunk.content.replace(pattern, replacer);
        if (chunk.content.length) {
          shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
        }
      }
    }
    else {
      charIndex = chunk.start;
      while (charIndex < end) {
        if (!isExcluded[charIndex]) {
          var char = this.original[charIndex];
          if (char === '\n') {
            shouldIndentNextCharacter = true;
          }
          else if (char !== '\r' && shouldIndentNextCharacter) {
            shouldIndentNextCharacter = false;
            if (charIndex === chunk.start) {
              chunk.prependRight(indentStr);
            }
            else {
              this._splitChunk(chunk, charIndex);
              chunk = chunk.next;
              chunk.prependRight(indentStr);
            }
          }
        }
        charIndex += 1;
      }
    }
    charIndex = chunk.end;
    chunk = chunk.next;
  }
  this.outro = this.outro.replace(pattern, replacer);
  return this;
};
MagicString$2.prototype.insert = function insert() {
  throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
};
MagicString$2.prototype.insertLeft = function insertLeft(index, content) {
  if (!warned$2.insertLeft) {
    console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
    warned$2.insertLeft = true;
  }
  return this.appendLeft(index, content);
};
MagicString$2.prototype.insertRight = function insertRight(index, content) {
  if (!warned$2.insertRight) {
    console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
    warned$2.insertRight = true;
  }
  return this.prependRight(index, content);
};
MagicString$2.prototype.move = function move(start, end, index) {
  if (index >= start && index <= end) {
    throw new Error('Cannot move a selection inside itself');
  }
  this._split(start);
  this._split(end);
  this._split(index);
  var first = this.byStart[start];
  var last = this.byEnd[end];
  var oldLeft = first.previous;
  var oldRight = last.next;
  var newRight = this.byStart[index];
  if (!newRight && last === this.lastChunk) {
    return this;
  }
  var newLeft = newRight ? newRight.previous : this.lastChunk;
  if (oldLeft) {
    oldLeft.next = oldRight;
  }
  if (oldRight) {
    oldRight.previous = oldLeft;
  }
  if (newLeft) {
    newLeft.next = first;
  }
  if (newRight) {
    newRight.previous = last;
  }
  if (!first.previous) {
    this.firstChunk = last.next;
  }
  if (!last.next) {
    this.lastChunk = first.previous;
    this.lastChunk.next = null;
  }
  first.previous = newLeft;
  last.next = newRight || null;
  if (!newLeft) {
    this.firstChunk = first;
  }
  if (!newRight) {
    this.lastChunk = last;
  }
  return this;
};
MagicString$2.prototype.overwrite = function overwrite(start, end, content, options) {
  if (typeof content !== 'string') {
    throw new TypeError('replacement content must be a string');
  }
  while (start < 0) {
    start += this.original.length;
  }
  while (end < 0) {
    end += this.original.length;
  }
  if (end > this.original.length) {
    throw new Error('end is out of bounds');
  }
  if (start === end) {
    throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');
  }
  this._split(start);
  this._split(end);
  if (options === true) {
    if (!warned$2.storeName) {
      console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
      warned$2.storeName = true;
    }
    options = { storeName: true };
  }
  var storeName = options !== undefined ? options.storeName : false;
  var contentOnly = options !== undefined ? options.contentOnly : false;
  if (storeName) {
    var original = this.original.slice(start, end);
    this.storedNames[original] = true;
  }
  var first = this.byStart[start];
  var last = this.byEnd[end];
  if (first) {
    if (end > first.end && first.next !== this.byStart[first.end]) {
      throw new Error('Cannot overwrite across a split point');
    }
    first.edit(content, storeName, contentOnly);
    if (first !== last) {
      var chunk = first.next;
      while (chunk !== last) {
        chunk.edit('', false);
        chunk = chunk.next;
      }
      chunk.edit('', false);
    }
  }
  else {
    // must be inserting at the end
    var newChunk = new Chunk$2(start, end, '').edit(content, storeName);
    // TODO last chunk in the array may not be the last chunk, if it's moved...
    last.next = newChunk;
    newChunk.previous = last;
  }
  return this;
};
MagicString$2.prototype.prepend = function prepend(content) {
  if (typeof content !== 'string') {
    throw new TypeError('outro content must be a string');
  }
  this.intro = content + this.intro;
  return this;
};
MagicString$2.prototype.prependLeft = function prependLeft(index, content) {
  if (typeof content !== 'string') {
    throw new TypeError('inserted content must be a string');
  }
  this._split(index);
  var chunk = this.byEnd[index];
  if (chunk) {
    chunk.prependLeft(content);
  }
  else {
    this.intro = content + this.intro;
  }
  return this;
};
MagicString$2.prototype.prependRight = function prependRight(index, content) {
  if (typeof content !== 'string') {
    throw new TypeError('inserted content must be a string');
  }
  this._split(index);
  var chunk = this.byStart[index];
  if (chunk) {
    chunk.prependRight(content);
  }
  else {
    this.outro = content + this.outro;
  }
  return this;
};
MagicString$2.prototype.remove = function remove(start, end) {
  while (start < 0) {
    start += this.original.length;
  }
  while (end < 0) {
    end += this.original.length;
  }
  if (start === end) {
    return this;
  }
  if (start < 0 || end > this.original.length) {
    throw new Error('Character is out of bounds');
  }
  if (start > end) {
    throw new Error('end must be greater than start');
  }
  this._split(start);
  this._split(end);
  var chunk = this.byStart[start];
  while (chunk) {
    chunk.intro = '';
    chunk.outro = '';
    chunk.edit('');
    chunk = end > chunk.end ? this.byStart[chunk.end] : null;
  }
  return this;
};
MagicString$2.prototype.lastChar = function lastChar() {
  if (this.outro.length) {
    return this.outro[this.outro.length - 1];
  }
  var chunk = this.lastChunk;
  do {
    if (chunk.outro.length) {
      return chunk.outro[chunk.outro.length - 1];
    }
    if (chunk.content.length) {
      return chunk.content[chunk.content.length - 1];
    }
    if (chunk.intro.length) {
      return chunk.intro[chunk.intro.length - 1];
    }
  } while (chunk = chunk.previous);
  if (this.intro.length) {
    return this.intro[this.intro.length - 1];
  }
  return '';
};
MagicString$2.prototype.lastLine = function lastLine() {
  var lineIndex = this.outro.lastIndexOf(n$2);
  if (lineIndex !== -1) {
    return this.outro.substr(lineIndex + 1);
  }
  var lineStr = this.outro;
  var chunk = this.lastChunk;
  do {
    if (chunk.outro.length > 0) {
      lineIndex = chunk.outro.lastIndexOf(n$2);
      if (lineIndex !== -1) {
        return chunk.outro.substr(lineIndex + 1) + lineStr;
      }
      lineStr = chunk.outro + lineStr;
    }
    if (chunk.content.length > 0) {
      lineIndex = chunk.content.lastIndexOf(n$2);
      if (lineIndex !== -1) {
        return chunk.content.substr(lineIndex + 1) + lineStr;
      }
      lineStr = chunk.content + lineStr;
    }
    if (chunk.intro.length > 0) {
      lineIndex = chunk.intro.lastIndexOf(n$2);
      if (lineIndex !== -1) {
        return chunk.intro.substr(lineIndex + 1) + lineStr;
      }
      lineStr = chunk.intro + lineStr;
    }
  } while (chunk = chunk.previous);
  lineIndex = this.intro.lastIndexOf(n$2);
  if (lineIndex !== -1) {
    return this.intro.substr(lineIndex + 1) + lineStr;
  }
  return this.intro + lineStr;
};
MagicString$2.prototype.slice = function slice(start, end) {
  if (start === void 0)
    start = 0;
  if (end === void 0)
    end = this.original.length;
  while (start < 0) {
    start += this.original.length;
  }
  while (end < 0) {
    end += this.original.length;
  }
  var result = '';
  // find start chunk
  var chunk = this.firstChunk;
  while (chunk && (chunk.start > start || chunk.end <= start)) {
    // found end chunk before start
    if (chunk.start < end && chunk.end >= end) {
      return result;
    }
    chunk = chunk.next;
  }
  if (chunk && chunk.edited && chunk.start !== start) {
    throw new Error(("Cannot use replaced character " + start + " as slice start anchor."));
  }
  var startChunk = chunk;
  while (chunk) {
    if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
      result += chunk.intro;
    }
    var containsEnd = chunk.start < end && chunk.end >= end;
    if (containsEnd && chunk.edited && chunk.end !== end) {
      throw new Error(("Cannot use replaced character " + end + " as slice end anchor."));
    }
    var sliceStart = startChunk === chunk ? start - chunk.start : 0;
    var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
    result += chunk.content.slice(sliceStart, sliceEnd);
    if (chunk.outro && (!containsEnd || chunk.end === end)) {
      result += chunk.outro;
    }
    if (containsEnd) {
      break;
    }
    chunk = chunk.next;
  }
  return result;
};
// TODO deprecate this? not really very useful
MagicString$2.prototype.snip = function snip(start, end) {
  var clone = this.clone();
  clone.remove(0, start);
  clone.remove(end, clone.original.length);
  return clone;
};
MagicString$2.prototype._split = function _split(index) {
  if (this.byStart[index] || this.byEnd[index]) {
    return;
  }
  var chunk = this.lastSearchedChunk;
  var searchForward = index > chunk.end;
  while (chunk) {
    if (chunk.contains(index)) {
      return this._splitChunk(chunk, index);
    }
    chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
  }
};
MagicString$2.prototype._splitChunk = function _splitChunk(chunk, index) {
  if (chunk.edited && chunk.content.length) {
    // zero-length edited chunks are a special case (overlapping replacements)
    var loc = getLocator$2(this.original)(index);
    throw new Error(("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")"));
  }
  var newChunk = chunk.split(index);
  this.byEnd[index] = chunk;
  this.byStart[index] = newChunk;
  this.byEnd[newChunk.end] = newChunk;
  if (chunk === this.lastChunk) {
    this.lastChunk = newChunk;
  }
  this.lastSearchedChunk = chunk;
  return true;
};
MagicString$2.prototype.toString = function toString() {
  var str = this.intro;
  var chunk = this.firstChunk;
  while (chunk) {
    str += chunk.toString();
    chunk = chunk.next;
  }
  return str + this.outro;
};
MagicString$2.prototype.isEmpty = function isEmpty() {
  var chunk = this.firstChunk;
  do {
    if (chunk.intro.length && chunk.intro.trim() ||
      chunk.content.length && chunk.content.trim() ||
      chunk.outro.length && chunk.outro.trim()) {
      return false;
    }
  } while (chunk = chunk.next);
  return true;
};
MagicString$2.prototype.length = function length() {
  var chunk = this.firstChunk;
  var length = 0;
  do {
    length += chunk.intro.length + chunk.content.length + chunk.outro.length;
  } while (chunk = chunk.next);
  return length;
};
MagicString$2.prototype.trimLines = function trimLines() {
  return this.trim('[\\r\\n]');
};
MagicString$2.prototype.trim = function trim(charType) {
  return this.trimStart(charType).trimEnd(charType);
};
MagicString$2.prototype.trimEndAborted = function trimEndAborted(charType) {
  var rx = new RegExp((charType || '\\s') + '+$');
  this.outro = this.outro.replace(rx, '');
  if (this.outro.length) {
    return true;
  }
  var chunk = this.lastChunk;
  do {
    var end = chunk.end;
    var aborted = chunk.trimEnd(rx);
    // if chunk was trimmed, we have a new lastChunk
    if (chunk.end !== end) {
      if (this.lastChunk === chunk) {
        this.lastChunk = chunk.next;
      }
      this.byEnd[chunk.end] = chunk;
      this.byStart[chunk.next.start] = chunk.next;
      this.byEnd[chunk.next.end] = chunk.next;
    }
    if (aborted) {
      return true;
    }
    chunk = chunk.previous;
  } while (chunk);
  return false;
};
MagicString$2.prototype.trimEnd = function trimEnd(charType) {
  this.trimEndAborted(charType);
  return this;
};
MagicString$2.prototype.trimStartAborted = function trimStartAborted(charType) {
  var rx = new RegExp('^' + (charType || '\\s') + '+');
  this.intro = this.intro.replace(rx, '');
  if (this.intro.length) {
    return true;
  }
  var chunk = this.firstChunk;
  do {
    var end = chunk.end;
    var aborted = chunk.trimStart(rx);
    if (chunk.end !== end) {
      // special case...
      if (chunk === this.lastChunk) {
        this.lastChunk = chunk.next;
      }
      this.byEnd[chunk.end] = chunk;
      this.byStart[chunk.next.start] = chunk.next;
      this.byEnd[chunk.next.end] = chunk.next;
    }
    if (aborted) {
      return true;
    }
    chunk = chunk.next;
  } while (chunk);
  return false;
};
MagicString$2.prototype.trimStart = function trimStart(charType) {
  this.trimStartAborted(charType);
  return this;
};
var hasOwnProp = Object.prototype.hasOwnProperty;
var Bundle = function Bundle(options) {
  if (options === void 0)
    options = {};
  this.intro = options.intro || '';
  this.separator = options.separator !== undefined ? options.separator : '\n';
  this.sources = [];
  this.uniqueSources = [];
  this.uniqueSourceIndexByFilename = {};
};
Bundle.prototype.addSource = function addSource(source) {
  if (source instanceof MagicString$2) {
    return this.addSource({
      content: source,
      filename: source.filename,
      separator: this.separator
    });
  }
  if (!isObject$4(source) || !source.content) {
    throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
  }
  ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
    if (!hasOwnProp.call(source, option)) {
      source[option] = source.content[option];
    }
  });
  if (source.separator === undefined) {
    // TODO there's a bunch of this sort of thing, needs cleaning up
    source.separator = this.separator;
  }
  if (source.filename) {
    if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
      this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
      this.uniqueSources.push({ filename: source.filename, content: source.content.original });
    }
    else {
      var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
      if (source.content.original !== uniqueSource.content) {
        throw new Error(("Illegal source: same filename (" + (source.filename) + "), different contents"));
      }
    }
  }
  this.sources.push(source);
  return this;
};
Bundle.prototype.append = function append(str, options) {
  this.addSource({
    content: new MagicString$2(str),
    separator: (options && options.separator) || ''
  });
  return this;
};
Bundle.prototype.clone = function clone() {
  var bundle = new Bundle({
    intro: this.intro,
    separator: this.separator
  });
  this.sources.forEach(function (source) {
    bundle.addSource({
      filename: source.filename,
      content: source.content.clone(),
      separator: source.separator
    });
  });
  return bundle;
};
Bundle.prototype.generateDecodedMap = function generateDecodedMap(options) {
  var this$1 = this;
  if (options === void 0)
    options = {};
  var names = [];
  this.sources.forEach(function (source) {
    Object.keys(source.content.storedNames).forEach(function (name) {
      if (!~names.indexOf(name)) {
        names.push(name);
      }
    });
  });
  var mappings = new Mappings$2(options.hires);
  if (this.intro) {
    mappings.advance(this.intro);
  }
  this.sources.forEach(function (source, i) {
    if (i > 0) {
      mappings.advance(this$1.separator);
    }
    var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[source.filename] : -1;
    var magicString = source.content;
    var locate = getLocator$2(magicString.original);
    if (magicString.intro) {
      mappings.advance(magicString.intro);
    }
    magicString.firstChunk.eachNext(function (chunk) {
      var loc = locate(chunk.start);
      if (chunk.intro.length) {
        mappings.advance(chunk.intro);
      }
      if (source.filename) {
        if (chunk.edited) {
          mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
        }
        else {
          mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);
        }
      }
      else {
        mappings.advance(chunk.content);
      }
      if (chunk.outro.length) {
        mappings.advance(chunk.outro);
      }
    });
    if (magicString.outro) {
      mappings.advance(magicString.outro);
    }
  });
  return {
    file: options.file ? options.file.split(/[/\\]/).pop() : null,
    sources: this.uniqueSources.map(function (source) {
      return options.file ? getRelativePath$2(options.file, source.filename) : source.filename;
    }),
    sourcesContent: this.uniqueSources.map(function (source) {
      return options.includeContent ? source.content : null;
    }),
    names: names,
    mappings: mappings.raw
  };
};
Bundle.prototype.generateMap = function generateMap(options) {
  return new SourceMap$2(this.generateDecodedMap(options));
};
Bundle.prototype.getIndentString = function getIndentString() {
  var indentStringCounts = {};
  this.sources.forEach(function (source) {
    var indentStr = source.content.indentStr;
    if (indentStr === null) {
      return;
    }
    if (!indentStringCounts[indentStr]) {
      indentStringCounts[indentStr] = 0;
    }
    indentStringCounts[indentStr] += 1;
  });
  return (Object.keys(indentStringCounts).sort(function (a, b) {
    return indentStringCounts[a] - indentStringCounts[b];
  })[0] || '\t');
};
Bundle.prototype.indent = function indent(indentStr) {
  var this$1 = this;
  if (!arguments.length) {
    indentStr = this.getIndentString();
  }
  if (indentStr === '') {
    return this;
  } // noop
  var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';
  this.sources.forEach(function (source, i) {
    var separator = source.separator !== undefined ? source.separator : this$1.separator;
    var indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));
    source.content.indent(indentStr, {
      exclude: source.indentExclusionRanges,
      indentStart: indentStart //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
    });
    trailingNewline = source.content.lastChar() === '\n';
  });
  if (this.intro) {
    this.intro =
      indentStr +
        this.intro.replace(/^[^\n]/gm, function (match, index) {
          return index > 0 ? indentStr + match : match;
        });
  }
  return this;
};
Bundle.prototype.prepend = function prepend(str) {
  this.intro = str + this.intro;
  return this;
};
Bundle.prototype.toString = function toString() {
  var this$1 = this;
  var body = this.sources
    .map(function (source, i) {
    var separator = source.separator !== undefined ? source.separator : this$1.separator;
    var str = (i > 0 ? separator : '') + source.content.toString();
    return str;
  })
    .join('');
  return this.intro + body;
};
Bundle.prototype.isEmpty = function isEmpty() {
  if (this.intro.length && this.intro.trim()) {
    return false;
  }
  if (this.sources.some(function (source) { return !source.content.isEmpty(); })) {
    return false;
  }
  return true;
};
Bundle.prototype.length = function length() {
  return this.sources.reduce(function (length, source) { return length + source.content.length(); }, this.intro.length);
};
Bundle.prototype.trimLines = function trimLines() {
  return this.trim('[\\r\\n]');
};
Bundle.prototype.trim = function trim(charType) {
  return this.trimStart(charType).trimEnd(charType);
};
Bundle.prototype.trimStart = function trimStart(charType) {
  var rx = new RegExp('^' + (charType || '\\s') + '+');
  this.intro = this.intro.replace(rx, '');
  if (!this.intro) {
    var source;
    var i = 0;
    do {
      source = this.sources[i++];
      if (!source) {
        break;
      }
    } while (!source.content.trimStartAborted(charType));
  }
  return this;
};
Bundle.prototype.trimEnd = function trimEnd(charType) {
  var rx = new RegExp((charType || '\\s') + '+$');
  var source;
  var i = this.sources.length - 1;
  do {
    source = this.sources[i--];
    if (!source) {
      this.intro = this.intro.replace(rx, '');
      break;
    }
  } while (!source.content.trimEndAborted(charType));
  return this;
};

var minimalisticAssert$1 = assert$3;
function assert$3(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}
assert$3.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

function createCommonjsModule$2(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var inherits_browser$1 = createCommonjsModule$2(function (module) {
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  }
  else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () { };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
});

var inherits$2 = createCommonjsModule$2(function (module) {
  try {
    var util$1 = util;
    if (typeof util$1.inherits !== 'function')
      throw '';
    module.exports = util$1.inherits;
  }
  catch (e) {
    module.exports = inherits_browser$1;
  }
});

var inherits_1$1 = inherits$2;
function isSurrogatePair$1(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray$1(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        }
        else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        }
        else if (isSurrogatePair$1(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
        else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    }
    else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  }
  else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
var toArray_1$1 = toArray$1;
function toHex$1(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2$1(msg[i].toString(16));
  return res;
}
var toHex_1$1 = toHex$1;
function htonl$1(w) {
  var res = (w >>> 24) |
    ((w >>> 8) & 0xff00) |
    ((w << 8) & 0xff0000) |
    ((w & 0xff) << 24);
  return res >>> 0;
}
var htonl_1$1 = htonl$1;
function toHex32$1(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl$1(w);
    res += zero8$1(w.toString(16));
  }
  return res;
}
var toHex32_1$1 = toHex32$1;
function zero2$1(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
var zero2_1$1 = zero2$1;
function zero8$1(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
var zero8_1$1 = zero8$1;
function join32$1(msg, start, end, endian) {
  var len = end - start;
  minimalisticAssert$1(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
var join32_1$1 = join32$1;
function split32$1(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    }
    else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
var split32_1$1 = split32$1;
function rotr32$2(w, b) {
  return (w >>> b) | (w << (32 - b));
}
var rotr32_1$1 = rotr32$2;
function rotl32$1(w, b) {
  return (w << b) | (w >>> (32 - b));
}
var rotl32_1$1 = rotl32$1;
function sum32$2(a, b) {
  return (a + b) >>> 0;
}
var sum32_1$1 = sum32$2;
function sum32_3$1(a, b, c) {
  return (a + b + c) >>> 0;
}
var sum32_3_1$1 = sum32_3$1;
function sum32_4$2(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
var sum32_4_1$1 = sum32_4$2;
function sum32_5$2(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
var sum32_5_1$1 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
var sum64_1$1 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
var sum64_hi_1$1 = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
var sum64_lo_1$1 = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
var sum64_4_hi_1$1 = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
var sum64_4_lo_1$1 = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
var sum64_5_hi_1$1 = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
var sum64_5_lo_1$1 = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
var rotr64_hi_1$1 = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
var rotr64_lo_1$1 = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
var shr64_hi_1$1 = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
var shr64_lo_1$1 = shr64_lo$1;
var utils$3 = {
  inherits: inherits_1$1,
  toArray: toArray_1$1,
  toHex: toHex_1$1,
  htonl: htonl_1$1,
  toHex32: toHex32_1$1,
  zero2: zero2_1$1,
  zero8: zero8_1$1,
  join32: join32_1$1,
  split32: split32_1$1,
  rotr32: rotr32_1$1,
  rotl32: rotl32_1$1,
  sum32: sum32_1$1,
  sum32_3: sum32_3_1$1,
  sum32_4: sum32_4_1$1,
  sum32_5: sum32_5_1$1,
  sum64: sum64_1$1,
  sum64_hi: sum64_hi_1$1,
  sum64_lo: sum64_lo_1$1,
  sum64_4_hi: sum64_4_hi_1$1,
  sum64_4_lo: sum64_4_lo_1$1,
  sum64_5_hi: sum64_5_hi_1$1,
  sum64_5_lo: sum64_5_lo_1$1,
  rotr64_hi: rotr64_hi_1$1,
  rotr64_lo: rotr64_lo_1$1,
  shr64_hi: shr64_hi_1$1,
  shr64_lo: shr64_lo_1$1
};

function BlockHash$2() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
var BlockHash_1$1 = BlockHash$2;
BlockHash$2.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils$3.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$3.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }
  return this;
};
BlockHash$2.prototype.digest = function digest(enc) {
  this.update(this._pad());
  minimalisticAssert$1(this.pending === null);
  return this._digest(enc);
};
BlockHash$2.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;
  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  }
  else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }
  return res;
};
var common$2 = {
  BlockHash: BlockHash_1$1
};

var rotr32$1$1 = utils$3.rotr32;
function ft_1$1(s, x, y, z) {
  if (s === 0)
    return ch32$2(x, y, z);
  if (s === 1 || s === 3)
    return p32$1(x, y, z);
  if (s === 2)
    return maj32$2(x, y, z);
}
var ft_1_1$1 = ft_1$1;
function ch32$2(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
var ch32_1$1 = ch32$2;
function maj32$2(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
var maj32_1$1 = maj32$2;
function p32$1(x, y, z) {
  return x ^ y ^ z;
}
var p32_1$1 = p32$1;
function s0_256$2(x) {
  return rotr32$1$1(x, 2) ^ rotr32$1$1(x, 13) ^ rotr32$1$1(x, 22);
}
var s0_256_1$1 = s0_256$2;
function s1_256$2(x) {
  return rotr32$1$1(x, 6) ^ rotr32$1$1(x, 11) ^ rotr32$1$1(x, 25);
}
var s1_256_1$1 = s1_256$2;
function g0_256$2(x) {
  return rotr32$1$1(x, 7) ^ rotr32$1$1(x, 18) ^ (x >>> 3);
}
var g0_256_1$1 = g0_256$2;
function g1_256$2(x) {
  return rotr32$1$1(x, 17) ^ rotr32$1$1(x, 19) ^ (x >>> 10);
}
var g1_256_1$1 = g1_256$2;
var common$1$1 = {
  ft_1: ft_1_1$1,
  ch32: ch32_1$1,
  maj32: maj32_1$1,
  p32: p32_1$1,
  s0_256: s0_256_1$1,
  s1_256: s1_256_1$1,
  g0_256: g0_256_1$1,
  g1_256: g1_256_1$1
};

var sum32$1$1 = utils$3.sum32;
var sum32_4$1$1 = utils$3.sum32_4;
var sum32_5$1$1 = utils$3.sum32_5;
var ch32$1$1 = common$1$1.ch32;
var maj32$1$1 = common$1$1.maj32;
var s0_256$1$1 = common$1$1.s0_256;
var s1_256$1$1 = common$1$1.s1_256;
var g0_256$1$1 = common$1$1.g0_256;
var g1_256$1$1 = common$1$1.g1_256;
var BlockHash$1$1 = common$2.BlockHash;
var sha256_K$1 = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$1$1.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K$1;
  this.W = new Array(64);
}
utils$3.inherits(SHA256$1, BlockHash$1$1);
var _256$1 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update(msg, start) {
  var W = this.W;
  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4$1$1(g1_256$1$1(W[i - 2]), W[i - 7], g0_256$1$1(W[i - 15]), W[i - 16]);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];
  minimalisticAssert$1(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5$1$1(h, s1_256$1$1(e), ch32$1$1(e, f, g), this.k[i], W[i]);
    var T2 = sum32$1$1(s0_256$1$1(a), maj32$1$1(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32$1$1(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32$1$1(T1, T2);
  }
  this.h[0] = sum32$1$1(this.h[0], a);
  this.h[1] = sum32$1$1(this.h[1], b);
  this.h[2] = sum32$1$1(this.h[2], c);
  this.h[3] = sum32$1$1(this.h[3], d);
  this.h[4] = sum32$1$1(this.h[4], e);
  this.h[5] = sum32$1$1(this.h[5], f);
  this.h[6] = sum32$1$1(this.h[6], g);
  this.h[7] = sum32$1$1(this.h[7], h);
};
SHA256$1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$3.toHex32(this.h, 'big');
  else
    return utils$3.split32(this.h, 'big');
};

const createHash$1 = () => _256$1();

function relative$1(from, to) {
  const fromParts = from.split(/[/\\]/).filter(Boolean);
  const toParts = to.split(/[/\\]/).filter(Boolean);
  if (fromParts[0] === '.')
    fromParts.shift();
  if (toParts[0] === '.')
    toParts.shift();
  while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  while (toParts[0] === '..' && fromParts.length > 0) {
    toParts.shift();
    fromParts.pop();
  }
  while (fromParts.pop()) {
    toParts.unshift('..');
  }
  return toParts.join('/');
}

const UnknownKey = Symbol('Unknown Key');
const EMPTY_PATH = [];
const UNKNOWN_PATH = [UnknownKey];
const EntitiesKey = Symbol('Entities');
class PathTracker {
  constructor() {
    this.entityPaths = Object.create(null, { [EntitiesKey]: { value: new Set() } });
  }
  getEntities(path) {
    let currentPaths = this.entityPaths;
    for (const pathSegment of path) {
      currentPaths = currentPaths[pathSegment] =
        currentPaths[pathSegment] ||
          Object.create(null, { [EntitiesKey]: { value: new Set() } });
    }
    return currentPaths[EntitiesKey];
  }
}
const SHARED_RECURSION_TRACKER = new PathTracker();

const BROKEN_FLOW_NONE = 0;
const BROKEN_FLOW_BREAK_CONTINUE = 1;
const BROKEN_FLOW_ERROR_RETURN_LABEL = 2;
function createInclusionContext() {
  return {
    brokenFlow: BROKEN_FLOW_NONE,
    includedLabels: new Set()
  };
}
function createHasEffectsContext() {
  return {
    accessed: new PathTracker(),
    assigned: new PathTracker(),
    brokenFlow: BROKEN_FLOW_NONE,
    called: new PathTracker(),
    ignore: {
      breaks: false,
      continues: false,
      labels: new Set(),
      returnAwaitYield: false
    },
    includedLabels: new Set(),
    instantiated: new PathTracker(),
    replacedVariableInits: new Map()
  };
}

const BlockStatement = 'BlockStatement';
const CallExpression = 'CallExpression';
const ExportNamespaceSpecifier = 'ExportNamespaceSpecifier';
const ExpressionStatement = 'ExpressionStatement';
const FunctionExpression = 'FunctionExpression';
const Identifier = 'Identifier';
const ImportDefaultSpecifier = 'ImportDefaultSpecifier';
const ImportNamespaceSpecifier = 'ImportNamespaceSpecifier';
const Program = 'Program';
const Property = 'Property';
const ReturnStatement = 'ReturnStatement';

function treeshakeNode(node, code, start, end) {
  code.remove(start, end);
  if (node.annotations) {
    for (const annotation of node.annotations) {
      if (annotation.start < start) {
        code.remove(annotation.start, annotation.end);
      }
      else {
        return;
      }
    }
  }
}
function removeAnnotations(node, code) {
  if (!node.annotations && node.parent.type === ExpressionStatement) {
    node = node.parent;
  }
  if (node.annotations) {
    for (const annotation of node.annotations) {
      code.remove(annotation.start, annotation.end);
    }
  }
}

const NO_SEMICOLON = { isNoStatement: true };
// This assumes there are only white-space and comments between start and the string we are looking for
function findFirstOccurrenceOutsideComment(code, searchString, start = 0) {
  let searchPos, charCodeAfterSlash;
  searchPos = code.indexOf(searchString, start);
  while (true) {
    start = code.indexOf('/', start);
    if (start === -1 || start >= searchPos)
      return searchPos;
    charCodeAfterSlash = code.charCodeAt(++start);
    ++start;
    // With our assumption, '/' always starts a comment. Determine comment type:
    start =
      charCodeAfterSlash === 47 /*"/"*/
        ? code.indexOf('\n', start) + 1
        : code.indexOf('*/', start) + 2;
    if (start > searchPos) {
      searchPos = code.indexOf(searchString, start);
    }
  }
}
// This assumes "code" only contains white-space and comments
function findFirstLineBreakOutsideComment(code) {
  let lineBreakPos, charCodeAfterSlash, start = 0;
  lineBreakPos = code.indexOf('\n', start);
  while (true) {
    start = code.indexOf('/', start);
    if (start === -1 || start > lineBreakPos)
      return lineBreakPos;
    // With our assumption, '/' always starts a comment. Determine comment type:
    charCodeAfterSlash = code.charCodeAt(++start);
    if (charCodeAfterSlash === 47 /*"/"*/)
      return lineBreakPos;
    start = code.indexOf('*/', start + 2) + 2;
    if (start > lineBreakPos) {
      lineBreakPos = code.indexOf('\n', start);
    }
  }
}
function renderStatementList(statements, code, start, end, options) {
  let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
  let nextNode = statements[0];
  let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
  if (nextNodeNeedsBoundaries) {
    nextNodeStart =
      start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start)) + 1;
  }
  for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {
    currentNode = nextNode;
    currentNodeStart = nextNodeStart;
    currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
    nextNode = statements[nextIndex];
    nextNodeNeedsBoundaries =
      nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;
    if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
      nextNodeStart =
        currentNode.end +
          findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start)) +
          1;
      if (currentNode.included) {
        currentNodeNeedsBoundaries
          ? currentNode.render(code, options, {
            end: nextNodeStart,
            start: currentNodeStart
          })
          : currentNode.render(code, options);
      }
      else {
        treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
      }
    }
    else {
      currentNode.render(code, options);
    }
  }
}
// This assumes that the first character is not part of the first node
function getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {
  const splitUpNodes = [];
  let node, nextNode, nextNodeStart, contentEnd, char;
  let separator = start - 1;
  for (let nextIndex = 0; nextIndex < nodes.length; nextIndex++) {
    nextNode = nodes[nextIndex];
    if (node !== undefined) {
      separator =
        node.end +
          findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');
    }
    nextNodeStart = contentEnd =
      separator +
        2 +
        findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start));
    while (((char = code.original.charCodeAt(nextNodeStart)),
      char === 32 /*" "*/ || char === 9 /*"\t"*/ || char === 10 /*"\n"*/ || char === 13) /*"\r"*/)
      nextNodeStart++;
    if (node !== undefined) {
      splitUpNodes.push({
        contentEnd,
        end: nextNodeStart,
        node,
        separator,
        start
      });
    }
    node = nextNode;
    start = nextNodeStart;
  }
  splitUpNodes.push({
    contentEnd: end,
    end,
    node: node,
    separator: null,
    start
  });
  return splitUpNodes;
}
// This assumes there are only white-space and comments between start and end
function removeLineBreaks(code, start, end) {
  while (true) {
    const lineBreakPos = findFirstLineBreakOutsideComment(code.original.slice(start, end));
    if (lineBreakPos === -1) {
      break;
    }
    start = start + lineBreakPos + 1;
    code.remove(start - 1, start);
  }
}

const chars$1$1 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
const base = 64;
function toBase64(num) {
  let outStr = '';
  do {
    const curDigit = num % base;
    num = Math.floor(num / base);
    outStr = chars$1$1[curDigit] + outStr;
  } while (num !== 0);
  return outStr;
}

// Verified on IE 6/7 that these keywords can't be used for object properties without escaping:
//   break case catch class const continue debugger default delete do
//   else enum export extends false finally for function if import
//   in instanceof new null return super switch this throw true
//   try typeof var void while with
const RESERVED_NAMES = Object.assign(Object.create(null), {
  await: true,
  break: true,
  case: true,
  catch: true,
  class: true,
  const: true,
  continue: true,
  debugger: true,
  default: true,
  delete: true,
  do: true,
  else: true,
  enum: true,
  eval: true,
  export: true,
  extends: true,
  false: true,
  finally: true,
  for: true,
  function: true,
  if: true,
  implements: true,
  import: true,
  in: true,
  instanceof: true,
  interface: true,
  let: true,
  new: true,
  null: true,
  package: true,
  private: true,
  protected: true,
  public: true,
  return: true,
  static: true,
  super: true,
  switch: true,
  this: true,
  throw: true,
  true: true,
  try: true,
  typeof: true,
  undefined: true,
  var: true,
  void: true,
  while: true,
  with: true,
  yield: true
});

function getSafeName(baseName, usedNames) {
  let safeName = baseName;
  let count = 1;
  while (usedNames.has(safeName) || RESERVED_NAMES[safeName]) {
    safeName = `${baseName}$${toBase64(count++)}`;
  }
  usedNames.add(safeName);
  return safeName;
}

const NO_ARGS = [];

function assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {
  return Object.create(inheritedDescriptions, memberDescriptions);
}
const UnknownValue = Symbol('Unknown Value');
const UNKNOWN_EXPRESSION = {
  deoptimizePath: () => { },
  getLiteralValueAtPath: () => UnknownValue,
  getReturnExpressionWhenCalledAtPath: () => UNKNOWN_EXPRESSION,
  hasEffectsWhenAccessedAtPath: path => path.length > 0,
  hasEffectsWhenAssignedAtPath: path => path.length > 0,
  hasEffectsWhenCalledAtPath: () => true,
  include: () => { },
  includeCallArguments(context, args) {
    for (const arg of args) {
      arg.include(context, false);
    }
  },
  included: true,
  toString: () => '[[UNKNOWN]]'
};
const UNDEFINED_EXPRESSION = {
  deoptimizePath: () => { },
  getLiteralValueAtPath: () => undefined,
  getReturnExpressionWhenCalledAtPath: () => UNKNOWN_EXPRESSION,
  hasEffectsWhenAccessedAtPath: path => path.length > 0,
  hasEffectsWhenAssignedAtPath: path => path.length > 0,
  hasEffectsWhenCalledAtPath: () => true,
  include: () => { },
  includeCallArguments() { },
  included: true,
  toString: () => 'undefined'
};
const returnsUnknown = {
  value: {
    callsArgs: null,
    mutatesSelf: false,
    returns: null,
    returnsPrimitive: UNKNOWN_EXPRESSION
  }
};
const mutatesSelfReturnsUnknown = {
  value: { returns: null, returnsPrimitive: UNKNOWN_EXPRESSION, callsArgs: null, mutatesSelf: true }
};
const callsArgReturnsUnknown = {
  value: { returns: null, returnsPrimitive: UNKNOWN_EXPRESSION, callsArgs: [0], mutatesSelf: false }
};
class UnknownArrayExpression {
  constructor() {
    this.included = false;
  }
  deoptimizePath() { }
  getLiteralValueAtPath() {
    return UnknownValue;
  }
  getReturnExpressionWhenCalledAtPath(path) {
    if (path.length === 1) {
      return getMemberReturnExpressionWhenCalled(arrayMembers, path[0]);
    }
    return UNKNOWN_EXPRESSION;
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenAssignedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (path.length === 1) {
      return hasMemberEffectWhenCalled(arrayMembers, path[0], this.included, callOptions, context);
    }
    return true;
  }
  include() {
    this.included = true;
  }
  includeCallArguments(context, args) {
    for (const arg of args) {
      arg.include(context, false);
    }
  }
  toString() {
    return '[[UNKNOWN ARRAY]]';
  }
}
const returnsArray = {
  value: {
    callsArgs: null,
    mutatesSelf: false,
    returns: UnknownArrayExpression,
    returnsPrimitive: null
  }
};
const mutatesSelfReturnsArray = {
  value: {
    callsArgs: null,
    mutatesSelf: true,
    returns: UnknownArrayExpression,
    returnsPrimitive: null
  }
};
const callsArgReturnsArray = {
  value: {
    callsArgs: [0],
    mutatesSelf: false,
    returns: UnknownArrayExpression,
    returnsPrimitive: null
  }
};
const callsArgMutatesSelfReturnsArray = {
  value: {
    callsArgs: [0],
    mutatesSelf: true,
    returns: UnknownArrayExpression,
    returnsPrimitive: null
  }
};
const UNKNOWN_LITERAL_BOOLEAN = {
  deoptimizePath: () => { },
  getLiteralValueAtPath: () => UnknownValue,
  getReturnExpressionWhenCalledAtPath: path => {
    if (path.length === 1) {
      return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path[0]);
    }
    return UNKNOWN_EXPRESSION;
  },
  hasEffectsWhenAccessedAtPath: path => path.length > 1,
  hasEffectsWhenAssignedAtPath: path => path.length > 0,
  hasEffectsWhenCalledAtPath: path => {
    if (path.length === 1) {
      const subPath = path[0];
      return typeof subPath !== 'string' || !literalBooleanMembers[subPath];
    }
    return true;
  },
  include: () => { },
  includeCallArguments(context, args) {
    for (const arg of args) {
      arg.include(context, false);
    }
  },
  included: true,
  toString: () => '[[UNKNOWN BOOLEAN]]'
};
const returnsBoolean = {
  value: {
    callsArgs: null,
    mutatesSelf: false,
    returns: null,
    returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
  }
};
const callsArgReturnsBoolean = {
  value: {
    callsArgs: [0],
    mutatesSelf: false,
    returns: null,
    returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
  }
};
const UNKNOWN_LITERAL_NUMBER = {
  deoptimizePath: () => { },
  getLiteralValueAtPath: () => UnknownValue,
  getReturnExpressionWhenCalledAtPath: path => {
    if (path.length === 1) {
      return getMemberReturnExpressionWhenCalled(literalNumberMembers, path[0]);
    }
    return UNKNOWN_EXPRESSION;
  },
  hasEffectsWhenAccessedAtPath: path => path.length > 1,
  hasEffectsWhenAssignedAtPath: path => path.length > 0,
  hasEffectsWhenCalledAtPath: path => {
    if (path.length === 1) {
      const subPath = path[0];
      return typeof subPath !== 'string' || !literalNumberMembers[subPath];
    }
    return true;
  },
  include: () => { },
  includeCallArguments(context, args) {
    for (const arg of args) {
      arg.include(context, false);
    }
  },
  included: true,
  toString: () => '[[UNKNOWN NUMBER]]'
};
const returnsNumber = {
  value: {
    callsArgs: null,
    mutatesSelf: false,
    returns: null,
    returnsPrimitive: UNKNOWN_LITERAL_NUMBER
  }
};
const mutatesSelfReturnsNumber = {
  value: {
    callsArgs: null,
    mutatesSelf: true,
    returns: null,
    returnsPrimitive: UNKNOWN_LITERAL_NUMBER
  }
};
const callsArgReturnsNumber = {
  value: {
    callsArgs: [0],
    mutatesSelf: false,
    returns: null,
    returnsPrimitive: UNKNOWN_LITERAL_NUMBER
  }
};
const UNKNOWN_LITERAL_STRING = {
  deoptimizePath: () => { },
  getLiteralValueAtPath: () => UnknownValue,
  getReturnExpressionWhenCalledAtPath: path => {
    if (path.length === 1) {
      return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
    }
    return UNKNOWN_EXPRESSION;
  },
  hasEffectsWhenAccessedAtPath: path => path.length > 1,
  hasEffectsWhenAssignedAtPath: path => path.length > 0,
  hasEffectsWhenCalledAtPath: (path, callOptions, context) => {
    if (path.length === 1) {
      return hasMemberEffectWhenCalled(literalStringMembers, path[0], true, callOptions, context);
    }
    return true;
  },
  include: () => { },
  includeCallArguments(context, args) {
    for (const arg of args) {
      arg.include(context, false);
    }
  },
  included: true,
  toString: () => '[[UNKNOWN STRING]]'
};
const returnsString = {
  value: {
    callsArgs: null,
    mutatesSelf: false,
    returns: null,
    returnsPrimitive: UNKNOWN_LITERAL_STRING
  }
};
class UnknownObjectExpression {
  constructor() {
    this.included = false;
  }
  deoptimizePath() { }
  getLiteralValueAtPath() {
    return UnknownValue;
  }
  getReturnExpressionWhenCalledAtPath(path) {
    if (path.length === 1) {
      return getMemberReturnExpressionWhenCalled(objectMembers, path[0]);
    }
    return UNKNOWN_EXPRESSION;
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenAssignedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (path.length === 1) {
      return hasMemberEffectWhenCalled(objectMembers, path[0], this.included, callOptions, context);
    }
    return true;
  }
  include() {
    this.included = true;
  }
  includeCallArguments(context, args) {
    for (const arg of args) {
      arg.include(context, false);
    }
  }
  toString() {
    return '[[UNKNOWN OBJECT]]';
  }
}
const objectMembers = assembleMemberDescriptions({
  hasOwnProperty: returnsBoolean,
  isPrototypeOf: returnsBoolean,
  propertyIsEnumerable: returnsBoolean,
  toLocaleString: returnsString,
  toString: returnsString,
  valueOf: returnsUnknown
});
const arrayMembers = assembleMemberDescriptions({
  concat: returnsArray,
  copyWithin: mutatesSelfReturnsArray,
  every: callsArgReturnsBoolean,
  fill: mutatesSelfReturnsArray,
  filter: callsArgReturnsArray,
  find: callsArgReturnsUnknown,
  findIndex: callsArgReturnsNumber,
  forEach: callsArgReturnsUnknown,
  includes: returnsBoolean,
  indexOf: returnsNumber,
  join: returnsString,
  lastIndexOf: returnsNumber,
  map: callsArgReturnsArray,
  pop: mutatesSelfReturnsUnknown,
  push: mutatesSelfReturnsNumber,
  reduce: callsArgReturnsUnknown,
  reduceRight: callsArgReturnsUnknown,
  reverse: mutatesSelfReturnsArray,
  shift: mutatesSelfReturnsUnknown,
  slice: returnsArray,
  some: callsArgReturnsBoolean,
  sort: callsArgMutatesSelfReturnsArray,
  splice: mutatesSelfReturnsArray,
  unshift: mutatesSelfReturnsNumber
}, objectMembers);
const literalBooleanMembers = assembleMemberDescriptions({
  valueOf: returnsBoolean
}, objectMembers);
const literalNumberMembers = assembleMemberDescriptions({
  toExponential: returnsString,
  toFixed: returnsString,
  toLocaleString: returnsString,
  toPrecision: returnsString,
  valueOf: returnsNumber
}, objectMembers);
const literalStringMembers = assembleMemberDescriptions({
  charAt: returnsString,
  charCodeAt: returnsNumber,
  codePointAt: returnsNumber,
  concat: returnsString,
  endsWith: returnsBoolean,
  includes: returnsBoolean,
  indexOf: returnsNumber,
  lastIndexOf: returnsNumber,
  localeCompare: returnsNumber,
  match: returnsBoolean,
  normalize: returnsString,
  padEnd: returnsString,
  padStart: returnsString,
  repeat: returnsString,
  replace: {
    value: {
      callsArgs: [1],
      mutatesSelf: false,
      returns: null,
      returnsPrimitive: UNKNOWN_LITERAL_STRING
    }
  },
  search: returnsNumber,
  slice: returnsString,
  split: returnsArray,
  startsWith: returnsBoolean,
  substr: returnsString,
  substring: returnsString,
  toLocaleLowerCase: returnsString,
  toLocaleUpperCase: returnsString,
  toLowerCase: returnsString,
  toUpperCase: returnsString,
  trim: returnsString,
  valueOf: returnsString
}, objectMembers);
function getLiteralMembersForValue(value) {
  switch (typeof value) {
    case 'boolean':
      return literalBooleanMembers;
    case 'number':
      return literalNumberMembers;
    case 'string':
      return literalStringMembers;
    default:
      return Object.create(null);
  }
}
function hasMemberEffectWhenCalled(members, memberName, parentIncluded, callOptions, context) {
  if (typeof memberName !== 'string' ||
    !members[memberName] ||
    (members[memberName].mutatesSelf && parentIncluded))
    return true;
  if (!members[memberName].callsArgs)
    return false;
  for (const argIndex of members[memberName].callsArgs) {
    if (callOptions.args[argIndex] &&
      callOptions.args[argIndex].hasEffectsWhenCalledAtPath(EMPTY_PATH, {
        args: NO_ARGS,
        withNew: false
      }, context))
      return true;
  }
  return false;
}
function getMemberReturnExpressionWhenCalled(members, memberName) {
  if (typeof memberName !== 'string' || !members[memberName])
    return UNKNOWN_EXPRESSION;
  return members[memberName].returnsPrimitive !== null
    ? members[memberName].returnsPrimitive
    : new members[memberName].returns();
}

class Variable {
  constructor(name) {
    this.alwaysRendered = false;
    this.exportName = null;
    this.included = false;
    this.isId = false;
    this.isReassigned = false;
    this.renderBaseName = null;
    this.renderName = null;
    this.safeExportName = null;
    this.name = name;
  }
  /**
   * Binds identifiers that reference this variable to this variable.
   * Necessary to be able to change variable names.
   */
  addReference(_identifier) { }
  deoptimizePath(_path) { }
  getBaseVariableName() {
    return this.renderBaseName || this.renderName || this.name;
  }
  getLiteralValueAtPath(_path, _recursionTracker, _origin) {
    return UnknownValue;
  }
  getName() {
    const name = this.renderName || this.name;
    return this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name)}` : name;
  }
  getReturnExpressionWhenCalledAtPath(_path, _recursionTracker, _origin) {
    return UNKNOWN_EXPRESSION;
  }
  hasEffectsWhenAccessedAtPath(path, _context) {
    return path.length > 0;
  }
  hasEffectsWhenAssignedAtPath(_path, _context) {
    return true;
  }
  hasEffectsWhenCalledAtPath(_path, _callOptions, _context) {
    return true;
  }
  /**
   * Marks this variable as being part of the bundle, which is usually the case when one of
   * its identifiers becomes part of the bundle. Returns true if it has not been included
   * previously.
   * Once a variable is included, it should take care all its declarations are included.
   */
  include(_context) {
    this.included = true;
  }
  includeCallArguments(context, args) {
    for (const arg of args) {
      arg.include(context, false);
    }
  }
  markCalledFromTryStatement() { }
  setRenderNames(baseName, name) {
    this.renderBaseName = baseName;
    this.renderName = name;
  }
  setSafeName(name) {
    this.renderName = name;
  }
  toString() {
    return this.name;
  }
}
const getPropertyAccess = (name) => {
  return /^(?!\d)[\w$]+$/.test(name) ? `.${name}` : `[${JSON.stringify(name)}]`;
};

class ExternalVariable extends Variable {
  constructor(module, name) {
    super(name);
    this.module = module;
    this.isNamespace = name === '*';
    this.referenced = false;
  }
  addReference(identifier) {
    this.referenced = true;
    if (this.name === 'default' || this.name === '*') {
      this.module.suggestName(identifier.name);
    }
  }
  include() {
    if (!this.included) {
      this.included = true;
      this.module.used = true;
    }
  }
}

const reservedWords$2 = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'.split(' ');
const builtins$2 = 'Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'.split(' ');
const blacklisted = new Set(reservedWords$2.concat(builtins$2));
const illegalCharacters = /[^$_a-zA-Z0-9]/g;
const startsWithDigit = (str) => /\d/.test(str[0]);
function isLegal(str) {
  if (startsWithDigit(str) || blacklisted.has(str)) {
    return false;
  }
  return !illegalCharacters.test(str);
}
function makeLegal(str) {
  str = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(illegalCharacters, '_');
  if (startsWithDigit(str) || blacklisted.has(str))
    str = `_${str}`;
  return str || '_';
}

const absolutePath = /^(?:\/|(?:[A-Za-z]:)?[\\|/])/;
const relativePath = /^\.?\.\//;
function isAbsolute$1(path) {
  return absolutePath.test(path);
}
function isRelative(path) {
  return relativePath.test(path);
}
function normalize$1(path) {
  if (path.indexOf('\\') == -1)
    return path;
  return path.replace(/\\/g, '/');
}

class ExternalModule {
  constructor(graph, id, moduleSideEffects) {
    this.exportsNames = false;
    this.exportsNamespace = false;
    this.mostCommonSuggestion = 0;
    this.reexported = false;
    this.renderPath = undefined;
    this.renormalizeRenderPath = false;
    this.used = false;
    this.graph = graph;
    this.id = id;
    this.execIndex = Infinity;
    this.moduleSideEffects = moduleSideEffects;
    const parts = id.split(/[\\/]/);
    this.variableName = makeLegal(parts.pop());
    this.nameSuggestions = Object.create(null);
    this.declarations = Object.create(null);
    this.exportedVariables = new Map();
  }
  getVariableForExportName(name) {
    if (name === '*') {
      this.exportsNamespace = true;
    }
    else if (name !== 'default') {
      this.exportsNames = true;
    }
    let declaration = this.declarations[name];
    if (declaration)
      return declaration;
    this.declarations[name] = declaration = new ExternalVariable(this, name);
    this.exportedVariables.set(declaration, name);
    return declaration;
  }
  setRenderPath(options, inputBase) {
    this.renderPath = '';
    if (options.paths) {
      this.renderPath =
        typeof options.paths === 'function' ? options.paths(this.id) : options.paths[this.id];
    }
    if (!this.renderPath) {
      if (!isAbsolute$1(this.id)) {
        this.renderPath = this.id;
      }
      else {
        this.renderPath = normalize$1(relative(inputBase, this.id));
        this.renormalizeRenderPath = true;
      }
    }
    return this.renderPath;
  }
  suggestName(name) {
    if (!this.nameSuggestions[name])
      this.nameSuggestions[name] = 0;
    this.nameSuggestions[name] += 1;
    if (this.nameSuggestions[name] > this.mostCommonSuggestion) {
      this.mostCommonSuggestion = this.nameSuggestions[name];
      this.variableName = name;
    }
  }
  warnUnusedImports() {
    const unused = Object.keys(this.declarations).filter(name => {
      if (name === '*')
        return false;
      const declaration = this.declarations[name];
      return !declaration.included && !this.reexported && !declaration.referenced;
    });
    if (unused.length === 0)
      return;
    const names = unused.length === 1
      ? `'${unused[0]}' is`
      : `${unused
        .slice(0, -1)
        .map(name => `'${name}'`)
        .join(', ')} and '${unused.slice(-1)}' are`;
    this.graph.warn({
      code: 'UNUSED_EXTERNAL_IMPORT',
      message: `${names} imported from external module '${this.id}' but never used`,
      names: unused,
      source: this.id
    });
  }
}

function markModuleAndImpureDependenciesAsExecuted(baseModule) {
  baseModule.isExecuted = true;
  const modules = [baseModule];
  const visitedModules = new Set();
  for (const module of modules) {
    for (const dependency of module.dependencies) {
      if (!(dependency instanceof ExternalModule) &&
        !dependency.isExecuted &&
        dependency.moduleSideEffects &&
        !visitedModules.has(dependency.id)) {
        dependency.isExecuted = true;
        visitedModules.add(dependency.id);
        modules.push(dependency);
      }
    }
  }
}

// To avoid infinite recursions
const MAX_PATH_DEPTH = 7;
class LocalVariable extends Variable {
  constructor(name, declarator, init, context) {
    super(name);
    this.additionalInitializers = null;
    this.calledFromTryStatement = false;
    this.expressionsToBeDeoptimized = [];
    this.declarations = declarator ? [declarator] : [];
    this.init = init;
    this.deoptimizationTracker = context.deoptimizationTracker;
    this.module = context.module;
  }
  addDeclaration(identifier, init) {
    this.declarations.push(identifier);
    if (this.additionalInitializers === null) {
      this.additionalInitializers = this.init === null ? [] : [this.init];
      this.init = UNKNOWN_EXPRESSION;
      this.isReassigned = true;
    }
    if (init !== null) {
      this.additionalInitializers.push(init);
    }
  }
  consolidateInitializers() {
    if (this.additionalInitializers !== null) {
      for (const initializer of this.additionalInitializers) {
        initializer.deoptimizePath(UNKNOWN_PATH);
      }
      this.additionalInitializers = null;
    }
  }
  deoptimizePath(path) {
    if (path.length > MAX_PATH_DEPTH || this.isReassigned)
      return;
    const trackedEntities = this.deoptimizationTracker.getEntities(path);
    if (trackedEntities.has(this))
      return;
    trackedEntities.add(this);
    if (path.length === 0) {
      if (!this.isReassigned) {
        this.isReassigned = true;
        const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
        this.expressionsToBeDeoptimized = [];
        for (const expression of expressionsToBeDeoptimized) {
          expression.deoptimizeCache();
        }
        if (this.init) {
          this.init.deoptimizePath(UNKNOWN_PATH);
        }
      }
    }
    else if (this.init) {
      this.init.deoptimizePath(path);
    }
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    if (this.isReassigned || !this.init || path.length > MAX_PATH_DEPTH) {
      return UnknownValue;
    }
    const trackedEntities = recursionTracker.getEntities(path);
    if (trackedEntities.has(this.init)) {
      return UnknownValue;
    }
    this.expressionsToBeDeoptimized.push(origin);
    trackedEntities.add(this.init);
    const value = this.init.getLiteralValueAtPath(path, recursionTracker, origin);
    trackedEntities.delete(this.init);
    return value;
  }
  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
    if (this.isReassigned || !this.init || path.length > MAX_PATH_DEPTH) {
      return UNKNOWN_EXPRESSION;
    }
    const trackedEntities = recursionTracker.getEntities(path);
    if (trackedEntities.has(this.init)) {
      return UNKNOWN_EXPRESSION;
    }
    this.expressionsToBeDeoptimized.push(origin);
    trackedEntities.add(this.init);
    const value = this.init.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
    trackedEntities.delete(this.init);
    return value;
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    if (path.length === 0)
      return false;
    if (this.isReassigned || path.length > MAX_PATH_DEPTH)
      return true;
    const trackedExpressions = context.accessed.getEntities(path);
    if (trackedExpressions.has(this))
      return false;
    trackedExpressions.add(this);
    return (this.init && this.init.hasEffectsWhenAccessedAtPath(path, context));
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    if (this.included || path.length > MAX_PATH_DEPTH)
      return true;
    if (path.length === 0)
      return false;
    if (this.isReassigned)
      return true;
    const trackedExpressions = context.assigned.getEntities(path);
    if (trackedExpressions.has(this))
      return false;
    trackedExpressions.add(this);
    return (this.init && this.init.hasEffectsWhenAssignedAtPath(path, context));
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (path.length > MAX_PATH_DEPTH || this.isReassigned)
      return true;
    const trackedExpressions = (callOptions.withNew
      ? context.instantiated
      : context.called).getEntities(path);
    if (trackedExpressions.has(this))
      return false;
    trackedExpressions.add(this);
    return (this.init && this.init.hasEffectsWhenCalledAtPath(path, callOptions, context));
  }
  include(context) {
    if (!this.included) {
      this.included = true;
      if (!this.module.isExecuted) {
        markModuleAndImpureDependenciesAsExecuted(this.module);
      }
      for (const declaration of this.declarations) {
        // If node is a default export, it can save a tree-shaking run to include the full declaration now
        if (!declaration.included)
          declaration.include(context, false);
        let node = declaration.parent;
        while (!node.included) {
          // We do not want to properly include parents in case they are part of a dead branch
          // in which case .include() might pull in more dead code
          node.included = true;
          if (node.type === Program)
            break;
          node = node.parent;
        }
      }
    }
  }
  includeCallArguments(context, args) {
    if (this.isReassigned) {
      for (const arg of args) {
        arg.include(context, false);
      }
    }
    else if (this.init) {
      this.init.includeCallArguments(context, args);
    }
  }
  markCalledFromTryStatement() {
    this.calledFromTryStatement = true;
  }
}

class Scope$2 {
  constructor() {
    this.children = [];
    this.variables = new Map();
  }
  addDeclaration(identifier, context, init = null, _isHoisted) {
    const name = identifier.name;
    let variable = this.variables.get(name);
    if (variable) {
      variable.addDeclaration(identifier, init);
    }
    else {
      variable = new LocalVariable(identifier.name, identifier, init || UNDEFINED_EXPRESSION, context);
      this.variables.set(name, variable);
    }
    return variable;
  }
  contains(name) {
    return this.variables.has(name);
  }
  findVariable(_name) {
    throw new Error('Internal Error: findVariable needs to be implemented by a subclass');
  }
}

class ChildScope extends Scope$2 {
  constructor(parent) {
    super();
    this.accessedOutsideVariables = new Map();
    this.parent = parent;
    parent.children.push(this);
  }
  addAccessedDynamicImport(importExpression) {
    (this.accessedDynamicImports || (this.accessedDynamicImports = new Set())).add(importExpression);
    if (this.parent instanceof ChildScope) {
      this.parent.addAccessedDynamicImport(importExpression);
    }
  }
  addAccessedGlobalsByFormat(globalsByFormat) {
    const accessedGlobalVariablesByFormat = this.accessedGlobalVariablesByFormat || (this.accessedGlobalVariablesByFormat = new Map());
    for (const format of Object.keys(globalsByFormat)) {
      let accessedGlobalVariables = accessedGlobalVariablesByFormat.get(format);
      if (!accessedGlobalVariables) {
        accessedGlobalVariables = new Set();
        accessedGlobalVariablesByFormat.set(format, accessedGlobalVariables);
      }
      for (const name of globalsByFormat[format]) {
        accessedGlobalVariables.add(name);
      }
    }
    if (this.parent instanceof ChildScope) {
      this.parent.addAccessedGlobalsByFormat(globalsByFormat);
    }
  }
  addNamespaceMemberAccess(name, variable) {
    this.accessedOutsideVariables.set(name, variable);
    this.parent.addNamespaceMemberAccess(name, variable);
  }
  addReturnExpression(expression) {
    this.parent instanceof ChildScope && this.parent.addReturnExpression(expression);
  }
  addUsedOutsideNames(usedNames, format) {
    for (const variable of this.accessedOutsideVariables.values()) {
      if (variable.included) {
        usedNames.add(variable.getBaseVariableName());
        if (variable.exportName && format === 'system') {
          usedNames.add('exports');
        }
      }
    }
    const accessedGlobalVariables = this.accessedGlobalVariablesByFormat && this.accessedGlobalVariablesByFormat.get(format);
    if (accessedGlobalVariables) {
      for (const name of accessedGlobalVariables) {
        usedNames.add(name);
      }
    }
  }
  contains(name) {
    return this.variables.has(name) || this.parent.contains(name);
  }
  deconflict(format) {
    const usedNames = new Set();
    this.addUsedOutsideNames(usedNames, format);
    if (this.accessedDynamicImports) {
      for (const importExpression of this.accessedDynamicImports) {
        if (importExpression.inlineNamespace) {
          usedNames.add(importExpression.inlineNamespace.getBaseVariableName());
        }
      }
    }
    for (const [name, variable] of this.variables) {
      if (variable.included || variable.alwaysRendered) {
        variable.setSafeName(getSafeName(name, usedNames));
      }
    }
    for (const scope of this.children) {
      scope.deconflict(format);
    }
  }
  findLexicalBoundary() {
    return this.parent.findLexicalBoundary();
  }
  findVariable(name) {
    const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);
    if (knownVariable) {
      return knownVariable;
    }
    const variable = this.parent.findVariable(name);
    this.accessedOutsideVariables.set(name, variable);
    return variable;
  }
}

function getLocator$1$1(source, options) {
  if (options === void 0) {
    options = {};
  }
  var offsetLine = options.offsetLine || 0;
  var offsetColumn = options.offsetColumn || 0;
  var originalLines = source.split('\n');
  var start = 0;
  var lineRanges = originalLines.map(function (line, i) {
    var end = start + line.length + 1;
    var range = { start: start, end: end, line: i };
    start = end;
    return range;
  });
  var i = 0;
  function rangeContains(range, index) {
    return range.start <= index && index < range.end;
  }
  function getLocation(range, index) {
    return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };
  }
  function locate(search, startIndex) {
    if (typeof search === 'string') {
      search = source.indexOf(search, startIndex || 0);
    }
    var range = lineRanges[i];
    var d = search >= range.end ? 1 : -1;
    while (range) {
      if (rangeContains(range, search))
        return getLocation(range, search);
      i += d;
      range = lineRanges[i];
    }
  }
  return locate;
}
function locate(source, search, options) {
  if (typeof options === 'number') {
    throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');
  }
  return getLocator$1$1(source, options)(search, options && options.startIndex);
}

const keys = {
  Literal: [],
  Program: ['body']
};
function getAndCreateKeys(esTreeNode) {
  keys[esTreeNode.type] = Object.keys(esTreeNode).filter(key => typeof esTreeNode[key] === 'object');
  return keys[esTreeNode.type];
}

const INCLUDE_PARAMETERS = 'variables';
class NodeBase {
  constructor(esTreeNode, parent, parentScope) {
    this.included = false;
    this.keys = keys[esTreeNode.type] || getAndCreateKeys(esTreeNode);
    this.parent = parent;
    this.context = parent.context;
    this.createScope(parentScope);
    this.parseNode(esTreeNode);
    this.initialise();
    this.context.magicString.addSourcemapLocation(this.start);
    this.context.magicString.addSourcemapLocation(this.end);
  }
  /**
   * Override this to bind assignments to variables and do any initialisations that
   * require the scopes to be populated with variables.
   */
  bind() {
    for (const key of this.keys) {
      const value = this[key];
      if (value === null || key === 'annotations')
        continue;
      if (Array.isArray(value)) {
        for (const child of value) {
          if (child !== null)
            child.bind();
        }
      }
      else {
        value.bind();
      }
    }
  }
  /**
   * Override if this node should receive a different scope than the parent scope.
   */
  createScope(parentScope) {
    this.scope = parentScope;
  }
  declare(_kind, _init) {
    return [];
  }
  deoptimizePath(_path) { }
  getLiteralValueAtPath(_path, _recursionTracker, _origin) {
    return UnknownValue;
  }
  getReturnExpressionWhenCalledAtPath(_path, _recursionTracker, _origin) {
    return UNKNOWN_EXPRESSION;
  }
  hasEffects(context) {
    for (const key of this.keys) {
      const value = this[key];
      if (value === null || key === 'annotations')
        continue;
      if (Array.isArray(value)) {
        for (const child of value) {
          if (child !== null && child.hasEffects(context))
            return true;
        }
      }
      else if (value.hasEffects(context))
        return true;
    }
    return false;
  }
  hasEffectsWhenAccessedAtPath(path, _context) {
    return path.length > 0;
  }
  hasEffectsWhenAssignedAtPath(_path, _context) {
    return true;
  }
  hasEffectsWhenCalledAtPath(_path, _callOptions, _context) {
    return true;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    for (const key of this.keys) {
      const value = this[key];
      if (value === null || key === 'annotations')
        continue;
      if (Array.isArray(value)) {
        for (const child of value) {
          if (child !== null)
            child.include(context, includeChildrenRecursively);
        }
      }
      else {
        value.include(context, includeChildrenRecursively);
      }
    }
  }
  includeCallArguments(context, args) {
    for (const arg of args) {
      arg.include(context, false);
    }
  }
  includeWithAllDeclaredVariables(includeChildrenRecursively, context) {
    this.include(context, includeChildrenRecursively);
  }
  /**
   * Override to perform special initialisation steps after the scope is initialised
   */
  initialise() { }
  insertSemicolon(code) {
    if (code.original[this.end - 1] !== ';') {
      code.appendLeft(this.end, ';');
    }
  }
  locate() {
    // useful for debugging
    const location = locate(this.context.code, this.start, { offsetLine: 1 });
    location.file = this.context.fileName;
    location.toString = () => JSON.stringify(location);
    return location;
  }
  parseNode(esTreeNode) {
    for (const key of Object.keys(esTreeNode)) {
      // That way, we can override this function to add custom initialisation and then call super.parseNode
      if (this.hasOwnProperty(key))
        continue;
      const value = esTreeNode[key];
      if (typeof value !== 'object' || value === null || key === 'annotations') {
        this[key] = value;
      }
      else if (Array.isArray(value)) {
        this[key] = [];
        for (const child of value) {
          this[key].push(child === null
            ? null
            : new (this.context.nodeConstructors[child.type] ||
              this.context.nodeConstructors.UnknownNode)(child, this, this.scope));
        }
      }
      else {
        this[key] = new (this.context.nodeConstructors[value.type] ||
          this.context.nodeConstructors.UnknownNode)(value, this, this.scope);
      }
    }
  }
  render(code, options) {
    for (const key of this.keys) {
      const value = this[key];
      if (value === null || key === 'annotations')
        continue;
      if (Array.isArray(value)) {
        for (const child of value) {
          if (child !== null)
            child.render(code, options);
        }
      }
      else {
        value.render(code, options);
      }
    }
  }
  shouldBeIncluded(context) {
    return this.included || (!context.brokenFlow && this.hasEffects(createHasEffectsContext()));
  }
  toString() {
    return this.context.code.slice(this.start, this.end);
  }
}

class ClassNode extends NodeBase {
  createScope(parentScope) {
    this.scope = new ChildScope(parentScope);
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenAssignedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (!callOptions.withNew)
      return true;
    return (this.body.hasEffectsWhenCalledAtPath(path, callOptions, context) ||
      (this.superClass !== null &&
        this.superClass.hasEffectsWhenCalledAtPath(path, callOptions, context)));
  }
  initialise() {
    if (this.id !== null) {
      this.id.declare('class', this);
    }
  }
}

class ClassDeclaration extends ClassNode {
  initialise() {
    super.initialise();
    if (this.id !== null) {
      this.id.variable.isId = true;
    }
  }
  parseNode(esTreeNode) {
    if (esTreeNode.id !== null) {
      this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope
        .parent);
    }
    super.parseNode(esTreeNode);
  }
  render(code, options) {
    if (options.format === 'system' && this.id && this.id.variable.exportName) {
      code.appendLeft(this.end, ` exports('${this.id.variable.exportName}', ${this.id.variable.getName()});`);
    }
    super.render(code, options);
  }
}

class ArgumentsVariable extends LocalVariable {
  constructor(context) {
    super('arguments', null, UNKNOWN_EXPRESSION, context);
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenAssignedAtPath() {
    return true;
  }
  hasEffectsWhenCalledAtPath() {
    return true;
  }
}

class ThisVariable extends LocalVariable {
  constructor(context) {
    super('this', null, null, context);
  }
  getLiteralValueAtPath() {
    return UnknownValue;
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    return (this.getInit(context).hasEffectsWhenAccessedAtPath(path, context) ||
      super.hasEffectsWhenAccessedAtPath(path, context));
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    return (this.getInit(context).hasEffectsWhenAssignedAtPath(path, context) ||
      super.hasEffectsWhenAssignedAtPath(path, context));
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    return (this.getInit(context).hasEffectsWhenCalledAtPath(path, callOptions, context) ||
      super.hasEffectsWhenCalledAtPath(path, callOptions, context));
  }
  getInit(context) {
    return context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION;
  }
}

class ParameterScope extends ChildScope {
  constructor(parent, context) {
    super(parent);
    this.parameters = [];
    this.hasRest = false;
    this.context = context;
    this.hoistedBodyVarScope = new ChildScope(this);
  }
  /**
   * Adds a parameter to this scope. Parameters must be added in the correct
   * order, e.g. from left to right.
   */
  addParameterDeclaration(identifier) {
    const name = identifier.name;
    let variable = this.hoistedBodyVarScope.variables.get(name);
    if (variable) {
      variable.addDeclaration(identifier, null);
    }
    else {
      variable = new LocalVariable(name, identifier, UNKNOWN_EXPRESSION, this.context);
    }
    this.variables.set(name, variable);
    return variable;
  }
  addParameterVariables(parameters, hasRest) {
    this.parameters = parameters;
    for (const parameterList of parameters) {
      for (const parameter of parameterList) {
        parameter.alwaysRendered = true;
      }
    }
    this.hasRest = hasRest;
  }
  includeCallArguments(context, args) {
    let calledFromTryStatement = false;
    let argIncluded = false;
    const restParam = this.hasRest && this.parameters[this.parameters.length - 1];
    for (let index = args.length - 1; index >= 0; index--) {
      const paramVars = this.parameters[index] || restParam;
      const arg = args[index];
      if (paramVars) {
        calledFromTryStatement = false;
        for (const variable of paramVars) {
          if (variable.included) {
            argIncluded = true;
          }
          if (variable.calledFromTryStatement) {
            calledFromTryStatement = true;
          }
        }
      }
      if (!argIncluded && arg.shouldBeIncluded(context)) {
        argIncluded = true;
      }
      if (argIncluded) {
        arg.include(context, calledFromTryStatement);
      }
    }
  }
}

class ReturnValueScope extends ParameterScope {
  constructor() {
    super(...arguments);
    this.returnExpression = null;
    this.returnExpressions = [];
  }
  addReturnExpression(expression) {
    this.returnExpressions.push(expression);
  }
  getReturnExpression() {
    if (this.returnExpression === null)
      this.updateReturnExpression();
    return this.returnExpression;
  }
  updateReturnExpression() {
    if (this.returnExpressions.length === 1) {
      this.returnExpression = this.returnExpressions[0];
    }
    else {
      this.returnExpression = UNKNOWN_EXPRESSION;
      for (const expression of this.returnExpressions) {
        expression.deoptimizePath(UNKNOWN_PATH);
      }
    }
  }
}

class FunctionScope extends ReturnValueScope {
  constructor(parent, context) {
    super(parent, context);
    this.variables.set('arguments', (this.argumentsVariable = new ArgumentsVariable(context)));
    this.variables.set('this', (this.thisVariable = new ThisVariable(context)));
  }
  findLexicalBoundary() {
    return this;
  }
  includeCallArguments(context, args) {
    super.includeCallArguments(context, args);
    if (this.argumentsVariable.included) {
      for (const arg of args) {
        if (!arg.included) {
          arg.include(context, false);
        }
      }
    }
  }
}

function isReference$1(node, parent) {
  if (node.type === 'MemberExpression') {
    return !node.computed && isReference$1(node.object, node);
  }
  if (node.type === 'Identifier') {
    if (!parent)
      return true;
    switch (parent.type) {
      // disregard `bar` in `foo.bar`
      case 'MemberExpression': return parent.computed || node === parent.object;
      // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
      case 'MethodDefinition': return parent.computed;
      // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
      case 'Property': return parent.computed || node === parent.value;
      // disregard the `bar` in `export { foo as bar }` or
      // the foo in `import { foo as bar }`
      case 'ExportSpecifier':
      case 'ImportSpecifier': return node === parent.local;
      // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
      case 'LabeledStatement':
      case 'BreakStatement':
      case 'ContinueStatement': return false;
      default: return true;
    }
  }
  return false;
}

const BLANK = Object.create(null);

const ValueProperties = Symbol('Value Properties');
const PURE = { pure: true };
const IMPURE = { pure: false };
// We use shortened variables to reduce file size here
/* OBJECT */
const O = {
  // @ts-ignore
  __proto__: null,
  [ValueProperties]: IMPURE
};
/* PURE FUNCTION */
const PF = {
  // @ts-ignore
  __proto__: null,
  [ValueProperties]: PURE
};
/* CONSTRUCTOR */
const C = {
  // @ts-ignore
  __proto__: null,
  [ValueProperties]: IMPURE,
  prototype: O
};
/* PURE CONSTRUCTOR */
const PC = {
  // @ts-ignore
  __proto__: null,
  [ValueProperties]: PURE,
  prototype: O
};
const ARRAY_TYPE = {
  // @ts-ignore
  __proto__: null,
  [ValueProperties]: PURE,
  from: PF,
  of: PF,
  prototype: O
};
const INTL_MEMBER = {
  // @ts-ignore
  __proto__: null,
  [ValueProperties]: PURE,
  supportedLocalesOf: PC
};
const knownGlobals = {
  // Placeholders for global objects to avoid shape mutations
  global: O,
  globalThis: O,
  self: O,
  window: O,
  // Common globals
  // @ts-ignore
  __proto__: null,
  [ValueProperties]: IMPURE,
  Array: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: IMPURE,
    from: PF,
    isArray: PF,
    of: PF,
    prototype: O
  },
  ArrayBuffer: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: PURE,
    isView: PF,
    prototype: O
  },
  Atomics: O,
  BigInt: C,
  BigInt64Array: C,
  BigUint64Array: C,
  Boolean: PC,
  // @ts-ignore
  constructor: C,
  DataView: PC,
  Date: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: PURE,
    now: PF,
    parse: PF,
    prototype: O,
    UTC: PF
  },
  decodeURI: PF,
  decodeURIComponent: PF,
  encodeURI: PF,
  encodeURIComponent: PF,
  Error: PC,
  escape: PF,
  eval: O,
  EvalError: PC,
  Float32Array: ARRAY_TYPE,
  Float64Array: ARRAY_TYPE,
  Function: C,
  // @ts-ignore
  hasOwnProperty: O,
  Infinity: O,
  Int16Array: ARRAY_TYPE,
  Int32Array: ARRAY_TYPE,
  Int8Array: ARRAY_TYPE,
  isFinite: PF,
  isNaN: PF,
  // @ts-ignore
  isPrototypeOf: O,
  JSON: O,
  Map: PC,
  Math: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: IMPURE,
    abs: PF,
    acos: PF,
    acosh: PF,
    asin: PF,
    asinh: PF,
    atan: PF,
    atan2: PF,
    atanh: PF,
    cbrt: PF,
    ceil: PF,
    clz32: PF,
    cos: PF,
    cosh: PF,
    exp: PF,
    expm1: PF,
    floor: PF,
    fround: PF,
    hypot: PF,
    imul: PF,
    log: PF,
    log10: PF,
    log1p: PF,
    log2: PF,
    max: PF,
    min: PF,
    pow: PF,
    random: PF,
    round: PF,
    sign: PF,
    sin: PF,
    sinh: PF,
    sqrt: PF,
    tan: PF,
    tanh: PF,
    trunc: PF
  },
  NaN: O,
  Number: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: PURE,
    isFinite: PF,
    isInteger: PF,
    isNaN: PF,
    isSafeInteger: PF,
    parseFloat: PF,
    parseInt: PF,
    prototype: O
  },
  Object: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: PURE,
    create: PF,
    getNotifier: PF,
    getOwn: PF,
    getOwnPropertyDescriptor: PF,
    getOwnPropertyNames: PF,
    getOwnPropertySymbols: PF,
    getPrototypeOf: PF,
    is: PF,
    isExtensible: PF,
    isFrozen: PF,
    isSealed: PF,
    keys: PF,
    prototype: O
  },
  parseFloat: PF,
  parseInt: PF,
  Promise: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: IMPURE,
    all: PF,
    prototype: O,
    race: PF,
    resolve: PF
  },
  // @ts-ignore
  propertyIsEnumerable: O,
  Proxy: O,
  RangeError: PC,
  ReferenceError: PC,
  Reflect: O,
  RegExp: PC,
  Set: PC,
  SharedArrayBuffer: C,
  String: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: PURE,
    fromCharCode: PF,
    fromCodePoint: PF,
    prototype: O,
    raw: PF
  },
  Symbol: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: PURE,
    for: PF,
    keyFor: PF,
    prototype: O
  },
  SyntaxError: PC,
  // @ts-ignore
  toLocaleString: O,
  // @ts-ignore
  toString: O,
  TypeError: PC,
  Uint16Array: ARRAY_TYPE,
  Uint32Array: ARRAY_TYPE,
  Uint8Array: ARRAY_TYPE,
  Uint8ClampedArray: ARRAY_TYPE,
  // Technically, this is a global, but it needs special handling
  // undefined: ?,
  unescape: PF,
  URIError: PC,
  // @ts-ignore
  valueOf: O,
  WeakMap: PC,
  WeakSet: PC,
  // Additional globals shared by Node and Browser that are not strictly part of the language
  clearInterval: C,
  clearTimeout: C,
  console: O,
  Intl: {
    // @ts-ignore
    __proto__: null,
    [ValueProperties]: IMPURE,
    Collator: INTL_MEMBER,
    DateTimeFormat: INTL_MEMBER,
    ListFormat: INTL_MEMBER,
    NumberFormat: INTL_MEMBER,
    PluralRules: INTL_MEMBER,
    RelativeTimeFormat: INTL_MEMBER
  },
  setInterval: C,
  setTimeout: C,
  TextDecoder: C,
  TextEncoder: C,
  URL: C,
  URLSearchParams: C,
  // Browser specific globals
  AbortController: C,
  AbortSignal: C,
  addEventListener: O,
  alert: O,
  AnalyserNode: C,
  Animation: C,
  AnimationEvent: C,
  applicationCache: O,
  ApplicationCache: C,
  ApplicationCacheErrorEvent: C,
  atob: O,
  Attr: C,
  Audio: C,
  AudioBuffer: C,
  AudioBufferSourceNode: C,
  AudioContext: C,
  AudioDestinationNode: C,
  AudioListener: C,
  AudioNode: C,
  AudioParam: C,
  AudioProcessingEvent: C,
  AudioScheduledSourceNode: C,
  AudioWorkletNode: C,
  BarProp: C,
  BaseAudioContext: C,
  BatteryManager: C,
  BeforeUnloadEvent: C,
  BiquadFilterNode: C,
  Blob: C,
  BlobEvent: C,
  blur: O,
  BroadcastChannel: C,
  btoa: O,
  ByteLengthQueuingStrategy: C,
  Cache: C,
  caches: O,
  CacheStorage: C,
  cancelAnimationFrame: O,
  cancelIdleCallback: O,
  CanvasCaptureMediaStreamTrack: C,
  CanvasGradient: C,
  CanvasPattern: C,
  CanvasRenderingContext2D: C,
  ChannelMergerNode: C,
  ChannelSplitterNode: C,
  CharacterData: C,
  clientInformation: O,
  ClipboardEvent: C,
  close: O,
  closed: O,
  CloseEvent: C,
  Comment: C,
  CompositionEvent: C,
  confirm: O,
  ConstantSourceNode: C,
  ConvolverNode: C,
  CountQueuingStrategy: C,
  createImageBitmap: O,
  Credential: C,
  CredentialsContainer: C,
  crypto: O,
  Crypto: C,
  CryptoKey: C,
  CSS: C,
  CSSConditionRule: C,
  CSSFontFaceRule: C,
  CSSGroupingRule: C,
  CSSImportRule: C,
  CSSKeyframeRule: C,
  CSSKeyframesRule: C,
  CSSMediaRule: C,
  CSSNamespaceRule: C,
  CSSPageRule: C,
  CSSRule: C,
  CSSRuleList: C,
  CSSStyleDeclaration: C,
  CSSStyleRule: C,
  CSSStyleSheet: C,
  CSSSupportsRule: C,
  CustomElementRegistry: C,
  customElements: O,
  CustomEvent: C,
  DataTransfer: C,
  DataTransferItem: C,
  DataTransferItemList: C,
  defaultstatus: O,
  defaultStatus: O,
  DelayNode: C,
  DeviceMotionEvent: C,
  DeviceOrientationEvent: C,
  devicePixelRatio: O,
  dispatchEvent: O,
  document: O,
  Document: C,
  DocumentFragment: C,
  DocumentType: C,
  DOMError: C,
  DOMException: C,
  DOMImplementation: C,
  DOMMatrix: C,
  DOMMatrixReadOnly: C,
  DOMParser: C,
  DOMPoint: C,
  DOMPointReadOnly: C,
  DOMQuad: C,
  DOMRect: C,
  DOMRectReadOnly: C,
  DOMStringList: C,
  DOMStringMap: C,
  DOMTokenList: C,
  DragEvent: C,
  DynamicsCompressorNode: C,
  Element: C,
  ErrorEvent: C,
  Event: C,
  EventSource: C,
  EventTarget: C,
  external: O,
  fetch: O,
  File: C,
  FileList: C,
  FileReader: C,
  find: O,
  focus: O,
  FocusEvent: C,
  FontFace: C,
  FontFaceSetLoadEvent: C,
  FormData: C,
  frames: O,
  GainNode: C,
  Gamepad: C,
  GamepadButton: C,
  GamepadEvent: C,
  getComputedStyle: O,
  getSelection: O,
  HashChangeEvent: C,
  Headers: C,
  history: O,
  History: C,
  HTMLAllCollection: C,
  HTMLAnchorElement: C,
  HTMLAreaElement: C,
  HTMLAudioElement: C,
  HTMLBaseElement: C,
  HTMLBodyElement: C,
  HTMLBRElement: C,
  HTMLButtonElement: C,
  HTMLCanvasElement: C,
  HTMLCollection: C,
  HTMLContentElement: C,
  HTMLDataElement: C,
  HTMLDataListElement: C,
  HTMLDetailsElement: C,
  HTMLDialogElement: C,
  HTMLDirectoryElement: C,
  HTMLDivElement: C,
  HTMLDListElement: C,
  HTMLDocument: C,
  HTMLElement: C,
  HTMLEmbedElement: C,
  HTMLFieldSetElement: C,
  HTMLFontElement: C,
  HTMLFormControlsCollection: C,
  HTMLFormElement: C,
  HTMLFrameElement: C,
  HTMLFrameSetElement: C,
  HTMLHeadElement: C,
  HTMLHeadingElement: C,
  HTMLHRElement: C,
  HTMLHtmlElement: C,
  HTMLIFrameElement: C,
  HTMLImageElement: C,
  HTMLInputElement: C,
  HTMLLabelElement: C,
  HTMLLegendElement: C,
  HTMLLIElement: C,
  HTMLLinkElement: C,
  HTMLMapElement: C,
  HTMLMarqueeElement: C,
  HTMLMediaElement: C,
  HTMLMenuElement: C,
  HTMLMetaElement: C,
  HTMLMeterElement: C,
  HTMLModElement: C,
  HTMLObjectElement: C,
  HTMLOListElement: C,
  HTMLOptGroupElement: C,
  HTMLOptionElement: C,
  HTMLOptionsCollection: C,
  HTMLOutputElement: C,
  HTMLParagraphElement: C,
  HTMLParamElement: C,
  HTMLPictureElement: C,
  HTMLPreElement: C,
  HTMLProgressElement: C,
  HTMLQuoteElement: C,
  HTMLScriptElement: C,
  HTMLSelectElement: C,
  HTMLShadowElement: C,
  HTMLSlotElement: C,
  HTMLSourceElement: C,
  HTMLSpanElement: C,
  HTMLStyleElement: C,
  HTMLTableCaptionElement: C,
  HTMLTableCellElement: C,
  HTMLTableColElement: C,
  HTMLTableElement: C,
  HTMLTableRowElement: C,
  HTMLTableSectionElement: C,
  HTMLTemplateElement: C,
  HTMLTextAreaElement: C,
  HTMLTimeElement: C,
  HTMLTitleElement: C,
  HTMLTrackElement: C,
  HTMLUListElement: C,
  HTMLUnknownElement: C,
  HTMLVideoElement: C,
  IDBCursor: C,
  IDBCursorWithValue: C,
  IDBDatabase: C,
  IDBFactory: C,
  IDBIndex: C,
  IDBKeyRange: C,
  IDBObjectStore: C,
  IDBOpenDBRequest: C,
  IDBRequest: C,
  IDBTransaction: C,
  IDBVersionChangeEvent: C,
  IdleDeadline: C,
  IIRFilterNode: C,
  Image: C,
  ImageBitmap: C,
  ImageBitmapRenderingContext: C,
  ImageCapture: C,
  ImageData: C,
  indexedDB: O,
  innerHeight: O,
  innerWidth: O,
  InputEvent: C,
  IntersectionObserver: C,
  IntersectionObserverEntry: C,
  isSecureContext: O,
  KeyboardEvent: C,
  KeyframeEffect: C,
  length: O,
  localStorage: O,
  location: O,
  Location: C,
  locationbar: O,
  matchMedia: O,
  MediaDeviceInfo: C,
  MediaDevices: C,
  MediaElementAudioSourceNode: C,
  MediaEncryptedEvent: C,
  MediaError: C,
  MediaKeyMessageEvent: C,
  MediaKeySession: C,
  MediaKeyStatusMap: C,
  MediaKeySystemAccess: C,
  MediaList: C,
  MediaQueryList: C,
  MediaQueryListEvent: C,
  MediaRecorder: C,
  MediaSettingsRange: C,
  MediaSource: C,
  MediaStream: C,
  MediaStreamAudioDestinationNode: C,
  MediaStreamAudioSourceNode: C,
  MediaStreamEvent: C,
  MediaStreamTrack: C,
  MediaStreamTrackEvent: C,
  menubar: O,
  MessageChannel: C,
  MessageEvent: C,
  MessagePort: C,
  MIDIAccess: C,
  MIDIConnectionEvent: C,
  MIDIInput: C,
  MIDIInputMap: C,
  MIDIMessageEvent: C,
  MIDIOutput: C,
  MIDIOutputMap: C,
  MIDIPort: C,
  MimeType: C,
  MimeTypeArray: C,
  MouseEvent: C,
  moveBy: O,
  moveTo: O,
  MutationEvent: C,
  MutationObserver: C,
  MutationRecord: C,
  name: O,
  NamedNodeMap: C,
  NavigationPreloadManager: C,
  navigator: O,
  Navigator: C,
  NetworkInformation: C,
  Node: C,
  NodeFilter: O,
  NodeIterator: C,
  NodeList: C,
  Notification: C,
  OfflineAudioCompletionEvent: C,
  OfflineAudioContext: C,
  offscreenBuffering: O,
  OffscreenCanvas: C,
  open: O,
  openDatabase: O,
  Option: C,
  origin: O,
  OscillatorNode: C,
  outerHeight: O,
  outerWidth: O,
  PageTransitionEvent: C,
  pageXOffset: O,
  pageYOffset: O,
  PannerNode: C,
  parent: O,
  Path2D: C,
  PaymentAddress: C,
  PaymentRequest: C,
  PaymentRequestUpdateEvent: C,
  PaymentResponse: C,
  performance: O,
  Performance: C,
  PerformanceEntry: C,
  PerformanceLongTaskTiming: C,
  PerformanceMark: C,
  PerformanceMeasure: C,
  PerformanceNavigation: C,
  PerformanceNavigationTiming: C,
  PerformanceObserver: C,
  PerformanceObserverEntryList: C,
  PerformancePaintTiming: C,
  PerformanceResourceTiming: C,
  PerformanceTiming: C,
  PeriodicWave: C,
  Permissions: C,
  PermissionStatus: C,
  personalbar: O,
  PhotoCapabilities: C,
  Plugin: C,
  PluginArray: C,
  PointerEvent: C,
  PopStateEvent: C,
  postMessage: O,
  Presentation: C,
  PresentationAvailability: C,
  PresentationConnection: C,
  PresentationConnectionAvailableEvent: C,
  PresentationConnectionCloseEvent: C,
  PresentationConnectionList: C,
  PresentationReceiver: C,
  PresentationRequest: C,
  print: O,
  ProcessingInstruction: C,
  ProgressEvent: C,
  PromiseRejectionEvent: C,
  prompt: O,
  PushManager: C,
  PushSubscription: C,
  PushSubscriptionOptions: C,
  queueMicrotask: O,
  RadioNodeList: C,
  Range: C,
  ReadableStream: C,
  RemotePlayback: C,
  removeEventListener: O,
  Request: C,
  requestAnimationFrame: O,
  requestIdleCallback: O,
  resizeBy: O,
  ResizeObserver: C,
  ResizeObserverEntry: C,
  resizeTo: O,
  Response: C,
  RTCCertificate: C,
  RTCDataChannel: C,
  RTCDataChannelEvent: C,
  RTCDtlsTransport: C,
  RTCIceCandidate: C,
  RTCIceTransport: C,
  RTCPeerConnection: C,
  RTCPeerConnectionIceEvent: C,
  RTCRtpReceiver: C,
  RTCRtpSender: C,
  RTCSctpTransport: C,
  RTCSessionDescription: C,
  RTCStatsReport: C,
  RTCTrackEvent: C,
  screen: O,
  Screen: C,
  screenLeft: O,
  ScreenOrientation: C,
  screenTop: O,
  screenX: O,
  screenY: O,
  ScriptProcessorNode: C,
  scroll: O,
  scrollbars: O,
  scrollBy: O,
  scrollTo: O,
  scrollX: O,
  scrollY: O,
  SecurityPolicyViolationEvent: C,
  Selection: C,
  ServiceWorker: C,
  ServiceWorkerContainer: C,
  ServiceWorkerRegistration: C,
  sessionStorage: O,
  ShadowRoot: C,
  SharedWorker: C,
  SourceBuffer: C,
  SourceBufferList: C,
  speechSynthesis: O,
  SpeechSynthesisEvent: C,
  SpeechSynthesisUtterance: C,
  StaticRange: C,
  status: O,
  statusbar: O,
  StereoPannerNode: C,
  stop: O,
  Storage: C,
  StorageEvent: C,
  StorageManager: C,
  styleMedia: O,
  StyleSheet: C,
  StyleSheetList: C,
  SubtleCrypto: C,
  SVGAElement: C,
  SVGAngle: C,
  SVGAnimatedAngle: C,
  SVGAnimatedBoolean: C,
  SVGAnimatedEnumeration: C,
  SVGAnimatedInteger: C,
  SVGAnimatedLength: C,
  SVGAnimatedLengthList: C,
  SVGAnimatedNumber: C,
  SVGAnimatedNumberList: C,
  SVGAnimatedPreserveAspectRatio: C,
  SVGAnimatedRect: C,
  SVGAnimatedString: C,
  SVGAnimatedTransformList: C,
  SVGAnimateElement: C,
  SVGAnimateMotionElement: C,
  SVGAnimateTransformElement: C,
  SVGAnimationElement: C,
  SVGCircleElement: C,
  SVGClipPathElement: C,
  SVGComponentTransferFunctionElement: C,
  SVGDefsElement: C,
  SVGDescElement: C,
  SVGDiscardElement: C,
  SVGElement: C,
  SVGEllipseElement: C,
  SVGFEBlendElement: C,
  SVGFEColorMatrixElement: C,
  SVGFEComponentTransferElement: C,
  SVGFECompositeElement: C,
  SVGFEConvolveMatrixElement: C,
  SVGFEDiffuseLightingElement: C,
  SVGFEDisplacementMapElement: C,
  SVGFEDistantLightElement: C,
  SVGFEDropShadowElement: C,
  SVGFEFloodElement: C,
  SVGFEFuncAElement: C,
  SVGFEFuncBElement: C,
  SVGFEFuncGElement: C,
  SVGFEFuncRElement: C,
  SVGFEGaussianBlurElement: C,
  SVGFEImageElement: C,
  SVGFEMergeElement: C,
  SVGFEMergeNodeElement: C,
  SVGFEMorphologyElement: C,
  SVGFEOffsetElement: C,
  SVGFEPointLightElement: C,
  SVGFESpecularLightingElement: C,
  SVGFESpotLightElement: C,
  SVGFETileElement: C,
  SVGFETurbulenceElement: C,
  SVGFilterElement: C,
  SVGForeignObjectElement: C,
  SVGGElement: C,
  SVGGeometryElement: C,
  SVGGradientElement: C,
  SVGGraphicsElement: C,
  SVGImageElement: C,
  SVGLength: C,
  SVGLengthList: C,
  SVGLinearGradientElement: C,
  SVGLineElement: C,
  SVGMarkerElement: C,
  SVGMaskElement: C,
  SVGMatrix: C,
  SVGMetadataElement: C,
  SVGMPathElement: C,
  SVGNumber: C,
  SVGNumberList: C,
  SVGPathElement: C,
  SVGPatternElement: C,
  SVGPoint: C,
  SVGPointList: C,
  SVGPolygonElement: C,
  SVGPolylineElement: C,
  SVGPreserveAspectRatio: C,
  SVGRadialGradientElement: C,
  SVGRect: C,
  SVGRectElement: C,
  SVGScriptElement: C,
  SVGSetElement: C,
  SVGStopElement: C,
  SVGStringList: C,
  SVGStyleElement: C,
  SVGSVGElement: C,
  SVGSwitchElement: C,
  SVGSymbolElement: C,
  SVGTextContentElement: C,
  SVGTextElement: C,
  SVGTextPathElement: C,
  SVGTextPositioningElement: C,
  SVGTitleElement: C,
  SVGTransform: C,
  SVGTransformList: C,
  SVGTSpanElement: C,
  SVGUnitTypes: C,
  SVGUseElement: C,
  SVGViewElement: C,
  TaskAttributionTiming: C,
  Text: C,
  TextEvent: C,
  TextMetrics: C,
  TextTrack: C,
  TextTrackCue: C,
  TextTrackCueList: C,
  TextTrackList: C,
  TimeRanges: C,
  toolbar: O,
  top: O,
  Touch: C,
  TouchEvent: C,
  TouchList: C,
  TrackEvent: C,
  TransitionEvent: C,
  TreeWalker: C,
  UIEvent: C,
  ValidityState: C,
  visualViewport: O,
  VisualViewport: C,
  VTTCue: C,
  WaveShaperNode: C,
  WebAssembly: O,
  WebGL2RenderingContext: C,
  WebGLActiveInfo: C,
  WebGLBuffer: C,
  WebGLContextEvent: C,
  WebGLFramebuffer: C,
  WebGLProgram: C,
  WebGLQuery: C,
  WebGLRenderbuffer: C,
  WebGLRenderingContext: C,
  WebGLSampler: C,
  WebGLShader: C,
  WebGLShaderPrecisionFormat: C,
  WebGLSync: C,
  WebGLTexture: C,
  WebGLTransformFeedback: C,
  WebGLUniformLocation: C,
  WebGLVertexArrayObject: C,
  WebSocket: C,
  WheelEvent: C,
  Window: C,
  Worker: C,
  WritableStream: C,
  XMLDocument: C,
  XMLHttpRequest: C,
  XMLHttpRequestEventTarget: C,
  XMLHttpRequestUpload: C,
  XMLSerializer: C,
  XPathEvaluator: C,
  XPathExpression: C,
  XPathResult: C,
  XSLTProcessor: C
};
for (const global of ['window', 'global', 'self', 'globalThis']) {
  knownGlobals[global] = knownGlobals;
}
function getGlobalAtPath(path) {
  let currentGlobal = knownGlobals;
  for (const pathSegment of path) {
    if (typeof pathSegment !== 'string') {
      return null;
    }
    currentGlobal = currentGlobal[pathSegment];
    if (!currentGlobal) {
      return null;
    }
  }
  return currentGlobal[ValueProperties];
}
function isPureGlobal(path) {
  const globalAtPath = getGlobalAtPath(path);
  return globalAtPath !== null && globalAtPath.pure;
}
function isGlobalMember(path) {
  if (path.length === 1) {
    return path[0] === 'undefined' || getGlobalAtPath(path) !== null;
  }
  return getGlobalAtPath(path.slice(0, -1)) !== null;
}

class GlobalVariable extends Variable {
  hasEffectsWhenAccessedAtPath(path) {
    return !isGlobalMember([this.name, ...path]);
  }
  hasEffectsWhenCalledAtPath(path) {
    return !isPureGlobal([this.name, ...path]);
  }
}

class Identifier$1 extends NodeBase {
  constructor() {
    super(...arguments);
    this.variable = null;
    this.bound = false;
  }
  addExportedVariables(variables) {
    if (this.variable !== null && this.variable.exportName) {
      variables.push(this.variable);
    }
  }
  bind() {
    if (this.bound)
      return;
    this.bound = true;
    if (this.variable === null && isReference$1(this, this.parent)) {
      this.variable = this.scope.findVariable(this.name);
      this.variable.addReference(this);
    }
    if (this.variable !== null &&
      this.variable instanceof LocalVariable &&
      this.variable.additionalInitializers !== null) {
      this.variable.consolidateInitializers();
    }
  }
  declare(kind, init) {
    let variable;
    switch (kind) {
      case 'var':
        variable = this.scope.addDeclaration(this, this.context, init, true);
        break;
      case 'function':
        variable = this.scope.addDeclaration(this, this.context, init, 'function');
        break;
      case 'let':
      case 'const':
      case 'class':
        variable = this.scope.addDeclaration(this, this.context, init, false);
        break;
      case 'parameter':
        variable = this.scope.addParameterDeclaration(this);
        break;
      /* istanbul ignore next */
      default:
        /* istanbul ignore next */
        throw new Error(`Internal Error: Unexpected identifier kind ${kind}.`);
    }
    return [(this.variable = variable)];
  }
  deoptimizePath(path) {
    if (!this.bound)
      this.bind();
    if (path.length === 0 && !this.scope.contains(this.name)) {
      this.disallowImportReassignment();
    }
    this.variable.deoptimizePath(path);
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    if (!this.bound)
      this.bind();
    return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);
  }
  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
    if (!this.bound)
      this.bind();
    return this.variable.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
  }
  hasEffects() {
    return (this.context.unknownGlobalSideEffects &&
      this.variable instanceof GlobalVariable &&
      this.variable.hasEffectsWhenAccessedAtPath(EMPTY_PATH));
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    return this.variable !== null && this.variable.hasEffectsWhenAccessedAtPath(path, context);
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    return !this.variable || this.variable.hasEffectsWhenAssignedAtPath(path, context);
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    return !this.variable || this.variable.hasEffectsWhenCalledAtPath(path, callOptions, context);
  }
  include(context) {
    if (!this.included) {
      this.included = true;
      if (this.variable !== null) {
        this.context.includeVariable(context, this.variable);
      }
    }
  }
  includeCallArguments(context, args) {
    this.variable.includeCallArguments(context, args);
  }
  render(code, _options, { renderedParentType, isCalleeOfRenderedParent, isShorthandProperty } = BLANK) {
    if (this.variable) {
      const name = this.variable.getName();
      if (name !== this.name) {
        code.overwrite(this.start, this.end, name, {
          contentOnly: true,
          storeName: true
        });
        if (isShorthandProperty) {
          code.prependRight(this.start, `${this.name}: `);
        }
      }
      // In strict mode, any variable named "eval" must be the actual "eval" function
      if (name === 'eval' &&
        renderedParentType === CallExpression &&
        isCalleeOfRenderedParent) {
        code.appendRight(this.start, '0, ');
      }
    }
  }
  disallowImportReassignment() {
    return this.context.error({
      code: 'ILLEGAL_REASSIGNMENT',
      message: `Illegal reassignment to import '${this.name}'`
    }, this.start);
  }
}

class RestElement extends NodeBase {
  constructor() {
    super(...arguments);
    this.declarationInit = null;
  }
  addExportedVariables(variables) {
    this.argument.addExportedVariables(variables);
  }
  bind() {
    super.bind();
    if (this.declarationInit !== null) {
      this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
    }
  }
  declare(kind, init) {
    this.declarationInit = init;
    return this.argument.declare(kind, UNKNOWN_EXPRESSION);
  }
  deoptimizePath(path) {
    path.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    return path.length > 0 || this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
  }
}

class FunctionNode extends NodeBase {
  constructor() {
    super(...arguments);
    this.isPrototypeDeoptimized = false;
  }
  createScope(parentScope) {
    this.scope = new FunctionScope(parentScope, this.context);
  }
  deoptimizePath(path) {
    if (path.length === 1) {
      if (path[0] === 'prototype') {
        this.isPrototypeDeoptimized = true;
      }
      else if (path[0] === UnknownKey) {
        this.isPrototypeDeoptimized = true;
        // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
        // which means the return expression needs to be reassigned as well
        this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
      }
    }
  }
  getReturnExpressionWhenCalledAtPath(path) {
    return path.length === 0 ? this.scope.getReturnExpression() : UNKNOWN_EXPRESSION;
  }
  hasEffects() {
    return this.id !== null && this.id.hasEffects();
  }
  hasEffectsWhenAccessedAtPath(path) {
    if (path.length <= 1)
      return false;
    return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;
  }
  hasEffectsWhenAssignedAtPath(path) {
    if (path.length <= 1) {
      return false;
    }
    return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (path.length > 0)
      return true;
    for (const param of this.params) {
      if (param.hasEffects(context))
        return true;
    }
    const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);
    context.replacedVariableInits.set(this.scope.thisVariable, callOptions.withNew ? new UnknownObjectExpression() : UNKNOWN_EXPRESSION);
    const { brokenFlow, ignore } = context;
    context.ignore = {
      breaks: false,
      continues: false,
      labels: new Set(),
      returnAwaitYield: true
    };
    if (this.body.hasEffects(context))
      return true;
    context.brokenFlow = brokenFlow;
    if (thisInit) {
      context.replacedVariableInits.set(this.scope.thisVariable, thisInit);
    }
    else {
      context.replacedVariableInits.delete(this.scope.thisVariable);
    }
    context.ignore = ignore;
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    if (this.id)
      this.id.include(context);
    const hasArguments = this.scope.argumentsVariable.included;
    for (const param of this.params) {
      if (!(param instanceof Identifier$1) || hasArguments) {
        param.include(context, includeChildrenRecursively);
      }
    }
    const { brokenFlow } = context;
    context.brokenFlow = BROKEN_FLOW_NONE;
    this.body.include(context, includeChildrenRecursively);
    context.brokenFlow = brokenFlow;
  }
  includeCallArguments(context, args) {
    this.scope.includeCallArguments(context, args);
  }
  initialise() {
    if (this.id !== null) {
      this.id.declare('function', this);
    }
    this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
    this.body.addImplicitReturnExpressionToScope();
  }
  parseNode(esTreeNode) {
    this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
    super.parseNode(esTreeNode);
  }
}
FunctionNode.prototype.preventChildBlockScope = true;

class FunctionDeclaration extends FunctionNode {
  initialise() {
    super.initialise();
    if (this.id !== null) {
      this.id.variable.isId = true;
    }
  }
  parseNode(esTreeNode) {
    if (esTreeNode.id !== null) {
      this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope
        .parent);
    }
    super.parseNode(esTreeNode);
  }
}

const WHITESPACE = /\s/;
// The header ends at the first non-white-space after "default"
function getDeclarationStart(code, start = 0) {
  start = findFirstOccurrenceOutsideComment(code, 'default', start) + 7;
  while (WHITESPACE.test(code[start]))
    start++;
  return start;
}
function getIdInsertPosition(code, declarationKeyword, start = 0) {
  const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;
  code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, '{', declarationEnd));
  const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');
  if (generatorStarPos === -1) {
    return declarationEnd;
  }
  return declarationEnd + generatorStarPos + 1;
}
class ExportDefaultDeclaration extends NodeBase {
  include(context, includeChildrenRecursively) {
    super.include(context, includeChildrenRecursively);
    if (includeChildrenRecursively) {
      this.context.includeVariable(context, this.variable);
    }
  }
  initialise() {
    const declaration = this.declaration;
    this.declarationName =
      (declaration.id && declaration.id.name) || this.declaration.name;
    this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);
    this.context.addExport(this);
  }
  render(code, options, nodeRenderOptions) {
    const { start, end } = nodeRenderOptions;
    const declarationStart = getDeclarationStart(code.original, this.start);
    if (this.declaration instanceof FunctionDeclaration) {
      this.renderNamedDeclaration(code, declarationStart, 'function', this.declaration.id === null, options);
    }
    else if (this.declaration instanceof ClassDeclaration) {
      this.renderNamedDeclaration(code, declarationStart, 'class', this.declaration.id === null, options);
    }
    else if (this.variable.getOriginalVariable() !== this.variable) {
      // Remove altogether to prevent re-declaring the same variable
      if (options.format === 'system' && this.variable.exportName) {
        code.overwrite(start, end, `exports('${this.variable.exportName}', ${this.variable.getName()});`);
      }
      else {
        treeshakeNode(this, code, start, end);
      }
      return;
    }
    else if (this.variable.included) {
      this.renderVariableDeclaration(code, declarationStart, options);
    }
    else {
      code.remove(this.start, declarationStart);
      this.declaration.render(code, options, {
        isCalleeOfRenderedParent: false,
        renderedParentType: ExpressionStatement
      });
      if (code.original[this.end - 1] !== ';') {
        code.appendLeft(this.end, ';');
      }
      return;
    }
    this.declaration.render(code, options);
  }
  renderNamedDeclaration(code, declarationStart, declarationKeyword, needsId, options) {
    const name = this.variable.getName();
    // Remove `export default`
    code.remove(this.start, declarationStart);
    if (needsId) {
      code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, declarationStart), ` ${name}`);
    }
    if (options.format === 'system' &&
      this.declaration instanceof ClassDeclaration &&
      this.variable.exportName) {
      code.appendLeft(this.end, ` exports('${this.variable.exportName}', ${name});`);
    }
  }
  renderVariableDeclaration(code, declarationStart, options) {
    const systemBinding = options.format === 'system' && this.variable.exportName
      ? `exports('${this.variable.exportName}', `
      : '';
    code.overwrite(this.start, declarationStart, `${options.varOrConst} ${this.variable.getName()} = ${systemBinding}`);
    const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59; /*";"*/
    if (systemBinding) {
      code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));
    }
    else if (!hasTrailingSemicolon) {
      code.appendLeft(this.end, ';');
    }
  }
}
ExportDefaultDeclaration.prototype.needsBoundaries = true;

class ExportDefaultVariable extends LocalVariable {
  constructor(name, exportDefaultDeclaration, context) {
    super(name, exportDefaultDeclaration, exportDefaultDeclaration.declaration, context);
    this.hasId = false;
    // Not initialised during construction
    this.originalId = null;
    this.originalVariable = null;
    const declaration = exportDefaultDeclaration.declaration;
    if ((declaration instanceof FunctionDeclaration || declaration instanceof ClassDeclaration) &&
      declaration.id) {
      this.hasId = true;
      this.originalId = declaration.id;
    }
    else if (declaration instanceof Identifier$1) {
      this.originalId = declaration;
    }
  }
  addReference(identifier) {
    if (!this.hasId) {
      this.name = identifier.name;
    }
  }
  getAssignedVariableName() {
    return (this.originalId && this.originalId.name) || null;
  }
  getBaseVariableName() {
    const original = this.getOriginalVariable();
    if (original === this) {
      return super.getBaseVariableName();
    }
    else {
      return original.getBaseVariableName();
    }
  }
  getName() {
    const original = this.getOriginalVariable();
    if (original === this) {
      return super.getName();
    }
    else {
      return original.getName();
    }
  }
  getOriginalVariable() {
    if (this.originalVariable === null) {
      if (!this.originalId || (!this.hasId && this.originalId.variable.isReassigned)) {
        this.originalVariable = this;
      }
      else {
        const assignedOriginal = this.originalId.variable;
        this.originalVariable =
          assignedOriginal instanceof ExportDefaultVariable
            ? assignedOriginal.getOriginalVariable()
            : assignedOriginal;
      }
    }
    return this.originalVariable;
  }
  setRenderNames(baseName, name) {
    const original = this.getOriginalVariable();
    if (original === this) {
      super.setRenderNames(baseName, name);
    }
    else {
      original.setRenderNames(baseName, name);
    }
  }
  setSafeName(name) {
    const original = this.getOriginalVariable();
    if (original === this) {
      super.setSafeName(name);
    }
    else {
      original.setSafeName(name);
    }
  }
}

const MISSING_EXPORT_SHIM_VARIABLE = '_missingExportShim';
const INTEROP_DEFAULT_VARIABLE = '_interopDefault';
const INTEROP_NAMESPACE_VARIABLE = '_interopNamespace';

class ExportShimVariable extends Variable {
  constructor(module) {
    super(MISSING_EXPORT_SHIM_VARIABLE);
    this.module = module;
  }
}

class NamespaceVariable extends Variable {
  constructor(context, syntheticNamedExports) {
    super(context.getModuleName());
    this.memberVariables = Object.create(null);
    this.containsExternalNamespace = false;
    this.referencedEarly = false;
    this.references = [];
    this.context = context;
    this.module = context.module;
    this.syntheticNamedExports = syntheticNamedExports;
  }
  addReference(identifier) {
    this.references.push(identifier);
    this.name = identifier.name;
  }
  // This is only called if "UNKNOWN_PATH" is reassigned as in all other situations, either the
  // build fails due to an illegal namespace reassignment or MemberExpression already forwards
  // the reassignment to the right variable. This means we lost track of this variable and thus
  // need to reassign all exports.
  deoptimizePath() {
    for (const key in this.memberVariables) {
      this.memberVariables[key].deoptimizePath(UNKNOWN_PATH);
    }
  }
  include(context) {
    if (!this.included) {
      if (this.containsExternalNamespace) {
        return this.context.error({
          code: 'NAMESPACE_CANNOT_CONTAIN_EXTERNAL',
          id: this.module.id,
          message: `Cannot create an explicit namespace object for module "${this.context.getModuleName()}" because it contains a reexported external namespace`
        });
      }
      this.included = true;
      for (const identifier of this.references) {
        if (identifier.context.getModuleExecIndex() <= this.context.getModuleExecIndex()) {
          this.referencedEarly = true;
          break;
        }
      }
      if (this.context.preserveModules) {
        for (const memberName of Object.keys(this.memberVariables))
          this.memberVariables[memberName].include(context);
      }
      else {
        for (const memberName of Object.keys(this.memberVariables))
          this.context.includeVariable(context, this.memberVariables[memberName]);
      }
    }
  }
  initialise() {
    for (const name of this.context.getExports().concat(this.context.getReexports())) {
      if (name[0] === '*' && name.length > 1)
        this.containsExternalNamespace = true;
      this.memberVariables[name] = this.context.traceExport(name);
    }
  }
  renderBlock(options) {
    const _ = options.compact ? '' : ' ';
    const n = options.compact ? '' : '\n';
    const t = options.indent;
    const members = Object.keys(this.memberVariables).map(name => {
      const original = this.memberVariables[name];
      if (this.referencedEarly || original.isReassigned) {
        return `${t}get ${name}${_}()${_}{${_}return ${original.getName()}${options.compact ? '' : ';'}${_}}`;
      }
      const safeName = RESERVED_NAMES[name] ? `'${name}'` : name;
      return `${t}${safeName}: ${original.getName()}`;
    });
    members.unshift(`${t}__proto__:${_}null`);
    if (options.namespaceToStringTag) {
      members.unshift(`${t}[Symbol.toStringTag]:${_}'Module'`);
    }
    const name = this.getName();
    let output = `{${n}${members.join(`,${n}`)}${n}}`;
    if (this.syntheticNamedExports) {
      output = `/*#__PURE__*/Object.assign(${output}, ${this.module.getDefaultExport().getName()})`;
    }
    if (options.freeze) {
      output = `/*#__PURE__*/Object.freeze(${output})`;
    }
    output = `${options.varOrConst} ${name}${_}=${_}${output};`;
    if (options.format === 'system' && this.exportName) {
      output += `${n}exports('${this.exportName}',${_}${name});`;
    }
    return output;
  }
  renderFirst() {
    return this.referencedEarly;
  }
}
NamespaceVariable.prototype.isNamespace = true;

const esModuleExport = `Object.defineProperty(exports, '__esModule', { value: true });`;
const compactEsModuleExport = `Object.defineProperty(exports,'__esModule',{value:true});`;

function getExportBlock(exports, dependencies, namedExportsMode, interop, compact, t, mechanism = 'return ') {
  const _ = compact ? '' : ' ';
  const n = compact ? '' : '\n';
  if (!namedExportsMode) {
    let local;
    if (exports.length > 0) {
      local = exports[0].local;
    }
    else {
      for (const dep of dependencies) {
        if (dep.reexports) {
          const expt = dep.reexports[0];
          local =
            dep.namedExportsMode && expt.imported !== '*' && expt.imported !== 'default'
              ? `${dep.name}.${expt.imported}`
              : dep.name;
          break;
        }
      }
    }
    return `${mechanism}${local};`;
  }
  let exportBlock = '';
  // star exports must always output first for precedence
  for (const { name, reexports } of dependencies) {
    if (reexports && namedExportsMode) {
      for (const specifier of reexports) {
        if (specifier.reexported === '*') {
          if (exportBlock)
            exportBlock += n;
          if (specifier.needsLiveBinding) {
            exportBlock +=
              `Object.keys(${name}).forEach(function${_}(k)${_}{${n}` +
                `${t}if${_}(k${_}!==${_}'default')${_}Object.defineProperty(exports,${_}k,${_}{${n}` +
                `${t}${t}enumerable:${_}true,${n}` +
                `${t}${t}get:${_}function${_}()${_}{${n}` +
                `${t}${t}${t}return ${name}[k];${n}` +
                `${t}${t}}${n}${t}});${n}});`;
          }
          else {
            exportBlock +=
              `Object.keys(${name}).forEach(function${_}(k)${_}{${n}` +
                `${t}if${_}(k${_}!==${_}'default')${_}exports[k]${_}=${_}${name}[k];${n}});`;
          }
        }
      }
    }
  }
  for (const { name, imports, reexports, isChunk, namedExportsMode: depNamedExportsMode, exportsNames } of dependencies) {
    if (reexports && namedExportsMode) {
      for (const specifier of reexports) {
        if (specifier.imported === 'default' && !isChunk) {
          if (exportBlock)
            exportBlock += n;
          if (exportsNames &&
            (reexports.some(specifier => specifier.imported === 'default'
              ? specifier.reexported === 'default'
              : specifier.imported !== '*') ||
              (imports && imports.some(specifier => specifier.imported !== 'default')))) {
            exportBlock += `exports.${specifier.reexported}${_}=${_}${name}${interop !== false ? '__default' : '.default'};`;
          }
          else {
            exportBlock += `exports.${specifier.reexported}${_}=${_}${name};`;
          }
        }
        else if (specifier.imported !== '*') {
          if (exportBlock)
            exportBlock += n;
          const importName = specifier.imported === 'default' && !depNamedExportsMode
            ? name
            : `${name}.${specifier.imported}`;
          exportBlock += specifier.needsLiveBinding
            ? `Object.defineProperty(exports,${_}'${specifier.reexported}',${_}{${n}` +
              `${t}enumerable:${_}true,${n}` +
              `${t}get:${_}function${_}()${_}{${n}` +
              `${t}${t}return ${importName};${n}${t}}${n}});`
            : `exports.${specifier.reexported}${_}=${_}${importName};`;
        }
        else if (specifier.reexported !== '*') {
          if (exportBlock)
            exportBlock += n;
          exportBlock += `exports.${specifier.reexported}${_}=${_}${name};`;
        }
      }
    }
  }
  for (const expt of exports) {
    const lhs = `exports.${expt.exported}`;
    const rhs = expt.local;
    if (lhs !== rhs) {
      if (exportBlock)
        exportBlock += n;
      exportBlock += `${lhs}${_}=${_}${rhs};`;
    }
  }
  return exportBlock;
}

function getInteropBlock(dependencies, options, varOrConst) {
  const _ = options.compact ? '' : ' ';
  return dependencies
    .map(({ name, exportsNames, exportsDefault, namedExportsMode }) => {
    if (!namedExportsMode || !exportsDefault || options.interop === false)
      return null;
    if (exportsNames) {
      return (`${varOrConst} ${name}__default${_}=${_}'default'${_}in ${name}${_}?` +
        `${_}${name}['default']${_}:${_}${name};`);
    }
    return (`${name}${_}=${_}${name}${_}&&${_}${name}.hasOwnProperty('default')${_}?` +
      `${_}${name}['default']${_}:${_}${name};`);
  })
    .filter(Boolean)
    .join(options.compact ? '' : '\n');
}

function copyPropertyLiveBinding(_, n, t, i) {
  return (`${i}var d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
    `${i}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
    `${i}${t}enumerable:${_}true,${n}` +
    `${i}${t}get:${_}function${_}()${_}{${n}` +
    `${i}${t}${t}return e[k];${n}` +
    `${i}${t}}${n}` +
    `${i}});${n}`);
}
function copyPropertyStatic(_, n, _t, i) {
  return `${i}n[k]${_}=e${_}[k];${n}`;
}
function getInteropNamespace(_, n, t, liveBindings) {
  return (`function ${INTEROP_NAMESPACE_VARIABLE}(e)${_}{${n}` +
    `${t}if${_}(e${_}&&${_}e.__esModule)${_}{${_}return e;${_}}${_}else${_}{${n}` +
    `${t}${t}var n${_}=${_}{};${n}` +
    `${t}${t}if${_}(e)${_}{${n}` +
    `${t}${t}${t}Object.keys(e).forEach(function${_}(k)${_}{${n}` +
    (liveBindings ? copyPropertyLiveBinding : copyPropertyStatic)(_, n, t, t + t + t + t) +
    `${t}${t}${t}});${n}` +
    `${t}${t}}${n}` +
    `${t}${t}n['default']${_}=${_}e;${n}` +
    `${t}${t}return n;${n}` +
    `${t}}${n}` +
    `}${n}${n}`);
}

const builtins$1$1 = {
  assert: true,
  buffer: true,
  console: true,
  constants: true,
  domain: true,
  events: true,
  http: true,
  https: true,
  os: true,
  path: true,
  process: true,
  punycode: true,
  querystring: true,
  stream: true,
  string_decoder: true,
  timers: true,
  tty: true,
  url: true,
  util: true,
  vm: true,
  zlib: true
};
// Creating a browser chunk that depends on Node.js built-in modules ('util'). You might need to include https://www.npmjs.com/package/rollup-plugin-node-builtins
function warnOnBuiltins(warn, dependencies) {
  const externalBuiltins = dependencies.map(({ id }) => id).filter(id => id in builtins$1$1);
  if (!externalBuiltins.length)
    return;
  const detail = externalBuiltins.length === 1
    ? `module ('${externalBuiltins[0]}')`
    : `modules (${externalBuiltins
      .slice(0, -1)
      .map(name => `'${name}'`)
      .join(', ')} and '${externalBuiltins.slice(-1)}')`;
  warn({
    code: 'MISSING_NODE_BUILTINS',
    message: `Creating a browser bundle that depends on Node.js built-in ${detail}. You might need to include https://www.npmjs.com/package/rollup-plugin-node-builtins`,
    modules: externalBuiltins
  });
}

// AMD resolution will only respect the AMD baseUrl if the .js extension is omitted.
// The assumption is that this makes sense for all relative ids:
// https://requirejs.org/docs/api.html#jsfiles
function removeExtensionFromRelativeAmdId(id) {
  if (id[0] === '.' && id.endsWith('.js')) {
    return id.slice(0, -3);
  }
  return id;
}
function amd(magicString, { accessedGlobals, dependencies, exports, hasExports, indentString: t, intro, isEntryModuleFacade, namedExportsMode, outro, varOrConst, warn }, options) {
  warnOnBuiltins(warn, dependencies);
  const deps = dependencies.map(m => `'${removeExtensionFromRelativeAmdId(m.id)}'`);
  const args = dependencies.map(m => m.name);
  const n = options.compact ? '' : '\n';
  const _ = options.compact ? '' : ' ';
  if (namedExportsMode && hasExports) {
    args.unshift(`exports`);
    deps.unshift(`'exports'`);
  }
  if (accessedGlobals.has('require')) {
    args.unshift('require');
    deps.unshift(`'require'`);
  }
  if (accessedGlobals.has('module')) {
    args.unshift('module');
    deps.unshift(`'module'`);
  }
  const amdOptions = options.amd || {};
  const params = (amdOptions.id ? `'${amdOptions.id}',${_}` : ``) +
    (deps.length ? `[${deps.join(`,${_}`)}],${_}` : ``);
  const useStrict = options.strict !== false ? `${_}'use strict';` : ``;
  const define = amdOptions.define || 'define';
  const wrapperStart = `${define}(${params}function${_}(${args.join(`,${_}`)})${_}{${useStrict}${n}${n}`;
  // var foo__default = 'default' in foo ? foo['default'] : foo;
  const interopBlock = getInteropBlock(dependencies, options, varOrConst);
  if (interopBlock) {
    magicString.prepend(interopBlock + n + n);
  }
  if (accessedGlobals.has(INTEROP_NAMESPACE_VARIABLE)) {
    magicString.prepend(getInteropNamespace(_, n, t, options.externalLiveBindings !== false));
  }
  if (intro)
    magicString.prepend(intro);
  const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);
  if (exportBlock)
    magicString.append(n + n + exportBlock);
  if (namedExportsMode && hasExports && isEntryModuleFacade && options.esModule)
    magicString.append(`${n}${n}${options.compact ? compactEsModuleExport : esModuleExport}`);
  if (outro)
    magicString.append(outro);
  return magicString
    .indent(t)
    .append(n + n + '});')
    .prepend(wrapperStart);
}

function cjs(magicString, { accessedGlobals, dependencies, exports, hasExports, indentString: t, intro, isEntryModuleFacade, namedExportsMode, outro, varOrConst }, options) {
  const n = options.compact ? '' : '\n';
  const _ = options.compact ? '' : ' ';
  intro =
    (options.strict === false ? intro : `'use strict';${n}${n}${intro}`) +
      (namedExportsMode && hasExports && isEntryModuleFacade && options.esModule
        ? `${options.compact ? compactEsModuleExport : esModuleExport}${n}${n}`
        : '');
  let needsInterop = false;
  const interop = options.interop !== false;
  let importBlock;
  let definingVariable = false;
  importBlock = '';
  for (const { id, namedExportsMode, isChunk, name, reexports, imports, exportsNames, exportsDefault } of dependencies) {
    if (!reexports && !imports) {
      if (importBlock) {
        importBlock += !options.compact || definingVariable ? `;${n}` : ',';
      }
      definingVariable = false;
      importBlock += `require('${id}')`;
    }
    else {
      importBlock +=
        options.compact && definingVariable ? ',' : `${importBlock ? `;${n}` : ''}${varOrConst} `;
      definingVariable = true;
      if (!interop || isChunk || !exportsDefault || !namedExportsMode) {
        importBlock += `${name}${_}=${_}require('${id}')`;
      }
      else {
        needsInterop = true;
        if (exportsNames)
          importBlock += `${name}${_}=${_}require('${id}')${options.compact ? ',' : `;\n${varOrConst} `}${name}__default${_}=${_}${INTEROP_DEFAULT_VARIABLE}(${name})`;
        else
          importBlock += `${name}${_}=${_}${INTEROP_DEFAULT_VARIABLE}(require('${id}'))`;
      }
    }
  }
  if (importBlock)
    importBlock += ';';
  if (needsInterop) {
    const ex = options.compact ? 'e' : 'ex';
    intro +=
      `function ${INTEROP_DEFAULT_VARIABLE}${_}(${ex})${_}{${_}return${_}` +
        `(${ex}${_}&&${_}(typeof ${ex}${_}===${_}'object')${_}&&${_}'default'${_}in ${ex})${_}` +
        `?${_}${ex}['default']${_}:${_}${ex}${options.compact ? '' : '; '}}${n}${n}`;
  }
  if (accessedGlobals.has(INTEROP_NAMESPACE_VARIABLE)) {
    intro += getInteropNamespace(_, n, t, options.externalLiveBindings !== false);
  }
  if (importBlock)
    intro += importBlock + n + n;
  const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t, `module.exports${_}=${_}`);
  magicString.prepend(intro);
  if (exportBlock)
    magicString.append(n + n + exportBlock);
  if (outro)
    magicString.append(outro);
  return magicString;
}

function esm(magicString, { intro, outro, dependencies, exports }, options) {
  const _ = options.compact ? '' : ' ';
  const n = options.compact ? '' : '\n';
  const importBlock = getImportBlock(dependencies, _);
  if (importBlock.length > 0)
    intro += importBlock.join(n) + n + n;
  if (intro)
    magicString.prepend(intro);
  const exportBlock = getExportBlock$1(exports, _);
  if (exportBlock.length)
    magicString.append(n + n + exportBlock.join(n).trim());
  if (outro)
    magicString.append(outro);
  return magicString.trim();
}
function getImportBlock(dependencies, _) {
  const importBlock = [];
  for (const { id, reexports, imports, name } of dependencies) {
    if (!reexports && !imports) {
      importBlock.push(`import${_}'${id}';`);
      continue;
    }
    if (imports) {
      let defaultImport = null;
      let starImport = null;
      const importedNames = [];
      for (const specifier of imports) {
        if (specifier.imported === 'default') {
          defaultImport = specifier;
        }
        else if (specifier.imported === '*') {
          starImport = specifier;
        }
        else {
          importedNames.push(specifier);
        }
      }
      if (starImport) {
        importBlock.push(`import${_}*${_}as ${starImport.local} from${_}'${id}';`);
      }
      if (defaultImport && importedNames.length === 0) {
        importBlock.push(`import ${defaultImport.local} from${_}'${id}';`);
      }
      else if (importedNames.length > 0) {
        importBlock.push(`import ${defaultImport ? `${defaultImport.local},${_}` : ''}{${_}${importedNames
          .map(specifier => {
          if (specifier.imported === specifier.local) {
            return specifier.imported;
          }
          else {
            return `${specifier.imported} as ${specifier.local}`;
          }
        })
          .join(`,${_}`)}${_}}${_}from${_}'${id}';`);
      }
    }
    if (reexports) {
      let starExport = null;
      const namespaceReexports = [];
      const namedReexports = [];
      for (const specifier of reexports) {
        if (specifier.reexported === '*') {
          starExport = specifier;
        }
        else if (specifier.imported === '*') {
          namespaceReexports.push(specifier);
        }
        else {
          namedReexports.push(specifier);
        }
      }
      if (starExport) {
        importBlock.push(`export${_}*${_}from${_}'${id}';`);
      }
      if (namespaceReexports.length > 0) {
        if (!imports ||
          !imports.some(specifier => specifier.imported === '*' && specifier.local === name)) {
          importBlock.push(`import${_}*${_}as ${name} from${_}'${id}';`);
        }
        for (const specifier of namespaceReexports) {
          importBlock.push(`export${_}{${_}${name === specifier.reexported ? name : `${name} as ${specifier.reexported}`} };`);
        }
      }
      if (namedReexports.length > 0) {
        importBlock.push(`export${_}{${_}${namedReexports
          .map(specifier => {
          if (specifier.imported === specifier.reexported) {
            return specifier.imported;
          }
          else {
            return `${specifier.imported} as ${specifier.reexported}`;
          }
        })
          .join(`,${_}`)}${_}}${_}from${_}'${id}';`);
      }
    }
  }
  return importBlock;
}
function getExportBlock$1(exports, _) {
  const exportBlock = [];
  const exportDeclaration = [];
  for (const specifier of exports) {
    if (specifier.exported === 'default') {
      exportBlock.push(`export default ${specifier.local};`);
    }
    else {
      exportDeclaration.push(specifier.exported === specifier.local
        ? specifier.local
        : `${specifier.local} as ${specifier.exported}`);
    }
  }
  if (exportDeclaration.length) {
    exportBlock.push(`export${_}{${_}${exportDeclaration.join(`,${_}`)}${_}};`);
  }
  return exportBlock;
}

function spaces(i) {
  let result = '';
  while (i--)
    result += ' ';
  return result;
}
function tabsToSpaces(str) {
  return str.replace(/^\t+/, match => match.split('\t').join('  '));
}
function getCodeFrame(source, line, column) {
  let lines = source.split('\n');
  const frameStart = Math.max(0, line - 3);
  let frameEnd = Math.min(line + 2, lines.length);
  lines = lines.slice(frameStart, frameEnd);
  while (!/\S/.test(lines[lines.length - 1])) {
    lines.pop();
    frameEnd -= 1;
  }
  const digits = String(frameEnd).length;
  return lines
    .map((str, i) => {
    const isErrorLine = frameStart + i + 1 === line;
    let lineNum = String(i + frameStart + 1);
    while (lineNum.length < digits)
      lineNum = ` ${lineNum}`;
    if (isErrorLine) {
      const indicator = spaces(digits + 2 + tabsToSpaces(str.slice(0, column)).length) + '^';
      return `${lineNum}: ${tabsToSpaces(str)}\n${indicator}`;
    }
    return `${lineNum}: ${tabsToSpaces(str)}`;
  })
    .join('\n');
}

function sanitizeFileName(name) {
  return name.replace(/[\0?*]/g, '_');
}

function getAliasName(id) {
  const base = basename(id);
  return base.substr(0, base.length - extname(id).length);
}
function relativeId(id) {
  if (typeof process === 'undefined' || !isAbsolute$1(id))
    return id;
  return relative(process.cwd(), id);
}
function isPlainPathFragment(name) {
  // not starting with "/", "./", "../"
  return (name[0] !== '/' &&
    !(name[0] === '.' && (name[1] === '/' || name[1] === '.')) &&
    sanitizeFileName(name) === name);
}

function error(base, props) {
  if (!(base instanceof Error))
    base = Object.assign(new Error(base.message), base);
  if (props)
    Object.assign(base, props);
  throw base;
}
function augmentCodeLocation(object, pos, source, id) {
  if (typeof pos === 'object') {
    const { line, column } = pos;
    object.loc = { file: id, line, column };
  }
  else {
    object.pos = pos;
    const { line, column } = locate(source, pos, { offsetLine: 1 });
    object.loc = { file: id, line, column };
  }
  if (object.frame === undefined) {
    const { line, column } = object.loc;
    object.frame = getCodeFrame(source, line, column);
  }
}
var Errors;
(function (Errors) {
  Errors["ASSET_NOT_FINALISED"] = "ASSET_NOT_FINALISED";
  Errors["ASSET_NOT_FOUND"] = "ASSET_NOT_FOUND";
  Errors["ASSET_SOURCE_ALREADY_SET"] = "ASSET_SOURCE_ALREADY_SET";
  Errors["ASSET_SOURCE_MISSING"] = "ASSET_SOURCE_MISSING";
  Errors["BAD_LOADER"] = "BAD_LOADER";
  Errors["CANNOT_EMIT_FROM_OPTIONS_HOOK"] = "CANNOT_EMIT_FROM_OPTIONS_HOOK";
  Errors["CHUNK_NOT_GENERATED"] = "CHUNK_NOT_GENERATED";
  Errors["DEPRECATED_FEATURE"] = "DEPRECATED_FEATURE";
  Errors["FILE_NOT_FOUND"] = "FILE_NOT_FOUND";
  Errors["FILE_NAME_CONFLICT"] = "FILE_NAME_CONFLICT";
  Errors["INPUT_HOOK_IN_OUTPUT_PLUGIN"] = "INPUT_HOOK_IN_OUTPUT_PLUGIN";
  Errors["INVALID_CHUNK"] = "INVALID_CHUNK";
  Errors["INVALID_EXPORT_OPTION"] = "INVALID_EXPORT_OPTION";
  Errors["INVALID_EXTERNAL_ID"] = "INVALID_EXTERNAL_ID";
  Errors["INVALID_OPTION"] = "INVALID_OPTION";
  Errors["INVALID_PLUGIN_HOOK"] = "INVALID_PLUGIN_HOOK";
  Errors["INVALID_ROLLUP_PHASE"] = "INVALID_ROLLUP_PHASE";
  Errors["MIXED_EXPORTS"] = "MIXED_EXPORTS";
  Errors["NAMESPACE_CONFLICT"] = "NAMESPACE_CONFLICT";
  Errors["PLUGIN_ERROR"] = "PLUGIN_ERROR";
  Errors["UNRESOLVED_ENTRY"] = "UNRESOLVED_ENTRY";
  Errors["UNRESOLVED_IMPORT"] = "UNRESOLVED_IMPORT";
  Errors["VALIDATION_ERROR"] = "VALIDATION_ERROR";
  Errors["EXTERNAL_SYNTHETIC_EXPORTS"] = "EXTERNAL_SYNTHETIC_EXPORTS";
  Errors["SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT"] = "SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT";
})(Errors || (Errors = {}));
function errAssetNotFinalisedForFileName(name) {
  return {
    code: Errors.ASSET_NOT_FINALISED,
    message: `Plugin error - Unable to get file name for asset "${name}". Ensure that the source is set and that generate is called first.`
  };
}
function errCannotEmitFromOptionsHook() {
  return {
    code: Errors.CANNOT_EMIT_FROM_OPTIONS_HOOK,
    message: `Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.`
  };
}
function errChunkNotGeneratedForFileName(name) {
  return {
    code: Errors.CHUNK_NOT_GENERATED,
    message: `Plugin error - Unable to get file name for chunk "${name}". Ensure that generate is called first.`
  };
}
function errAssetReferenceIdNotFoundForSetSource(assetReferenceId) {
  return {
    code: Errors.ASSET_NOT_FOUND,
    message: `Plugin error - Unable to set the source for unknown asset "${assetReferenceId}".`
  };
}
function errAssetSourceAlreadySet(name) {
  return {
    code: Errors.ASSET_SOURCE_ALREADY_SET,
    message: `Unable to set the source for asset "${name}", source already set.`
  };
}
function errNoAssetSourceSet(assetName) {
  return {
    code: Errors.ASSET_SOURCE_MISSING,
    message: `Plugin error creating asset "${assetName}" - no asset source set.`
  };
}
function errBadLoader(id) {
  return {
    code: Errors.BAD_LOADER,
    message: `Error loading ${relativeId(id)}: plugin load hook should return a string, a { code, map } object, or nothing/null`
  };
}
function errDeprecation(deprecation) {
  return Object.assign({ code: Errors.DEPRECATED_FEATURE }, (typeof deprecation === 'string' ? { message: deprecation } : deprecation));
}
function errFileReferenceIdNotFoundForFilename(assetReferenceId) {
  return {
    code: Errors.FILE_NOT_FOUND,
    message: `Plugin error - Unable to get file name for unknown file "${assetReferenceId}".`
  };
}
function errFileNameConflict(fileName) {
  return {
    code: Errors.FILE_NAME_CONFLICT,
    message: `The emitted file "${fileName}" overwrites a previously emitted file of the same name.`
  };
}
function errInputHookInOutputPlugin(pluginName, hookName) {
  return {
    code: Errors.INPUT_HOOK_IN_OUTPUT_PLUGIN,
    message: `The "${hookName}" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`
  };
}
function errCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {
  return {
    code: Errors.INVALID_CHUNK,
    message: `Cannot assign ${relativeId(moduleId)} to the "${assignToAlias}" chunk as it is already in the "${currentAlias}" chunk.`
  };
}
function errInvalidExportOptionValue(optionValue) {
  return {
    code: Errors.INVALID_EXPORT_OPTION,
    message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${optionValue}"`,
    url: `https://rollupjs.org/guide/en/#output-exports`
  };
}
function errIncompatibleExportOptionValue(optionValue, keys, entryModule) {
  return {
    code: 'INVALID_EXPORT_OPTION',
    message: `"${optionValue}" was specified for "output.exports", but entry module "${relativeId(entryModule)}" has the following exports: ${keys.join(', ')}`
  };
}
function errInternalIdCannotBeExternal(source, importer) {
  return {
    code: Errors.INVALID_EXTERNAL_ID,
    message: `'${source}' is imported as an external by ${relativeId(importer)}, but is already an existing non-external module id.`
  };
}
function errInvalidOption(option, explanation) {
  return {
    code: Errors.INVALID_OPTION,
    message: `Invalid value for option "${option}" - ${explanation}.`
  };
}
function errInvalidRollupPhaseForAddWatchFile() {
  return {
    code: Errors.INVALID_ROLLUP_PHASE,
    message: `Cannot call addWatchFile after the build has finished.`
  };
}
function errInvalidRollupPhaseForChunkEmission() {
  return {
    code: Errors.INVALID_ROLLUP_PHASE,
    message: `Cannot emit chunks after module loading has finished.`
  };
}
function errMixedExport(facadeModuleId, name) {
  return {
    code: Errors.MIXED_EXPORTS,
    id: facadeModuleId,
    message: `Entry module "${relativeId(facadeModuleId)}" is using named and default exports together. Consumers of your bundle will have to use \`${name ||
      'chunk'}["default"]\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning`,
    url: `https://rollupjs.org/guide/en/#output-exports`
  };
}
function errNamespaceConflict(name, reexportingModule, additionalExportAllModule) {
  return {
    code: Errors.NAMESPACE_CONFLICT,
    message: `Conflicting namespaces: ${relativeId(reexportingModule.id)} re-exports '${name}' from both ${relativeId(reexportingModule.exportsAll[name])} and ${relativeId(additionalExportAllModule.exportsAll[name])} (will be ignored)`,
    name,
    reexporter: reexportingModule.id,
    sources: [reexportingModule.exportsAll[name], additionalExportAllModule.exportsAll[name]]
  };
}
function errEntryCannotBeExternal(unresolvedId) {
  return {
    code: Errors.UNRESOLVED_ENTRY,
    message: `Entry module cannot be external (${relativeId(unresolvedId)}).`
  };
}
function errUnresolvedEntry(unresolvedId) {
  return {
    code: Errors.UNRESOLVED_ENTRY,
    message: `Could not resolve entry module (${relativeId(unresolvedId)}).`
  };
}
function errUnresolvedImport(source, importer) {
  return {
    code: Errors.UNRESOLVED_IMPORT,
    message: `Could not resolve '${source}' from ${relativeId(importer)}`
  };
}
function errUnresolvedImportTreatedAsExternal(source, importer) {
  return {
    code: Errors.UNRESOLVED_IMPORT,
    importer: relativeId(importer),
    message: `'${source}' is imported by ${relativeId(importer)}, but could not be resolved – treating it as an external dependency`,
    source,
    url: 'https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency'
  };
}
function errExternalSyntheticExports(source, importer) {
  return {
    code: Errors.EXTERNAL_SYNTHETIC_EXPORTS,
    importer: relativeId(importer),
    message: `External '${source}' can not have 'syntheticNamedExports' enabled.`,
    source
  };
}
function errFailedValidation(message) {
  return {
    code: Errors.VALIDATION_ERROR,
    message
  };
}

// Generate strings which dereference dotted properties, but use array notation `['prop-deref']`
// if the property name isn't trivial
const shouldUseDot = /^[a-zA-Z$_][a-zA-Z0-9$_]*$/;
function property(prop) {
  return shouldUseDot.test(prop) ? `.${prop}` : `['${prop}']`;
}
function keypath(keypath) {
  return keypath
    .split('.')
    .map(property)
    .join('');
}

function setupNamespace(name, root, globals, compact) {
  const parts = name.split('.');
  if (globals) {
    parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];
  }
  const _ = compact ? '' : ' ';
  parts.pop();
  let acc = root;
  return (parts
    .map(part => ((acc += property(part)), `${acc}${_}=${_}${acc}${_}||${_}{}${compact ? '' : ';'}`))
    .join(compact ? ',' : '\n') + (compact && parts.length ? ';' : '\n'));
}
function assignToDeepVariable(deepName, root, globals, compact, assignment) {
  const _ = compact ? '' : ' ';
  const parts = deepName.split('.');
  if (globals) {
    parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];
  }
  const last = parts.pop();
  let acc = root;
  let deepAssignment = parts
    .map(part => ((acc += property(part)), `${acc}${_}=${_}${acc}${_}||${_}{}`))
    .concat(`${acc}${property(last)}`)
    .join(`,${_}`)
    .concat(`${_}=${_}${assignment}`);
  if (parts.length > 0) {
    deepAssignment = `(${deepAssignment})`;
  }
  return deepAssignment;
}

function trimEmptyImports(dependencies) {
  let i = dependencies.length;
  while (i--) {
    const dependency = dependencies[i];
    if (dependency.exportsDefault || dependency.exportsNames) {
      return dependencies.slice(0, i + 1);
    }
  }
  return [];
}

const thisProp = (name) => `this${keypath(name)}`;
function iife(magicString, { dependencies, exports, hasExports, indentString: t, intro, namedExportsMode, outro, varOrConst, warn }, options) {
  const _ = options.compact ? '' : ' ';
  const n = options.compact ? '' : '\n';
  const { extend, name } = options;
  const isNamespaced = name && name.indexOf('.') !== -1;
  const useVariableAssignment = !extend && !isNamespaced;
  if (name && useVariableAssignment && !isLegal(name)) {
    return error({
      code: 'ILLEGAL_IDENTIFIER_AS_NAME',
      message: `Given name "${name}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`
    });
  }
  warnOnBuiltins(warn, dependencies);
  const external = trimEmptyImports(dependencies);
  const deps = external.map(dep => dep.globalName || 'null');
  const args = external.map(m => m.name);
  if (hasExports && !name) {
    warn({
      message: `If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.`
    });
  }
  if (namedExportsMode && hasExports) {
    if (extend) {
      deps.unshift(`${thisProp(name)}${_}=${_}${thisProp(name)}${_}||${_}{}`);
      args.unshift('exports');
    }
    else {
      deps.unshift('{}');
      args.unshift('exports');
    }
  }
  const useStrict = options.strict !== false ? `${t}'use strict';${n}${n}` : ``;
  let wrapperIntro = `(function${_}(${args.join(`,${_}`)})${_}{${n}${useStrict}`;
  if (hasExports && (!extend || !namedExportsMode) && name) {
    wrapperIntro =
      (useVariableAssignment ? `${varOrConst} ${name}` : thisProp(name)) +
        `${_}=${_}${wrapperIntro}`;
  }
  if (isNamespaced && hasExports) {
    wrapperIntro = setupNamespace(name, 'this', options.globals, options.compact) + wrapperIntro;
  }
  let wrapperOutro = `${n}${n}}(${deps.join(`,${_}`)}));`;
  if (!extend && namedExportsMode && hasExports) {
    wrapperOutro = `${n}${n}${t}return exports;${wrapperOutro}`;
  }
  // var foo__default = 'default' in foo ? foo['default'] : foo;
  const interopBlock = getInteropBlock(dependencies, options, varOrConst);
  if (interopBlock)
    magicString.prepend(interopBlock + n + n);
  if (intro)
    magicString.prepend(intro);
  const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);
  if (exportBlock)
    magicString.append(n + n + exportBlock);
  if (outro)
    magicString.append(outro);
  return magicString
    .indent(t)
    .prepend(wrapperIntro)
    .append(wrapperOutro);
}

function getStarExcludes({ dependencies, exports }) {
  const starExcludes = new Set(exports.map(expt => expt.exported));
  if (!starExcludes.has('default'))
    starExcludes.add('default');
  // also include reexport names
  for (const { reexports } of dependencies) {
    if (reexports) {
      for (const reexport of reexports) {
        if (reexport.imported !== '*' && !starExcludes.has(reexport.reexported))
          starExcludes.add(reexport.reexported);
      }
    }
  }
  return starExcludes;
}
const getStarExcludesBlock = (starExcludes, varOrConst, _, t, n) => starExcludes
  ? `${n}${t}${varOrConst} _starExcludes${_}=${_}{${_}${Array.from(starExcludes).join(`:${_}1,${_}`)}${starExcludes.size ? `:${_}1` : ''}${_}};`
  : '';
const getImportBindingsBlock = (importBindings, _, t, n) => (importBindings.length ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '');
function getExportsBlock(exports, _, t, n) {
  if (exports.length === 0) {
    return '';
  }
  if (exports.length === 1) {
    return `${t}${t}${t}exports('${exports[0].name}',${_}${exports[0].value});${n}${n}`;
  }
  return (`${t}${t}${t}exports({${n}` +
    exports.map(({ name, value }) => `${t}${t}${t}${t}${name}:${_}${value}`).join(`,${n}`) +
    `${n}${t}${t}${t}});${n}${n}`);
}
const getHoistedExportsBlock = (exports, _, t, n) => getExportsBlock(exports
  .filter(expt => expt.hoisted || expt.uninitialized)
  .map(expt => ({ name: expt.exported, value: expt.uninitialized ? 'void 0' : expt.local })), _, t, n);
const getMissingExportsBlock = (exports, _, t, n) => getExportsBlock(exports
  .filter(expt => expt.local === MISSING_EXPORT_SHIM_VARIABLE)
  .map(expt => ({ name: expt.exported, value: MISSING_EXPORT_SHIM_VARIABLE })), _, t, n);
function system(magicString, { accessedGlobals, dependencies, exports, hasExports, indentString: t, intro, outro, usesTopLevelAwait, varOrConst }, options) {
  const n = options.compact ? '' : '\n';
  const _ = options.compact ? '' : ' ';
  const dependencyIds = dependencies.map(m => `'${m.id}'`);
  const importBindings = [];
  let starExcludes;
  const setters = [];
  for (const { imports, reexports } of dependencies) {
    const setter = [];
    if (imports) {
      for (const specifier of imports) {
        importBindings.push(specifier.local);
        if (specifier.imported === '*') {
          setter.push(`${specifier.local}${_}=${_}module;`);
        }
        else {
          setter.push(`${specifier.local}${_}=${_}module.${specifier.imported};`);
        }
      }
    }
    if (reexports) {
      let createdSetter = false;
      // bulk-reexport form
      if (reexports.length > 1 ||
        (reexports.length === 1 &&
          (reexports[0].reexported === '*' || reexports[0].imported === '*'))) {
        // star reexports
        for (const specifier of reexports) {
          if (specifier.reexported !== '*')
            continue;
          // need own exports list for deduping in star export case
          if (!starExcludes) {
            starExcludes = getStarExcludes({ dependencies, exports });
          }
          if (!createdSetter) {
            setter.push(`${varOrConst} _setter${_}=${_}{};`);
            createdSetter = true;
          }
          setter.push(`for${_}(var _$p${_}in${_}module)${_}{`);
          setter.push(`${t}if${_}(!_starExcludes[_$p])${_}_setter[_$p]${_}=${_}module[_$p];`);
          setter.push('}');
        }
        // star import reexport
        for (const specifier of reexports) {
          if (specifier.imported !== '*' || specifier.reexported === '*')
            continue;
          setter.push(`exports('${specifier.reexported}',${_}module);`);
        }
        // reexports
        for (const specifier of reexports) {
          if (specifier.reexported === '*' || specifier.imported === '*')
            continue;
          if (!createdSetter) {
            setter.push(`${varOrConst} _setter${_}=${_}{};`);
            createdSetter = true;
          }
          setter.push(`_setter.${specifier.reexported}${_}=${_}module.${specifier.imported};`);
        }
        if (createdSetter) {
          setter.push('exports(_setter);');
        }
      }
      else {
        // single reexport
        for (const specifier of reexports) {
          setter.push(`exports('${specifier.reexported}',${_}module.${specifier.imported});`);
        }
      }
    }
    setters.push(setter.join(`${n}${t}${t}${t}`));
  }
  const registeredName = options.name ? `'${options.name}',${_}` : '';
  const wrapperParams = accessedGlobals.has('module')
    ? `exports,${_}module`
    : hasExports
      ? 'exports'
      : '';
  let wrapperStart = `System.register(${registeredName}[` +
    dependencyIds.join(`,${_}`) +
    `],${_}function${_}(${wrapperParams})${_}{${n}${t}${options.strict ? "'use strict';" : ''}` +
    getStarExcludesBlock(starExcludes, varOrConst, _, t, n) +
    getImportBindingsBlock(importBindings, _, t, n) +
    `${n}${t}return${_}{${setters.length
      ? `${n}${t}${t}setters:${_}[${setters
        .map(s => s
        ? `function${_}(module)${_}{${n}${t}${t}${t}${s}${n}${t}${t}}`
        : `function${_}()${_}{}`)
        .join(`,${_}`)}],`
      : ''}${n}`;
  wrapperStart +=
    `${t}${t}execute:${_}${usesTopLevelAwait ? `async${_}` : ''}function${_}()${_}{${n}${n}` +
      getHoistedExportsBlock(exports, _, t, n);
  const wrapperEnd = `${n}${n}` +
    getMissingExportsBlock(exports, _, t, n) +
    `${t}${t}}${n}${t}}${options.compact ? '' : ';'}${n}});`;
  if (intro)
    magicString.prepend(intro);
  if (outro)
    magicString.append(outro);
  return magicString
    .indent(`${t}${t}${t}`)
    .append(wrapperEnd)
    .prepend(wrapperStart);
}

function globalProp(name, globalVar) {
  if (!name)
    return 'null';
  return `${globalVar}${keypath(name)}`;
}
function safeAccess(name, globalVar, _) {
  const parts = name.split('.');
  let acc = globalVar;
  return parts.map(part => ((acc += property(part)), acc)).join(`${_}&&${_}`);
}
function umd(magicString, { dependencies, exports, hasExports, indentString: t, intro, namedExportsMode, outro, varOrConst, warn }, options) {
  const _ = options.compact ? '' : ' ';
  const n = options.compact ? '' : '\n';
  const factoryVar = options.compact ? 'f' : 'factory';
  const globalVar = options.compact ? 'g' : 'global';
  if (hasExports && !options.name) {
    return error({
      code: 'INVALID_OPTION',
      message: 'You must supply "output.name" for UMD bundles.'
    });
  }
  warnOnBuiltins(warn, dependencies);
  const amdDeps = dependencies.map(m => `'${m.id}'`);
  const cjsDeps = dependencies.map(m => `require('${m.id}')`);
  const trimmedImports = trimEmptyImports(dependencies);
  const globalDeps = trimmedImports.map(module => globalProp(module.globalName, globalVar));
  const factoryArgs = trimmedImports.map(m => m.name);
  if (namedExportsMode && (hasExports || options.noConflict === true)) {
    amdDeps.unshift(`'exports'`);
    cjsDeps.unshift(`exports`);
    globalDeps.unshift(assignToDeepVariable(options.name, globalVar, options.globals, options.compact, `${options.extend ? `${globalProp(options.name, globalVar)}${_}||${_}` : ''}{}`));
    factoryArgs.unshift('exports');
  }
  const amdOptions = options.amd || {};
  const amdParams = (amdOptions.id ? `'${amdOptions.id}',${_}` : ``) +
    (amdDeps.length ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);
  const define = amdOptions.define || 'define';
  const cjsExport = !namedExportsMode && hasExports ? `module.exports${_}=${_}` : ``;
  const useStrict = options.strict !== false ? `${_}'use strict';${n}` : ``;
  let iifeExport;
  if (options.noConflict === true) {
    const noConflictExportsVar = options.compact ? 'e' : 'exports';
    let factory;
    if (!namedExportsMode && hasExports) {
      factory = `var ${noConflictExportsVar}${_}=${_}${assignToDeepVariable(options.name, globalVar, options.globals, options.compact, `${factoryVar}(${globalDeps.join(`,${_}`)})`)};`;
    }
    else if (namedExportsMode) {
      const module = globalDeps.shift();
      factory =
        `var ${noConflictExportsVar}${_}=${_}${module};${n}` +
          `${t}${t}${factoryVar}(${[noConflictExportsVar].concat(globalDeps).join(`,${_}`)});`;
    }
    iifeExport =
      `(function${_}()${_}{${n}` +
        `${t}${t}var current${_}=${_}${safeAccess(options.name, globalVar, _)};${n}` +
        `${t}${t}${factory}${n}` +
        `${t}${t}${noConflictExportsVar}.noConflict${_}=${_}function${_}()${_}{${_}` +
        `${globalProp(options.name, globalVar)}${_}=${_}current;${_}return ${noConflictExportsVar}${options.compact ? '' : '; '}};${n}` +
        `${t}}())`;
  }
  else {
    iifeExport = `${factoryVar}(${globalDeps.join(`,${_}`)})`;
    if (!namedExportsMode && hasExports) {
      iifeExport = assignToDeepVariable(options.name, globalVar, options.globals, options.compact, iifeExport);
    }
  }
  const iifeNeedsGlobal = hasExports || (options.noConflict === true && namedExportsMode) || globalDeps.length > 0;
  const globalParam = iifeNeedsGlobal ? `${globalVar},${_}` : '';
  const globalArg = iifeNeedsGlobal ? `this,${_}` : '';
  const iifeStart = iifeNeedsGlobal ? `(${globalVar}${_}=${_}${globalVar}${_}||${_}self,${_}` : '';
  const iifeEnd = iifeNeedsGlobal ? ')' : '';
  const cjsIntro = iifeNeedsGlobal
    ? `${t}typeof exports${_}===${_}'object'${_}&&${_}typeof module${_}!==${_}'undefined'${_}?` +
      `${_}${cjsExport}${factoryVar}(${cjsDeps.join(`,${_}`)})${_}:${n}`
    : '';
  // factory function should be wrapped by parentheses to avoid lazy parsing
  const wrapperIntro = `(function${_}(${globalParam}${factoryVar})${_}{${n}` +
    cjsIntro +
    `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParams}${factoryVar})${_}:${n}` +
    `${t}${iifeStart}${iifeExport}${iifeEnd};${n}` +
    `}(${globalArg}(function${_}(${factoryArgs.join(', ')})${_}{${useStrict}${n}`;
  const wrapperOutro = n + n + '})));';
  // var foo__default = 'default' in foo ? foo['default'] : foo;
  const interopBlock = getInteropBlock(dependencies, options, varOrConst);
  if (interopBlock)
    magicString.prepend(interopBlock + n + n);
  if (intro)
    magicString.prepend(intro);
  const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);
  if (exportBlock)
    magicString.append(n + n + exportBlock);
  if (namedExportsMode && hasExports && options.esModule)
    magicString.append(n + n + (options.compact ? compactEsModuleExport : esModuleExport));
  if (outro)
    magicString.append(outro);
  return magicString
    .trim()
    .indent(t)
    .append(wrapperOutro)
    .prepend(wrapperIntro);
}

var finalisers = { system, amd, cjs, es: esm, iife, umd };

const extractors$1 = {
  ArrayPattern(names, param) {
    for (const element of param.elements) {
      if (element)
        extractors$1[element.type](names, element);
    }
  },
  AssignmentPattern(names, param) {
    extractors$1[param.left.type](names, param.left);
  },
  Identifier(names, param) {
    names.push(param.name);
  },
  MemberExpression() { },
  ObjectPattern(names, param) {
    for (const prop of param.properties) {
      if (prop.type === 'RestElement') {
        extractors$1.RestElement(names, prop);
      }
      else {
        extractors$1[prop.value.type](names, prop.value);
      }
    }
  },
  RestElement(names, param) {
    extractors$1[param.argument.type](names, param.argument);
  }
};
const extractAssignedNames$1 = function extractAssignedNames(param) {
  const names = [];
  extractors$1[param.type](names, param);
  return names;
};

class ExportAllDeclaration extends NodeBase {
  hasEffects() {
    return false;
  }
  initialise() {
    this.context.addExport(this);
  }
  render(code, _options, nodeRenderOptions) {
    code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
  }
}
ExportAllDeclaration.prototype.needsBoundaries = true;

class ArrayExpression extends NodeBase {
  bind() {
    super.bind();
    for (const element of this.elements) {
      if (element !== null)
        element.deoptimizePath(UNKNOWN_PATH);
    }
  }
  getReturnExpressionWhenCalledAtPath(path) {
    if (path.length !== 1)
      return UNKNOWN_EXPRESSION;
    return getMemberReturnExpressionWhenCalled(arrayMembers, path[0]);
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (path.length === 1) {
      return hasMemberEffectWhenCalled(arrayMembers, path[0], this.included, callOptions, context);
    }
    return true;
  }
}

class ArrayPattern extends NodeBase {
  addExportedVariables(variables) {
    for (const element of this.elements) {
      if (element !== null) {
        element.addExportedVariables(variables);
      }
    }
  }
  declare(kind) {
    const variables = [];
    for (const element of this.elements) {
      if (element !== null) {
        variables.push(...element.declare(kind, UNKNOWN_EXPRESSION));
      }
    }
    return variables;
  }
  deoptimizePath(path) {
    if (path.length === 0) {
      for (const element of this.elements) {
        if (element !== null) {
          element.deoptimizePath(path);
        }
      }
    }
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    if (path.length > 0)
      return true;
    for (const element of this.elements) {
      if (element !== null && element.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))
        return true;
    }
    return false;
  }
}

class BlockScope extends ChildScope {
  addDeclaration(identifier, context, init = null, isHoisted) {
    if (isHoisted) {
      return this.parent.addDeclaration(identifier, context, isHoisted === 'function' ? init : UNKNOWN_EXPRESSION, isHoisted);
    }
    else {
      return super.addDeclaration(identifier, context, init, false);
    }
  }
}

class ExpressionStatement$1 extends NodeBase {
  initialise() {
    if (this.directive &&
      this.directive !== 'use strict' &&
      this.parent.type === Program) {
      this.context.warn(
      // This is necessary, because either way (deleting or not) can lead to errors.
      {
        code: 'MODULE_LEVEL_DIRECTIVE',
        message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.`
      }, this.start);
    }
  }
  render(code, options) {
    super.render(code, options);
    if (this.included)
      this.insertSemicolon(code);
  }
  shouldBeIncluded(context) {
    if (this.directive && this.directive !== 'use strict')
      return this.parent.type !== Program;
    return super.shouldBeIncluded(context);
  }
}

class BlockStatement$1 extends NodeBase {
  constructor() {
    super(...arguments);
    this.directlyIncluded = false;
  }
  addImplicitReturnExpressionToScope() {
    const lastStatement = this.body[this.body.length - 1];
    if (!lastStatement || lastStatement.type !== ReturnStatement) {
      this.scope.addReturnExpression(UNKNOWN_EXPRESSION);
    }
  }
  createScope(parentScope) {
    this.scope = this.parent.preventChildBlockScope
      ? parentScope
      : new BlockScope(parentScope);
  }
  hasEffects(context) {
    if (this.deoptimizeBody)
      return true;
    for (const node of this.body) {
      if (node.hasEffects(context))
        return true;
      if (context.brokenFlow)
        break;
    }
    return false;
  }
  include(context, includeChildrenRecursively) {
    if (!this.deoptimizeBody || !this.directlyIncluded) {
      this.included = true;
      this.directlyIncluded = true;
      if (this.deoptimizeBody)
        includeChildrenRecursively = true;
      for (const node of this.body) {
        if (includeChildrenRecursively || node.shouldBeIncluded(context))
          node.include(context, includeChildrenRecursively);
      }
    }
  }
  initialise() {
    const firstBodyStatement = this.body[0];
    this.deoptimizeBody =
      firstBodyStatement instanceof ExpressionStatement$1 &&
        firstBodyStatement.directive === 'use asm';
  }
  render(code, options) {
    if (this.body.length) {
      renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
    }
    else {
      super.render(code, options);
    }
  }
}

class ArrowFunctionExpression extends NodeBase {
  createScope(parentScope) {
    this.scope = new ReturnValueScope(parentScope, this.context);
  }
  deoptimizePath(path) {
    // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
    // which means the return expression needs to be reassigned
    if (path.length === 1 && path[0] === UnknownKey) {
      this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
    }
  }
  getReturnExpressionWhenCalledAtPath(path) {
    return path.length === 0 ? this.scope.getReturnExpression() : UNKNOWN_EXPRESSION;
  }
  hasEffects() {
    return false;
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenAssignedAtPath(path) {
    return path.length > 1;
  }
  hasEffectsWhenCalledAtPath(path, _callOptions, context) {
    if (path.length > 0)
      return true;
    for (const param of this.params) {
      if (param.hasEffects(context))
        return true;
    }
    const { ignore, brokenFlow } = context;
    context.ignore = {
      breaks: false,
      continues: false,
      labels: new Set(),
      returnAwaitYield: true
    };
    if (this.body.hasEffects(context))
      return true;
    context.ignore = ignore;
    context.brokenFlow = brokenFlow;
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    for (const param of this.params) {
      if (!(param instanceof Identifier$1)) {
        param.include(context, includeChildrenRecursively);
      }
    }
    const { brokenFlow } = context;
    context.brokenFlow = BROKEN_FLOW_NONE;
    this.body.include(context, includeChildrenRecursively);
    context.brokenFlow = brokenFlow;
  }
  includeCallArguments(context, args) {
    this.scope.includeCallArguments(context, args);
  }
  initialise() {
    this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
    if (this.body instanceof BlockStatement$1) {
      this.body.addImplicitReturnExpressionToScope();
    }
    else {
      this.scope.addReturnExpression(this.body);
    }
  }
  parseNode(esTreeNode) {
    if (esTreeNode.body.type === BlockStatement) {
      this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
    }
    super.parseNode(esTreeNode);
  }
}
ArrowFunctionExpression.prototype.preventChildBlockScope = true;

function getSystemExportStatement(exportedVariables) {
  if (exportedVariables.length === 1) {
    return `exports('${exportedVariables[0].safeExportName ||
      exportedVariables[0].exportName}', ${exportedVariables[0].getName()});`;
  }
  else {
    return `exports({${exportedVariables
      .map(variable => `${variable.safeExportName || variable.exportName}: ${variable.getName()}`)
      .join(', ')}});`;
  }
}

class AssignmentExpression extends NodeBase {
  constructor() {
    super(...arguments);
    this.deoptimized = false;
  }
  hasEffects(context) {
    if (!this.deoptimized)
      this.applyDeoptimizations();
    return (this.right.hasEffects(context) ||
      this.left.hasEffects(context) ||
      this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context));
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    return path.length > 0 && this.right.hasEffectsWhenAccessedAtPath(path, context);
  }
  include(context, includeChildrenRecursively) {
    if (!this.deoptimized)
      this.applyDeoptimizations();
    this.included = true;
    this.left.include(context, includeChildrenRecursively);
    this.right.include(context, includeChildrenRecursively);
  }
  render(code, options) {
    this.left.render(code, options);
    this.right.render(code, options);
    if (options.format === 'system') {
      if (this.left.variable && this.left.variable.exportName) {
        const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);
        const operation = this.operator.length > 1
          ? ` ${this.left.variable.exportName} ${this.operator.slice(0, -1)}`
          : '';
        code.overwrite(operatorPos, operatorPos + this.operator.length, `= exports('${this.left.variable.exportName}',${operation}`);
        code.appendLeft(this.right.end, `)`);
      }
      else if ('addExportedVariables' in this.left) {
        const systemPatternExports = [];
        this.left.addExportedVariables(systemPatternExports);
        if (systemPatternExports.length > 0) {
          code.prependRight(this.start, `function (v) {${getSystemExportStatement(systemPatternExports)} return v;} (`);
          code.appendLeft(this.end, ')');
        }
      }
    }
  }
  applyDeoptimizations() {
    this.deoptimized = true;
    this.left.deoptimizePath(EMPTY_PATH);
    this.right.deoptimizePath(UNKNOWN_PATH);
  }
}

class AssignmentPattern extends NodeBase {
  addExportedVariables(variables) {
    this.left.addExportedVariables(variables);
  }
  bind() {
    super.bind();
    this.left.deoptimizePath(EMPTY_PATH);
    this.right.deoptimizePath(UNKNOWN_PATH);
  }
  declare(kind, init) {
    return this.left.declare(kind, init);
  }
  deoptimizePath(path) {
    path.length === 0 && this.left.deoptimizePath(path);
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    return path.length > 0 || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
  }
  render(code, options, { isShorthandProperty } = BLANK) {
    this.left.render(code, options, { isShorthandProperty });
    this.right.render(code, options);
  }
}

class AwaitExpression extends NodeBase {
  hasEffects(context) {
    return !context.ignore.returnAwaitYield || this.argument.hasEffects(context);
  }
  include(context, includeChildrenRecursively) {
    if (!this.included) {
      this.included = true;
      checkTopLevelAwait: if (!this.context.usesTopLevelAwait) {
        let parent = this.parent;
        do {
          if (parent instanceof FunctionNode || parent instanceof ArrowFunctionExpression)
            break checkTopLevelAwait;
        } while ((parent = parent.parent));
        this.context.usesTopLevelAwait = true;
      }
    }
    this.argument.include(context, includeChildrenRecursively);
  }
}

const binaryOperators = {
  '!=': (left, right) => left != right,
  '!==': (left, right) => left !== right,
  '%': (left, right) => left % right,
  '&': (left, right) => left & right,
  '*': (left, right) => left * right,
  // At the moment, "**" will be transpiled to Math.pow
  '**': (left, right) => Math.pow(left, right),
  '+': (left, right) => left + right,
  '-': (left, right) => left - right,
  '/': (left, right) => left / right,
  '<': (left, right) => left < right,
  '<<': (left, right) => left << right,
  '<=': (left, right) => left <= right,
  '==': (left, right) => left == right,
  '===': (left, right) => left === right,
  '>': (left, right) => left > right,
  '>=': (left, right) => left >= right,
  '>>': (left, right) => left >> right,
  '>>>': (left, right) => left >>> right,
  '^': (left, right) => left ^ right,
  in: () => UnknownValue,
  instanceof: () => UnknownValue,
  '|': (left, right) => left | right
};
class BinaryExpression extends NodeBase {
  deoptimizeCache() { }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    if (path.length > 0)
      return UnknownValue;
    const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
    if (leftValue === UnknownValue)
      return UnknownValue;
    const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
    if (rightValue === UnknownValue)
      return UnknownValue;
    const operatorFn = binaryOperators[this.operator];
    if (!operatorFn)
      return UnknownValue;
    return operatorFn(leftValue, rightValue);
  }
  hasEffects(context) {
    // support some implicit type coercion runtime errors
    if (this.operator === '+' &&
      this.parent instanceof ExpressionStatement$1 &&
      this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '')
      return true;
    return super.hasEffects(context);
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
}

class BreakStatement extends NodeBase {
  hasEffects(context) {
    if (this.label) {
      if (!context.ignore.labels.has(this.label.name))
        return true;
      context.includedLabels.add(this.label.name);
      context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
    }
    else {
      if (!context.ignore.breaks)
        return true;
      context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;
    }
    return false;
  }
  include(context) {
    this.included = true;
    if (this.label) {
      this.label.include(context);
      context.includedLabels.add(this.label.name);
    }
    context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;
  }
}

class Literal extends NodeBase {
  getLiteralValueAtPath(path) {
    if (path.length > 0 ||
      // unknown literals can also be null but do not start with an "n"
      (this.value === null && this.context.code.charCodeAt(this.start) !== 110) ||
      typeof this.value === 'bigint' ||
      // to support shims for regular expressions
      this.context.code.charCodeAt(this.start) === 47) {
      return UnknownValue;
    }
    return this.value;
  }
  getReturnExpressionWhenCalledAtPath(path) {
    if (path.length !== 1)
      return UNKNOWN_EXPRESSION;
    return getMemberReturnExpressionWhenCalled(this.members, path[0]);
  }
  hasEffectsWhenAccessedAtPath(path) {
    if (this.value === null) {
      return path.length > 0;
    }
    return path.length > 1;
  }
  hasEffectsWhenAssignedAtPath(path) {
    return path.length > 0;
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (path.length === 1) {
      return hasMemberEffectWhenCalled(this.members, path[0], this.included, callOptions, context);
    }
    return true;
  }
  initialise() {
    this.members = getLiteralMembersForValue(this.value);
  }
  render(code) {
    if (typeof this.value === 'string') {
      code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
    }
  }
}

function getResolvablePropertyKey(memberExpression) {
  return memberExpression.computed
    ? getResolvableComputedPropertyKey(memberExpression.property)
    : memberExpression.property.name;
}
function getResolvableComputedPropertyKey(propertyKey) {
  if (propertyKey instanceof Literal) {
    return String(propertyKey.value);
  }
  return null;
}
function getPathIfNotComputed(memberExpression) {
  const nextPathKey = memberExpression.propertyKey;
  const object = memberExpression.object;
  if (typeof nextPathKey === 'string') {
    if (object instanceof Identifier$1) {
      return [
        { key: object.name, pos: object.start },
        { key: nextPathKey, pos: memberExpression.property.start }
      ];
    }
    if (object instanceof MemberExpression) {
      const parentPath = getPathIfNotComputed(object);
      return (parentPath && [...parentPath, { key: nextPathKey, pos: memberExpression.property.start }]);
    }
  }
  return null;
}
function getStringFromPath(path) {
  let pathString = path[0].key;
  for (let index = 1; index < path.length; index++) {
    pathString += '.' + path[index].key;
  }
  return pathString;
}
class MemberExpression extends NodeBase {
  constructor() {
    super(...arguments);
    this.variable = null;
    this.bound = false;
    this.expressionsToBeDeoptimized = [];
    this.replacement = null;
    this.wasPathDeoptimizedWhileOptimized = false;
  }
  addExportedVariables() { }
  bind() {
    if (this.bound)
      return;
    this.bound = true;
    const path = getPathIfNotComputed(this);
    const baseVariable = path && this.scope.findVariable(path[0].key);
    if (baseVariable && baseVariable.isNamespace) {
      const resolvedVariable = this.resolveNamespaceVariables(baseVariable, path.slice(1));
      if (!resolvedVariable) {
        super.bind();
      }
      else if (typeof resolvedVariable === 'string') {
        this.replacement = resolvedVariable;
      }
      else {
        if (resolvedVariable instanceof ExternalVariable && resolvedVariable.module) {
          resolvedVariable.module.suggestName(path[0].key);
        }
        this.variable = resolvedVariable;
        this.scope.addNamespaceMemberAccess(getStringFromPath(path), resolvedVariable);
      }
    }
    else {
      super.bind();
      // ensure the propertyKey is set for the tree-shaking passes
      this.getPropertyKey();
    }
  }
  deoptimizeCache() {
    const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
    this.expressionsToBeDeoptimized = [];
    this.propertyKey = UnknownKey;
    if (this.wasPathDeoptimizedWhileOptimized) {
      this.object.deoptimizePath(UNKNOWN_PATH);
    }
    for (const expression of expressionsToBeDeoptimized) {
      expression.deoptimizeCache();
    }
  }
  deoptimizePath(path) {
    if (!this.bound)
      this.bind();
    if (path.length === 0)
      this.disallowNamespaceReassignment();
    if (this.variable) {
      this.variable.deoptimizePath(path);
    }
    else {
      const propertyKey = this.getPropertyKey();
      if (propertyKey === UnknownKey) {
        this.object.deoptimizePath(UNKNOWN_PATH);
      }
      else {
        this.wasPathDeoptimizedWhileOptimized = true;
        this.object.deoptimizePath([propertyKey, ...path]);
      }
    }
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    if (!this.bound)
      this.bind();
    if (this.variable !== null) {
      return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);
    }
    this.expressionsToBeDeoptimized.push(origin);
    return this.object.getLiteralValueAtPath([this.getPropertyKey(), ...path], recursionTracker, origin);
  }
  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
    if (!this.bound)
      this.bind();
    if (this.variable !== null) {
      return this.variable.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
    }
    this.expressionsToBeDeoptimized.push(origin);
    return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path], recursionTracker, origin);
  }
  hasEffects(context) {
    return (this.property.hasEffects(context) ||
      this.object.hasEffects(context) ||
      (this.context.propertyReadSideEffects &&
        this.object.hasEffectsWhenAccessedAtPath([this.propertyKey], context)));
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    if (path.length === 0)
      return false;
    if (this.variable !== null) {
      return this.variable.hasEffectsWhenAccessedAtPath(path, context);
    }
    return this.object.hasEffectsWhenAccessedAtPath([this.propertyKey, ...path], context);
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    if (this.variable !== null) {
      return this.variable.hasEffectsWhenAssignedAtPath(path, context);
    }
    return this.object.hasEffectsWhenAssignedAtPath([this.propertyKey, ...path], context);
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (this.variable !== null) {
      return this.variable.hasEffectsWhenCalledAtPath(path, callOptions, context);
    }
    return this.object.hasEffectsWhenCalledAtPath([this.propertyKey, ...path], callOptions, context);
  }
  include(context, includeChildrenRecursively) {
    if (!this.included) {
      this.included = true;
      if (this.variable !== null) {
        this.context.includeVariable(context, this.variable);
      }
    }
    this.object.include(context, includeChildrenRecursively);
    this.property.include(context, includeChildrenRecursively);
  }
  includeCallArguments(context, args) {
    if (this.variable) {
      this.variable.includeCallArguments(context, args);
    }
    else {
      super.includeCallArguments(context, args);
    }
  }
  initialise() {
    this.propertyKey = getResolvablePropertyKey(this);
  }
  render(code, options, { renderedParentType, isCalleeOfRenderedParent } = BLANK) {
    const isCalleeOfDifferentParent = renderedParentType === CallExpression && isCalleeOfRenderedParent;
    if (this.variable || this.replacement) {
      let replacement = this.variable ? this.variable.getName() : this.replacement;
      if (isCalleeOfDifferentParent)
        replacement = '0, ' + replacement;
      code.overwrite(this.start, this.end, replacement, {
        contentOnly: true,
        storeName: true
      });
    }
    else {
      if (isCalleeOfDifferentParent) {
        code.appendRight(this.start, '0, ');
      }
      super.render(code, options);
    }
  }
  disallowNamespaceReassignment() {
    if (this.object instanceof Identifier$1 &&
      this.scope.findVariable(this.object.name).isNamespace) {
      return this.context.error({
        code: 'ILLEGAL_NAMESPACE_REASSIGNMENT',
        message: `Illegal reassignment to import '${this.object.name}'`
      }, this.start);
    }
  }
  getPropertyKey() {
    if (this.propertyKey === null) {
      this.propertyKey = UnknownKey;
      const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
      return (this.propertyKey = value === UnknownValue ? UnknownKey : String(value));
    }
    return this.propertyKey;
  }
  resolveNamespaceVariables(baseVariable, path) {
    if (path.length === 0)
      return baseVariable;
    if (!baseVariable.isNamespace)
      return null;
    const exportName = path[0].key;
    const variable = baseVariable instanceof ExternalVariable
      ? baseVariable.module.getVariableForExportName(exportName)
      : baseVariable.context.traceExport(exportName);
    if (!variable) {
      const fileName = baseVariable instanceof ExternalVariable
        ? baseVariable.module.id
        : baseVariable.context.fileName;
      this.context.warn({
        code: 'MISSING_EXPORT',
        exporter: relativeId(fileName),
        importer: relativeId(this.context.fileName),
        message: `'${exportName}' is not exported by '${relativeId(fileName)}'`,
        missing: exportName,
        url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`
      }, path[0].pos);
      return 'undefined';
    }
    return this.resolveNamespaceVariables(variable, path.slice(1));
  }
}

class CallExpression$1 extends NodeBase {
  constructor() {
    super(...arguments);
    this.expressionsToBeDeoptimized = [];
    this.returnExpression = null;
    this.wasPathDeoptmizedWhileOptimized = false;
  }
  bind() {
    super.bind();
    if (this.callee instanceof Identifier$1) {
      const variable = this.scope.findVariable(this.callee.name);
      if (variable.isNamespace) {
        return this.context.error({
          code: 'CANNOT_CALL_NAMESPACE',
          message: `Cannot call a namespace ('${this.callee.name}')`
        }, this.start);
      }
      if (this.callee.name === 'eval') {
        this.context.warn({
          code: 'EVAL',
          message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,
          url: 'https://rollupjs.org/guide/en/#avoiding-eval'
        }, this.start);
      }
    }
    // ensure the returnExpression is set for the tree-shaking passes
    this.getReturnExpression(SHARED_RECURSION_TRACKER);
    // This deoptimizes "this" for non-namespace calls until we have a better solution
    if (this.callee instanceof MemberExpression && !this.callee.variable) {
      this.callee.object.deoptimizePath(UNKNOWN_PATH);
    }
    for (const argument of this.arguments) {
      // This will make sure all properties of parameters behave as "unknown"
      argument.deoptimizePath(UNKNOWN_PATH);
    }
  }
  deoptimizeCache() {
    if (this.returnExpression !== UNKNOWN_EXPRESSION) {
      this.returnExpression = null;
      const returnExpression = this.getReturnExpression(SHARED_RECURSION_TRACKER);
      const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
      if (returnExpression !== UNKNOWN_EXPRESSION) {
        // We need to replace here because is possible new expressions are added
        // while we are deoptimizing the old ones
        this.expressionsToBeDeoptimized = [];
        if (this.wasPathDeoptmizedWhileOptimized) {
          returnExpression.deoptimizePath(UNKNOWN_PATH);
          this.wasPathDeoptmizedWhileOptimized = false;
        }
      }
      for (const expression of expressionsToBeDeoptimized) {
        expression.deoptimizeCache();
      }
    }
  }
  deoptimizePath(path) {
    if (path.length === 0)
      return;
    const trackedEntities = this.context.deoptimizationTracker.getEntities(path);
    if (trackedEntities.has(this))
      return;
    trackedEntities.add(this);
    const returnExpression = this.getReturnExpression(SHARED_RECURSION_TRACKER);
    if (returnExpression !== UNKNOWN_EXPRESSION) {
      this.wasPathDeoptmizedWhileOptimized = true;
      returnExpression.deoptimizePath(path);
    }
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    const returnExpression = this.getReturnExpression(recursionTracker);
    if (returnExpression === UNKNOWN_EXPRESSION) {
      return UnknownValue;
    }
    const trackedEntities = recursionTracker.getEntities(path);
    if (trackedEntities.has(returnExpression)) {
      return UnknownValue;
    }
    this.expressionsToBeDeoptimized.push(origin);
    trackedEntities.add(returnExpression);
    const value = returnExpression.getLiteralValueAtPath(path, recursionTracker, origin);
    trackedEntities.delete(returnExpression);
    return value;
  }
  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
    const returnExpression = this.getReturnExpression(recursionTracker);
    if (this.returnExpression === UNKNOWN_EXPRESSION) {
      return UNKNOWN_EXPRESSION;
    }
    const trackedEntities = recursionTracker.getEntities(path);
    if (trackedEntities.has(returnExpression)) {
      return UNKNOWN_EXPRESSION;
    }
    this.expressionsToBeDeoptimized.push(origin);
    trackedEntities.add(returnExpression);
    const value = returnExpression.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
    trackedEntities.delete(returnExpression);
    return value;
  }
  hasEffects(context) {
    for (const argument of this.arguments) {
      if (argument.hasEffects(context))
        return true;
    }
    if (this.context.annotations && this.annotatedPure)
      return false;
    return (this.callee.hasEffects(context) ||
      this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    if (path.length === 0)
      return false;
    const trackedExpressions = context.accessed.getEntities(path);
    if (trackedExpressions.has(this))
      return false;
    trackedExpressions.add(this);
    return this.returnExpression.hasEffectsWhenAccessedAtPath(path, context);
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    if (path.length === 0)
      return true;
    const trackedExpressions = context.assigned.getEntities(path);
    if (trackedExpressions.has(this))
      return false;
    trackedExpressions.add(this);
    return this.returnExpression.hasEffectsWhenAssignedAtPath(path, context);
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    const trackedExpressions = (callOptions.withNew
      ? context.instantiated
      : context.called).getEntities(path);
    if (trackedExpressions.has(this))
      return false;
    trackedExpressions.add(this);
    return this.returnExpression.hasEffectsWhenCalledAtPath(path, callOptions, context);
  }
  include(context, includeChildrenRecursively) {
    if (includeChildrenRecursively) {
      super.include(context, includeChildrenRecursively);
      if (includeChildrenRecursively === INCLUDE_PARAMETERS &&
        this.callee instanceof Identifier$1 &&
        this.callee.variable) {
        this.callee.variable.markCalledFromTryStatement();
      }
    }
    else {
      this.included = true;
      this.callee.include(context, false);
    }
    this.callee.includeCallArguments(context, this.arguments);
    if (!this.returnExpression.included) {
      this.returnExpression.include(context, false);
    }
  }
  initialise() {
    this.callOptions = {
      args: this.arguments,
      withNew: false
    };
  }
  render(code, options, { renderedParentType } = BLANK) {
    this.callee.render(code, options);
    if (this.arguments.length > 0) {
      if (this.arguments[this.arguments.length - 1].included) {
        for (const arg of this.arguments) {
          arg.render(code, options);
        }
      }
      else {
        let lastIncludedIndex = this.arguments.length - 2;
        while (lastIncludedIndex >= 0 && !this.arguments[lastIncludedIndex].included) {
          lastIncludedIndex--;
        }
        if (lastIncludedIndex >= 0) {
          for (let index = 0; index <= lastIncludedIndex; index++) {
            this.arguments[index].render(code, options);
          }
          code.remove(findFirstOccurrenceOutsideComment(code.original, ',', this.arguments[lastIncludedIndex].end), this.end - 1);
        }
        else {
          code.remove(findFirstOccurrenceOutsideComment(code.original, '(', this.callee.end) + 1, this.end - 1);
        }
      }
    }
    if (renderedParentType === ExpressionStatement &&
      this.callee.type === FunctionExpression) {
      code.appendRight(this.start, '(');
      code.prependLeft(this.end, ')');
    }
  }
  getReturnExpression(recursionTracker) {
    if (this.returnExpression === null) {
      this.returnExpression = UNKNOWN_EXPRESSION;
      return (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, recursionTracker, this));
    }
    return this.returnExpression;
  }
}

class CatchScope extends ParameterScope {
  addDeclaration(identifier, context, init, isHoisted) {
    if (isHoisted) {
      return this.parent.addDeclaration(identifier, context, init, isHoisted);
    }
    else {
      return super.addDeclaration(identifier, context, init, false);
    }
  }
}

class CatchClause extends NodeBase {
  createScope(parentScope) {
    this.scope = new CatchScope(parentScope, this.context);
  }
  initialise() {
    if (this.param) {
      this.param.declare('parameter', UNKNOWN_EXPRESSION);
    }
  }
  parseNode(esTreeNode) {
    this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope);
    super.parseNode(esTreeNode);
  }
}
CatchClause.prototype.preventChildBlockScope = true;

class ClassBody extends NodeBase {
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (path.length > 0)
      return true;
    return (this.classConstructor !== null &&
      this.classConstructor.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, context));
  }
  initialise() {
    for (const method of this.body) {
      if (method.kind === 'constructor') {
        this.classConstructor = method;
        return;
      }
    }
    this.classConstructor = null;
  }
}

class ClassExpression extends ClassNode {
}

class MultiExpression {
  constructor(expressions) {
    this.included = false;
    this.expressions = expressions;
  }
  deoptimizePath(path) {
    for (const expression of this.expressions) {
      expression.deoptimizePath(path);
    }
  }
  getLiteralValueAtPath() {
    return UnknownValue;
  }
  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
    return new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)));
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    for (const expression of this.expressions) {
      if (expression.hasEffectsWhenAccessedAtPath(path, context))
        return true;
    }
    return false;
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    for (const expression of this.expressions) {
      if (expression.hasEffectsWhenAssignedAtPath(path, context))
        return true;
    }
    return false;
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    for (const expression of this.expressions) {
      if (expression.hasEffectsWhenCalledAtPath(path, callOptions, context))
        return true;
    }
    return false;
  }
  include() { }
  includeCallArguments() { }
}

class ConditionalExpression extends NodeBase {
  constructor() {
    super(...arguments);
    this.expressionsToBeDeoptimized = [];
    this.isBranchResolutionAnalysed = false;
    this.usedBranch = null;
    this.wasPathDeoptimizedWhileOptimized = false;
  }
  bind() {
    super.bind();
    // ensure the usedBranch is set for the tree-shaking passes
    this.getUsedBranch();
  }
  deoptimizeCache() {
    if (this.usedBranch !== null) {
      const unusedBranch = this.usedBranch === this.consequent ? this.alternate : this.consequent;
      this.usedBranch = null;
      const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
      this.expressionsToBeDeoptimized = [];
      if (this.wasPathDeoptimizedWhileOptimized) {
        unusedBranch.deoptimizePath(UNKNOWN_PATH);
      }
      for (const expression of expressionsToBeDeoptimized) {
        expression.deoptimizeCache();
      }
    }
  }
  deoptimizePath(path) {
    if (path.length > 0) {
      const usedBranch = this.getUsedBranch();
      if (usedBranch === null) {
        this.consequent.deoptimizePath(path);
        this.alternate.deoptimizePath(path);
      }
      else {
        this.wasPathDeoptimizedWhileOptimized = true;
        usedBranch.deoptimizePath(path);
      }
    }
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    const usedBranch = this.getUsedBranch();
    if (usedBranch === null)
      return UnknownValue;
    this.expressionsToBeDeoptimized.push(origin);
    return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
  }
  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
    const usedBranch = this.getUsedBranch();
    if (usedBranch === null)
      return new MultiExpression([
        this.consequent.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin),
        this.alternate.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)
      ]);
    this.expressionsToBeDeoptimized.push(origin);
    return usedBranch.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
  }
  hasEffects(context) {
    if (this.test.hasEffects(context))
      return true;
    if (this.usedBranch === null) {
      return this.consequent.hasEffects(context) || this.alternate.hasEffects(context);
    }
    return this.usedBranch.hasEffects(context);
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    if (path.length === 0)
      return false;
    if (this.usedBranch === null) {
      return (this.consequent.hasEffectsWhenAccessedAtPath(path, context) ||
        this.alternate.hasEffectsWhenAccessedAtPath(path, context));
    }
    return this.usedBranch.hasEffectsWhenAccessedAtPath(path, context);
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    if (path.length === 0)
      return true;
    if (this.usedBranch === null) {
      return (this.consequent.hasEffectsWhenAssignedAtPath(path, context) ||
        this.alternate.hasEffectsWhenAssignedAtPath(path, context));
    }
    return this.usedBranch.hasEffectsWhenAssignedAtPath(path, context);
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (this.usedBranch === null) {
      return (this.consequent.hasEffectsWhenCalledAtPath(path, callOptions, context) ||
        this.alternate.hasEffectsWhenCalledAtPath(path, callOptions, context));
    }
    return this.usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    if (includeChildrenRecursively ||
      this.test.shouldBeIncluded(context) ||
      this.usedBranch === null) {
      this.test.include(context, includeChildrenRecursively);
      this.consequent.include(context, includeChildrenRecursively);
      this.alternate.include(context, includeChildrenRecursively);
    }
    else {
      this.usedBranch.include(context, includeChildrenRecursively);
    }
  }
  render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = BLANK) {
    if (!this.test.included) {
      const colonPos = findFirstOccurrenceOutsideComment(code.original, ':', this.consequent.end);
      const inclusionStart = (this.consequent.included
        ? findFirstOccurrenceOutsideComment(code.original, '?', this.test.end)
        : colonPos) + 1;
      if (preventASI) {
        removeLineBreaks(code, inclusionStart, this.usedBranch.start);
      }
      code.remove(this.start, inclusionStart);
      if (this.consequent.included) {
        code.remove(colonPos, this.end);
      }
      removeAnnotations(this, code);
      this.usedBranch.render(code, options, {
        isCalleeOfRenderedParent: renderedParentType
          ? isCalleeOfRenderedParent
          : this.parent.callee === this,
        renderedParentType: renderedParentType || this.parent.type
      });
    }
    else {
      super.render(code, options);
    }
  }
  getUsedBranch() {
    if (this.isBranchResolutionAnalysed) {
      return this.usedBranch;
    }
    this.isBranchResolutionAnalysed = true;
    const testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
    return testValue === UnknownValue
      ? null
      : (this.usedBranch = testValue ? this.consequent : this.alternate);
  }
}

class ContinueStatement extends NodeBase {
  hasEffects(context) {
    if (this.label) {
      if (!context.ignore.labels.has(this.label.name))
        return true;
      context.includedLabels.add(this.label.name);
      context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
    }
    else {
      if (!context.ignore.continues)
        return true;
      context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;
    }
    return false;
  }
  include(context) {
    this.included = true;
    if (this.label) {
      this.label.include(context);
      context.includedLabels.add(this.label.name);
    }
    context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;
  }
}

class DoWhileStatement extends NodeBase {
  hasEffects(context) {
    if (this.test.hasEffects(context))
      return true;
    const { brokenFlow, ignore: { breaks, continues } } = context;
    context.ignore.breaks = true;
    context.ignore.continues = true;
    if (this.body.hasEffects(context))
      return true;
    context.ignore.breaks = breaks;
    context.ignore.continues = continues;
    context.brokenFlow = brokenFlow;
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    this.test.include(context, includeChildrenRecursively);
    const { brokenFlow } = context;
    this.body.include(context, includeChildrenRecursively);
    context.brokenFlow = brokenFlow;
  }
}

class EmptyStatement extends NodeBase {
  hasEffects() {
    return false;
  }
}

class ExportNamedDeclaration extends NodeBase {
  bind() {
    // Do not bind specifiers
    if (this.declaration !== null)
      this.declaration.bind();
  }
  hasEffects(context) {
    return this.declaration !== null && this.declaration.hasEffects(context);
  }
  initialise() {
    this.context.addExport(this);
  }
  render(code, options, nodeRenderOptions) {
    const { start, end } = nodeRenderOptions;
    if (this.declaration === null) {
      code.remove(start, end);
    }
    else {
      code.remove(this.start, this.declaration.start);
      this.declaration.render(code, options, { start, end });
    }
  }
}
ExportNamedDeclaration.prototype.needsBoundaries = true;

class ForInStatement extends NodeBase {
  bind() {
    this.left.bind();
    this.left.deoptimizePath(EMPTY_PATH);
    this.right.bind();
    this.body.bind();
  }
  createScope(parentScope) {
    this.scope = new BlockScope(parentScope);
  }
  hasEffects(context) {
    if ((this.left &&
      (this.left.hasEffects(context) ||
        this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))) ||
      (this.right && this.right.hasEffects(context)))
      return true;
    const { brokenFlow, ignore: { breaks, continues } } = context;
    context.ignore.breaks = true;
    context.ignore.continues = true;
    if (this.body.hasEffects(context))
      return true;
    context.ignore.breaks = breaks;
    context.ignore.continues = continues;
    context.brokenFlow = brokenFlow;
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    this.left.includeWithAllDeclaredVariables(includeChildrenRecursively, context);
    this.left.deoptimizePath(EMPTY_PATH);
    this.right.include(context, includeChildrenRecursively);
    const { brokenFlow } = context;
    this.body.include(context, includeChildrenRecursively);
    context.brokenFlow = brokenFlow;
  }
  render(code, options) {
    this.left.render(code, options, NO_SEMICOLON);
    this.right.render(code, options, NO_SEMICOLON);
    // handle no space between "in" and the right side
    if (code.original.charCodeAt(this.right.start - 1) === 110 /* n */) {
      code.prependLeft(this.right.start, ' ');
    }
    this.body.render(code, options);
  }
}

class ForOfStatement extends NodeBase {
  bind() {
    this.left.bind();
    this.left.deoptimizePath(EMPTY_PATH);
    this.right.bind();
    this.body.bind();
  }
  createScope(parentScope) {
    this.scope = new BlockScope(parentScope);
  }
  hasEffects() {
    // Placeholder until proper Symbol.Iterator support
    return true;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    this.left.includeWithAllDeclaredVariables(includeChildrenRecursively, context);
    this.left.deoptimizePath(EMPTY_PATH);
    this.right.include(context, includeChildrenRecursively);
    const { brokenFlow } = context;
    this.body.include(context, includeChildrenRecursively);
    context.brokenFlow = brokenFlow;
  }
  render(code, options) {
    this.left.render(code, options, NO_SEMICOLON);
    this.right.render(code, options, NO_SEMICOLON);
    // handle no space between "of" and the right side
    if (code.original.charCodeAt(this.right.start - 1) === 102 /* f */) {
      code.prependLeft(this.right.start, ' ');
    }
    this.body.render(code, options);
  }
}

class ForStatement extends NodeBase {
  createScope(parentScope) {
    this.scope = new BlockScope(parentScope);
  }
  hasEffects(context) {
    if ((this.init && this.init.hasEffects(context)) ||
      (this.test && this.test.hasEffects(context)) ||
      (this.update && this.update.hasEffects(context)))
      return true;
    const { brokenFlow, ignore: { breaks, continues } } = context;
    context.ignore.breaks = true;
    context.ignore.continues = true;
    if (this.body.hasEffects(context))
      return true;
    context.ignore.breaks = breaks;
    context.ignore.continues = continues;
    context.brokenFlow = brokenFlow;
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    if (this.init)
      this.init.include(context, includeChildrenRecursively);
    if (this.test)
      this.test.include(context, includeChildrenRecursively);
    const { brokenFlow } = context;
    if (this.update)
      this.update.include(context, includeChildrenRecursively);
    this.body.include(context, includeChildrenRecursively);
    context.brokenFlow = brokenFlow;
  }
  render(code, options) {
    if (this.init)
      this.init.render(code, options, NO_SEMICOLON);
    if (this.test)
      this.test.render(code, options, NO_SEMICOLON);
    if (this.update)
      this.update.render(code, options, NO_SEMICOLON);
    this.body.render(code, options);
  }
}

class FunctionExpression$1 extends FunctionNode {
}

const unset = Symbol('unset');
class IfStatement extends NodeBase {
  constructor() {
    super(...arguments);
    this.testValue = unset;
  }
  deoptimizeCache() {
    this.testValue = UnknownValue;
  }
  hasEffects(context) {
    if (this.test.hasEffects(context)) {
      return true;
    }
    const testValue = this.getTestValue();
    if (testValue === UnknownValue) {
      const { brokenFlow } = context;
      if (this.consequent.hasEffects(context))
        return true;
      const consequentBrokenFlow = context.brokenFlow;
      context.brokenFlow = brokenFlow;
      if (this.alternate === null)
        return false;
      if (this.alternate.hasEffects(context))
        return true;
      context.brokenFlow =
        context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
      return false;
    }
    return testValue
      ? this.consequent.hasEffects(context)
      : this.alternate !== null && this.alternate.hasEffects(context);
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    if (includeChildrenRecursively) {
      this.includeRecursively(includeChildrenRecursively, context);
    }
    else {
      const testValue = this.getTestValue();
      if (testValue === UnknownValue) {
        this.includeUnknownTest(context);
      }
      else {
        this.includeKnownTest(context, testValue);
      }
    }
  }
  render(code, options) {
    // Note that unknown test values are always included
    const testValue = this.getTestValue();
    if (!this.test.included &&
      (testValue ? this.alternate === null || !this.alternate.included : !this.consequent.included)) {
      const singleRetainedBranch = (testValue ? this.consequent : this.alternate);
      code.remove(this.start, singleRetainedBranch.start);
      code.remove(singleRetainedBranch.end, this.end);
      removeAnnotations(this, code);
      singleRetainedBranch.render(code, options);
    }
    else {
      if (this.test.included) {
        this.test.render(code, options);
      }
      else {
        code.overwrite(this.test.start, this.test.end, testValue ? 'true' : 'false');
      }
      if (this.consequent.included) {
        this.consequent.render(code, options);
      }
      else {
        code.overwrite(this.consequent.start, this.consequent.end, ';');
      }
      if (this.alternate !== null) {
        if (this.alternate.included) {
          this.alternate.render(code, options);
        }
        else {
          code.remove(this.consequent.end, this.alternate.end);
        }
      }
    }
  }
  getTestValue() {
    if (this.testValue === unset) {
      return (this.testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));
    }
    return this.testValue;
  }
  includeKnownTest(context, testValue) {
    if (this.test.shouldBeIncluded(context)) {
      this.test.include(context, false);
    }
    if (testValue && this.consequent.shouldBeIncluded(context)) {
      this.consequent.include(context, false);
    }
    if (this.alternate !== null && !testValue && this.alternate.shouldBeIncluded(context)) {
      this.alternate.include(context, false);
    }
  }
  includeRecursively(includeChildrenRecursively, context) {
    this.test.include(context, includeChildrenRecursively);
    this.consequent.include(context, includeChildrenRecursively);
    if (this.alternate !== null) {
      this.alternate.include(context, includeChildrenRecursively);
    }
  }
  includeUnknownTest(context) {
    this.test.include(context, false);
    const { brokenFlow } = context;
    let consequentBrokenFlow = BROKEN_FLOW_NONE;
    if (this.consequent.shouldBeIncluded(context)) {
      this.consequent.include(context, false);
      consequentBrokenFlow = context.brokenFlow;
      context.brokenFlow = brokenFlow;
    }
    if (this.alternate !== null && this.alternate.shouldBeIncluded(context)) {
      this.alternate.include(context, false);
      context.brokenFlow =
        context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
    }
  }
}

class ImportDeclaration extends NodeBase {
  bind() { }
  hasEffects() {
    return false;
  }
  initialise() {
    this.context.addImport(this);
  }
  render(code, _options, nodeRenderOptions) {
    code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
  }
}
ImportDeclaration.prototype.needsBoundaries = true;

class Import extends NodeBase {
  constructor() {
    super(...arguments);
    this.exportMode = 'auto';
  }
  hasEffects() {
    return true;
  }
  include(context, includeChildrenRecursively) {
    if (!this.included) {
      this.included = true;
      this.context.includeDynamicImport(this);
      this.scope.addAccessedDynamicImport(this);
    }
    this.source.include(context, includeChildrenRecursively);
  }
  initialise() {
    this.context.addDynamicImport(this);
  }
  render(code, options) {
    if (this.inlineNamespace) {
      const _ = options.compact ? '' : ' ';
      const s = options.compact ? '' : ';';
      code.overwrite(this.start, this.end, `Promise.resolve().then(function${_}()${_}{${_}return ${this.inlineNamespace.getName()}${s}${_}})`);
      return;
    }
    const importMechanism = this.getDynamicImportMechanism(options);
    if (importMechanism) {
      code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, importMechanism.left);
      code.overwrite(this.end - 1, this.end, importMechanism.right);
    }
    this.source.render(code, options);
  }
  renderFinalResolution(code, resolution, format) {
    if (this.included) {
      if (format === 'amd' && resolution.startsWith("'.") && resolution.endsWith(".js'")) {
        resolution = resolution.slice(0, -4) + "'";
      }
      code.overwrite(this.source.start, this.source.end, resolution);
    }
  }
  setResolution(exportMode, inlineNamespace) {
    this.exportMode = exportMode;
    if (inlineNamespace) {
      this.inlineNamespace = inlineNamespace;
    }
    else {
      this.scope.addAccessedGlobalsByFormat({
        amd: ['require'],
        cjs: ['require'],
        system: ['module']
      });
      if (exportMode === 'auto') {
        this.scope.addAccessedGlobalsByFormat({
          amd: [INTEROP_NAMESPACE_VARIABLE],
          cjs: [INTEROP_NAMESPACE_VARIABLE]
        });
      }
    }
  }
  getDynamicImportMechanism(options) {
    switch (options.format) {
      case 'cjs': {
        const _ = options.compact ? '' : ' ';
        const resolve = options.compact ? 'c' : 'resolve';
        switch (this.exportMode) {
          case 'default':
            return {
              left: `new Promise(function${_}(${resolve})${_}{${_}${resolve}({${_}'default':${_}require(`,
              right: `)${_}});${_}})`
            };
          case 'auto':
            return {
              left: `new Promise(function${_}(${resolve})${_}{${_}${resolve}(${INTEROP_NAMESPACE_VARIABLE}(require(`,
              right: `)));${_}})`
            };
          default:
            return {
              left: `new Promise(function${_}(${resolve})${_}{${_}${resolve}(require(`,
              right: `));${_}})`
            };
        }
      }
      case 'amd': {
        const _ = options.compact ? '' : ' ';
        const resolve = options.compact ? 'c' : 'resolve';
        const reject = options.compact ? 'e' : 'reject';
        const resolveNamespace = this.exportMode === 'default'
          ? `function${_}(m)${_}{${_}${resolve}({${_}'default':${_}m${_}});${_}}`
          : this.exportMode === 'auto'
            ? `function${_}(m)${_}{${_}${resolve}(${INTEROP_NAMESPACE_VARIABLE}(m));${_}}`
            : resolve;
        return {
          left: `new Promise(function${_}(${resolve},${_}${reject})${_}{${_}require([`,
          right: `],${_}${resolveNamespace},${_}${reject})${_}})`
        };
      }
      case 'system':
        return {
          left: 'module.import(',
          right: ')'
        };
      case 'es':
        if (options.dynamicImportFunction) {
          return {
            left: `${options.dynamicImportFunction}(`,
            right: ')'
          };
        }
    }
    return null;
  }
}

class LabeledStatement extends NodeBase {
  hasEffects(context) {
    const brokenFlow = context.brokenFlow;
    context.ignore.labels.add(this.label.name);
    if (this.body.hasEffects(context))
      return true;
    context.ignore.labels.delete(this.label.name);
    if (context.includedLabels.has(this.label.name)) {
      context.includedLabels.delete(this.label.name);
      context.brokenFlow = brokenFlow;
    }
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    const brokenFlow = context.brokenFlow;
    this.body.include(context, includeChildrenRecursively);
    if (context.includedLabels.has(this.label.name)) {
      this.label.include(context);
      context.includedLabels.delete(this.label.name);
      context.brokenFlow = brokenFlow;
    }
  }
  render(code, options) {
    if (this.label.included) {
      this.label.render(code, options);
    }
    else {
      code.remove(this.start, findFirstOccurrenceOutsideComment(code.original, ':', this.label.end) + 1);
    }
    this.body.render(code, options);
  }
}

class LogicalExpression extends NodeBase {
  constructor() {
    super(...arguments);
    // We collect deoptimization information if usedBranch !== null
    this.expressionsToBeDeoptimized = [];
    this.isBranchResolutionAnalysed = false;
    this.unusedBranch = null;
    this.usedBranch = null;
    this.wasPathDeoptimizedWhileOptimized = false;
  }
  bind() {
    super.bind();
    // ensure the usedBranch is set for the tree-shaking passes
    this.getUsedBranch();
  }
  deoptimizeCache() {
    if (this.usedBranch !== null) {
      this.usedBranch = null;
      const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
      this.expressionsToBeDeoptimized = [];
      if (this.wasPathDeoptimizedWhileOptimized) {
        this.unusedBranch.deoptimizePath(UNKNOWN_PATH);
      }
      for (const expression of expressionsToBeDeoptimized) {
        expression.deoptimizeCache();
      }
    }
  }
  deoptimizePath(path) {
    const usedBranch = this.getUsedBranch();
    if (usedBranch === null) {
      this.left.deoptimizePath(path);
      this.right.deoptimizePath(path);
    }
    else {
      this.wasPathDeoptimizedWhileOptimized = true;
      usedBranch.deoptimizePath(path);
    }
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    const usedBranch = this.getUsedBranch();
    if (usedBranch === null)
      return UnknownValue;
    this.expressionsToBeDeoptimized.push(origin);
    return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
  }
  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
    const usedBranch = this.getUsedBranch();
    if (usedBranch === null)
      return new MultiExpression([
        this.left.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin),
        this.right.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)
      ]);
    this.expressionsToBeDeoptimized.push(origin);
    return usedBranch.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
  }
  hasEffects(context) {
    if (this.usedBranch === null) {
      return this.left.hasEffects(context) || this.right.hasEffects(context);
    }
    return this.usedBranch.hasEffects(context);
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    if (path.length === 0)
      return false;
    if (this.usedBranch === null) {
      return (this.left.hasEffectsWhenAccessedAtPath(path, context) ||
        this.right.hasEffectsWhenAccessedAtPath(path, context));
    }
    return this.usedBranch.hasEffectsWhenAccessedAtPath(path, context);
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    if (path.length === 0)
      return true;
    if (this.usedBranch === null) {
      return (this.left.hasEffectsWhenAssignedAtPath(path, context) ||
        this.right.hasEffectsWhenAssignedAtPath(path, context));
    }
    return this.usedBranch.hasEffectsWhenAssignedAtPath(path, context);
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (this.usedBranch === null) {
      return (this.left.hasEffectsWhenCalledAtPath(path, callOptions, context) ||
        this.right.hasEffectsWhenCalledAtPath(path, callOptions, context));
    }
    return this.usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    if (includeChildrenRecursively ||
      (this.usedBranch === this.right && this.left.shouldBeIncluded(context)) ||
      this.usedBranch === null) {
      this.left.include(context, includeChildrenRecursively);
      this.right.include(context, includeChildrenRecursively);
    }
    else {
      this.usedBranch.include(context, includeChildrenRecursively);
    }
  }
  render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = BLANK) {
    if (!this.left.included || !this.right.included) {
      const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);
      if (this.right.included) {
        code.remove(this.start, operatorPos + 2);
        if (preventASI) {
          removeLineBreaks(code, operatorPos + 2, this.right.start);
        }
      }
      else {
        code.remove(operatorPos, this.end);
      }
      removeAnnotations(this, code);
      this.usedBranch.render(code, options, {
        isCalleeOfRenderedParent: renderedParentType
          ? isCalleeOfRenderedParent
          : this.parent.callee === this,
        renderedParentType: renderedParentType || this.parent.type
      });
    }
    else {
      super.render(code, options);
    }
  }
  getUsedBranch() {
    if (!this.isBranchResolutionAnalysed) {
      this.isBranchResolutionAnalysed = true;
      const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
      if (leftValue === UnknownValue) {
        return null;
      }
      else {
        if (this.operator === '||' ? leftValue : !leftValue) {
          this.usedBranch = this.left;
          this.unusedBranch = this.right;
        }
        else {
          this.usedBranch = this.right;
          this.unusedBranch = this.left;
        }
      }
    }
    return this.usedBranch;
  }
}

const readFile$2 = (file) => new Promise((fulfil, reject) => readFile(file, 'utf-8', (err, contents) => (err ? reject(err) : fulfil(contents))));
function mkdirpath(path) {
  const dir = dirname(path);
  try {
    readdirSync(dir);
  }
  catch (err) {
    mkdirpath(dir);
    try {
      mkdirSync(dir);
    }
    catch (err2) {
      if (err2.code !== 'EEXIST') {
        throw err2;
      }
    }
  }
}
function writeFile$1(dest, data) {
  return new Promise((fulfil, reject) => {
    mkdirpath(dest);
    writeFile(dest, data, err => {
      if (err) {
        reject(err);
      }
      else {
        fulfil();
      }
    });
  });
}

function getRollupDefaultPlugin(preserveSymlinks) {
  return {
    name: 'Rollup Core',
    resolveId: createResolveId(preserveSymlinks),
    load(id) {
      return readFile$2(id);
    },
    resolveFileUrl({ relativePath, format }) {
      return relativeUrlMechanisms[format](relativePath);
    },
    resolveImportMeta(prop, { chunkId, format }) {
      const mechanism = importMetaMechanisms[format] && importMetaMechanisms[format](prop, chunkId);
      if (mechanism) {
        return mechanism;
      }
    }
  };
}
function findFile(file, preserveSymlinks) {
  try {
    const stats = lstatSync(file);
    if (!preserveSymlinks && stats.isSymbolicLink())
      return findFile(realpathSync(file), preserveSymlinks);
    if ((preserveSymlinks && stats.isSymbolicLink()) || stats.isFile()) {
      // check case
      const name = basename(file);
      const files = readdirSync(dirname(file));
      if (files.indexOf(name) !== -1)
        return file;
    }
  }
  catch (err) {
    // suppress
  }
}
function addJsExtensionIfNecessary(file, preserveSymlinks) {
  let found = findFile(file, preserveSymlinks);
  if (found)
    return found;
  found = findFile(file + '.mjs', preserveSymlinks);
  if (found)
    return found;
  found = findFile(file + '.js', preserveSymlinks);
  return found;
}
function createResolveId(preserveSymlinks) {
  return function (source, importer) {
    if (typeof process === 'undefined') {
      return error({
        code: 'MISSING_PROCESS',
        message: `It looks like you're using Rollup in a non-Node.js environment. This means you must supply a plugin with custom resolveId and load functions`,
        url: 'https://rollupjs.org/guide/en/#a-simple-example'
      });
    }
    // external modules (non-entry modules that start with neither '.' or '/')
    // are skipped at this stage.
    if (importer !== undefined && !isAbsolute$1(source) && source[0] !== '.')
      return null;
    // `resolve` processes paths from right to left, prepending them until an
    // absolute path is created. Absolute importees therefore shortcircuit the
    // resolve call and require no special handing on our part.
    // See https://nodejs.org/api/path.html#path_path_resolve_paths
    return addJsExtensionIfNecessary(resolve(importer ? dirname(importer) : resolve(), source), preserveSymlinks);
  };
}
const getResolveUrl = (path, URL = 'URL') => `new ${URL}(${path}).href`;
const getUrlFromDocument = (chunkId) => `(document.currentScript && document.currentScript.src || new URL('${chunkId}', document.baseURI).href)`;
const getGenericImportMetaMechanism = (getUrl) => (prop, chunkId) => {
  const urlMechanism = getUrl(chunkId);
  return prop === null ? `({ url: ${urlMechanism} })` : prop === 'url' ? urlMechanism : 'undefined';
};
const importMetaMechanisms = {
  amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
  cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`),
  iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),
  system: prop => (prop === null ? `module.meta` : `module.meta.${prop}`),
  umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`)
};
const getRelativeUrlFromDocument = (relativePath) => getResolveUrl(`'${relativePath}', document.currentScript && document.currentScript.src || document.baseURI`);
const relativeUrlMechanisms = {
  amd: relativePath => {
    if (relativePath[0] !== '.')
      relativePath = './' + relativePath;
    return getResolveUrl(`require.toUrl('${relativePath}'), document.baseURI`);
  },
  cjs: relativePath => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: relativePath => getResolveUrl(`'${relativePath}', import.meta.url`),
  iife: relativePath => getRelativeUrlFromDocument(relativePath),
  system: relativePath => getResolveUrl(`'${relativePath}', module.meta.url`),
  umd: relativePath => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`
};
const accessedMetaUrlGlobals = {
  amd: ['document', 'module', 'URL'],
  cjs: ['document', 'require', 'URL'],
  iife: ['document', 'URL'],
  system: ['module'],
  umd: ['document', 'require', 'URL']
};
const accessedFileUrlGlobals = {
  amd: ['document', 'require', 'URL'],
  cjs: ['document', 'require', 'URL'],
  iife: ['document', 'URL'],
  system: ['module', 'URL'],
  umd: ['document', 'require', 'URL']
};

const ASSET_PREFIX = 'ROLLUP_ASSET_URL_';
const CHUNK_PREFIX = 'ROLLUP_CHUNK_URL_';
const FILE_PREFIX = 'ROLLUP_FILE_URL_';
class MetaProperty extends NodeBase {
  hasEffects() {
    return false;
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
  include() {
    if (!this.included) {
      this.included = true;
      const parent = this.parent;
      const metaProperty = (this.metaProperty =
        parent instanceof MemberExpression && typeof parent.propertyKey === 'string'
          ? parent.propertyKey
          : null);
      if (metaProperty &&
        (metaProperty.startsWith(FILE_PREFIX) ||
          metaProperty.startsWith(ASSET_PREFIX) ||
          metaProperty.startsWith(CHUNK_PREFIX))) {
        this.scope.addAccessedGlobalsByFormat(accessedFileUrlGlobals);
      }
      else {
        this.scope.addAccessedGlobalsByFormat(accessedMetaUrlGlobals);
      }
    }
  }
  initialise() {
    if (this.meta.name === 'import') {
      this.context.addImportMeta(this);
    }
  }
  renderFinalMechanism(code, chunkId, format, outputPluginDriver) {
    if (!this.included)
      return;
    const parent = this.parent;
    const metaProperty = this.metaProperty;
    if (metaProperty &&
      (metaProperty.startsWith(FILE_PREFIX) ||
        metaProperty.startsWith(ASSET_PREFIX) ||
        metaProperty.startsWith(CHUNK_PREFIX))) {
      let referenceId = null;
      let assetReferenceId = null;
      let chunkReferenceId = null;
      let fileName;
      if (metaProperty.startsWith(FILE_PREFIX)) {
        referenceId = metaProperty.substr(FILE_PREFIX.length);
        fileName = outputPluginDriver.getFileName(referenceId);
      }
      else if (metaProperty.startsWith(ASSET_PREFIX)) {
        this.context.warnDeprecation(`Using the "${ASSET_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, false);
        assetReferenceId = metaProperty.substr(ASSET_PREFIX.length);
        fileName = outputPluginDriver.getFileName(assetReferenceId);
      }
      else {
        this.context.warnDeprecation(`Using the "${CHUNK_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, false);
        chunkReferenceId = metaProperty.substr(CHUNK_PREFIX.length);
        fileName = outputPluginDriver.getFileName(chunkReferenceId);
      }
      const relativePath = normalize$1(relative(dirname(chunkId), fileName));
      let replacement;
      if (assetReferenceId !== null) {
        replacement = outputPluginDriver.hookFirstSync('resolveAssetUrl', [
          {
            assetFileName: fileName,
            chunkId,
            format,
            moduleId: this.context.module.id,
            relativeAssetPath: relativePath
          }
        ]);
      }
      if (!replacement) {
        replacement = outputPluginDriver.hookFirstSync('resolveFileUrl', [
          {
            assetReferenceId,
            chunkId,
            chunkReferenceId,
            fileName,
            format,
            moduleId: this.context.module.id,
            referenceId: referenceId || assetReferenceId || chunkReferenceId,
            relativePath
          }
        ]);
      }
      code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
      return;
    }
    const replacement = outputPluginDriver.hookFirstSync('resolveImportMeta', [
      metaProperty,
      {
        chunkId,
        format,
        moduleId: this.context.module.id
      }
    ]);
    if (typeof replacement === 'string') {
      if (parent instanceof MemberExpression) {
        code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
      }
      else {
        code.overwrite(this.start, this.end, replacement, { contentOnly: true });
      }
    }
  }
}

class MethodDefinition extends NodeBase {
  hasEffects(context) {
    return this.key.hasEffects(context);
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    return (path.length > 0 || this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, context));
  }
}

class NewExpression extends NodeBase {
  bind() {
    super.bind();
    for (const argument of this.arguments) {
      // This will make sure all properties of parameters behave as "unknown"
      argument.deoptimizePath(UNKNOWN_PATH);
    }
  }
  hasEffects(context) {
    for (const argument of this.arguments) {
      if (argument.hasEffects(context))
        return true;
    }
    if (this.context.annotations && this.annotatedPure)
      return false;
    return (this.callee.hasEffects(context) ||
      this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
  initialise() {
    this.callOptions = {
      args: this.arguments,
      withNew: true
    };
  }
}

class SpreadElement extends NodeBase {
  bind() {
    super.bind();
    // Only properties of properties of the argument could become subject to reassignment
    // This will also reassign the return values of iterators
    this.argument.deoptimizePath([UnknownKey, UnknownKey]);
  }
}

class ObjectExpression extends NodeBase {
  constructor() {
    super(...arguments);
    this.deoptimizedPaths = new Set();
    // We collect deoptimization information if we can resolve a computed property access
    this.expressionsToBeDeoptimized = new Map();
    this.hasUnknownDeoptimizedProperty = false;
    this.propertyMap = null;
    this.unmatchablePropertiesRead = [];
    this.unmatchablePropertiesWrite = [];
  }
  bind() {
    super.bind();
    // ensure the propertyMap is set for the tree-shaking passes
    this.getPropertyMap();
  }
  // We could also track this per-property but this would quickly become much more complex
  deoptimizeCache() {
    if (!this.hasUnknownDeoptimizedProperty)
      this.deoptimizeAllProperties();
  }
  deoptimizePath(path) {
    if (this.hasUnknownDeoptimizedProperty)
      return;
    const propertyMap = this.getPropertyMap();
    const key = path[0];
    if (path.length === 1) {
      if (typeof key !== 'string') {
        this.deoptimizeAllProperties();
        return;
      }
      if (!this.deoptimizedPaths.has(key)) {
        this.deoptimizedPaths.add(key);
        // we only deoptimizeCache exact matches as in all other cases,
        // we do not return a literal value or return expression
        const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);
        if (expressionsToBeDeoptimized) {
          for (const expression of expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
          }
        }
      }
    }
    const subPath = path.length === 1 ? UNKNOWN_PATH : path.slice(1);
    for (const property of typeof key === 'string'
      ? propertyMap[key]
        ? propertyMap[key].propertiesRead
        : []
      : this.properties) {
      property.deoptimizePath(subPath);
    }
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    const propertyMap = this.getPropertyMap();
    const key = path[0];
    if (path.length === 0 ||
      this.hasUnknownDeoptimizedProperty ||
      typeof key !== 'string' ||
      this.deoptimizedPaths.has(key))
      return UnknownValue;
    if (path.length === 1 &&
      !propertyMap[key] &&
      !objectMembers[key] &&
      this.unmatchablePropertiesRead.length === 0) {
      const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);
      if (expressionsToBeDeoptimized) {
        expressionsToBeDeoptimized.push(origin);
      }
      else {
        this.expressionsToBeDeoptimized.set(key, [origin]);
      }
      return undefined;
    }
    if (!propertyMap[key] ||
      propertyMap[key].exactMatchRead === null ||
      propertyMap[key].propertiesRead.length > 1) {
      return UnknownValue;
    }
    const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);
    if (expressionsToBeDeoptimized) {
      expressionsToBeDeoptimized.push(origin);
    }
    else {
      this.expressionsToBeDeoptimized.set(key, [origin]);
    }
    return propertyMap[key].exactMatchRead.getLiteralValueAtPath(path.slice(1), recursionTracker, origin);
  }
  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
    const propertyMap = this.getPropertyMap();
    const key = path[0];
    if (path.length === 0 ||
      this.hasUnknownDeoptimizedProperty ||
      typeof key !== 'string' ||
      this.deoptimizedPaths.has(key))
      return UNKNOWN_EXPRESSION;
    if (path.length === 1 &&
      objectMembers[key] &&
      this.unmatchablePropertiesRead.length === 0 &&
      (!propertyMap[key] || propertyMap[key].exactMatchRead === null))
      return getMemberReturnExpressionWhenCalled(objectMembers, key);
    if (!propertyMap[key] ||
      propertyMap[key].exactMatchRead === null ||
      propertyMap[key].propertiesRead.length > 1)
      return UNKNOWN_EXPRESSION;
    const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);
    if (expressionsToBeDeoptimized) {
      expressionsToBeDeoptimized.push(origin);
    }
    else {
      this.expressionsToBeDeoptimized.set(key, [origin]);
    }
    return propertyMap[key].exactMatchRead.getReturnExpressionWhenCalledAtPath(path.slice(1), recursionTracker, origin);
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    if (path.length === 0)
      return false;
    const key = path[0];
    const propertyMap = this.propertyMap;
    if (path.length > 1 &&
      (this.hasUnknownDeoptimizedProperty ||
        typeof key !== 'string' ||
        this.deoptimizedPaths.has(key) ||
        !propertyMap[key] ||
        propertyMap[key].exactMatchRead === null))
      return true;
    const subPath = path.slice(1);
    for (const property of typeof key !== 'string'
      ? this.properties
      : propertyMap[key]
        ? propertyMap[key].propertiesRead
        : []) {
      if (property.hasEffectsWhenAccessedAtPath(subPath, context))
        return true;
    }
    return false;
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    const key = path[0];
    const propertyMap = this.propertyMap;
    if (path.length > 1 &&
      (this.hasUnknownDeoptimizedProperty ||
        this.deoptimizedPaths.has(key) ||
        !propertyMap[key] ||
        propertyMap[key].exactMatchRead === null)) {
      return true;
    }
    const subPath = path.slice(1);
    for (const property of typeof key !== 'string'
      ? this.properties
      : path.length > 1
        ? propertyMap[key].propertiesRead
        : propertyMap[key]
          ? propertyMap[key].propertiesWrite
          : []) {
      if (property.hasEffectsWhenAssignedAtPath(subPath, context))
        return true;
    }
    return false;
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    const key = path[0];
    if (typeof key !== 'string' ||
      this.hasUnknownDeoptimizedProperty ||
      this.deoptimizedPaths.has(key) ||
      (this.propertyMap[key]
        ? !this.propertyMap[key].exactMatchRead
        : path.length > 1 || !objectMembers[key])) {
      return true;
    }
    const subPath = path.slice(1);
    if (this.propertyMap[key]) {
      for (const property of this.propertyMap[key].propertiesRead) {
        if (property.hasEffectsWhenCalledAtPath(subPath, callOptions, context))
          return true;
      }
    }
    if (path.length === 1 && objectMembers[key])
      return hasMemberEffectWhenCalled(objectMembers, key, this.included, callOptions, context);
    return false;
  }
  render(code, options, { renderedParentType } = BLANK) {
    super.render(code, options);
    if (renderedParentType === ExpressionStatement) {
      code.appendRight(this.start, '(');
      code.prependLeft(this.end, ')');
    }
  }
  deoptimizeAllProperties() {
    this.hasUnknownDeoptimizedProperty = true;
    for (const property of this.properties) {
      property.deoptimizePath(UNKNOWN_PATH);
    }
    for (const expressionsToBeDeoptimized of this.expressionsToBeDeoptimized.values()) {
      for (const expression of expressionsToBeDeoptimized) {
        expression.deoptimizeCache();
      }
    }
  }
  getPropertyMap() {
    if (this.propertyMap !== null) {
      return this.propertyMap;
    }
    const propertyMap = (this.propertyMap = Object.create(null));
    for (let index = this.properties.length - 1; index >= 0; index--) {
      const property = this.properties[index];
      if (property instanceof SpreadElement) {
        this.unmatchablePropertiesRead.push(property);
        continue;
      }
      const isWrite = property.kind !== 'get';
      const isRead = property.kind !== 'set';
      let key;
      if (property.computed) {
        const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
        if (keyValue === UnknownValue) {
          if (isRead) {
            this.unmatchablePropertiesRead.push(property);
          }
          else {
            this.unmatchablePropertiesWrite.push(property);
          }
          continue;
        }
        key = String(keyValue);
      }
      else if (property.key instanceof Identifier$1) {
        key = property.key.name;
      }
      else {
        key = String(property.key.value);
      }
      const propertyMapProperty = propertyMap[key];
      if (!propertyMapProperty) {
        propertyMap[key] = {
          exactMatchRead: isRead ? property : null,
          exactMatchWrite: isWrite ? property : null,
          propertiesRead: isRead ? [property, ...this.unmatchablePropertiesRead] : [],
          propertiesWrite: isWrite && !isRead ? [property, ...this.unmatchablePropertiesWrite] : []
        };
        continue;
      }
      if (isRead && propertyMapProperty.exactMatchRead === null) {
        propertyMapProperty.exactMatchRead = property;
        propertyMapProperty.propertiesRead.push(property, ...this.unmatchablePropertiesRead);
      }
      if (isWrite && !isRead && propertyMapProperty.exactMatchWrite === null) {
        propertyMapProperty.exactMatchWrite = property;
        propertyMapProperty.propertiesWrite.push(property, ...this.unmatchablePropertiesWrite);
      }
    }
    return propertyMap;
  }
}

class ObjectPattern extends NodeBase {
  addExportedVariables(variables) {
    for (const property of this.properties) {
      if (property.type === Property) {
        property.value.addExportedVariables(variables);
      }
      else {
        property.argument.addExportedVariables(variables);
      }
    }
  }
  declare(kind, init) {
    const variables = [];
    for (const property of this.properties) {
      variables.push(...property.declare(kind, init));
    }
    return variables;
  }
  deoptimizePath(path) {
    if (path.length === 0) {
      for (const property of this.properties) {
        property.deoptimizePath(path);
      }
    }
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    if (path.length > 0)
      return true;
    for (const property of this.properties) {
      if (property.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))
        return true;
    }
    return false;
  }
}

class Program$1 extends NodeBase {
  hasEffects(context) {
    for (const node of this.body) {
      if (node.hasEffects(context))
        return true;
    }
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    for (const node of this.body) {
      if (includeChildrenRecursively || node.shouldBeIncluded(context)) {
        node.include(context, includeChildrenRecursively);
      }
    }
  }
  render(code, options) {
    if (this.body.length) {
      renderStatementList(this.body, code, this.start, this.end, options);
    }
    else {
      super.render(code, options);
    }
  }
}

class Property$1 extends NodeBase {
  constructor() {
    super(...arguments);
    this.declarationInit = null;
    this.returnExpression = null;
  }
  bind() {
    super.bind();
    if (this.kind === 'get') {
      // ensure the returnExpression is set for the tree-shaking passes
      this.getReturnExpression();
    }
    if (this.declarationInit !== null) {
      this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
    }
  }
  declare(kind, init) {
    this.declarationInit = init;
    return this.value.declare(kind, UNKNOWN_EXPRESSION);
  }
  // As getter properties directly receive their values from function expressions that always
  // have a fixed return value, there is no known situation where a getter is deoptimized.
  deoptimizeCache() { }
  deoptimizePath(path) {
    if (this.kind === 'get') {
      this.getReturnExpression().deoptimizePath(path);
    }
    else {
      this.value.deoptimizePath(path);
    }
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    if (this.kind === 'get') {
      return this.getReturnExpression().getLiteralValueAtPath(path, recursionTracker, origin);
    }
    return this.value.getLiteralValueAtPath(path, recursionTracker, origin);
  }
  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
    if (this.kind === 'get') {
      return this.getReturnExpression().getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
    }
    return this.value.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
  }
  hasEffects(context) {
    return this.key.hasEffects(context) || this.value.hasEffects(context);
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    if (this.kind === 'get') {
      const trackedExpressions = context.accessed.getEntities(path);
      if (trackedExpressions.has(this))
        return false;
      trackedExpressions.add(this);
      return (this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context) ||
        (path.length > 0 && this.returnExpression.hasEffectsWhenAccessedAtPath(path, context)));
    }
    return this.value.hasEffectsWhenAccessedAtPath(path, context);
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    if (this.kind === 'get') {
      const trackedExpressions = context.assigned.getEntities(path);
      if (trackedExpressions.has(this))
        return false;
      trackedExpressions.add(this);
      return this.returnExpression.hasEffectsWhenAssignedAtPath(path, context);
    }
    if (this.kind === 'set') {
      const trackedExpressions = context.assigned.getEntities(path);
      if (trackedExpressions.has(this))
        return false;
      trackedExpressions.add(this);
      return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context);
    }
    return this.value.hasEffectsWhenAssignedAtPath(path, context);
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    if (this.kind === 'get') {
      const trackedExpressions = (callOptions.withNew
        ? context.instantiated
        : context.called).getEntities(path);
      if (trackedExpressions.has(this))
        return false;
      trackedExpressions.add(this);
      return this.returnExpression.hasEffectsWhenCalledAtPath(path, callOptions, context);
    }
    return this.value.hasEffectsWhenCalledAtPath(path, callOptions, context);
  }
  initialise() {
    this.accessorCallOptions = {
      args: NO_ARGS,
      withNew: false
    };
  }
  render(code, options) {
    if (!this.shorthand) {
      this.key.render(code, options);
    }
    this.value.render(code, options, { isShorthandProperty: this.shorthand });
  }
  getReturnExpression() {
    if (this.returnExpression === null) {
      this.returnExpression = UNKNOWN_EXPRESSION;
      return (this.returnExpression = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));
    }
    return this.returnExpression;
  }
}

class ReturnStatement$1 extends NodeBase {
  hasEffects(context) {
    if (!context.ignore.returnAwaitYield ||
      (this.argument !== null && this.argument.hasEffects(context)))
      return true;
    context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    if (this.argument) {
      this.argument.include(context, includeChildrenRecursively);
    }
    context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
  }
  initialise() {
    this.scope.addReturnExpression(this.argument || UNKNOWN_EXPRESSION);
  }
  render(code, options) {
    if (this.argument) {
      this.argument.render(code, options, { preventASI: true });
      if (this.argument.start === this.start + 6 /* 'return'.length */) {
        code.prependLeft(this.start + 6, ' ');
      }
    }
  }
}

class SequenceExpression extends NodeBase {
  deoptimizePath(path) {
    if (path.length > 0)
      this.expressions[this.expressions.length - 1].deoptimizePath(path);
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path, recursionTracker, origin);
  }
  hasEffects(context) {
    for (const expression of this.expressions) {
      if (expression.hasEffects(context))
        return true;
    }
    return false;
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    return (path.length > 0 &&
      this.expressions[this.expressions.length - 1].hasEffectsWhenAccessedAtPath(path, context));
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    return (path.length === 0 ||
      this.expressions[this.expressions.length - 1].hasEffectsWhenAssignedAtPath(path, context));
  }
  hasEffectsWhenCalledAtPath(path, callOptions, context) {
    return this.expressions[this.expressions.length - 1].hasEffectsWhenCalledAtPath(path, callOptions, context);
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    for (let i = 0; i < this.expressions.length - 1; i++) {
      const node = this.expressions[i];
      if (includeChildrenRecursively || node.shouldBeIncluded(context))
        node.include(context, includeChildrenRecursively);
    }
    this.expressions[this.expressions.length - 1].include(context, includeChildrenRecursively);
  }
  render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = BLANK) {
    let includedNodes = 0;
    for (const { node, start, end } of getCommaSeparatedNodesWithBoundaries(this.expressions, code, this.start, this.end)) {
      if (!node.included) {
        treeshakeNode(node, code, start, end);
        continue;
      }
      includedNodes++;
      if (includedNodes === 1 && preventASI) {
        removeLineBreaks(code, start, node.start);
      }
      if (node === this.expressions[this.expressions.length - 1] && includedNodes === 1) {
        node.render(code, options, {
          isCalleeOfRenderedParent: renderedParentType
            ? isCalleeOfRenderedParent
            : this.parent.callee === this,
          renderedParentType: renderedParentType || this.parent.type
        });
      }
      else {
        node.render(code, options);
      }
    }
  }
}

class SwitchCase extends NodeBase {
  hasEffects(context) {
    if (this.test && this.test.hasEffects(context))
      return true;
    for (const node of this.consequent) {
      if (context.brokenFlow)
        break;
      if (node.hasEffects(context))
        return true;
    }
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    if (this.test)
      this.test.include(context, includeChildrenRecursively);
    for (const node of this.consequent) {
      if (includeChildrenRecursively || node.shouldBeIncluded(context))
        node.include(context, includeChildrenRecursively);
    }
  }
  render(code, options, nodeRenderOptions) {
    if (this.consequent.length) {
      this.test && this.test.render(code, options);
      const testEnd = this.test
        ? this.test.end
        : findFirstOccurrenceOutsideComment(code.original, 'default', this.start) + 7;
      const consequentStart = findFirstOccurrenceOutsideComment(code.original, ':', testEnd) + 1;
      renderStatementList(this.consequent, code, consequentStart, nodeRenderOptions.end, options);
    }
    else {
      super.render(code, options);
    }
  }
}
SwitchCase.prototype.needsBoundaries = true;

class SwitchStatement extends NodeBase {
  createScope(parentScope) {
    this.scope = new BlockScope(parentScope);
  }
  hasEffects(context) {
    if (this.discriminant.hasEffects(context))
      return true;
    const { brokenFlow, ignore: { breaks } } = context;
    let minBrokenFlow = Infinity;
    context.ignore.breaks = true;
    for (const switchCase of this.cases) {
      if (switchCase.hasEffects(context))
        return true;
      minBrokenFlow = context.brokenFlow < minBrokenFlow ? context.brokenFlow : minBrokenFlow;
      context.brokenFlow = brokenFlow;
    }
    if (this.defaultCase !== null && !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {
      context.brokenFlow = minBrokenFlow;
    }
    context.ignore.breaks = breaks;
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    this.discriminant.include(context, includeChildrenRecursively);
    const { brokenFlow } = context;
    let minBrokenFlow = Infinity;
    let isCaseIncluded = includeChildrenRecursively ||
      (this.defaultCase !== null && this.defaultCase < this.cases.length - 1);
    for (let caseIndex = this.cases.length - 1; caseIndex >= 0; caseIndex--) {
      const switchCase = this.cases[caseIndex];
      if (switchCase.included) {
        isCaseIncluded = true;
      }
      if (!isCaseIncluded) {
        const hasEffectsContext = createHasEffectsContext();
        hasEffectsContext.ignore.breaks = true;
        isCaseIncluded = switchCase.hasEffects(hasEffectsContext);
      }
      if (isCaseIncluded) {
        switchCase.include(context, includeChildrenRecursively);
        minBrokenFlow = minBrokenFlow < context.brokenFlow ? minBrokenFlow : context.brokenFlow;
        context.brokenFlow = brokenFlow;
      }
      else {
        minBrokenFlow = brokenFlow;
      }
    }
    if (isCaseIncluded &&
      this.defaultCase !== null &&
      !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {
      context.brokenFlow = minBrokenFlow;
    }
  }
  initialise() {
    for (let caseIndex = 0; caseIndex < this.cases.length; caseIndex++) {
      if (this.cases[caseIndex].test === null) {
        this.defaultCase = caseIndex;
        return;
      }
    }
    this.defaultCase = null;
  }
  render(code, options) {
    this.discriminant.render(code, options);
    if (this.cases.length > 0) {
      renderStatementList(this.cases, code, this.cases[0].start, this.end - 1, options);
    }
  }
}

class TaggedTemplateExpression extends NodeBase {
  bind() {
    super.bind();
    if (this.tag.type === Identifier) {
      const name = this.tag.name;
      const variable = this.scope.findVariable(name);
      if (variable.isNamespace) {
        return this.context.error({
          code: 'CANNOT_CALL_NAMESPACE',
          message: `Cannot call a namespace ('${name}')`
        }, this.start);
      }
      if (name === 'eval') {
        this.context.warn({
          code: 'EVAL',
          message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,
          url: 'https://rollupjs.org/guide/en/#avoiding-eval'
        }, this.start);
      }
    }
  }
  hasEffects(context) {
    return (super.hasEffects(context) ||
      this.tag.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));
  }
  initialise() {
    this.callOptions = {
      args: NO_ARGS,
      withNew: false
    };
  }
}

class TemplateElement extends NodeBase {
  hasEffects() {
    return false;
  }
}

class TemplateLiteral extends NodeBase {
  getLiteralValueAtPath(path) {
    if (path.length > 0 || this.quasis.length !== 1) {
      return UnknownValue;
    }
    return this.quasis[0].value.cooked;
  }
  render(code, options) {
    code.indentExclusionRanges.push([this.start, this.end]);
    super.render(code, options);
  }
}

class ModuleScope extends ChildScope {
  constructor(parent, context) {
    super(parent);
    this.context = context;
    this.variables.set('this', new LocalVariable('this', null, UNDEFINED_EXPRESSION, context));
  }
  addExportDefaultDeclaration(name, exportDefaultDeclaration, context) {
    const variable = new ExportDefaultVariable(name, exportDefaultDeclaration, context);
    this.variables.set('default', variable);
    return variable;
  }
  addNamespaceMemberAccess(_name, variable) {
    if (variable instanceof GlobalVariable) {
      this.accessedOutsideVariables.set(variable.name, variable);
    }
  }
  deconflict(format) {
    // all module level variables are already deconflicted when deconflicting the chunk
    for (const scope of this.children)
      scope.deconflict(format);
  }
  findLexicalBoundary() {
    return this;
  }
  findVariable(name) {
    const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);
    if (knownVariable) {
      return knownVariable;
    }
    const variable = this.context.traceVariable(name) || this.parent.findVariable(name);
    if (variable instanceof GlobalVariable) {
      this.accessedOutsideVariables.set(name, variable);
    }
    return variable;
  }
}

class ThisExpression extends NodeBase {
  bind() {
    super.bind();
    this.variable = this.scope.findVariable('this');
  }
  hasEffectsWhenAccessedAtPath(path, context) {
    return path.length > 0 && this.variable.hasEffectsWhenAccessedAtPath(path, context);
  }
  hasEffectsWhenAssignedAtPath(path, context) {
    return this.variable.hasEffectsWhenAssignedAtPath(path, context);
  }
  initialise() {
    this.alias =
      this.scope.findLexicalBoundary() instanceof ModuleScope ? this.context.moduleContext : null;
    if (this.alias === 'undefined') {
      this.context.warn({
        code: 'THIS_IS_UNDEFINED',
        message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
        url: `https://rollupjs.org/guide/en/#error-this-is-undefined`
      }, this.start);
    }
  }
  render(code) {
    if (this.alias !== null) {
      code.overwrite(this.start, this.end, this.alias, {
        contentOnly: false,
        storeName: true
      });
    }
  }
}

class ThrowStatement extends NodeBase {
  hasEffects() {
    return true;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    this.argument.include(context, includeChildrenRecursively);
    context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
  }
  render(code, options) {
    this.argument.render(code, options, { preventASI: true });
    if (this.argument.start === this.start + 5 /* 'throw'.length */) {
      code.prependLeft(this.start + 5, ' ');
    }
  }
}

class TryStatement extends NodeBase {
  constructor() {
    super(...arguments);
    this.directlyIncluded = false;
  }
  hasEffects(context) {
    return ((this.context.tryCatchDeoptimization
      ? this.block.body.length > 0
      : this.block.hasEffects(context)) ||
      (this.finalizer !== null && this.finalizer.hasEffects(context)));
  }
  include(context, includeChildrenRecursively) {
    const { brokenFlow } = context;
    if (!this.directlyIncluded || !this.context.tryCatchDeoptimization) {
      this.included = true;
      this.directlyIncluded = true;
      this.block.include(context, this.context.tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);
      context.brokenFlow = brokenFlow;
    }
    if (this.handler !== null) {
      this.handler.include(context, includeChildrenRecursively);
      context.brokenFlow = brokenFlow;
    }
    if (this.finalizer !== null) {
      this.finalizer.include(context, includeChildrenRecursively);
    }
  }
}

const unaryOperators = {
  '!': value => !value,
  '+': value => +value,
  '-': value => -value,
  delete: () => UnknownValue,
  typeof: value => typeof value,
  void: () => undefined,
  '~': value => ~value
};
class UnaryExpression extends NodeBase {
  bind() {
    super.bind();
    if (this.operator === 'delete') {
      this.argument.deoptimizePath(EMPTY_PATH);
    }
  }
  getLiteralValueAtPath(path, recursionTracker, origin) {
    if (path.length > 0)
      return UnknownValue;
    const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
    if (argumentValue === UnknownValue)
      return UnknownValue;
    return unaryOperators[this.operator](argumentValue);
  }
  hasEffects(context) {
    if (this.operator === 'typeof' && this.argument instanceof Identifier$1)
      return false;
    return (this.argument.hasEffects(context) ||
      (this.operator === 'delete' &&
        this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context)));
  }
  hasEffectsWhenAccessedAtPath(path) {
    if (this.operator === 'void') {
      return path.length > 0;
    }
    return path.length > 1;
  }
}

class UnknownNode extends NodeBase {
  hasEffects() {
    return true;
  }
  include(context) {
    super.include(context, true);
  }
}

class UpdateExpression extends NodeBase {
  bind() {
    super.bind();
    this.argument.deoptimizePath(EMPTY_PATH);
    if (this.argument instanceof Identifier$1) {
      const variable = this.scope.findVariable(this.argument.name);
      variable.isReassigned = true;
    }
  }
  hasEffects(context) {
    return (this.argument.hasEffects(context) ||
      this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context));
  }
  hasEffectsWhenAccessedAtPath(path) {
    return path.length > 1;
  }
  render(code, options) {
    this.argument.render(code, options);
    const variable = this.argument.variable;
    if (options.format === 'system' && variable && variable.exportName) {
      const name = variable.getName();
      if (this.prefix) {
        code.overwrite(this.start, this.end, `exports('${variable.exportName}', ${this.operator}${name})`);
      }
      else {
        let op;
        switch (this.operator) {
          case '++':
            op = `${name} + 1`;
            break;
          case '--':
            op = `${name} - 1`;
            break;
        }
        code.overwrite(this.start, this.end, `(exports('${variable.exportName}', ${op}), ${name}${this.operator})`);
      }
    }
  }
}

function isReassignedExportsMember(variable) {
  return variable.renderBaseName !== null && variable.exportName !== null && variable.isReassigned;
}
function areAllDeclarationsIncludedAndNotExported(declarations) {
  for (const declarator of declarations) {
    if (!declarator.included)
      return false;
    if (declarator.id.type === Identifier) {
      if (declarator.id.variable.exportName)
        return false;
    }
    else {
      const exportedVariables = [];
      declarator.id.addExportedVariables(exportedVariables);
      if (exportedVariables.length > 0)
        return false;
    }
  }
  return true;
}
class VariableDeclaration extends NodeBase {
  deoptimizePath() {
    for (const declarator of this.declarations) {
      declarator.deoptimizePath(EMPTY_PATH);
    }
  }
  hasEffectsWhenAssignedAtPath() {
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    for (const declarator of this.declarations) {
      if (includeChildrenRecursively || declarator.shouldBeIncluded(context))
        declarator.include(context, includeChildrenRecursively);
    }
  }
  includeWithAllDeclaredVariables(includeChildrenRecursively, context) {
    this.included = true;
    for (const declarator of this.declarations) {
      declarator.include(context, includeChildrenRecursively);
    }
  }
  initialise() {
    for (const declarator of this.declarations) {
      declarator.declareDeclarator(this.kind);
    }
  }
  render(code, options, nodeRenderOptions = BLANK) {
    if (areAllDeclarationsIncludedAndNotExported(this.declarations)) {
      for (const declarator of this.declarations) {
        declarator.render(code, options);
      }
      if (!nodeRenderOptions.isNoStatement &&
        code.original.charCodeAt(this.end - 1) !== 59 /*";"*/) {
        code.appendLeft(this.end, ';');
      }
    }
    else {
      this.renderReplacedDeclarations(code, options, nodeRenderOptions);
    }
  }
  renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, addSemicolon, systemPatternExports) {
    if (code.original.charCodeAt(this.end - 1) === 59 /*";"*/) {
      code.remove(this.end - 1, this.end);
    }
    if (addSemicolon) {
      separatorString += ';';
    }
    if (lastSeparatorPos !== null) {
      if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*"\n"*/ &&
        (code.original.charCodeAt(this.end) === 10 /*"\n"*/ ||
          code.original.charCodeAt(this.end) === 13) /*"\r"*/) {
        actualContentEnd--;
        if (code.original.charCodeAt(actualContentEnd) === 13 /*"\r"*/) {
          actualContentEnd--;
        }
      }
      if (actualContentEnd === lastSeparatorPos + 1) {
        code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
      }
      else {
        code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
        code.remove(actualContentEnd, renderedContentEnd);
      }
    }
    else {
      code.appendLeft(renderedContentEnd, separatorString);
    }
    if (systemPatternExports.length > 0) {
      code.appendLeft(renderedContentEnd, ' ' + getSystemExportStatement(systemPatternExports));
    }
  }
  renderReplacedDeclarations(code, options, { start = this.start, end = this.end, isNoStatement }) {
    const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*";"*/ ? 1 : 0));
    let actualContentEnd, renderedContentEnd;
    if (/\n\s*$/.test(code.slice(this.start, separatedNodes[0].start))) {
      renderedContentEnd = this.start + this.kind.length;
    }
    else {
      renderedContentEnd = separatedNodes[0].start;
    }
    let lastSeparatorPos = renderedContentEnd - 1;
    code.remove(this.start, lastSeparatorPos);
    let isInDeclaration = false;
    let hasRenderedContent = false;
    let separatorString = '', leadingString, nextSeparatorString;
    const systemPatternExports = [];
    for (const { node, start, separator, contentEnd, end } of separatedNodes) {
      if (!node.included ||
        (node.id instanceof Identifier$1 &&
          isReassignedExportsMember(node.id.variable) &&
          node.init === null)) {
        code.remove(start, end);
        continue;
      }
      leadingString = '';
      nextSeparatorString = '';
      if (node.id instanceof Identifier$1 &&
        isReassignedExportsMember(node.id.variable)) {
        if (hasRenderedContent) {
          separatorString += ';';
        }
        isInDeclaration = false;
      }
      else {
        if (options.format === 'system' && node.init !== null) {
          if (node.id.type !== Identifier) {
            node.id.addExportedVariables(systemPatternExports);
          }
          else if (node.id.variable.exportName) {
            code.prependLeft(code.original.indexOf('=', node.id.end) + 1, ` exports('${node.id.variable.safeExportName || node.id.variable.exportName}',`);
            nextSeparatorString += ')';
          }
        }
        if (isInDeclaration) {
          separatorString += ',';
        }
        else {
          if (hasRenderedContent) {
            separatorString += ';';
          }
          leadingString += `${this.kind} `;
          isInDeclaration = true;
        }
      }
      if (renderedContentEnd === lastSeparatorPos + 1) {
        code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
      }
      else {
        code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
        code.appendLeft(renderedContentEnd, leadingString);
      }
      node.render(code, options);
      actualContentEnd = contentEnd;
      renderedContentEnd = end;
      hasRenderedContent = true;
      lastSeparatorPos = separator;
      separatorString = nextSeparatorString;
    }
    if (hasRenderedContent) {
      this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, !isNoStatement, systemPatternExports);
    }
    else {
      code.remove(start, end);
    }
  }
}

class VariableDeclarator extends NodeBase {
  declareDeclarator(kind) {
    this.id.declare(kind, this.init || UNDEFINED_EXPRESSION);
  }
  deoptimizePath(path) {
    this.id.deoptimizePath(path);
  }
  render(code, options) {
    // This can happen for hoisted variables in dead branches
    if (this.init !== null && !this.init.included) {
      code.remove(this.id.end, this.end);
      this.id.render(code, options);
    }
    else {
      super.render(code, options);
    }
  }
}

class WhileStatement extends NodeBase {
  hasEffects(context) {
    if (this.test.hasEffects(context))
      return true;
    const { brokenFlow, ignore: { breaks, continues } } = context;
    context.ignore.breaks = true;
    context.ignore.continues = true;
    if (this.body.hasEffects(context))
      return true;
    context.ignore.breaks = breaks;
    context.ignore.continues = continues;
    context.brokenFlow = brokenFlow;
    return false;
  }
  include(context, includeChildrenRecursively) {
    this.included = true;
    this.test.include(context, includeChildrenRecursively);
    const { brokenFlow } = context;
    this.body.include(context, includeChildrenRecursively);
    context.brokenFlow = brokenFlow;
  }
}

class YieldExpression extends NodeBase {
  bind() {
    super.bind();
    if (this.argument !== null) {
      this.argument.deoptimizePath(UNKNOWN_PATH);
    }
  }
  hasEffects(context) {
    return (!context.ignore.returnAwaitYield ||
      (this.argument !== null && this.argument.hasEffects(context)));
  }
  render(code, options) {
    if (this.argument) {
      this.argument.render(code, options);
      if (this.argument.start === this.start + 5 /* 'yield'.length */) {
        code.prependLeft(this.start + 5, ' ');
      }
    }
  }
}

const nodeConstructors = {
  ArrayExpression,
  ArrayPattern,
  ArrowFunctionExpression,
  AssignmentExpression,
  AssignmentPattern,
  AwaitExpression,
  BinaryExpression,
  BlockStatement: BlockStatement$1,
  BreakStatement,
  CallExpression: CallExpression$1,
  CatchClause,
  ClassBody,
  ClassDeclaration,
  ClassExpression,
  ConditionalExpression,
  ContinueStatement,
  DoWhileStatement,
  EmptyStatement,
  ExportAllDeclaration,
  ExportDefaultDeclaration,
  ExportNamedDeclaration,
  ExpressionStatement: ExpressionStatement$1,
  ForInStatement,
  ForOfStatement,
  ForStatement,
  FunctionDeclaration,
  FunctionExpression: FunctionExpression$1,
  Identifier: Identifier$1,
  IfStatement,
  ImportDeclaration,
  ImportExpression: Import,
  LabeledStatement,
  Literal,
  LogicalExpression,
  MemberExpression,
  MetaProperty,
  MethodDefinition,
  NewExpression,
  ObjectExpression,
  ObjectPattern,
  Program: Program$1,
  Property: Property$1,
  RestElement,
  ReturnStatement: ReturnStatement$1,
  SequenceExpression,
  SpreadElement,
  SwitchCase,
  SwitchStatement,
  TaggedTemplateExpression,
  TemplateElement,
  TemplateLiteral,
  ThisExpression,
  ThrowStatement,
  TryStatement,
  UnaryExpression,
  UnknownNode,
  UpdateExpression,
  VariableDeclaration,
  VariableDeclarator,
  WhileStatement,
  YieldExpression
};

class SyntheticNamedExportVariableVariable extends Variable {
  constructor(context, name, defaultVariable) {
    super(name);
    this.context = context;
    this.module = context.module;
    this.defaultVariable = defaultVariable;
    this.setRenderNames(defaultVariable.getName(), name);
  }
  include(context) {
    if (!this.included) {
      this.included = true;
      this.context.includeVariable(context, this.defaultVariable);
    }
  }
}

function getOriginalLocation(sourcemapChain, location) {
  // This cast is guaranteed. If it were a missing Map, it wouldn't have a mappings.
  const filteredSourcemapChain = sourcemapChain.filter(sourcemap => sourcemap.mappings);
  while (filteredSourcemapChain.length > 0) {
    const sourcemap = filteredSourcemapChain.pop();
    const line = sourcemap.mappings[location.line - 1];
    let locationFound = false;
    if (line !== undefined) {
      for (const segment of line) {
        if (segment[0] >= location.column) {
          if (segment.length === 1)
            break;
          location = {
            column: segment[3],
            line: segment[2] + 1,
            name: segment.length === 5 ? sourcemap.names[segment[4]] : undefined,
            source: sourcemap.sources[segment[1]]
          };
          locationFound = true;
          break;
        }
      }
    }
    if (!locationFound) {
      throw new Error("Can't resolve original location of error.");
    }
  }
  return location;
}

// AST walker module for Mozilla Parser API compatible trees

function skipThrough(node, st, c) { c(node, st); }
function ignore(_node, _st, _c) {}

// Node walkers.

var base$1 = {};

base$1.Program = base$1.BlockStatement = function (node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1)
  {
  var stmt = list[i];

  c(stmt, st, "Statement");
  }
};
base$1.Statement = skipThrough;
base$1.EmptyStatement = ignore;
base$1.ExpressionStatement = base$1.ParenthesizedExpression =
  function (node, st, c) { return c(node.expression, st, "Expression"); };
base$1.IfStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) { c(node.alternate, st, "Statement"); }
};
base$1.LabeledStatement = function (node, st, c) { return c(node.body, st, "Statement"); };
base$1.BreakStatement = base$1.ContinueStatement = ignore;
base$1.WithStatement = function (node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base$1.SwitchStatement = function (node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
  var cs = list$1[i$1];

  if (cs.test) { c(cs.test, st, "Expression"); }
  for (var i = 0, list = cs.consequent; i < list.length; i += 1)
    {
    var cons = list[i];

    c(cons, st, "Statement");
  }
  }
};
base$1.SwitchCase = function (node, st, c) {
  if (node.test) { c(node.test, st, "Expression"); }
  for (var i = 0, list = node.consequent; i < list.length; i += 1)
  {
  var cons = list[i];

  c(cons, st, "Statement");
  }
};
base$1.ReturnStatement = base$1.YieldExpression = base$1.AwaitExpression = function (node, st, c) {
  if (node.argument) { c(node.argument, st, "Expression"); }
};
base$1.ThrowStatement = base$1.SpreadElement =
  function (node, st, c) { return c(node.argument, st, "Expression"); };
base$1.TryStatement = function (node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) { c(node.handler, st); }
  if (node.finalizer) { c(node.finalizer, st, "Statement"); }
};
base$1.CatchClause = function (node, st, c) {
  if (node.param) { c(node.param, st, "Pattern"); }
  c(node.body, st, "Statement");
};
base$1.WhileStatement = base$1.DoWhileStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base$1.ForStatement = function (node, st, c) {
  if (node.init) { c(node.init, st, "ForInit"); }
  if (node.test) { c(node.test, st, "Expression"); }
  if (node.update) { c(node.update, st, "Expression"); }
  c(node.body, st, "Statement");
};
base$1.ForInStatement = base$1.ForOfStatement = function (node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base$1.ForInit = function (node, st, c) {
  if (node.type === "VariableDeclaration") { c(node, st); }
  else { c(node, st, "Expression"); }
};
base$1.DebuggerStatement = ignore;

base$1.FunctionDeclaration = function (node, st, c) { return c(node, st, "Function"); };
base$1.VariableDeclaration = function (node, st, c) {
  for (var i = 0, list = node.declarations; i < list.length; i += 1)
  {
  var decl = list[i];

  c(decl, st);
  }
};
base$1.VariableDeclarator = function (node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) { c(node.init, st, "Expression"); }
};

base$1.Function = function (node, st, c) {
  if (node.id) { c(node.id, st, "Pattern"); }
  for (var i = 0, list = node.params; i < list.length; i += 1)
  {
  var param = list[i];

  c(param, st, "Pattern");
  }
  c(node.body, st, node.expression ? "Expression" : "Statement");
};

base$1.Pattern = function (node, st, c) {
  if (node.type === "Identifier")
  { c(node, st, "VariablePattern"); }
  else if (node.type === "MemberExpression")
  { c(node, st, "MemberPattern"); }
  else
  { c(node, st); }
};
base$1.VariablePattern = ignore;
base$1.MemberPattern = skipThrough;
base$1.RestElement = function (node, st, c) { return c(node.argument, st, "Pattern"); };
base$1.ArrayPattern = function (node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
  var elt = list[i];

  if (elt) { c(elt, st, "Pattern"); }
  }
};
base$1.ObjectPattern = function (node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1) {
  var prop = list[i];

  if (prop.type === "Property") {
    if (prop.computed) { c(prop.key, st, "Expression"); }
    c(prop.value, st, "Pattern");
  } else if (prop.type === "RestElement") {
    c(prop.argument, st, "Pattern");
  }
  }
};

base$1.Expression = skipThrough;
base$1.ThisExpression = base$1.Super = base$1.MetaProperty = ignore;
base$1.ArrayExpression = function (node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
  var elt = list[i];

  if (elt) { c(elt, st, "Expression"); }
  }
};
base$1.ObjectExpression = function (node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1)
  {
  var prop = list[i];

  c(prop, st);
  }
};
base$1.FunctionExpression = base$1.ArrowFunctionExpression = base$1.FunctionDeclaration;
base$1.SequenceExpression = function (node, st, c) {
  for (var i = 0, list = node.expressions; i < list.length; i += 1)
  {
  var expr = list[i];

  c(expr, st, "Expression");
  }
};
base$1.TemplateLiteral = function (node, st, c) {
  for (var i = 0, list = node.quasis; i < list.length; i += 1)
  {
  var quasi = list[i];

  c(quasi, st);
  }

  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)
  {
  var expr = list$1[i$1];

  c(expr, st, "Expression");
  }
};
base$1.TemplateElement = ignore;
base$1.UnaryExpression = base$1.UpdateExpression = function (node, st, c) {
  c(node.argument, st, "Expression");
};
base$1.BinaryExpression = base$1.LogicalExpression = function (node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base$1.AssignmentExpression = base$1.AssignmentPattern = function (node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
base$1.ConditionalExpression = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base$1.NewExpression = base$1.CallExpression = function (node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments)
  { for (var i = 0, list = node.arguments; i < list.length; i += 1)
    {
    var arg = list[i];

    c(arg, st, "Expression");
    } }
};
base$1.MemberExpression = function (node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) { c(node.property, st, "Expression"); }
};
base$1.ExportNamedDeclaration = base$1.ExportDefaultDeclaration = function (node, st, c) {
  if (node.declaration)
  { c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); }
  if (node.source) { c(node.source, st, "Expression"); }
};
base$1.ExportAllDeclaration = function (node, st, c) {
  c(node.source, st, "Expression");
};
base$1.ImportDeclaration = function (node, st, c) {
  for (var i = 0, list = node.specifiers; i < list.length; i += 1)
  {
  var spec = list[i];

  c(spec, st);
  }
  c(node.source, st, "Expression");
};
base$1.ImportExpression = function (node, st, c) {
  c(node.source, st, "Expression");
};
base$1.ImportSpecifier = base$1.ImportDefaultSpecifier = base$1.ImportNamespaceSpecifier = base$1.Identifier = base$1.Literal = ignore;

base$1.TaggedTemplateExpression = function (node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st, "Expression");
};
base$1.ClassDeclaration = base$1.ClassExpression = function (node, st, c) { return c(node, st, "Class"); };
base$1.Class = function (node, st, c) {
  if (node.id) { c(node.id, st, "Pattern"); }
  if (node.superClass) { c(node.superClass, st, "Expression"); }
  c(node.body, st);
};
base$1.ClassBody = function (node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1)
  {
  var elt = list[i];

  c(elt, st);
  }
};
base$1.MethodDefinition = base$1.Property = function (node, st, c) {
  if (node.computed) { c(node.key, st, "Expression"); }
  c(node.value, st, "Expression");
};

// @ts-ignore
function handlePureAnnotationsOfNode(node, state, type = node.type) {
  let commentNode = state.commentNodes[state.commentIndex];
  while (commentNode && node.start >= commentNode.end) {
    markPureNode(node, commentNode);
    commentNode = state.commentNodes[++state.commentIndex];
  }
  if (commentNode && commentNode.end <= node.end) {
    base$1[type](node, state, handlePureAnnotationsOfNode);
  }
}
function markPureNode(node, comment) {
  if (node.annotations) {
    node.annotations.push(comment);
  }
  else {
    node.annotations = [comment];
  }
  if (node.type === 'ExpressionStatement') {
    node = node.expression;
  }
  if (node.type === 'CallExpression' || node.type === 'NewExpression') {
    node.annotatedPure = true;
  }
}
const pureCommentRegex = /[@#]__PURE__/;
const isPureComment = (comment) => pureCommentRegex.test(comment.text);
function markPureCallExpressions(comments, esTreeAst) {
  handlePureAnnotationsOfNode(esTreeAst, {
    commentIndex: 0,
    commentNodes: comments.filter(isPureComment)
  });
}

// this looks ridiculous, but it prevents sourcemap tooling from mistaking
// this for an actual sourceMappingURL
let SOURCEMAPPING_URL = 'sourceMa';
SOURCEMAPPING_URL += 'ppingURL';
const SOURCEMAPPING_URL_RE = new RegExp(`^#\\s+${SOURCEMAPPING_URL}=.+\\n?`);

const NOOP = () => { };
let getStartTime = () => [0, 0];
let getElapsedTime = () => 0;
let getMemory = () => 0;
let timers$2 = {};
const normalizeHrTime = (time) => time[0] * 1e3 + time[1] / 1e6;
function setTimeHelpers() {
  if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {
    getStartTime = process.hrtime.bind(process);
    getElapsedTime = previous => normalizeHrTime(process.hrtime(previous));
  }
  else if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
    getStartTime = () => [performance.now(), 0];
    getElapsedTime = previous => performance.now() - previous[0];
  }
  if (typeof process !== 'undefined' && typeof process.memoryUsage === 'function') {
    getMemory = () => process.memoryUsage().heapUsed;
  }
}
function getPersistedLabel(label, level) {
  switch (level) {
    case 1:
      return `# ${label}`;
    case 2:
      return `## ${label}`;
    case 3:
      return label;
    default:
      return `${'  '.repeat(level - 4)}- ${label}`;
  }
}
function timeStartImpl(label, level = 3) {
  label = getPersistedLabel(label, level);
  if (!timers$2.hasOwnProperty(label)) {
    timers$2[label] = {
      memory: 0,
      startMemory: undefined,
      startTime: undefined,
      time: 0,
      totalMemory: 0
    };
  }
  const currentMemory = getMemory();
  timers$2[label].startTime = getStartTime();
  timers$2[label].startMemory = currentMemory;
}
function timeEndImpl(label, level = 3) {
  label = getPersistedLabel(label, level);
  if (timers$2.hasOwnProperty(label)) {
    const currentMemory = getMemory();
    timers$2[label].time += getElapsedTime(timers$2[label].startTime);
    timers$2[label].totalMemory = Math.max(timers$2[label].totalMemory, currentMemory);
    timers$2[label].memory += currentMemory - timers$2[label].startMemory;
  }
}
function getTimings() {
  const newTimings = {};
  for (const label of Object.keys(timers$2)) {
    newTimings[label] = [timers$2[label].time, timers$2[label].memory, timers$2[label].totalMemory];
  }
  return newTimings;
}
let timeStart = NOOP, timeEnd = NOOP;
const TIMED_PLUGIN_HOOKS = {
  load: true,
  ongenerate: true,
  onwrite: true,
  resolveDynamicImport: true,
  resolveId: true,
  transform: true,
  transformBundle: true
};
function getPluginWithTimers(plugin, index) {
  const timedPlugin = {};
  for (const hook of Object.keys(plugin)) {
    if (TIMED_PLUGIN_HOOKS[hook] === true) {
      let timerLabel = `plugin ${index}`;
      if (plugin.name) {
        timerLabel += ` (${plugin.name})`;
      }
      timerLabel += ` - ${hook}`;
      timedPlugin[hook] = function () {
        timeStart(timerLabel, 4);
        const result = plugin[hook].apply(this === timedPlugin ? plugin : this, arguments);
        timeEnd(timerLabel, 4);
        if (result && typeof result.then === 'function') {
          timeStart(`${timerLabel} (async)`, 4);
          result.then(() => timeEnd(`${timerLabel} (async)`, 4));
        }
        return result;
      };
    }
    else {
      timedPlugin[hook] = plugin[hook];
    }
  }
  return timedPlugin;
}
function initialiseTimers(inputOptions) {
  if (inputOptions.perf) {
    timers$2 = {};
    setTimeHelpers();
    timeStart = timeStartImpl;
    timeEnd = timeEndImpl;
    inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);
  }
  else {
    timeStart = NOOP;
    timeEnd = NOOP;
  }
}

const defaultAcornOptions = {
  ecmaVersion: 2020,
  preserveParens: false,
  sourceType: 'module'
};
function tryParse$1(module, Parser, acornOptions) {
  try {
    return Parser.parse(module.code, Object.assign(Object.assign(Object.assign({}, defaultAcornOptions), acornOptions), { onComment: (block, text, start, end) => module.comments.push({ block, text, start, end }) }));
  }
  catch (err) {
    let message = err.message.replace(/ \(\d+:\d+\)$/, '');
    if (module.id.endsWith('.json')) {
      message += ' (Note that you need @rollup/plugin-json to import JSON files)';
    }
    else if (!module.id.endsWith('.js')) {
      message += ' (Note that you need plugins to import files that are not JavaScript)';
    }
    return module.error({
      code: 'PARSE_ERROR',
      message,
      parserError: err
    }, err.pos);
  }
}
function handleMissingExport(exportName, importingModule, importedModule, importerStart) {
  return importingModule.error({
    code: 'MISSING_EXPORT',
    message: `'${exportName}' is not exported by ${relativeId(importedModule)}`,
    url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`
  }, importerStart);
}
const MISSING_EXPORT_SHIM_DESCRIPTION = {
  identifier: null,
  localName: MISSING_EXPORT_SHIM_VARIABLE
};
function getVariableForExportNameRecursive(target, name, isExportAllSearch, searchedNamesAndModules = new Map()) {
  const searchedModules = searchedNamesAndModules.get(name);
  if (searchedModules) {
    if (searchedModules.has(target)) {
      return null;
    }
    searchedModules.add(target);
  }
  else {
    searchedNamesAndModules.set(name, new Set([target]));
  }
  return target.getVariableForExportName(name, isExportAllSearch, searchedNamesAndModules);
}
class Module$1 {
  constructor(graph, id, moduleSideEffects, syntheticNamedExports, isEntry) {
    this.chunk = null;
    this.chunkFileNames = new Set();
    this.chunkName = null;
    this.comments = [];
    this.dependencies = [];
    this.dynamicallyImportedBy = [];
    this.dynamicDependencies = [];
    this.dynamicImports = [];
    this.entryPointsHash = new Uint8Array(10);
    this.execIndex = Infinity;
    this.exportAllModules = [];
    this.exportAllSources = new Set();
    this.exports = Object.create(null);
    this.exportsAll = Object.create(null);
    this.exportShimVariable = new ExportShimVariable(this);
    this.facadeChunk = null;
    this.importDescriptions = Object.create(null);
    this.importMetas = [];
    this.imports = new Set();
    this.isExecuted = false;
    this.isUserDefinedEntryPoint = false;
    this.manualChunkAlias = null;
    this.reexportDescriptions = Object.create(null);
    this.sources = new Set();
    this.userChunkNames = new Set();
    this.usesTopLevelAwait = false;
    this.allExportNames = null;
    this.defaultExport = null;
    this.namespaceVariable = null;
    this.syntheticExports = new Map();
    this.transformDependencies = [];
    this.transitiveReexports = null;
    this.id = id;
    this.graph = graph;
    this.excludeFromSourcemap = /\0/.test(id);
    this.context = graph.getModuleContext(id);
    this.moduleSideEffects = moduleSideEffects;
    this.syntheticNamedExports = syntheticNamedExports;
    this.isEntryPoint = isEntry;
  }
  basename() {
    const base = basename(this.id);
    const ext = extname(this.id);
    return makeLegal(ext ? base.slice(0, -ext.length) : base);
  }
  bindReferences() {
    this.ast.bind();
  }
  error(props, pos) {
    if (typeof pos === 'number') {
      props.pos = pos;
      let location = locate(this.code, pos, { offsetLine: 1 });
      try {
        location = getOriginalLocation(this.sourcemapChain, location);
      }
      catch (e) {
        this.warn({
          code: 'SOURCEMAP_ERROR',
          loc: {
            column: location.column,
            file: this.id,
            line: location.line
          },
          message: `Error when using sourcemap for reporting an error: ${e.message}`,
          pos
        });
      }
      props.loc = {
        column: location.column,
        file: this.id,
        line: location.line
      };
      props.frame = getCodeFrame(this.originalCode, location.line, location.column);
    }
    return error(props);
  }
  getAllExportNames() {
    if (this.allExportNames) {
      return this.allExportNames;
    }
    const allExportNames = (this.allExportNames = new Set());
    for (const name of Object.keys(this.exports)) {
      allExportNames.add(name);
    }
    for (const name of Object.keys(this.reexportDescriptions)) {
      allExportNames.add(name);
    }
    for (const module of this.exportAllModules) {
      if (module instanceof ExternalModule) {
        allExportNames.add(`*${module.id}`);
        continue;
      }
      for (const name of module.getAllExportNames()) {
        if (name !== 'default')
          allExportNames.add(name);
      }
    }
    return allExportNames;
  }
  getDefaultExport() {
    if (this.defaultExport === null) {
      this.defaultExport = undefined;
      this.defaultExport = this.getVariableForExportName('default');
    }
    if (!this.defaultExport) {
      return error({
        code: Errors.SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT,
        id: this.id,
        message: `Modules with 'syntheticNamedExports' need a default export.`
      });
    }
    return this.defaultExport;
  }
  getDynamicImportExpressions() {
    return this.dynamicImports.map(({ node }) => {
      const importArgument = node.source;
      if (importArgument instanceof TemplateLiteral &&
        importArgument.quasis.length === 1 &&
        importArgument.quasis[0].value.cooked) {
        return importArgument.quasis[0].value.cooked;
      }
      if (importArgument instanceof Literal && typeof importArgument.value === 'string') {
        return importArgument.value;
      }
      return importArgument;
    });
  }
  getExportNamesByVariable() {
    const exportNamesByVariable = new Map();
    for (const exportName of this.getAllExportNames()) {
      const tracedVariable = this.getVariableForExportName(exportName);
      if (!tracedVariable ||
        !(tracedVariable.included || tracedVariable instanceof ExternalVariable)) {
        continue;
      }
      const existingExportNames = exportNamesByVariable.get(tracedVariable);
      if (existingExportNames) {
        existingExportNames.push(exportName);
      }
      else {
        exportNamesByVariable.set(tracedVariable, [exportName]);
      }
    }
    return exportNamesByVariable;
  }
  getExports() {
    return Object.keys(this.exports);
  }
  getOrCreateNamespace() {
    if (!this.namespaceVariable) {
      this.namespaceVariable = new NamespaceVariable(this.astContext, this.syntheticNamedExports);
      this.namespaceVariable.initialise();
    }
    return this.namespaceVariable;
  }
  getReexports() {
    if (this.transitiveReexports) {
      return this.transitiveReexports;
    }
    // to avoid infinite recursion when using circular `export * from X`
    this.transitiveReexports = [];
    const reexports = new Set();
    for (const name in this.reexportDescriptions) {
      reexports.add(name);
    }
    for (const module of this.exportAllModules) {
      if (module instanceof ExternalModule) {
        reexports.add(`*${module.id}`);
      }
      else {
        for (const name of module.getExports().concat(module.getReexports())) {
          if (name !== 'default')
            reexports.add(name);
        }
      }
    }
    return (this.transitiveReexports = Array.from(reexports));
  }
  getRenderedExports() {
    // only direct exports are counted here, not reexports at all
    const renderedExports = [];
    const removedExports = [];
    for (const exportName in this.exports) {
      const variable = this.getVariableForExportName(exportName);
      (variable && variable.included ? renderedExports : removedExports).push(exportName);
    }
    return { renderedExports, removedExports };
  }
  getTransitiveDependencies() {
    return this.dependencies.concat(this.getReexports()
      .concat(this.getExports())
      .map((exportName) => this.getVariableForExportName(exportName).module));
  }
  getVariableForExportName(name, isExportAllSearch, searchedNamesAndModules) {
    if (name[0] === '*') {
      if (name.length === 1) {
        return this.getOrCreateNamespace();
      }
      else {
        // export * from 'external'
        const module = this.graph.moduleById.get(name.slice(1));
        return module.getVariableForExportName('*');
      }
    }
    // export { foo } from './other'
    const reexportDeclaration = this.reexportDescriptions[name];
    if (reexportDeclaration) {
      const declaration = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, false, searchedNamesAndModules);
      if (!declaration) {
        return handleMissingExport(reexportDeclaration.localName, this, reexportDeclaration.module.id, reexportDeclaration.start);
      }
      return declaration;
    }
    const exportDeclaration = this.exports[name];
    if (exportDeclaration) {
      if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {
        return this.exportShimVariable;
      }
      const name = exportDeclaration.localName;
      return this.traceVariable(name) || this.graph.scope.findVariable(name);
    }
    if (name !== 'default') {
      for (const module of this.exportAllModules) {
        const declaration = getVariableForExportNameRecursive(module, name, true, searchedNamesAndModules);
        if (declaration)
          return declaration;
      }
    }
    // we don't want to create shims when we are just
    // probing export * modules for exports
    if (!isExportAllSearch) {
      if (this.syntheticNamedExports) {
        let syntheticExport = this.syntheticExports.get(name);
        if (!syntheticExport) {
          const defaultExport = this.getDefaultExport();
          syntheticExport = new SyntheticNamedExportVariableVariable(this.astContext, name, defaultExport);
          this.syntheticExports.set(name, syntheticExport);
          return syntheticExport;
        }
        return syntheticExport;
      }
      if (this.graph.shimMissingExports) {
        this.shimMissingExport(name);
        return this.exportShimVariable;
      }
    }
    return null;
  }
  include() {
    const context = createInclusionContext();
    if (this.ast.shouldBeIncluded(context))
      this.ast.include(context, false);
  }
  includeAllExports() {
    if (!this.isExecuted) {
      this.graph.needsTreeshakingPass = true;
      markModuleAndImpureDependenciesAsExecuted(this);
    }
    const context = createInclusionContext();
    for (const exportName of this.getExports()) {
      const variable = this.getVariableForExportName(exportName);
      variable.deoptimizePath(UNKNOWN_PATH);
      if (!variable.included) {
        variable.include(context);
        this.graph.needsTreeshakingPass = true;
      }
    }
    for (const name of this.getReexports()) {
      const variable = this.getVariableForExportName(name);
      variable.deoptimizePath(UNKNOWN_PATH);
      if (!variable.included) {
        variable.include(context);
        this.graph.needsTreeshakingPass = true;
      }
      if (variable instanceof ExternalVariable) {
        variable.module.reexported = true;
      }
    }
  }
  includeAllInBundle() {
    this.ast.include(createInclusionContext(), true);
  }
  isIncluded() {
    return this.ast.included || (this.namespaceVariable && this.namespaceVariable.included);
  }
  linkDependencies() {
    for (const source of this.sources) {
      const id = this.resolvedIds[source].id;
      if (id) {
        const module = this.graph.moduleById.get(id);
        this.dependencies.push(module);
      }
    }
    for (const { resolution } of this.dynamicImports) {
      if (resolution instanceof Module$1 || resolution instanceof ExternalModule) {
        this.dynamicDependencies.push(resolution);
      }
    }
    this.addModulesToImportDescriptions(this.importDescriptions);
    this.addModulesToImportDescriptions(this.reexportDescriptions);
    const externalExportAllModules = [];
    for (const source of this.exportAllSources) {
      const module = this.graph.moduleById.get(this.resolvedIds[source].id);
      (module instanceof ExternalModule ? externalExportAllModules : this.exportAllModules).push(module);
    }
    this.exportAllModules = this.exportAllModules.concat(externalExportAllModules);
  }
  render(options) {
    const magicString = this.magicString.clone();
    this.ast.render(magicString, options);
    this.usesTopLevelAwait = this.astContext.usesTopLevelAwait;
    return magicString;
  }
  setSource({ ast, code, customTransformCache, moduleSideEffects, originalCode, originalSourcemap, resolvedIds, sourcemapChain, syntheticNamedExports, transformDependencies, transformFiles }) {
    this.code = code;
    this.originalCode = originalCode;
    this.originalSourcemap = originalSourcemap;
    this.sourcemapChain = sourcemapChain;
    if (transformFiles) {
      this.transformFiles = transformFiles;
    }
    this.transformDependencies = transformDependencies;
    this.customTransformCache = customTransformCache;
    if (typeof moduleSideEffects === 'boolean') {
      this.moduleSideEffects = moduleSideEffects;
    }
    if (typeof syntheticNamedExports === 'boolean') {
      this.syntheticNamedExports = syntheticNamedExports;
    }
    timeStart('generate ast', 3);
    this.esTreeAst = ast || tryParse$1(this, this.graph.acornParser, this.graph.acornOptions);
    markPureCallExpressions(this.comments, this.esTreeAst);
    timeEnd('generate ast', 3);
    this.resolvedIds = resolvedIds || Object.create(null);
    // By default, `id` is the file name. Custom resolvers and loaders
    // can change that, but it makes sense to use it for the source file name
    const fileName = this.id;
    this.magicString = new MagicString$2(code, {
      filename: (this.excludeFromSourcemap ? null : fileName),
      indentExclusionRanges: []
    });
    this.removeExistingSourceMap();
    timeStart('analyse ast', 3);
    this.astContext = {
      addDynamicImport: this.addDynamicImport.bind(this),
      addExport: this.addExport.bind(this),
      addImport: this.addImport.bind(this),
      addImportMeta: this.addImportMeta.bind(this),
      annotations: (this.graph.treeshakingOptions && this.graph.treeshakingOptions.annotations),
      code,
      deoptimizationTracker: this.graph.deoptimizationTracker,
      error: this.error.bind(this),
      fileName,
      getExports: this.getExports.bind(this),
      getModuleExecIndex: () => this.execIndex,
      getModuleName: this.basename.bind(this),
      getReexports: this.getReexports.bind(this),
      importDescriptions: this.importDescriptions,
      includeDynamicImport: this.includeDynamicImport.bind(this),
      includeVariable: this.includeVariable.bind(this),
      isCrossChunkImport: importDescription => importDescription.module.chunk !== this.chunk,
      magicString: this.magicString,
      module: this,
      moduleContext: this.context,
      nodeConstructors,
      preserveModules: this.graph.preserveModules,
      propertyReadSideEffects: (!this.graph.treeshakingOptions ||
        this.graph.treeshakingOptions.propertyReadSideEffects),
      traceExport: this.getVariableForExportName.bind(this),
      traceVariable: this.traceVariable.bind(this),
      treeshake: !!this.graph.treeshakingOptions,
      tryCatchDeoptimization: (!this.graph.treeshakingOptions ||
        this.graph.treeshakingOptions.tryCatchDeoptimization),
      unknownGlobalSideEffects: (!this.graph.treeshakingOptions ||
        this.graph.treeshakingOptions.unknownGlobalSideEffects),
      usesTopLevelAwait: false,
      warn: this.warn.bind(this),
      warnDeprecation: this.graph.warnDeprecation.bind(this.graph)
    };
    this.scope = new ModuleScope(this.graph.scope, this.astContext);
    this.ast = new Program$1(this.esTreeAst, { type: 'Module', context: this.astContext }, this.scope);
    timeEnd('analyse ast', 3);
  }
  toJSON() {
    return {
      ast: this.esTreeAst,
      code: this.code,
      customTransformCache: this.customTransformCache,
      dependencies: this.dependencies.map(module => module.id),
      id: this.id,
      moduleSideEffects: this.moduleSideEffects,
      originalCode: this.originalCode,
      originalSourcemap: this.originalSourcemap,
      resolvedIds: this.resolvedIds,
      sourcemapChain: this.sourcemapChain,
      syntheticNamedExports: this.syntheticNamedExports,
      transformDependencies: this.transformDependencies,
      transformFiles: this.transformFiles
    };
  }
  traceVariable(name) {
    const localVariable = this.scope.variables.get(name);
    if (localVariable) {
      return localVariable;
    }
    if (name in this.importDescriptions) {
      const importDeclaration = this.importDescriptions[name];
      const otherModule = importDeclaration.module;
      if (otherModule instanceof Module$1 && importDeclaration.name === '*') {
        return otherModule.getOrCreateNamespace();
      }
      const declaration = otherModule.getVariableForExportName(importDeclaration.name);
      if (!declaration) {
        return handleMissingExport(importDeclaration.name, this, otherModule.id, importDeclaration.start);
      }
      return declaration;
    }
    return null;
  }
  warn(warning, pos) {
    if (typeof pos === 'number') {
      warning.pos = pos;
      const { line, column } = locate(this.code, pos, { offsetLine: 1 }); // TODO trace sourcemaps, cf. error()
      warning.loc = { file: this.id, line, column };
      warning.frame = getCodeFrame(this.code, line, column);
    }
    warning.id = this.id;
    this.graph.warn(warning);
  }
  addDynamicImport(node) {
    this.dynamicImports.push({ node, resolution: null });
  }
  addExport(node) {
    if (node instanceof ExportDefaultDeclaration) {
      // export default foo;
      this.exports.default = {
        identifier: node.variable.getAssignedVariableName(),
        localName: 'default'
      };
    }
    else if (node instanceof ExportAllDeclaration) {
      // export * from './other'
      const source = node.source.value;
      this.sources.add(source);
      this.exportAllSources.add(source);
    }
    else if (node.source instanceof Literal) {
      // export { name } from './other'
      const source = node.source.value;
      this.sources.add(source);
      for (const specifier of node.specifiers) {
        const name = specifier.exported.name;
        this.reexportDescriptions[name] = {
          localName: specifier.type === ExportNamespaceSpecifier ? '*' : specifier.local.name,
          module: null,
          source,
          start: specifier.start
        };
      }
    }
    else if (node.declaration) {
      const declaration = node.declaration;
      if (declaration instanceof VariableDeclaration) {
        // export var { foo, bar } = ...
        // export var foo = 1, bar = 2;
        for (const declarator of declaration.declarations) {
          for (const localName of extractAssignedNames$1(declarator.id)) {
            this.exports[localName] = { identifier: null, localName };
          }
        }
      }
      else {
        // export function foo () {}
        const localName = declaration.id.name;
        this.exports[localName] = { identifier: null, localName };
      }
    }
    else {
      // export { foo, bar, baz }
      for (const specifier of node.specifiers) {
        const localName = specifier.local.name;
        const exportedName = specifier.exported.name;
        this.exports[exportedName] = { identifier: null, localName };
      }
    }
  }
  addImport(node) {
    const source = node.source.value;
    this.sources.add(source);
    for (const specifier of node.specifiers) {
      const localName = specifier.local.name;
      if (this.importDescriptions[localName]) {
        return this.error({
          code: 'DUPLICATE_IMPORT',
          message: `Duplicated import '${localName}'`
        }, specifier.start);
      }
      const isDefault = specifier.type === ImportDefaultSpecifier;
      const isNamespace = specifier.type === ImportNamespaceSpecifier;
      const name = isDefault
        ? 'default'
        : isNamespace
          ? '*'
          : specifier.imported.name;
      this.importDescriptions[localName] = {
        module: null,
        name,
        source,
        start: specifier.start
      };
    }
  }
  addImportMeta(node) {
    this.importMetas.push(node);
  }
  addModulesToImportDescriptions(importDescription) {
    for (const name of Object.keys(importDescription)) {
      const specifier = importDescription[name];
      const id = this.resolvedIds[specifier.source].id;
      specifier.module = this.graph.moduleById.get(id);
    }
  }
  includeDynamicImport(node) {
    const resolution = this.dynamicImports.find(dynamicImport => dynamicImport.node === node).resolution;
    if (resolution instanceof Module$1) {
      resolution.dynamicallyImportedBy.push(this);
      resolution.includeAllExports();
    }
  }
  includeVariable(context, variable) {
    const variableModule = variable.module;
    if (!variable.included) {
      variable.include(context);
      this.graph.needsTreeshakingPass = true;
    }
    if (variableModule && variableModule !== this) {
      this.imports.add(variable);
    }
  }
  removeExistingSourceMap() {
    for (const comment of this.comments) {
      if (!comment.block && SOURCEMAPPING_URL_RE.test(comment.text)) {
        this.magicString.remove(comment.start, comment.end);
      }
    }
  }
  shimMissingExport(name) {
    if (!this.exports[name]) {
      this.graph.warn({
        code: 'SHIMMED_EXPORT',
        exporter: relativeId(this.id),
        exportName: name,
        message: `Missing export "${name}" has been shimmed in module ${relativeId(this.id)}.`
      });
      this.exports[name] = MISSING_EXPORT_SHIM_DESCRIPTION;
    }
  }
}

class Source {
  constructor(filename, content) {
    this.isOriginal = true;
    this.filename = filename;
    this.content = content;
  }
  traceSegment(line, column, name) {
    return { line, column, name, source: this };
  }
}
class Link {
  constructor(map, sources) {
    this.sources = sources;
    this.names = map.names;
    this.mappings = map.mappings;
  }
  traceMappings() {
    const sources = [];
    const sourcesContent = [];
    const names = [];
    const mappings = [];
    for (const line of this.mappings) {
      const tracedLine = [];
      for (const segment of line) {
        if (segment.length == 1)
          continue;
        const source = this.sources[segment[1]];
        if (!source)
          continue;
        const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');
        if (traced) {
          // newer sources are more likely to be used, so search backwards.
          let sourceIndex = sources.lastIndexOf(traced.source.filename);
          if (sourceIndex === -1) {
            sourceIndex = sources.length;
            sources.push(traced.source.filename);
            sourcesContent[sourceIndex] = traced.source.content;
          }
          else if (sourcesContent[sourceIndex] == null) {
            sourcesContent[sourceIndex] = traced.source.content;
          }
          else if (traced.source.content != null &&
            sourcesContent[sourceIndex] !== traced.source.content) {
            return error({
              message: `Multiple conflicting contents for sourcemap source ${traced.source.filename}`
            });
          }
          const tracedSegment = [
            segment[0],
            sourceIndex,
            traced.line,
            traced.column
          ];
          if (traced.name) {
            let nameIndex = names.indexOf(traced.name);
            if (nameIndex === -1) {
              nameIndex = names.length;
              names.push(traced.name);
            }
            tracedSegment[4] = nameIndex;
          }
          tracedLine.push(tracedSegment);
        }
      }
      mappings.push(tracedLine);
    }
    return { sources, sourcesContent, names, mappings };
  }
  traceSegment(line, column, name) {
    const segments = this.mappings[line];
    if (!segments)
      return null;
    // binary search through segments for the given column
    let i = 0;
    let j = segments.length - 1;
    while (i <= j) {
      const m = (i + j) >> 1;
      const segment = segments[m];
      if (segment[0] === column) {
        if (segment.length == 1)
          return null;
        const source = this.sources[segment[1]];
        if (!source)
          return null;
        return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);
      }
      if (segment[0] > column) {
        j = m - 1;
      }
      else {
        i = m + 1;
      }
    }
    return null;
  }
}
function getLinkMap(graph) {
  return function linkMap(source, map) {
    if (map.mappings) {
      return new Link(map, [source]);
    }
    graph.warn({
      code: 'SOURCEMAP_BROKEN',
      message: `Sourcemap is likely to be incorrect: a plugin (${map.plugin}) was used to transform ` +
        "files, but didn't generate a sourcemap for the transformation. Consult the plugin " +
        'documentation for help',
      plugin: map.plugin,
      url: `https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect`
    });
    return new Link({
      mappings: [],
      names: []
    }, [source]);
  };
}
function getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {
  let source;
  if (!originalSourcemap) {
    source = new Source(id, originalCode);
  }
  else {
    const sources = originalSourcemap.sources;
    const sourcesContent = originalSourcemap.sourcesContent || [];
    // TODO indiscriminately treating IDs and sources as normal paths is probably bad.
    const directory = dirname(id) || '.';
    const sourceRoot = originalSourcemap.sourceRoot || '.';
    const baseSources = sources.map((source, i) => new Source(resolve(directory, sourceRoot, source), sourcesContent[i]));
    source = new Link(originalSourcemap, baseSources);
  }
  return sourcemapChain.reduce(linkMap, source);
}
function collapseSourcemaps(bundle, file, map, modules, bundleSourcemapChain, excludeContent) {
  const linkMap = getLinkMap(bundle.graph);
  const moduleSources = modules
    .filter(module => !module.excludeFromSourcemap)
    .map(module => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap));
  // DecodedSourceMap (from magic-string) uses a number[] instead of the more
  // correct SourceMapSegment tuples. Cast it here to gain type safety.
  let source = new Link(map, moduleSources);
  source = bundleSourcemapChain.reduce(linkMap, source);
  let { sources, sourcesContent, names, mappings } = source.traceMappings();
  if (file) {
    const directory = dirname(file);
    sources = sources.map((source) => relative(directory, source));
    file = basename(file);
  }
  sourcesContent = (excludeContent ? null : sourcesContent);
  return new SourceMap$2({ file, sources, sourcesContent, names, mappings });
}
function collapseSourcemap(graph, id, originalCode, originalSourcemap, sourcemapChain) {
  if (!sourcemapChain.length) {
    return originalSourcemap;
  }
  const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(graph));
  const map = source.traceMappings();
  return Object.assign({ version: 3 }, map);
}

const DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {
  amd: deconflictImportsOther,
  cjs: deconflictImportsOther,
  es: deconflictImportsEsm,
  iife: deconflictImportsOther,
  system: deconflictImportsEsm,
  umd: deconflictImportsOther
};
function deconflictChunk(modules, dependencies, imports, usedNames, format, interop, preserveModules) {
  for (const module of modules) {
    module.scope.addUsedOutsideNames(usedNames, format);
  }
  deconflictTopLevelVariables(usedNames, modules);
  DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependencies, interop, preserveModules);
  for (const module of modules) {
    module.scope.deconflict(format);
  }
}
function deconflictImportsEsm(usedNames, imports, _dependencies, interop) {
  for (const variable of imports) {
    const module = variable.module;
    const name = variable.name;
    let proposedName;
    if (module instanceof ExternalModule && (name === '*' || name === 'default')) {
      if (name === 'default' && interop && module.exportsNamespace) {
        proposedName = module.variableName + '__default';
      }
      else {
        proposedName = module.variableName;
      }
    }
    else {
      proposedName = name;
    }
    variable.setRenderNames(null, getSafeName(proposedName, usedNames));
  }
}
function deconflictImportsOther(usedNames, imports, dependencies, interop, preserveModules) {
  for (const chunkOrExternalModule of dependencies) {
    chunkOrExternalModule.variableName = getSafeName(chunkOrExternalModule.variableName, usedNames);
  }
  for (const variable of imports) {
    const module = variable.module;
    if (module instanceof ExternalModule) {
      const name = variable.name;
      if (name === 'default' && interop && (module.exportsNamespace || module.exportsNames)) {
        variable.setRenderNames(null, module.variableName + '__default');
      }
      else if (name === '*' || name === 'default') {
        variable.setRenderNames(null, module.variableName);
      }
      else {
        variable.setRenderNames(module.variableName, null);
      }
    }
    else {
      const chunk = module.chunk;
      if (chunk.exportMode === 'default' || (preserveModules && variable.isNamespace)) {
        variable.setRenderNames(null, chunk.variableName);
      }
      else {
        variable.setRenderNames(chunk.variableName, chunk.getVariableExportName(variable));
      }
    }
  }
}
function deconflictTopLevelVariables(usedNames, modules) {
  for (const module of modules) {
    for (const variable of module.scope.variables.values()) {
      if (variable.included &&
        // this will only happen for exports in some formats
        !(variable.renderBaseName ||
          (variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable))) {
        variable.setRenderNames(null, getSafeName(variable.name, usedNames));
      }
    }
    const namespace = module.getOrCreateNamespace();
    if (namespace.included) {
      namespace.setRenderNames(null, getSafeName(namespace.name, usedNames));
    }
  }
}

const compareExecIndex = (unitA, unitB) => unitA.execIndex > unitB.execIndex ? 1 : -1;
function sortByExecutionOrder(units) {
  units.sort(compareExecIndex);
}
function analyseModuleExecution(entryModules) {
  let nextExecIndex = 0;
  const cyclePaths = [];
  const analysedModules = {};
  const orderedModules = [];
  const dynamicImports = [];
  const parents = {};
  const analyseModule = (module) => {
    if (analysedModules[module.id])
      return;
    if (module instanceof ExternalModule) {
      module.execIndex = nextExecIndex++;
      analysedModules[module.id] = true;
      return;
    }
    for (const dependency of module.dependencies) {
      if (dependency.id in parents) {
        if (!analysedModules[dependency.id]) {
          cyclePaths.push(getCyclePath(dependency.id, module.id, parents));
        }
        continue;
      }
      parents[dependency.id] = module.id;
      analyseModule(dependency);
    }
    for (const { resolution } of module.dynamicImports) {
      if (resolution instanceof Module$1 && dynamicImports.indexOf(resolution) === -1) {
        dynamicImports.push(resolution);
      }
    }
    module.execIndex = nextExecIndex++;
    analysedModules[module.id] = true;
    orderedModules.push(module);
  };
  for (const curEntry of entryModules) {
    if (!parents[curEntry.id]) {
      parents[curEntry.id] = null;
      analyseModule(curEntry);
    }
  }
  for (const curEntry of dynamicImports) {
    if (!parents[curEntry.id]) {
      parents[curEntry.id] = null;
      analyseModule(curEntry);
    }
  }
  return { orderedModules, cyclePaths };
}
function getCyclePath(id, parentId, parents) {
  const path = [relativeId(id)];
  let curId = parentId;
  while (curId !== id) {
    path.push(relativeId(curId));
    curId = parents[curId];
    if (!curId)
      break;
  }
  path.push(path[0]);
  path.reverse();
  return path;
}

function guessIndentString(code) {
  const lines = code.split('\n');
  const tabbed = lines.filter(line => /^\t+/.test(line));
  const spaced = lines.filter(line => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  // More lines tabbed than spaced? Assume tabs, and
  // default to tabs in the case of a tie (or nothing
  // to go on)
  if (tabbed.length >= spaced.length) {
    return '\t';
  }
  // Otherwise, we need to guess the multiple
  const min = spaced.reduce((previous, current) => {
    const numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(' ');
}
function getIndentString(modules, options) {
  if (options.indent !== true)
    return options.indent || '';
  for (let i = 0; i < modules.length; i++) {
    const indent = guessIndentString(modules[i].originalCode);
    if (indent !== null)
      return indent;
  }
  return '\t';
}

function decodedSourcemap(map) {
  if (!map)
    return null;
  if (typeof map === 'string') {
    map = JSON.parse(map);
  }
  if (map.mappings === '') {
    return {
      mappings: [],
      names: [],
      sources: [],
      version: 3
    };
  }
  let mappings;
  if (typeof map.mappings === 'string') {
    mappings = decode$2(map.mappings);
  }
  else {
    mappings = map.mappings;
  }
  return Object.assign(Object.assign({}, map), { mappings });
}

function renderChunk({ chunk, code, options, outputPluginDriver, renderChunk, sourcemapChain }) {
  const renderChunkReducer = (code, result, plugin) => {
    if (result == null)
      return code;
    if (typeof result === 'string')
      result = {
        code: result,
        map: undefined
      };
    // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning
    if (result.map !== null) {
      const map = decodedSourcemap(result.map);
      sourcemapChain.push(map || { missing: true, plugin: plugin.name });
    }
    return result.code;
  };
  let inTransformBundle = false;
  let inRenderChunk = true;
  return outputPluginDriver
    .hookReduceArg0('renderChunk', [code, renderChunk, options], renderChunkReducer)
    .then(code => {
    inRenderChunk = false;
    return outputPluginDriver.hookReduceArg0('transformChunk', [code, options, chunk], renderChunkReducer);
  })
    .then(code => {
    inTransformBundle = true;
    return outputPluginDriver.hookReduceArg0('transformBundle', [code, options, chunk], renderChunkReducer);
  })
    .catch(err => {
    if (inRenderChunk)
      throw err;
    return error(err, {
      code: inTransformBundle ? 'BAD_BUNDLE_TRANSFORMER' : 'BAD_CHUNK_TRANSFORMER',
      message: `Error transforming ${(inTransformBundle ? 'bundle' : 'chunk') +
        (err.plugin ? ` with '${err.plugin}' plugin` : '')}: ${err.message}`,
      plugin: err.plugin
    });
  });
}

function renderNamePattern(pattern, patternName, replacements) {
  if (!isPlainPathFragment(pattern))
    return error(errFailedValidation(`Invalid pattern "${pattern}" for "${patternName}", patterns can be neither absolute nor relative paths and must not contain invalid characters.`));
  return pattern.replace(/\[(\w+)\]/g, (_match, type) => {
    if (!replacements.hasOwnProperty(type)) {
      return error(errFailedValidation(`"[${type}]" is not a valid placeholder in "${patternName}" pattern.`));
    }
    const replacement = replacements[type]();
    if (!isPlainPathFragment(replacement))
      return error(errFailedValidation(`Invalid substitution "${replacement}" for placeholder "[${type}]" in "${patternName}" pattern, can be neither absolute nor relative path.`));
    return replacement;
  });
}
function makeUnique(name, existingNames) {
  const existingNamesLowercase = new Set(Object.keys(existingNames).map(key => key.toLowerCase()));
  if (!existingNamesLowercase.has(name.toLocaleLowerCase()))
    return name;
  const ext = extname(name);
  name = name.substr(0, name.length - ext.length);
  let uniqueName, uniqueIndex = 1;
  while (existingNamesLowercase.has((uniqueName = name + ++uniqueIndex + ext).toLowerCase()))
    ;
  return uniqueName;
}

const NON_ASSET_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
function getGlobalName(module, globals, graph, hasExports) {
  let globalName;
  if (typeof globals === 'function') {
    globalName = globals(module.id);
  }
  else if (globals) {
    globalName = globals[module.id];
  }
  if (globalName) {
    return globalName;
  }
  if (hasExports) {
    graph.warn({
      code: 'MISSING_GLOBAL_NAME',
      guess: module.variableName,
      message: `No name was provided for external module '${module.id}' in output.globals – guessing '${module.variableName}'`,
      source: module.id
    });
    return module.variableName;
  }
}
function isChunkRendered(chunk) {
  return !chunk.isEmpty || chunk.entryModules.length > 0 || chunk.manualChunkAlias !== null;
}
class Chunk$1$1 {
  constructor(graph, orderedModules) {
    this.entryModules = [];
    this.exportMode = 'named';
    this.facadeModule = null;
    this.id = null;
    this.indentString = undefined;
    this.manualChunkAlias = null;
    this.usedModules = undefined;
    this.variableName = 'chunk';
    this.dependencies = undefined;
    this.dynamicDependencies = undefined;
    this.exportNames = Object.create(null);
    this.exports = new Set();
    this.fileName = null;
    this.imports = new Set();
    this.name = null;
    this.needsExportsShim = false;
    this.renderedDeclarations = undefined;
    this.renderedHash = undefined;
    this.renderedModuleSources = new Map();
    this.renderedSource = null;
    this.renderedSourceLength = undefined;
    this.sortedExportNames = null;
    this.graph = graph;
    this.orderedModules = orderedModules;
    this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;
    this.isEmpty = true;
    for (const module of orderedModules) {
      if (this.isEmpty && module.isIncluded()) {
        this.isEmpty = false;
      }
      if (module.manualChunkAlias) {
        this.manualChunkAlias = module.manualChunkAlias;
      }
      module.chunk = this;
      if (module.isEntryPoint ||
        module.dynamicallyImportedBy.some(module => orderedModules.indexOf(module) === -1)) {
        this.entryModules.push(module);
      }
    }
    const moduleForNaming = this.entryModules[0] || this.orderedModules[this.orderedModules.length - 1];
    if (moduleForNaming) {
      this.variableName = makeLegal(basename(moduleForNaming.chunkName ||
        moduleForNaming.manualChunkAlias ||
        getAliasName(moduleForNaming.id)));
    }
  }
  static generateFacade(graph, facadedModule, facadeName) {
    const chunk = new Chunk$1$1(graph, []);
    chunk.assignFacadeName(facadeName, facadedModule);
    if (!facadedModule.facadeChunk) {
      facadedModule.facadeChunk = chunk;
    }
    chunk.dependencies = [facadedModule.chunk];
    chunk.dynamicDependencies = [];
    chunk.facadeModule = facadedModule;
    for (const exportName of facadedModule.getAllExportNames()) {
      const tracedVariable = facadedModule.getVariableForExportName(exportName);
      chunk.exports.add(tracedVariable);
      chunk.exportNames[exportName] = tracedVariable;
    }
    return chunk;
  }
  canModuleBeFacade(moduleExportNamesByVariable) {
    for (const exposedVariable of this.exports) {
      if (!moduleExportNamesByVariable.has(exposedVariable)) {
        return false;
      }
    }
    return true;
  }
  generateFacades() {
    const facades = [];
    for (const module of this.entryModules) {
      const requiredFacades = Array.from(module.userChunkNames).map(name => ({
        name
      }));
      if (requiredFacades.length === 0 && module.isUserDefinedEntryPoint) {
        requiredFacades.push({});
      }
      requiredFacades.push(...Array.from(module.chunkFileNames).map(fileName => ({ fileName })));
      if (requiredFacades.length === 0) {
        requiredFacades.push({});
      }
      if (!this.facadeModule) {
        const exportNamesByVariable = module.getExportNamesByVariable();
        if (this.graph.preserveModules || this.canModuleBeFacade(exportNamesByVariable)) {
          this.facadeModule = module;
          module.facadeChunk = this;
          for (const [variable, exportNames] of exportNamesByVariable) {
            for (const exportName of exportNames) {
              this.exportNames[exportName] = variable;
            }
          }
          this.assignFacadeName(requiredFacades.shift(), module);
        }
      }
      for (const facadeName of requiredFacades) {
        facades.push(Chunk$1$1.generateFacade(this.graph, module, facadeName));
      }
    }
    return facades;
  }
  generateId(addons, options, existingNames, includeHash, outputPluginDriver) {
    if (this.fileName !== null) {
      return this.fileName;
    }
    const [pattern, patternName] = this.facadeModule && this.facadeModule.isUserDefinedEntryPoint
      ? [options.entryFileNames || '[name].js', 'output.entryFileNames']
      : [options.chunkFileNames || '[name]-[hash].js', 'output.chunkFileNames'];
    return makeUnique(renderNamePattern(pattern, patternName, {
      format: () => (options.format === 'es' ? 'esm' : options.format),
      hash: () => includeHash
        ? this.computeContentHashWithDependencies(addons, options, existingNames, outputPluginDriver)
        : '[hash]',
      name: () => this.getChunkName()
    }), existingNames);
  }
  generateIdPreserveModules(preserveModulesRelativeDir, options, existingNames) {
    const id = this.orderedModules[0].id;
    const sanitizedId = sanitizeFileName(id);
    let path;
    if (isAbsolute$1(id)) {
      const extension = extname(id);
      const name = renderNamePattern(options.entryFileNames ||
        (NON_ASSET_EXTENSIONS.includes(extension) ? '[name].js' : '[name][extname].js'), 'output.entryFileNames', {
        ext: () => extension.substr(1),
        extname: () => extension,
        format: () => (options.format === 'es' ? 'esm' : options.format),
        name: () => this.getChunkName()
      });
      path = relative$1(preserveModulesRelativeDir, `${dirname(sanitizedId)}/${name}`);
    }
    else {
      path = `_virtual/${basename(sanitizedId)}`;
    }
    return makeUnique(normalize$1(path), existingNames);
  }
  generateInternalExports(options) {
    if (this.facadeModule !== null)
      return;
    const mangle = options.format === 'system' || options.format === 'es' || options.compact;
    let i = 0, safeExportName;
    this.exportNames = Object.create(null);
    this.sortedExportNames = null;
    if (mangle) {
      for (const variable of this.exports) {
        const suggestedName = variable.name[0];
        if (!this.exportNames[suggestedName]) {
          this.exportNames[suggestedName] = variable;
        }
        else {
          do {
            safeExportName = toBase64(++i);
            // skip past leading number identifiers
            if (safeExportName.charCodeAt(0) === 49 /* '1' */) {
              i += 9 * Math.pow(64, (safeExportName.length - 1));
              safeExportName = toBase64(i);
            }
          } while (RESERVED_NAMES[safeExportName] || this.exportNames[safeExportName]);
          this.exportNames[safeExportName] = variable;
        }
      }
    }
    else {
      for (const variable of this.exports) {
        i = 0;
        safeExportName = variable.name;
        while (this.exportNames[safeExportName]) {
          safeExportName = variable.name + '$' + ++i;
        }
        this.exportNames[safeExportName] = variable;
      }
    }
  }
  getChunkName() {
    return this.name || (this.name = sanitizeFileName(this.getFallbackChunkName()));
  }
  getDynamicImportIds() {
    return this.dynamicDependencies.map(chunk => chunk.id).filter(Boolean);
  }
  getExportNames() {
    return (this.sortedExportNames || (this.sortedExportNames = Object.keys(this.exportNames).sort()));
  }
  getImportIds() {
    return this.dependencies.map(chunk => chunk.id).filter(Boolean);
  }
  getRenderedHash(outputPluginDriver) {
    if (this.renderedHash)
      return this.renderedHash;
    if (!this.renderedSource)
      return '';
    const hash = createHash$1();
    const hashAugmentation = this.calculateHashAugmentation(outputPluginDriver);
    hash.update(hashAugmentation);
    hash.update(this.renderedSource.toString());
    hash.update(this.getExportNames()
      .map(exportName => {
      const variable = this.exportNames[exportName];
      return `${relativeId(variable.module.id).replace(/\\/g, '/')}:${variable.name}:${exportName}`;
    })
      .join(','));
    return (this.renderedHash = hash.digest('hex'));
  }
  getRenderedSourceLength() {
    if (this.renderedSourceLength !== undefined)
      return this.renderedSourceLength;
    return (this.renderedSourceLength = this.renderedSource.length());
  }
  getVariableExportName(variable) {
    if (this.graph.preserveModules && variable instanceof NamespaceVariable) {
      return '*';
    }
    for (const exportName of Object.keys(this.exportNames)) {
      if (this.exportNames[exportName] === variable)
        return exportName;
    }
    throw new Error(`Internal Error: Could not find export name for variable ${variable.name}.`);
  }
  link() {
    const dependencies = new Set();
    const dynamicDependencies = new Set();
    for (const module of this.orderedModules) {
      this.addDependenciesToChunk(module.getTransitiveDependencies(), dependencies);
      this.addDependenciesToChunk(module.dynamicDependencies, dynamicDependencies);
      this.setUpChunkImportsAndExportsForModule(module);
    }
    this.dependencies = Array.from(dependencies);
    this.dynamicDependencies = Array.from(dynamicDependencies);
  }
  /*
   * Performs a full merge of another chunk into this chunk
   * chunkList allows updating references in other chunks for the merged chunk to this chunk
   * A new facade will be added to chunkList if tainting exports of either as an entry point
   */
  merge(chunk, chunkList, options, inputBase) {
    if (this.facadeModule !== null || chunk.facadeModule !== null)
      throw new Error('Internal error: Code splitting chunk merges not supported for facades');
    for (const module of chunk.orderedModules) {
      module.chunk = this;
      this.orderedModules.push(module);
    }
    for (const variable of chunk.imports) {
      if (!this.imports.has(variable) && variable.module.chunk !== this) {
        this.imports.add(variable);
      }
    }
    // NB detect when exported variables are orphaned by the merge itself
    // (involves reverse tracing dependents)
    for (const variable of chunk.exports) {
      if (!this.exports.has(variable)) {
        this.exports.add(variable);
      }
    }
    const thisOldExportNames = this.exportNames;
    // regenerate internal names
    this.generateInternalExports(options);
    const updateRenderedDeclaration = (dep, oldExportNames) => {
      if (dep.imports) {
        for (const impt of dep.imports) {
          impt.imported = this.getVariableExportName(oldExportNames[impt.imported]);
        }
      }
      if (dep.reexports) {
        for (const reexport of dep.reexports) {
          reexport.imported = this.getVariableExportName(oldExportNames[reexport.imported]);
        }
      }
    };
    const mergeRenderedDeclaration = (into, from) => {
      if (from.imports) {
        if (!into.imports) {
          into.imports = from.imports;
        }
        else {
          into.imports = into.imports.concat(from.imports);
        }
      }
      if (from.reexports) {
        if (!into.reexports) {
          into.reexports = from.reexports;
        }
        else {
          into.reexports = into.reexports.concat(from.reexports);
        }
      }
      if (!into.exportsNames && from.exportsNames) {
        into.exportsNames = true;
      }
      if (!into.exportsDefault && from.exportsDefault) {
        into.exportsDefault = true;
      }
      into.name = this.variableName;
    };
    // go through the other chunks and update their dependencies
    // also update their import and reexport names in the process
    for (const c of chunkList) {
      let includedDeclaration = undefined;
      for (let i = 0; i < c.dependencies.length; i++) {
        const dep = c.dependencies[i];
        if ((dep === chunk || dep === this) && includedDeclaration) {
          const duplicateDeclaration = c.renderedDeclarations.dependencies[i];
          updateRenderedDeclaration(duplicateDeclaration, dep === chunk ? chunk.exportNames : thisOldExportNames);
          mergeRenderedDeclaration(includedDeclaration, duplicateDeclaration);
          c.renderedDeclarations.dependencies.splice(i, 1);
          c.dependencies.splice(i--, 1);
        }
        else if (dep === chunk) {
          c.dependencies[i] = this;
          includedDeclaration = c.renderedDeclarations.dependencies[i];
          updateRenderedDeclaration(includedDeclaration, chunk.exportNames);
        }
        else if (dep === this) {
          includedDeclaration = c.renderedDeclarations.dependencies[i];
          updateRenderedDeclaration(includedDeclaration, thisOldExportNames);
        }
      }
    }
    // re-render the merged chunk
    this.preRender(options, inputBase);
  }
  // prerender allows chunk hashes and names to be generated before finalizing
  preRender(options, inputBase) {
    timeStart('render modules', 3);
    const magicString = new Bundle({ separator: options.compact ? '' : '\n\n' });
    this.usedModules = [];
    this.indentString = options.compact ? '' : getIndentString(this.orderedModules, options);
    const n = options.compact ? '' : '\n';
    const _ = options.compact ? '' : ' ';
    const renderOptions = {
      compact: options.compact,
      dynamicImportFunction: options.dynamicImportFunction,
      format: options.format,
      freeze: options.freeze !== false,
      indent: this.indentString,
      namespaceToStringTag: options.namespaceToStringTag === true,
      varOrConst: options.preferConst ? 'const' : 'var'
    };
    // Make sure the direct dependencies of a chunk are present to maintain execution order
    for (const { module } of this.imports) {
      const chunkOrExternal = (module instanceof Module$1 ? module.chunk : module);
      if (this.dependencies.indexOf(chunkOrExternal) === -1) {
        this.dependencies.push(chunkOrExternal);
      }
    }
    // for static and dynamic entry points, inline the execution list to avoid loading latency
    if (options.hoistTransitiveImports !== false &&
      !this.graph.preserveModules &&
      this.facadeModule !== null) {
      for (const dep of this.dependencies) {
        if (dep instanceof Chunk$1$1)
          this.inlineChunkDependencies(dep, true);
      }
    }
    // prune empty dependency chunks, inlining their side-effect dependencies
    for (let i = 0; i < this.dependencies.length; i++) {
      const dep = this.dependencies[i];
      if (dep instanceof Chunk$1$1 && dep.isEmpty) {
        this.dependencies.splice(i--, 1);
        this.inlineChunkDependencies(dep, false);
      }
    }
    sortByExecutionOrder(this.dependencies);
    this.prepareDynamicImports();
    this.setIdentifierRenderResolutions(options);
    let hoistedSource = '';
    const renderedModules = (this.renderedModules = Object.create(null));
    for (const module of this.orderedModules) {
      let renderedLength = 0;
      if (module.isIncluded()) {
        const source = module.render(renderOptions).trim();
        if (options.compact && source.lastLine().indexOf('//') !== -1)
          source.append('\n');
        const namespace = module.getOrCreateNamespace();
        if (namespace.included || source.length() > 0) {
          renderedLength = source.length();
          this.renderedModuleSources.set(module, source);
          magicString.addSource(source);
          this.usedModules.push(module);
          if (namespace.included && !this.graph.preserveModules) {
            const rendered = namespace.renderBlock(renderOptions);
            if (namespace.renderFirst())
              hoistedSource += n + rendered;
            else
              magicString.addSource(new MagicString$2(rendered));
          }
        }
      }
      const { renderedExports, removedExports } = module.getRenderedExports();
      renderedModules[module.id] = {
        originalLength: module.originalCode.length,
        removedExports,
        renderedExports,
        renderedLength
      };
    }
    if (hoistedSource)
      magicString.prepend(hoistedSource + n + n);
    if (this.needsExportsShim) {
      magicString.prepend(`${n}${renderOptions.varOrConst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);
    }
    if (options.compact) {
      this.renderedSource = magicString;
    }
    else {
      this.renderedSource = magicString.trim();
    }
    this.renderedSourceLength = undefined;
    this.renderedHash = undefined;
    if (this.isEmpty && this.getExportNames().length === 0 && this.dependencies.length === 0) {
      const chunkName = this.getChunkName();
      this.graph.warn({
        chunkName,
        code: 'EMPTY_BUNDLE',
        message: `Generated an empty chunk: "${chunkName}"`
      });
    }
    this.setExternalRenderPaths(options, inputBase);
    this.renderedDeclarations = {
      dependencies: this.getChunkDependencyDeclarations(options),
      exports: this.exportMode === 'none' ? [] : this.getChunkExportDeclarations()
    };
    timeEnd('render modules', 3);
  }
  render(options, addons, outputChunk, outputPluginDriver) {
    timeStart('render format', 3);
    const format = options.format;
    const finalise = finalisers[format];
    if (options.dynamicImportFunction && format !== 'es') {
      this.graph.warn({
        code: 'INVALID_OPTION',
        message: '"output.dynamicImportFunction" is ignored for formats other than "esm".'
      });
    }
    // populate ids in the rendered declarations only here
    // as chunk ids known only after prerender
    for (let i = 0; i < this.dependencies.length; i++) {
      const dep = this.dependencies[i];
      if (dep instanceof ExternalModule && !dep.renormalizeRenderPath)
        continue;
      const renderedDependency = this.renderedDeclarations.dependencies[i];
      const depId = dep instanceof ExternalModule ? renderedDependency.id : dep.id;
      if (dep instanceof Chunk$1$1)
        renderedDependency.namedExportsMode = dep.exportMode !== 'default';
      renderedDependency.id = this.getRelativePath(depId);
    }
    this.finaliseDynamicImports(format);
    this.finaliseImportMetas(format, outputPluginDriver);
    const hasExports = this.renderedDeclarations.exports.length !== 0 ||
      this.renderedDeclarations.dependencies.some(dep => (dep.reexports && dep.reexports.length !== 0));
    let usesTopLevelAwait = false;
    const accessedGlobals = new Set();
    for (const module of this.orderedModules) {
      if (module.usesTopLevelAwait) {
        usesTopLevelAwait = true;
      }
      const accessedGlobalVariablesByFormat = module.scope.accessedGlobalVariablesByFormat;
      const accessedGlobalVariables = accessedGlobalVariablesByFormat && accessedGlobalVariablesByFormat.get(format);
      if (accessedGlobalVariables) {
        for (const name of accessedGlobalVariables) {
          accessedGlobals.add(name);
        }
      }
    }
    if (usesTopLevelAwait && format !== 'es' && format !== 'system') {
      return error({
        code: 'INVALID_TLA_FORMAT',
        message: `Module format ${format} does not support top-level await. Use the "es" or "system" output formats rather.`
      });
    }
    const magicString = finalise(this.renderedSource, {
      accessedGlobals,
      dependencies: this.renderedDeclarations.dependencies,
      exports: this.renderedDeclarations.exports,
      hasExports,
      indentString: this.indentString,
      intro: addons.intro,
      isEntryModuleFacade: this.graph.preserveModules ||
        (this.facadeModule !== null && this.facadeModule.isEntryPoint),
      namedExportsMode: this.exportMode !== 'default',
      outro: addons.outro,
      usesTopLevelAwait,
      varOrConst: options.preferConst ? 'const' : 'var',
      warn: this.graph.warn.bind(this.graph)
    }, options);
    if (addons.banner)
      magicString.prepend(addons.banner);
    if (addons.footer)
      magicString.append(addons.footer);
    const prevCode = magicString.toString();
    timeEnd('render format', 3);
    let map = null;
    const chunkSourcemapChain = [];
    return renderChunk({
      chunk: this,
      code: prevCode,
      options,
      outputPluginDriver,
      renderChunk: outputChunk,
      sourcemapChain: chunkSourcemapChain
    }).then((code) => {
      if (options.sourcemap) {
        timeStart('sourcemap', 3);
        let file;
        if (options.file)
          file = resolve(options.sourcemapFile || options.file);
        else if (options.dir)
          file = resolve(options.dir, this.id);
        else
          file = resolve(this.id);
        const decodedMap = magicString.generateDecodedMap({});
        map = collapseSourcemaps(this, file, decodedMap, this.usedModules, chunkSourcemapChain, options.sourcemapExcludeSources);
        map.sources = map.sources.map(sourcePath => normalize$1(options.sourcemapPathTransform ? options.sourcemapPathTransform(sourcePath) : sourcePath));
        timeEnd('sourcemap', 3);
      }
      if (options.compact !== true && code[code.length - 1] !== '\n')
        code += '\n';
      return { code, map };
    });
  }
  visitDependencies(handleDependency) {
    const toBeVisited = [this];
    const visited = new Set();
    for (const current of toBeVisited) {
      handleDependency(current);
      if (current instanceof ExternalModule)
        continue;
      for (const dependency of current.dependencies.concat(current.dynamicDependencies)) {
        if (!visited.has(dependency)) {
          visited.add(dependency);
          toBeVisited.push(dependency);
        }
      }
    }
  }
  visitStaticDependenciesUntilCondition(isConditionSatisfied) {
    const seen = new Set();
    function visitDep(dep) {
      if (seen.has(dep))
        return undefined;
      seen.add(dep);
      if (dep instanceof Chunk$1$1) {
        for (const subDep of dep.dependencies) {
          if (visitDep(subDep))
            return true;
        }
      }
      return isConditionSatisfied(dep) === true;
    }
    return visitDep(this);
  }
  addDependenciesToChunk(moduleDependencies, chunkDependencies) {
    for (const depModule of moduleDependencies) {
      if (depModule.chunk === this) {
        continue;
      }
      let dependency;
      if (depModule instanceof Module$1) {
        dependency = depModule.chunk;
      }
      else {
        if (!(depModule.used || depModule.moduleSideEffects)) {
          continue;
        }
        dependency = depModule;
      }
      chunkDependencies.add(dependency);
    }
  }
  assignFacadeName({ fileName, name }, facadedModule) {
    if (fileName) {
      this.fileName = fileName;
    }
    else {
      this.name = sanitizeFileName(name || facadedModule.chunkName || getAliasName(facadedModule.id));
    }
  }
  calculateHashAugmentation(outputPluginDriver) {
    const facadeModule = this.facadeModule;
    const getChunkName = this.getChunkName.bind(this);
    const preRenderedChunk = {
      dynamicImports: this.getDynamicImportIds(),
      exports: this.getExportNames(),
      facadeModuleId: facadeModule && facadeModule.id,
      imports: this.getImportIds(),
      isDynamicEntry: facadeModule !== null && facadeModule.dynamicallyImportedBy.length > 0,
      isEntry: facadeModule !== null && facadeModule.isEntryPoint,
      modules: this.renderedModules,
      get name() {
        return getChunkName();
      }
    };
    return outputPluginDriver.hookReduceValueSync('augmentChunkHash', '', [preRenderedChunk], (hashAugmentation, pluginHash) => {
      if (pluginHash) {
        hashAugmentation += pluginHash;
      }
      return hashAugmentation;
    });
  }
  computeContentHashWithDependencies(addons, options, existingNames, outputPluginDriver) {
    const hash = createHash$1();
    hash.update([addons.intro, addons.outro, addons.banner, addons.footer].map(addon => addon || '').join(':'));
    hash.update(options.format);
    this.visitDependencies(dep => {
      if (dep instanceof ExternalModule) {
        hash.update(':' + dep.renderPath);
      }
      else {
        hash.update(dep.getRenderedHash(outputPluginDriver));
        hash.update(dep.generateId(addons, options, existingNames, false, outputPluginDriver));
      }
    });
    return hash.digest('hex').substr(0, 8);
  }
  finaliseDynamicImports(format) {
    for (const [module, code] of this.renderedModuleSources) {
      for (const { node, resolution } of module.dynamicImports) {
        if (!resolution)
          continue;
        if (resolution instanceof Module$1) {
          if (resolution.chunk !== this && isChunkRendered(resolution.chunk)) {
            const resolutionChunk = resolution.facadeChunk || resolution.chunk;
            node.renderFinalResolution(code, `'${this.getRelativePath(resolutionChunk.id)}'`, format);
          }
        }
        else {
          node.renderFinalResolution(code, resolution instanceof ExternalModule
            ? `'${resolution.renormalizeRenderPath
              ? this.getRelativePath(resolution.renderPath)
              : resolution.id}'`
            : resolution, format);
        }
      }
    }
  }
  finaliseImportMetas(format, outputPluginDriver) {
    for (const [module, code] of this.renderedModuleSources) {
      for (const importMeta of module.importMetas) {
        importMeta.renderFinalMechanism(code, this.id, format, outputPluginDriver);
      }
    }
  }
  getChunkDependencyDeclarations(options) {
    const reexportDeclarations = new Map();
    for (let exportName of this.getExportNames()) {
      let exportChunk;
      let importName;
      let needsLiveBinding = false;
      if (exportName[0] === '*') {
        needsLiveBinding = options.externalLiveBindings !== false;
        exportChunk = this.graph.moduleById.get(exportName.substr(1));
        importName = exportName = '*';
      }
      else {
        const variable = this.exportNames[exportName];
        const module = variable.module;
        // skip local exports
        if (!module || module.chunk === this)
          continue;
        if (module instanceof Module$1) {
          exportChunk = module.chunk;
          importName = exportChunk.getVariableExportName(variable);
          needsLiveBinding = variable.isReassigned;
        }
        else {
          exportChunk = module;
          importName = variable.name;
          needsLiveBinding = options.externalLiveBindings !== false;
        }
      }
      let reexportDeclaration = reexportDeclarations.get(exportChunk);
      if (!reexportDeclaration)
        reexportDeclarations.set(exportChunk, (reexportDeclaration = []));
      reexportDeclaration.push({ imported: importName, reexported: exportName, needsLiveBinding });
    }
    const renderedImports = new Set();
    const dependencies = [];
    for (const dep of this.dependencies) {
      const imports = [];
      for (const variable of this.imports) {
        const renderedVariable = variable instanceof ExportDefaultVariable ? variable.getOriginalVariable() : variable;
        if ((variable.module instanceof Module$1
          ? variable.module.chunk === dep
          : variable.module === dep) &&
          !renderedImports.has(renderedVariable)) {
          renderedImports.add(renderedVariable);
          imports.push({
            imported: variable.module instanceof ExternalModule
              ? variable.name
              : variable.module.chunk.getVariableExportName(variable),
            local: variable.getName()
          });
        }
      }
      const reexports = reexportDeclarations.get(dep);
      let exportsNames, exportsDefault;
      let namedExportsMode = true;
      if (dep instanceof ExternalModule) {
        exportsNames = dep.exportsNames || dep.exportsNamespace;
        exportsDefault = 'default' in dep.declarations;
      }
      else {
        exportsNames = true;
        // we don't want any interop patterns to trigger
        exportsDefault = false;
        namedExportsMode = dep.exportMode !== 'default';
      }
      let id = undefined;
      let globalName = undefined;
      if (dep instanceof ExternalModule) {
        id = dep.renderPath;
        if (options.format === 'umd' || options.format === 'iife') {
          globalName = getGlobalName(dep, options.globals, this.graph, exportsNames || exportsDefault);
        }
      }
      dependencies.push({
        exportsDefault,
        exportsNames,
        globalName,
        id,
        imports: imports.length > 0 ? imports : null,
        isChunk: dep instanceof Chunk$1$1,
        name: dep.variableName,
        namedExportsMode,
        reexports
      });
    }
    return dependencies;
  }
  getChunkExportDeclarations() {
    const exports = [];
    for (const exportName of this.getExportNames()) {
      if (exportName[0] === '*')
        continue;
      const variable = this.exportNames[exportName];
      const module = variable.module;
      if (module && module.chunk !== this)
        continue;
      let hoisted = false;
      let uninitialized = false;
      if (variable instanceof LocalVariable) {
        if (variable.init === UNDEFINED_EXPRESSION) {
          uninitialized = true;
        }
        for (const declaration of variable.declarations) {
          if (declaration.parent instanceof FunctionDeclaration ||
            (declaration instanceof ExportDefaultDeclaration &&
              declaration.declaration instanceof FunctionDeclaration)) {
            hoisted = true;
            break;
          }
        }
      }
      else if (variable instanceof GlobalVariable) {
        hoisted = true;
      }
      const localName = variable.getName();
      exports.push({
        exported: exportName === '*' ? localName : exportName,
        hoisted,
        local: localName,
        uninitialized
      });
    }
    return exports;
  }
  getFallbackChunkName() {
    if (this.manualChunkAlias) {
      return this.manualChunkAlias;
    }
    if (this.fileName) {
      return getAliasName(this.fileName);
    }
    return getAliasName(this.orderedModules[this.orderedModules.length - 1].id);
  }
  getRelativePath(targetPath) {
    const relativePath = normalize$1(relative$1(dirname(this.id), targetPath));
    return relativePath.startsWith('../') ? relativePath : './' + relativePath;
  }
  inlineChunkDependencies(chunk, deep) {
    for (const dep of chunk.dependencies) {
      if (dep instanceof ExternalModule) {
        if (this.dependencies.indexOf(dep) === -1)
          this.dependencies.push(dep);
      }
      else {
        if (dep === this || this.dependencies.indexOf(dep) !== -1)
          continue;
        if (!dep.isEmpty)
          this.dependencies.push(dep);
        if (deep)
          this.inlineChunkDependencies(dep, true);
      }
    }
  }
  prepareDynamicImports() {
    for (const module of this.orderedModules) {
      for (const { node, resolution } of module.dynamicImports) {
        if (!node.included)
          continue;
        if (resolution instanceof Module$1) {
          if (resolution.chunk === this) {
            const namespace = resolution.getOrCreateNamespace();
            node.setResolution('named', namespace);
          }
          else {
            node.setResolution(resolution.chunk.exportMode);
          }
        }
        else {
          node.setResolution('auto');
        }
      }
    }
  }
  setExternalRenderPaths(options, inputBase) {
    for (const dependency of this.dependencies.concat(this.dynamicDependencies)) {
      if (dependency instanceof ExternalModule) {
        dependency.setRenderPath(options, inputBase);
      }
    }
  }
  setIdentifierRenderResolutions(options) {
    for (const exportName of this.getExportNames()) {
      const exportVariable = this.exportNames[exportName];
      if (exportVariable) {
        if (exportVariable instanceof ExportShimVariable) {
          this.needsExportsShim = true;
        }
        exportVariable.exportName = exportName;
        if (options.format !== 'es' &&
          options.format !== 'system' &&
          exportVariable.isReassigned &&
          !exportVariable.isId &&
          !(exportVariable instanceof ExportDefaultVariable && exportVariable.hasId)) {
          exportVariable.setRenderNames('exports', exportName);
        }
        else {
          exportVariable.setRenderNames(null, null);
        }
      }
    }
    const usedNames = new Set();
    if (this.needsExportsShim) {
      usedNames.add(MISSING_EXPORT_SHIM_VARIABLE);
    }
    if (options.format !== 'es') {
      usedNames.add('exports');
      if (options.format === 'cjs') {
        usedNames
          .add(INTEROP_DEFAULT_VARIABLE)
          .add('require')
          .add('module')
          .add('__filename')
          .add('__dirname');
      }
    }
    deconflictChunk(this.orderedModules, this.dependencies, this.imports, usedNames, options.format, options.interop !== false, this.graph.preserveModules);
  }
  setUpChunkImportsAndExportsForModule(module) {
    for (const variable of module.imports) {
      if (variable.module.chunk !== this) {
        this.imports.add(variable);
        if (variable.module instanceof Module$1) {
          variable.module.chunk.exports.add(variable);
        }
      }
    }
    if (module.isEntryPoint ||
      module.dynamicallyImportedBy.some(importer => importer.chunk !== this)) {
      const map = module.getExportNamesByVariable();
      for (const exportedVariable of map.keys()) {
        this.exports.add(exportedVariable);
        const exportingModule = exportedVariable.module;
        if (exportingModule && exportingModule.chunk && exportingModule.chunk !== this) {
          exportingModule.chunk.exports.add(exportedVariable);
        }
      }
    }
    if (module.getOrCreateNamespace().included) {
      for (const reexportName of Object.keys(module.reexportDescriptions)) {
        const reexport = module.reexportDescriptions[reexportName];
        const variable = reexport.module.getVariableForExportName(reexport.localName);
        if (variable.module.chunk !== this) {
          this.imports.add(variable);
          if (variable.module instanceof Module$1) {
            variable.module.chunk.exports.add(variable);
          }
        }
      }
    }
    const context = createInclusionContext();
    for (const { node, resolution } of module.dynamicImports) {
      if (node.included && resolution instanceof Module$1 && resolution.chunk === this)
        resolution.getOrCreateNamespace().include(context);
    }
  }
}

/*
 * Given a chunk list, perform optimizations on that chunk list
 * to reduce the mumber of chunks. Mutates the chunks array.
 *
 * Manual chunks (with chunk.chunkAlias already set) are preserved
 * Entry points are carefully preserved as well
 *
 */
function optimizeChunks(chunks, options, CHUNK_GROUPING_SIZE, inputBase) {
  for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
    const mainChunk = chunks[chunkIndex];
    const execGroup = [];
    mainChunk.visitStaticDependenciesUntilCondition(dep => {
      if (dep instanceof Chunk$1$1) {
        execGroup.push(dep);
      }
    });
    if (execGroup.length < 2) {
      continue;
    }
    let execGroupIndex = 1;
    let seekingFirstMergeCandidate = true;
    let lastChunk = undefined, chunk = execGroup[0], nextChunk = execGroup[1];
    const isMergeCandidate = (chunk) => {
      if (chunk.facadeModule !== null || chunk.manualChunkAlias !== null) {
        return false;
      }
      if (!nextChunk || nextChunk.facadeModule !== null) {
        return false;
      }
      if (chunk.getRenderedSourceLength() > CHUNK_GROUPING_SIZE) {
        return false;
      }
      // if (!chunk.isPure()) continue;
      return true;
    };
    do {
      if (seekingFirstMergeCandidate) {
        if (isMergeCandidate(chunk)) {
          seekingFirstMergeCandidate = false;
        }
        continue;
      }
      let remainingSize = CHUNK_GROUPING_SIZE - lastChunk.getRenderedSourceLength() - chunk.getRenderedSourceLength();
      if (remainingSize <= 0) {
        if (!isMergeCandidate(chunk)) {
          seekingFirstMergeCandidate = true;
        }
        continue;
      }
      // if (!chunk.isPure()) continue;
      const chunkDependencies = new Set();
      chunk.visitStaticDependenciesUntilCondition(dep => chunkDependencies.add(dep));
      const ignoreSizeChunks = new Set([chunk, lastChunk]);
      if (lastChunk.visitStaticDependenciesUntilCondition(dep => {
        if (dep === chunk || dep === lastChunk) {
          return false;
        }
        if (chunkDependencies.has(dep)) {
          return false;
        }
        if (dep instanceof ExternalModule) {
          return true;
        }
        remainingSize -= dep.getRenderedSourceLength();
        if (remainingSize <= 0) {
          return true;
        }
        ignoreSizeChunks.add(dep);
      })) {
        if (!isMergeCandidate(chunk)) {
          seekingFirstMergeCandidate = true;
        }
        continue;
      }
      if (chunk.visitStaticDependenciesUntilCondition(dep => {
        if (ignoreSizeChunks.has(dep)) {
          return false;
        }
        if (dep instanceof ExternalModule) {
          return true;
        }
        remainingSize -= dep.getRenderedSourceLength();
        if (remainingSize <= 0) {
          return true;
        }
      })) {
        if (!isMergeCandidate(chunk)) {
          seekingFirstMergeCandidate = true;
        }
        continue;
      }
      // within the size limit -> merge!
      const optimizedChunkIndex = chunks.indexOf(chunk);
      if (optimizedChunkIndex <= chunkIndex)
        chunkIndex--;
      chunks.splice(optimizedChunkIndex, 1);
      lastChunk.merge(chunk, chunks, options, inputBase);
      execGroup.splice(--execGroupIndex, 1);
      chunk = lastChunk;
      // keep going to see if we can merge this with the next again
      if (nextChunk && !isMergeCandidate(nextChunk)) {
        seekingFirstMergeCandidate = true;
      }
    } while (((lastChunk = chunk), (chunk = nextChunk), (nextChunk = execGroup[++execGroupIndex]), chunk));
  }
  return chunks;
}

const skipWhiteSpace$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const tt = types;
var acornExportNsFrom = function (Parser) {
  return class extends Parser {
    parseExport(node, exports) {
      skipWhiteSpace$1.lastIndex = this.pos;
      const skip = skipWhiteSpace$1.exec(this.input);
      const next = this.input.charAt(this.pos + skip[0].length);
      if (next !== "*")
        return super.parseExport(node, exports);
      this.next();
      const specifier = this.startNode();
      this.expect(tt.star);
      if (this.eatContextual("as")) {
        node.declaration = null;
        specifier.exported = this.parseIdent(true);
        this.checkExport(exports, specifier.exported.name, this.lastTokStart);
        node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
      }
      this.expectContextual("from");
      if (this.type !== tt.string)
        this.unexpected();
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, node.specifiers ? "ExportNamedDeclaration" : "ExportAllDeclaration");
    }
  };
};

const tt$1 = types;
const skipWhiteSpace$1$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const nextTokenIsDot = parser => {
  skipWhiteSpace$1$1.lastIndex = parser.pos;
  let skip = skipWhiteSpace$1$1.exec(parser.input);
  let next = parser.pos + skip[0].length;
  return parser.input.slice(next, next + 1) === ".";
};
var acornImportMeta = function (Parser) {
  return class extends Parser {
    parseExprAtom(refDestructuringErrors) {
      if (this.type !== tt$1._import || !nextTokenIsDot(this))
        return super.parseExprAtom(refDestructuringErrors);
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
      }
      let node = this.startNode();
      node.meta = this.parseIdent(true);
      this.expect(tt$1.dot);
      node.property = this.parseIdent(true);
      if (node.property.name !== "meta") {
        this.raiseRecoverable(node.property.start, "The only valid meta property for import is import.meta");
      }
      if (this.containsEsc) {
        this.raiseRecoverable(node.property.start, "\"meta\" in import.meta must not contain escape sequences");
      }
      return this.finishNode(node, "MetaProperty");
    }
    parseStatement(context, topLevel, exports) {
      if (this.type !== tt$1._import || !nextTokenIsDot(this)) {
        return super.parseStatement(context, topLevel, exports);
      }
      let node = this.startNode();
      let expr = this.parseExpression();
      return this.parseExpressionStatement(node, expr);
    }
  };
};

class UndefinedVariable extends Variable {
  constructor() {
    super('undefined');
  }
  getLiteralValueAtPath() {
    return undefined;
  }
}

class GlobalScope extends Scope$2 {
  constructor() {
    super();
    this.variables.set('undefined', new UndefinedVariable());
  }
  findVariable(name) {
    let variable = this.variables.get(name);
    if (!variable) {
      variable = new GlobalVariable(name);
      this.variables.set(name, variable);
    }
    return variable;
  }
}

const ANONYMOUS_PLUGIN_PREFIX = 'at position ';
const ANONYMOUS_OUTPUT_PLUGIN_PREFIX = 'at output position ';
function throwPluginError(err, plugin, { hook, id } = {}) {
  if (typeof err === 'string')
    err = { message: err };
  if (err.code && err.code !== Errors.PLUGIN_ERROR) {
    err.pluginCode = err.code;
  }
  err.code = Errors.PLUGIN_ERROR;
  err.plugin = plugin;
  if (hook) {
    err.hook = hook;
  }
  if (id) {
    err.id = id;
  }
  return error(err);
}
const deprecatedHooks = [
  { active: true, deprecated: 'ongenerate', replacement: 'generateBundle' },
  { active: true, deprecated: 'onwrite', replacement: 'generateBundle/writeBundle' },
  { active: true, deprecated: 'transformBundle', replacement: 'renderChunk' },
  { active: true, deprecated: 'transformChunk', replacement: 'renderChunk' },
  { active: false, deprecated: 'resolveAssetUrl', replacement: 'resolveFileUrl' }
];
function warnDeprecatedHooks(plugins, graph) {
  for (const { active, deprecated, replacement } of deprecatedHooks) {
    for (const plugin of plugins) {
      if (deprecated in plugin) {
        graph.warnDeprecation({
          message: `The "${deprecated}" hook used by plugin ${plugin.name} is deprecated. The "${replacement}" hook should be used instead.`,
          plugin: plugin.name
        }, active);
      }
    }
  }
}

function createPluginCache(cache) {
  return {
    has(id) {
      const item = cache[id];
      if (!item)
        return false;
      item[0] = 0;
      return true;
    },
    get(id) {
      const item = cache[id];
      if (!item)
        return undefined;
      item[0] = 0;
      return item[1];
    },
    set(id, value) {
      cache[id] = [0, value];
    },
    delete(id) {
      return delete cache[id];
    }
  };
}
function getTrackedPluginCache(pluginCache) {
  const trackedCache = {
    cache: {
      has(id) {
        trackedCache.used = true;
        return pluginCache.has(id);
      },
      get(id) {
        trackedCache.used = true;
        return pluginCache.get(id);
      },
      set(id, value) {
        trackedCache.used = true;
        return pluginCache.set(id, value);
      },
      delete(id) {
        trackedCache.used = true;
        return pluginCache.delete(id);
      }
    },
    used: false
  };
  return trackedCache;
}
const NO_CACHE = {
  has() {
    return false;
  },
  get() {
    return undefined;
  },
  set() { },
  delete() {
    return false;
  }
};
function uncacheablePluginError(pluginName) {
  if (pluginName.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||
    pluginName.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX)) {
    return error({
      code: 'ANONYMOUS_PLUGIN_CACHE',
      message: 'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.'
    });
  }
  return error({
    code: 'DUPLICATE_PLUGIN_NAME',
    message: `The plugin name ${pluginName} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
  });
}
function getCacheForUncacheablePlugin(pluginName) {
  return {
    has() {
      return uncacheablePluginError(pluginName);
    },
    get() {
      return uncacheablePluginError(pluginName);
    },
    set() {
      return uncacheablePluginError(pluginName);
    },
    delete() {
      return uncacheablePluginError(pluginName);
    }
  };
}

function transform$1(graph, source, module) {
  const id = module.id;
  const sourcemapChain = [];
  let originalSourcemap = source.map === null ? null : decodedSourcemap(source.map);
  const originalCode = source.code;
  let ast = source.ast;
  const transformDependencies = [];
  const emittedFiles = [];
  let customTransformCache = false;
  let moduleSideEffects = null;
  let syntheticNamedExports = null;
  let trackedPluginCache;
  let curPlugin;
  const curSource = source.code;
  function transformReducer(code, result, plugin) {
    // track which plugins use the custom this.cache to opt-out of transform caching
    if (!customTransformCache && trackedPluginCache.used)
      customTransformCache = true;
    if (customTransformCache) {
      if (result && typeof result === 'object' && Array.isArray(result.dependencies)) {
        for (const dep of result.dependencies) {
          graph.watchFiles[resolve(dirname(id), dep)] = true;
        }
      }
    }
    else {
      // files emitted by a transform hook need to be emitted again if the hook is skipped
      if (emittedFiles.length)
        module.transformFiles = emittedFiles;
      if (result && typeof result === 'object' && Array.isArray(result.dependencies)) {
        // not great, but a useful way to track this without assuming WeakMap
        if (!curPlugin.warnedTransformDependencies)
          graph.warnDeprecation(`Returning "dependencies" from the "transform" hook as done by plugin ${plugin.name} is deprecated. The "this.addWatchFile" plugin context function should be used instead.`, true);
        curPlugin.warnedTransformDependencies = true;
        for (const dep of result.dependencies)
          transformDependencies.push(resolve(dirname(id), dep));
      }
    }
    if (typeof result === 'string') {
      result = {
        ast: undefined,
        code: result,
        map: undefined
      };
    }
    else if (result && typeof result === 'object') {
      if (typeof result.map === 'string') {
        result.map = JSON.parse(result.map);
      }
      if (typeof result.moduleSideEffects === 'boolean') {
        moduleSideEffects = result.moduleSideEffects;
      }
      if (typeof result.syntheticNamedExports === 'boolean') {
        syntheticNamedExports = result.syntheticNamedExports;
      }
    }
    else {
      return code;
    }
    // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning
    if (result.map !== null) {
      const map = decodedSourcemap(result.map);
      sourcemapChain.push(map || { missing: true, plugin: plugin.name });
    }
    ast = result.ast;
    return result.code;
  }
  let setAssetSourceErr;
  return graph.pluginDriver
    .hookReduceArg0('transform', [curSource, id], transformReducer, (pluginContext, plugin) => {
    curPlugin = plugin;
    if (curPlugin.cacheKey)
      customTransformCache = true;
    else
      trackedPluginCache = getTrackedPluginCache(pluginContext.cache);
    return Object.assign(Object.assign({}, pluginContext), { cache: trackedPluginCache ? trackedPluginCache.cache : pluginContext.cache, warn(warning, pos) {
        if (typeof warning === 'string')
          warning = { message: warning };
        if (pos)
          augmentCodeLocation(warning, pos, curSource, id);
        warning.id = id;
        warning.hook = 'transform';
        pluginContext.warn(warning);
      },
      error(err, pos) {
        if (typeof err === 'string')
          err = { message: err };
        if (pos)
          augmentCodeLocation(err, pos, curSource, id);
        err.id = id;
        err.hook = 'transform';
        return pluginContext.error(err);
      },
      emitAsset(name, source) {
        const emittedFile = { type: 'asset', name, source };
        emittedFiles.push(Object.assign({}, emittedFile));
        return graph.pluginDriver.emitFile(emittedFile);
      },
      emitChunk(id, options) {
        const emittedFile = { type: 'chunk', id, name: options && options.name };
        emittedFiles.push(Object.assign({}, emittedFile));
        return graph.pluginDriver.emitFile(emittedFile);
      },
      emitFile(emittedFile) {
        emittedFiles.push(emittedFile);
        return graph.pluginDriver.emitFile(emittedFile);
      },
      addWatchFile(id) {
        transformDependencies.push(id);
        pluginContext.addWatchFile(id);
      },
      setAssetSource(assetReferenceId, source) {
        pluginContext.setAssetSource(assetReferenceId, source);
        if (!customTransformCache && !setAssetSourceErr) {
          try {
            return this.error({
              code: 'INVALID_SETASSETSOURCE',
              message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`
            });
          }
          catch (err) {
            setAssetSourceErr = err;
          }
        }
      },
      getCombinedSourcemap() {
        const combinedMap = collapseSourcemap(graph, id, originalCode, originalSourcemap, sourcemapChain);
        if (!combinedMap) {
          const magicString = new MagicString$2(originalCode);
          return magicString.generateMap({ includeContent: true, hires: true, source: id });
        }
        if (originalSourcemap !== combinedMap) {
          originalSourcemap = combinedMap;
          sourcemapChain.length = 0;
        }
        return new SourceMap$2(Object.assign(Object.assign({}, combinedMap), { file: null, sourcesContent: combinedMap.sourcesContent }));
      } });
  })
    .catch(err => throwPluginError(err, curPlugin.name, { hook: 'transform', id }))
    .then(code => {
    if (!customTransformCache && setAssetSourceErr)
      throw setAssetSourceErr;
    return {
      ast: ast,
      code,
      customTransformCache,
      moduleSideEffects,
      originalCode,
      originalSourcemap,
      sourcemapChain,
      syntheticNamedExports,
      transformDependencies
    };
  });
}

function normalizeRelativeExternalId(importer, source) {
  return isRelative(source) ? resolve(importer, '..', source) : source;
}
function getIdMatcher(option) {
  if (option === true) {
    return () => true;
  }
  if (typeof option === 'function') {
    return (id, ...args) => (!id.startsWith('\0') && option(id, ...args)) || false;
  }
  if (option) {
    const ids = new Set(Array.isArray(option) ? option : option ? [option] : []);
    return (id => ids.has(id));
  }
  return () => false;
}
function getHasModuleSideEffects(moduleSideEffectsOption, pureExternalModules, graph) {
  if (typeof moduleSideEffectsOption === 'boolean') {
    return () => moduleSideEffectsOption;
  }
  if (moduleSideEffectsOption === 'no-external') {
    return (_id, external) => !external;
  }
  if (typeof moduleSideEffectsOption === 'function') {
    return (id, external) => !id.startsWith('\0') ? moduleSideEffectsOption(id, external) !== false : true;
  }
  if (Array.isArray(moduleSideEffectsOption)) {
    const ids = new Set(moduleSideEffectsOption);
    return id => ids.has(id);
  }
  if (moduleSideEffectsOption) {
    graph.warn(errInvalidOption('treeshake.moduleSideEffects', 'please use one of false, "no-external", a function or an array'));
  }
  const isPureExternalModule = getIdMatcher(pureExternalModules);
  return (id, external) => !(external && isPureExternalModule(id));
}
class ModuleLoader {
  constructor(graph, modulesById, pluginDriver, external, getManualChunk, moduleSideEffects, pureExternalModules) {
    this.indexedEntryModules = [];
    this.latestLoadModulesPromise = Promise.resolve();
    this.manualChunkModules = {};
    this.nextEntryModuleIndex = 0;
    this.loadEntryModule = (unresolvedId, isEntry) => this.pluginDriver.hookFirst('resolveId', [unresolvedId, undefined]).then(resolveIdResult => {
      if (resolveIdResult === false ||
        (resolveIdResult && typeof resolveIdResult === 'object' && resolveIdResult.external)) {
        return error(errEntryCannotBeExternal(unresolvedId));
      }
      const id = resolveIdResult && typeof resolveIdResult === 'object'
        ? resolveIdResult.id
        : resolveIdResult;
      if (typeof id === 'string') {
        return this.fetchModule(id, undefined, true, false, isEntry);
      }
      return error(errUnresolvedEntry(unresolvedId));
    });
    this.graph = graph;
    this.modulesById = modulesById;
    this.pluginDriver = pluginDriver;
    this.isExternal = getIdMatcher(external);
    this.hasModuleSideEffects = getHasModuleSideEffects(moduleSideEffects, pureExternalModules, graph);
    this.getManualChunk = typeof getManualChunk === 'function' ? getManualChunk : () => null;
  }
  addEntryModules(unresolvedEntryModules, isUserDefined) {
    const firstEntryModuleIndex = this.nextEntryModuleIndex;
    this.nextEntryModuleIndex += unresolvedEntryModules.length;
    const loadNewEntryModulesPromise = Promise.all(unresolvedEntryModules.map(({ fileName, id, name }) => this.loadEntryModule(id, true).then(module => {
      if (fileName !== null) {
        module.chunkFileNames.add(fileName);
      }
      else if (name !== null) {
        if (module.chunkName === null) {
          module.chunkName = name;
        }
        if (isUserDefined) {
          module.userChunkNames.add(name);
        }
      }
      return module;
    }))).then(entryModules => {
      let moduleIndex = firstEntryModuleIndex;
      for (const entryModule of entryModules) {
        entryModule.isUserDefinedEntryPoint = entryModule.isUserDefinedEntryPoint || isUserDefined;
        const existingIndexModule = this.indexedEntryModules.find(indexedModule => indexedModule.module.id === entryModule.id);
        if (!existingIndexModule) {
          this.indexedEntryModules.push({ module: entryModule, index: moduleIndex });
        }
        else {
          existingIndexModule.index = Math.min(existingIndexModule.index, moduleIndex);
        }
        moduleIndex++;
      }
      this.indexedEntryModules.sort(({ index: indexA }, { index: indexB }) => indexA > indexB ? 1 : -1);
      return entryModules;
    });
    return this.awaitLoadModulesPromise(loadNewEntryModulesPromise).then(newEntryModules => ({
      entryModules: this.indexedEntryModules.map(({ module }) => module),
      manualChunkModulesByAlias: this.manualChunkModules,
      newEntryModules
    }));
  }
  addManualChunks(manualChunks) {
    const unresolvedManualChunks = [];
    for (const alias of Object.keys(manualChunks)) {
      const manualChunkIds = manualChunks[alias];
      for (const id of manualChunkIds) {
        unresolvedManualChunks.push({ id, alias });
      }
    }
    const loadNewManualChunkModulesPromise = Promise.all(unresolvedManualChunks.map(({ id }) => this.loadEntryModule(id, false))).then(manualChunkModules => {
      for (let index = 0; index < manualChunkModules.length; index++) {
        this.addModuleToManualChunk(unresolvedManualChunks[index].alias, manualChunkModules[index]);
      }
    });
    return this.awaitLoadModulesPromise(loadNewManualChunkModulesPromise);
  }
  resolveId(source, importer, skip) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.normalizeResolveIdResult(this.isExternal(source, importer, false)
        ? false
        : yield this.pluginDriver.hookFirst('resolveId', [source, importer], null, skip), importer, source);
    });
  }
  addModuleToManualChunk(alias, module) {
    if (module.manualChunkAlias !== null && module.manualChunkAlias !== alias) {
      return error(errCannotAssignModuleToChunk(module.id, alias, module.manualChunkAlias));
    }
    module.manualChunkAlias = alias;
    if (!this.manualChunkModules[alias]) {
      this.manualChunkModules[alias] = [];
    }
    this.manualChunkModules[alias].push(module);
  }
  awaitLoadModulesPromise(loadNewModulesPromise) {
    this.latestLoadModulesPromise = Promise.all([
      loadNewModulesPromise,
      this.latestLoadModulesPromise
    ]);
    const getCombinedPromise = () => {
      const startingPromise = this.latestLoadModulesPromise;
      return startingPromise.then(() => {
        if (this.latestLoadModulesPromise !== startingPromise) {
          return getCombinedPromise();
        }
      });
    };
    return getCombinedPromise().then(() => loadNewModulesPromise);
  }
  fetchAllDependencies(module) {
    return Promise.all([
      ...Array.from(module.sources).map((source) => __awaiter(this, void 0, void 0, function* () {
        return this.fetchResolvedDependency(source, module.id, (module.resolvedIds[source] =
          module.resolvedIds[source] ||
            this.handleResolveId(yield this.resolveId(source, module.id), source, module.id)));
      })),
      ...module.getDynamicImportExpressions().map((specifier, index) => this.resolveDynamicImport(module, specifier, module.id).then(resolvedId => {
        if (resolvedId === null)
          return;
        const dynamicImport = module.dynamicImports[index];
        if (typeof resolvedId === 'string') {
          dynamicImport.resolution = resolvedId;
          return;
        }
        return this.fetchResolvedDependency(relativeId(resolvedId.id), module.id, resolvedId).then(module => {
          dynamicImport.resolution = module;
        });
      }))
    ]);
  }
  fetchModule(id, importer, moduleSideEffects, syntheticNamedExports, isEntry) {
    const existingModule = this.modulesById.get(id);
    if (existingModule instanceof Module$1) {
      existingModule.isEntryPoint = existingModule.isEntryPoint || isEntry;
      return Promise.resolve(existingModule);
    }
    const module = new Module$1(this.graph, id, moduleSideEffects, syntheticNamedExports, isEntry);
    this.modulesById.set(id, module);
    this.graph.watchFiles[id] = true;
    const manualChunkAlias = this.getManualChunk(id);
    if (typeof manualChunkAlias === 'string') {
      this.addModuleToManualChunk(manualChunkAlias, module);
    }
    timeStart('load modules', 3);
    return Promise.resolve(this.pluginDriver.hookFirst('load', [id]))
      .catch((err) => {
      timeEnd('load modules', 3);
      let msg = `Could not load ${id}`;
      if (importer)
        msg += ` (imported by ${importer})`;
      msg += `: ${err.message}`;
      err.message = msg;
      throw err;
    })
      .then(source => {
      timeEnd('load modules', 3);
      if (typeof source === 'string')
        return { code: source };
      if (source && typeof source === 'object' && typeof source.code === 'string')
        return source;
      return error(errBadLoader(id));
    })
      .then(sourceDescription => {
      const cachedModule = this.graph.cachedModules.get(id);
      if (cachedModule &&
        !cachedModule.customTransformCache &&
        cachedModule.originalCode === sourceDescription.code) {
        if (cachedModule.transformFiles) {
          for (const emittedFile of cachedModule.transformFiles)
            this.pluginDriver.emitFile(emittedFile);
        }
        return cachedModule;
      }
      if (typeof sourceDescription.moduleSideEffects === 'boolean') {
        module.moduleSideEffects = sourceDescription.moduleSideEffects;
      }
      if (typeof sourceDescription.syntheticNamedExports === 'boolean') {
        module.syntheticNamedExports = sourceDescription.syntheticNamedExports;
      }
      return transform$1(this.graph, sourceDescription, module);
    })
      .then((source) => {
      module.setSource(source);
      this.modulesById.set(id, module);
      return this.fetchAllDependencies(module).then(() => {
        for (const name in module.exports) {
          if (name !== 'default') {
            module.exportsAll[name] = module.id;
          }
        }
        for (const source of module.exportAllSources) {
          const id = module.resolvedIds[source].id;
          const exportAllModule = this.modulesById.get(id);
          if (exportAllModule instanceof ExternalModule)
            continue;
          for (const name in exportAllModule.exportsAll) {
            if (name in module.exportsAll) {
              this.graph.warn(errNamespaceConflict(name, module, exportAllModule));
            }
            else {
              module.exportsAll[name] = exportAllModule.exportsAll[name];
            }
          }
        }
        return module;
      });
    });
  }
  fetchResolvedDependency(source, importer, resolvedId) {
    if (resolvedId.external) {
      if (!this.modulesById.has(resolvedId.id)) {
        this.modulesById.set(resolvedId.id, new ExternalModule(this.graph, resolvedId.id, resolvedId.moduleSideEffects));
      }
      const externalModule = this.modulesById.get(resolvedId.id);
      if (!(externalModule instanceof ExternalModule)) {
        return error(errInternalIdCannotBeExternal(source, importer));
      }
      return Promise.resolve(externalModule);
    }
    else {
      return this.fetchModule(resolvedId.id, importer, resolvedId.moduleSideEffects, resolvedId.syntheticNamedExports, false);
    }
  }
  handleResolveId(resolvedId, source, importer) {
    if (resolvedId === null) {
      if (isRelative(source)) {
        return error(errUnresolvedImport(source, importer));
      }
      this.graph.warn(errUnresolvedImportTreatedAsExternal(source, importer));
      return {
        external: true,
        id: source,
        moduleSideEffects: this.hasModuleSideEffects(source, true),
        syntheticNamedExports: false
      };
    }
    else {
      if (resolvedId.external && resolvedId.syntheticNamedExports) {
        this.graph.warn(errExternalSyntheticExports(source, importer));
      }
    }
    return resolvedId;
  }
  normalizeResolveIdResult(resolveIdResult, importer, source) {
    let id = '';
    let external = false;
    let moduleSideEffects = null;
    let syntheticNamedExports = false;
    if (resolveIdResult) {
      if (typeof resolveIdResult === 'object') {
        id = resolveIdResult.id;
        if (resolveIdResult.external) {
          external = true;
        }
        if (typeof resolveIdResult.moduleSideEffects === 'boolean') {
          moduleSideEffects = resolveIdResult.moduleSideEffects;
        }
        if (typeof resolveIdResult.syntheticNamedExports === 'boolean') {
          syntheticNamedExports = resolveIdResult.syntheticNamedExports;
        }
      }
      else {
        if (this.isExternal(resolveIdResult, importer, true)) {
          external = true;
        }
        id = external ? normalizeRelativeExternalId(importer, resolveIdResult) : resolveIdResult;
      }
    }
    else {
      id = normalizeRelativeExternalId(importer, source);
      if (resolveIdResult !== false && !this.isExternal(id, importer, true)) {
        return null;
      }
      external = true;
    }
    return {
      external,
      id,
      moduleSideEffects: typeof moduleSideEffects === 'boolean'
        ? moduleSideEffects
        : this.hasModuleSideEffects(id, external),
      syntheticNamedExports
    };
  }
  resolveDynamicImport(module, specifier, importer) {
    return __awaiter(this, void 0, void 0, function* () {
      // TODO we only should expose the acorn AST here
      const resolution = yield this.pluginDriver.hookFirst('resolveDynamicImport', [
        specifier,
        importer
      ]);
      if (typeof specifier !== 'string') {
        if (typeof resolution === 'string') {
          return resolution;
        }
        if (!resolution) {
          return null;
        }
        return Object.assign({ external: false, moduleSideEffects: true }, resolution);
      }
      if (resolution == null) {
        return (module.resolvedIds[specifier] =
          module.resolvedIds[specifier] ||
            this.handleResolveId(yield this.resolveId(specifier, module.id), specifier, module.id));
      }
      return this.handleResolveId(this.normalizeResolveIdResult(resolution, importer, specifier), specifier, importer);
    });
  }
}

var BuildPhase;
(function (BuildPhase) {
  BuildPhase[BuildPhase["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
  BuildPhase[BuildPhase["ANALYSE"] = 1] = "ANALYSE";
  BuildPhase[BuildPhase["GENERATE"] = 2] = "GENERATE";
})(BuildPhase || (BuildPhase = {}));

const CHAR_CODE_A = 97;
const CHAR_CODE_0 = 48;
function intToHex(num) {
  if (num < 10)
    return String.fromCharCode(CHAR_CODE_0 + num);
  else
    return String.fromCharCode(CHAR_CODE_A + (num - 10));
}
function Uint8ArrayToHexString(buffer) {
  let str = '';
  // hex conversion - 2 chars per 8 bit component
  for (let i = 0; i < buffer.length; i++) {
    const num = buffer[i];
    // big endian conversion, but whatever
    str += intToHex(num >> 4);
    str += intToHex(num & 0xf);
  }
  return str;
}
function randomUint8Array(len) {
  const buffer = new Uint8Array(len);
  for (let i = 0; i < buffer.length; i++)
    buffer[i] = Math.random() * (2 << 8);
  return buffer;
}
function Uint8ArrayXor(to, from) {
  for (let i = 0; i < to.length; i++)
    to[i] = to[i] ^ from[i];
  return to;
}

function assignChunkColouringHashes(entryModules, manualChunkModules) {
  const { dependentEntryPointsByModule, dynamicImportersByModule } = analyzeModuleGraph(entryModules);
  const dynamicDependentEntryPointsByDynamicEntry = getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicImportersByModule);
  const staticEntries = new Set(entryModules);
  function addColourToModuleDependencies(entry, colour, dynamicDependentEntryPoints) {
    const manualChunkAlias = entry.manualChunkAlias;
    const modulesToHandle = new Set([entry]);
    for (const module of modulesToHandle) {
      if (manualChunkAlias) {
        module.manualChunkAlias = manualChunkAlias;
        module.entryPointsHash = colour;
      }
      else if (dynamicDependentEntryPoints &&
        areEntryPointsContainedOrDynamicallyDependent(dynamicDependentEntryPoints, dependentEntryPointsByModule.get(module))) {
        continue;
      }
      else {
        Uint8ArrayXor(module.entryPointsHash, colour);
      }
      for (const dependency of module.dependencies) {
        if (!(dependency instanceof ExternalModule || dependency.manualChunkAlias)) {
          modulesToHandle.add(dependency);
        }
      }
    }
  }
  function areEntryPointsContainedOrDynamicallyDependent(entryPoints, superSet) {
    const entriesToCheck = new Set(entryPoints);
    for (const entry of entriesToCheck) {
      if (!superSet.has(entry)) {
        if (staticEntries.has(entry))
          return false;
        const dynamicDependentEntryPoints = dynamicDependentEntryPointsByDynamicEntry.get(entry);
        for (const dependentEntry of dynamicDependentEntryPoints) {
          entriesToCheck.add(dependentEntry);
        }
      }
    }
    return true;
  }
  if (manualChunkModules) {
    for (const chunkName of Object.keys(manualChunkModules)) {
      const entryHash = randomUint8Array(10);
      for (const entry of manualChunkModules[chunkName]) {
        addColourToModuleDependencies(entry, entryHash, null);
      }
    }
  }
  for (const entry of entryModules) {
    if (!entry.manualChunkAlias) {
      const entryHash = randomUint8Array(10);
      addColourToModuleDependencies(entry, entryHash, null);
    }
  }
  for (const entry of dynamicImportersByModule.keys()) {
    if (!entry.manualChunkAlias) {
      const entryHash = randomUint8Array(10);
      addColourToModuleDependencies(entry, entryHash, dynamicDependentEntryPointsByDynamicEntry.get(entry));
    }
  }
}
function analyzeModuleGraph(entryModules) {
  const dynamicImportersByModule = new Map();
  const dependentEntryPointsByModule = new Map();
  const entriesToHandle = new Set(entryModules);
  for (const currentEntry of entriesToHandle) {
    const modulesToHandle = new Set([currentEntry]);
    for (const module of modulesToHandle) {
      getDependentModules(dependentEntryPointsByModule, module).add(currentEntry);
      for (const dependency of module.dependencies) {
        if (!(dependency instanceof ExternalModule)) {
          modulesToHandle.add(dependency);
        }
      }
      for (const { resolution } of module.dynamicImports) {
        if (resolution instanceof Module$1 &&
          resolution.dynamicallyImportedBy.length > 0 &&
          !resolution.manualChunkAlias) {
          getDependentModules(dynamicImportersByModule, resolution).add(module);
          entriesToHandle.add(resolution);
        }
      }
    }
  }
  return { dependentEntryPointsByModule, dynamicImportersByModule };
}
function getDependentModules(moduleMap, module) {
  const dependentModules = moduleMap.get(module) || new Set();
  moduleMap.set(module, dependentModules);
  return dependentModules;
}
function getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicImportersByModule) {
  const dynamicDependentEntryPointsByDynamicEntry = new Map();
  for (const [dynamicEntry, importers] of dynamicImportersByModule.entries()) {
    const dynamicDependentEntryPoints = getDependentModules(dynamicDependentEntryPointsByDynamicEntry, dynamicEntry);
    for (const importer of importers) {
      for (const entryPoint of dependentEntryPointsByModule.get(importer)) {
        dynamicDependentEntryPoints.add(entryPoint);
      }
    }
  }
  return dynamicDependentEntryPointsByDynamicEntry;
}

const createHash$1$1 = () => createHash();

function generateAssetFileName(name, source, output) {
  const emittedName = name || 'asset';
  return makeUnique(renderNamePattern(output.assetFileNames, 'output.assetFileNames', {
    hash() {
      const hash = createHash$1$1();
      hash.update(emittedName);
      hash.update(':');
      hash.update(source);
      return hash.digest('hex').substr(0, 8);
    },
    ext: () => extname(emittedName).substr(1),
    extname: () => extname(emittedName),
    name: () => emittedName.substr(0, emittedName.length - extname(emittedName).length)
  }), output.bundle);
}
function reserveFileNameInBundle(fileName, bundle, graph) {
  if (fileName in bundle) {
    graph.warn(errFileNameConflict(fileName));
  }
  bundle[fileName] = FILE_PLACEHOLDER;
}
const FILE_PLACEHOLDER = {
  type: 'placeholder'
};
function hasValidType(emittedFile) {
  return (emittedFile &&
    (emittedFile.type === 'asset' ||
      emittedFile.type === 'chunk'));
}
function hasValidName(emittedFile) {
  const validatedName = emittedFile.fileName || emittedFile.name;
  return (!validatedName || (typeof validatedName === 'string' && isPlainPathFragment(validatedName)));
}
function getValidSource(source, emittedFile, fileReferenceId) {
  if (typeof source !== 'string' && !Buffer.isBuffer(source)) {
    const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;
    return error(errFailedValidation(`Could not set source for ${typeof assetName === 'string' ? `asset "${assetName}"` : 'unnamed asset'}, asset source needs to be a string of Buffer.`));
  }
  return source;
}
function getAssetFileName(file, referenceId) {
  if (typeof file.fileName !== 'string') {
    return error(errAssetNotFinalisedForFileName(file.name || referenceId));
  }
  return file.fileName;
}
function getChunkFileName(file) {
  const fileName = file.fileName || (file.module && file.module.facadeChunk.id);
  if (!fileName)
    return error(errChunkNotGeneratedForFileName(file.fileName || file.name));
  return fileName;
}
class FileEmitter {
  constructor(graph, baseFileEmitter) {
    this.output = null;
    this.assertAssetsFinalized = () => {
      for (const [referenceId, emittedFile] of this.filesByReferenceId.entries()) {
        if (emittedFile.type === 'asset' && typeof emittedFile.fileName !== 'string')
          return error(errNoAssetSourceSet(emittedFile.name || referenceId));
      }
    };
    this.emitFile = (emittedFile) => {
      if (!hasValidType(emittedFile)) {
        return error(errFailedValidation(`Emitted files must be of type "asset" or "chunk", received "${emittedFile &&
          emittedFile.type}".`));
      }
      if (!hasValidName(emittedFile)) {
        return error(errFailedValidation(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths and do not contain invalid characters, received "${emittedFile.fileName ||
          emittedFile.name}".`));
      }
      if (emittedFile.type === 'chunk') {
        return this.emitChunk(emittedFile);
      }
      else {
        return this.emitAsset(emittedFile);
      }
    };
    this.getFileName = (fileReferenceId) => {
      const emittedFile = this.filesByReferenceId.get(fileReferenceId);
      if (!emittedFile)
        return error(errFileReferenceIdNotFoundForFilename(fileReferenceId));
      if (emittedFile.type === 'chunk') {
        return getChunkFileName(emittedFile);
      }
      else {
        return getAssetFileName(emittedFile, fileReferenceId);
      }
    };
    this.setAssetSource = (referenceId, requestedSource) => {
      const consumedFile = this.filesByReferenceId.get(referenceId);
      if (!consumedFile)
        return error(errAssetReferenceIdNotFoundForSetSource(referenceId));
      if (consumedFile.type !== 'asset') {
        return error(errFailedValidation(`Asset sources can only be set for emitted assets but "${referenceId}" is an emitted chunk.`));
      }
      if (consumedFile.source !== undefined) {
        return error(errAssetSourceAlreadySet(consumedFile.name || referenceId));
      }
      const source = getValidSource(requestedSource, consumedFile, referenceId);
      if (this.output) {
        this.finalizeAsset(consumedFile, source, referenceId, this.output);
      }
      else {
        consumedFile.source = source;
      }
    };
    this.setOutputBundle = (outputBundle, assetFileNames) => {
      this.output = {
        assetFileNames,
        bundle: outputBundle
      };
      for (const emittedFile of this.filesByReferenceId.values()) {
        if (emittedFile.fileName) {
          reserveFileNameInBundle(emittedFile.fileName, this.output.bundle, this.graph);
        }
      }
      for (const [referenceId, consumedFile] of this.filesByReferenceId.entries()) {
        if (consumedFile.type === 'asset' && consumedFile.source !== undefined) {
          this.finalizeAsset(consumedFile, consumedFile.source, referenceId, this.output);
        }
      }
    };
    this.graph = graph;
    this.filesByReferenceId = baseFileEmitter
      ? new Map(baseFileEmitter.filesByReferenceId)
      : new Map();
  }
  assignReferenceId(file, idBase) {
    let referenceId;
    do {
      const hash = createHash$1$1();
      if (referenceId) {
        hash.update(referenceId);
      }
      else {
        hash.update(idBase);
      }
      referenceId = hash.digest('hex').substr(0, 8);
    } while (this.filesByReferenceId.has(referenceId));
    this.filesByReferenceId.set(referenceId, file);
    return referenceId;
  }
  emitAsset(emittedAsset) {
    const source = typeof emittedAsset.source !== 'undefined'
      ? getValidSource(emittedAsset.source, emittedAsset, null)
      : undefined;
    const consumedAsset = {
      fileName: emittedAsset.fileName,
      name: emittedAsset.name,
      source,
      type: 'asset'
    };
    const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || emittedAsset.type);
    if (this.output) {
      if (emittedAsset.fileName) {
        reserveFileNameInBundle(emittedAsset.fileName, this.output.bundle, this.graph);
      }
      if (source !== undefined) {
        this.finalizeAsset(consumedAsset, source, referenceId, this.output);
      }
    }
    return referenceId;
  }
  emitChunk(emittedChunk) {
    if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {
      return error(errInvalidRollupPhaseForChunkEmission());
    }
    if (typeof emittedChunk.id !== 'string') {
      return error(errFailedValidation(`Emitted chunks need to have a valid string id, received "${emittedChunk.id}"`));
    }
    const consumedChunk = {
      fileName: emittedChunk.fileName,
      module: null,
      name: emittedChunk.name || emittedChunk.id,
      type: 'chunk'
    };
    this.graph.moduleLoader
      .addEntryModules([
      {
        fileName: emittedChunk.fileName || null,
        id: emittedChunk.id,
        name: emittedChunk.name || null
      }
    ], false)
      .then(({ newEntryModules: [module] }) => {
      consumedChunk.module = module;
    })
      .catch(() => {
      // Avoid unhandled Promise rejection as the error will be thrown later
      // once module loading has finished
    });
    return this.assignReferenceId(consumedChunk, emittedChunk.id);
  }
  finalizeAsset(consumedFile, source, referenceId, output) {
    const fileName = consumedFile.fileName ||
      this.findExistingAssetFileNameWithSource(output.bundle, source) ||
      generateAssetFileName(consumedFile.name, source, output);
    // We must not modify the original assets to avoid interaction between outputs
    const assetWithFileName = Object.assign(Object.assign({}, consumedFile), { source, fileName });
    this.filesByReferenceId.set(referenceId, assetWithFileName);
    const graph = this.graph;
    output.bundle[fileName] = {
      fileName,
      get isAsset() {
        graph.warnDeprecation('Accessing "isAsset" on files in the bundle is deprecated, please use "type === \'asset\'" instead', false);
        return true;
      },
      source,
      type: 'asset'
    };
  }
  findExistingAssetFileNameWithSource(bundle, source) {
    for (const fileName of Object.keys(bundle)) {
      const outputFile = bundle[fileName];
      if (outputFile.type === 'asset' &&
        (Buffer.isBuffer(source) && Buffer.isBuffer(outputFile.source)
          ? source.equals(outputFile.source)
          : source === outputFile.source))
        return fileName;
    }
    return null;
  }
}

function getDeprecatedContextHandler(handler, handlerName, newHandlerName, pluginName, activeDeprecation, graph) {
  let deprecationWarningShown = false;
  return ((...args) => {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      graph.warnDeprecation({
        message: `The "this.${handlerName}" plugin context function used by plugin ${pluginName} is deprecated. The "this.${newHandlerName}" plugin context function should be used instead.`,
        plugin: pluginName
      }, activeDeprecation);
    }
    return handler(...args);
  });
}
function getPluginContexts(pluginCache, graph, fileEmitter, watcher) {
  const existingPluginNames = new Set();
  return (plugin, pidx) => {
    let cacheable = true;
    if (typeof plugin.cacheKey !== 'string') {
      if (plugin.name.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||
        plugin.name.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX) ||
        existingPluginNames.has(plugin.name)) {
        cacheable = false;
      }
      else {
        existingPluginNames.add(plugin.name);
      }
    }
    let cacheInstance;
    if (!pluginCache) {
      cacheInstance = NO_CACHE;
    }
    else if (cacheable) {
      const cacheKey = plugin.cacheKey || plugin.name;
      cacheInstance = createPluginCache(pluginCache[cacheKey] || (pluginCache[cacheKey] = Object.create(null)));
    }
    else {
      cacheInstance = getCacheForUncacheablePlugin(plugin.name);
    }
    const context = {
      addWatchFile(id) {
        if (graph.phase >= BuildPhase.GENERATE) {
          return this.error(errInvalidRollupPhaseForAddWatchFile());
        }
        graph.watchFiles[id] = true;
      },
      cache: cacheInstance,
      emitAsset: getDeprecatedContextHandler((name, source) => fileEmitter.emitFile({ type: 'asset', name, source }), 'emitAsset', 'emitFile', plugin.name, false, graph),
      emitChunk: getDeprecatedContextHandler((id, options) => fileEmitter.emitFile({ type: 'chunk', id, name: options && options.name }), 'emitChunk', 'emitFile', plugin.name, false, graph),
      emitFile: fileEmitter.emitFile,
      error(err) {
        return throwPluginError(err, plugin.name);
      },
      getAssetFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getAssetFileName', 'getFileName', plugin.name, false, graph),
      getChunkFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getChunkFileName', 'getFileName', plugin.name, false, graph),
      getFileName: fileEmitter.getFileName,
      getModuleInfo(moduleId) {
        const foundModule = graph.moduleById.get(moduleId);
        if (foundModule == null) {
          throw new Error(`Unable to find module ${moduleId}`);
        }
        return {
          hasModuleSideEffects: foundModule.moduleSideEffects,
          id: foundModule.id,
          importedIds: foundModule instanceof ExternalModule
            ? []
            : Array.from(foundModule.sources).map(id => foundModule.resolvedIds[id].id),
          isEntry: foundModule instanceof Module$1 && foundModule.isEntryPoint,
          isExternal: foundModule instanceof ExternalModule
        };
      },
      isExternal: getDeprecatedContextHandler((id, parentId, isResolved = false) => graph.moduleLoader.isExternal(id, parentId, isResolved), 'isExternal', 'resolve', plugin.name, false, graph),
      meta: {
        rollupVersion: version$2
      },
      get moduleIds() {
        return graph.moduleById.keys();
      },
      parse: graph.contextParse,
      resolve(source, importer, options) {
        return graph.moduleLoader.resolveId(source, importer, options && options.skipSelf ? pidx : null);
      },
      resolveId: getDeprecatedContextHandler((source, importer) => graph.moduleLoader
        .resolveId(source, importer)
        .then(resolveId => resolveId && resolveId.id), 'resolveId', 'resolve', plugin.name, false, graph),
      setAssetSource: fileEmitter.setAssetSource,
      warn(warning) {
        if (typeof warning === 'string')
          warning = { message: warning };
        if (warning.code)
          warning.pluginCode = warning.code;
        warning.code = 'PLUGIN_WARNING';
        warning.plugin = plugin.name;
        graph.warn(warning);
      },
      watcher: watcher
        ? (() => {
          let deprecationWarningShown = false;
          function deprecatedWatchListener(event, handler) {
            if (!deprecationWarningShown) {
              context.warn({
                code: 'PLUGIN_WATCHER_DEPRECATED',
                message: `this.watcher usage is deprecated in plugins. Use the watchChange plugin hook and this.addWatchFile() instead.`
              });
              deprecationWarningShown = true;
            }
            return watcher.on(event, handler);
          }
          return Object.assign(Object.assign({}, watcher), { addListener: deprecatedWatchListener, on: deprecatedWatchListener });
        })()
        : undefined
    };
    return context;
  };
}

class PluginDriver {
  constructor(graph, userPlugins, pluginCache, preserveSymlinks, watcher, basePluginDriver) {
    this.previousHooks = new Set(['options']);
    warnDeprecatedHooks(userPlugins, graph);
    this.graph = graph;
    this.pluginCache = pluginCache;
    this.preserveSymlinks = preserveSymlinks;
    this.watcher = watcher;
    this.fileEmitter = new FileEmitter(graph, basePluginDriver && basePluginDriver.fileEmitter);
    this.emitFile = this.fileEmitter.emitFile;
    this.getFileName = this.fileEmitter.getFileName;
    this.finaliseAssets = this.fileEmitter.assertAssetsFinalized;
    this.setOutputBundle = this.fileEmitter.setOutputBundle;
    this.plugins = userPlugins.concat(basePluginDriver ? basePluginDriver.plugins : [getRollupDefaultPlugin(preserveSymlinks)]);
    this.pluginContexts = this.plugins.map(getPluginContexts(pluginCache, graph, this.fileEmitter, watcher));
    if (basePluginDriver) {
      for (const plugin of userPlugins) {
        for (const hook of basePluginDriver.previousHooks) {
          if (hook in plugin) {
            graph.warn(errInputHookInOutputPlugin(plugin.name, hook));
          }
        }
      }
    }
  }
  createOutputPluginDriver(plugins) {
    return new PluginDriver(this.graph, plugins, this.pluginCache, this.preserveSymlinks, this.watcher, this);
  }
  // chains, first non-null result stops and returns
  hookFirst(hookName, args, replaceContext, skip) {
    let promise = Promise.resolve();
    for (let i = 0; i < this.plugins.length; i++) {
      if (skip === i)
        continue;
      promise = promise.then((result) => {
        if (result != null)
          return result;
        return this.runHook(hookName, args, i, false, replaceContext);
      });
    }
    return promise;
  }
  // chains synchronously, first non-null result stops and returns
  hookFirstSync(hookName, args, replaceContext) {
    for (let i = 0; i < this.plugins.length; i++) {
      const result = this.runHookSync(hookName, args, i, replaceContext);
      if (result != null)
        return result;
    }
    return null;
  }
  // parallel, ignores returns
  hookParallel(hookName, args, replaceContext) {
    const promises = [];
    for (let i = 0; i < this.plugins.length; i++) {
      const hookPromise = this.runHook(hookName, args, i, false, replaceContext);
      if (!hookPromise)
        continue;
      promises.push(hookPromise);
    }
    return Promise.all(promises).then(() => { });
  }
  // chains, reduces returns of type R, to type T, handling the reduced value as the first hook argument
  hookReduceArg0(hookName, [arg0, ...args], reduce, replaceContext) {
    let promise = Promise.resolve(arg0);
    for (let i = 0; i < this.plugins.length; i++) {
      promise = promise.then(arg0 => {
        const hookPromise = this.runHook(hookName, [arg0, ...args], i, false, replaceContext);
        if (!hookPromise)
          return arg0;
        return hookPromise.then((result) => reduce.call(this.pluginContexts[i], arg0, result, this.plugins[i]));
      });
    }
    return promise;
  }
  // chains synchronously, reduces returns of type R, to type T, handling the reduced value as the first hook argument
  hookReduceArg0Sync(hookName, [arg0, ...args], reduce, replaceContext) {
    for (let i = 0; i < this.plugins.length; i++) {
      const result = this.runHookSync(hookName, [arg0, ...args], i, replaceContext);
      arg0 = reduce.call(this.pluginContexts[i], arg0, result, this.plugins[i]);
    }
    return arg0;
  }
  // chains, reduces returns of type R, to type T, handling the reduced value separately. permits hooks as values.
  hookReduceValue(hookName, initialValue, args, reduce, replaceContext) {
    let promise = Promise.resolve(initialValue);
    for (let i = 0; i < this.plugins.length; i++) {
      promise = promise.then(value => {
        const hookPromise = this.runHook(hookName, args, i, true, replaceContext);
        if (!hookPromise)
          return value;
        return hookPromise.then((result) => reduce.call(this.pluginContexts[i], value, result, this.plugins[i]));
      });
    }
    return promise;
  }
  // chains, reduces returns of type R, to type T, handling the reduced value separately. permits hooks as values.
  hookReduceValueSync(hookName, initialValue, args, reduce, replaceContext) {
    let acc = initialValue;
    for (let i = 0; i < this.plugins.length; i++) {
      const result = this.runHookSync(hookName, args, i, replaceContext);
      acc = reduce.call(this.pluginContexts[i], acc, result, this.plugins[i]);
    }
    return acc;
  }
  // chains, ignores returns
  hookSeq(hookName, args, replaceContext) {
    return __awaiter(this, void 0, void 0, function* () {
      let promise = Promise.resolve();
      for (let i = 0; i < this.plugins.length; i++)
        promise = promise.then(() => this.runHook(hookName, args, i, false, replaceContext));
      return promise;
    });
  }
  // chains, ignores returns
  hookSeqSync(hookName, args, replaceContext) {
    for (let i = 0; i < this.plugins.length; i++)
      this.runHookSync(hookName, args, i, replaceContext);
  }
  runHook(hookName, args, pluginIndex, permitValues, hookContext) {
    this.previousHooks.add(hookName);
    const plugin = this.plugins[pluginIndex];
    const hook = plugin[hookName];
    if (!hook)
      return undefined;
    let context = this.pluginContexts[pluginIndex];
    if (hookContext) {
      context = hookContext(context, plugin);
    }
    return Promise.resolve()
      .then(() => {
      // permit values allows values to be returned instead of a functional hook
      if (typeof hook !== 'function') {
        if (permitValues)
          return hook;
        return error({
          code: 'INVALID_PLUGIN_HOOK',
          message: `Error running plugin hook ${hookName} for ${plugin.name}, expected a function hook.`
        });
      }
      return hook.apply(context, args);
    })
      .catch(err => throwPluginError(err, plugin.name, { hook: hookName }));
  }
  runHookSync(hookName, args, pluginIndex, hookContext) {
    this.previousHooks.add(hookName);
    const plugin = this.plugins[pluginIndex];
    let context = this.pluginContexts[pluginIndex];
    const hook = plugin[hookName];
    if (!hook)
      return undefined;
    if (hookContext) {
      context = hookContext(context, plugin);
    }
    try {
      // permit values allows values to be returned instead of a functional hook
      if (typeof hook !== 'function') {
        return error({
          code: 'INVALID_PLUGIN_HOOK',
          message: `Error running plugin hook ${hookName} for ${plugin.name}, expected a function hook.`
        });
      }
      return hook.apply(context, args);
    }
    catch (err) {
      return throwPluginError(err, plugin.name, { hook: hookName });
    }
  }
}

function makeOnwarn() {
  const warned = Object.create(null);
  return (warning) => {
    const str = warning.toString();
    if (str in warned)
      return;
    console.error(str);
    warned[str] = true;
  };
}
function normalizeEntryModules(entryModules) {
  if (typeof entryModules === 'string') {
    return [{ fileName: null, name: null, id: entryModules }];
  }
  if (Array.isArray(entryModules)) {
    return entryModules.map(id => ({ fileName: null, name: null, id }));
  }
  return Object.keys(entryModules).map(name => ({
    fileName: null,
    id: entryModules[name],
    name
  }));
}
class Graph {
  constructor(options, watcher) {
    this.moduleById = new Map();
    this.needsTreeshakingPass = false;
    this.phase = BuildPhase.LOAD_AND_PARSE;
    this.watchFiles = Object.create(null);
    this.externalModules = [];
    this.modules = [];
    this.onwarn = options.onwarn || makeOnwarn();
    this.deoptimizationTracker = new PathTracker();
    this.cachedModules = new Map();
    if (options.cache) {
      if (options.cache.modules)
        for (const module of options.cache.modules)
          this.cachedModules.set(module.id, module);
    }
    if (options.cache !== false) {
      this.pluginCache = (options.cache && options.cache.plugins) || Object.create(null);
      // increment access counter
      for (const name in this.pluginCache) {
        const cache = this.pluginCache[name];
        for (const key of Object.keys(cache))
          cache[key][0]++;
      }
    }
    this.preserveModules = options.preserveModules;
    this.strictDeprecations = options.strictDeprecations;
    this.cacheExpiry = options.experimentalCacheExpiry;
    if (options.treeshake !== false) {
      this.treeshakingOptions =
        options.treeshake && options.treeshake !== true
          ? {
            annotations: options.treeshake.annotations !== false,
            moduleSideEffects: options.treeshake.moduleSideEffects,
            propertyReadSideEffects: options.treeshake.propertyReadSideEffects !== false,
            pureExternalModules: options.treeshake.pureExternalModules,
            tryCatchDeoptimization: options.treeshake.tryCatchDeoptimization !== false,
            unknownGlobalSideEffects: options.treeshake.unknownGlobalSideEffects !== false
          }
          : {
            annotations: true,
            moduleSideEffects: true,
            propertyReadSideEffects: true,
            tryCatchDeoptimization: true,
            unknownGlobalSideEffects: true
          };
      if (typeof this.treeshakingOptions.pureExternalModules !== 'undefined') {
        this.warnDeprecation(`The "treeshake.pureExternalModules" option is deprecated. The "treeshake.moduleSideEffects" option should be used instead. "treeshake.pureExternalModules: true" is equivalent to "treeshake.moduleSideEffects: 'no-external'"`, false);
      }
    }
    this.contextParse = (code, options = {}) => this.acornParser.parse(code, Object.assign(Object.assign(Object.assign({}, defaultAcornOptions), options), this.acornOptions));
    this.pluginDriver = new PluginDriver(this, options.plugins, this.pluginCache, options.preserveSymlinks === true, watcher);
    if (watcher) {
      const handleChange = (id) => this.pluginDriver.hookSeqSync('watchChange', [id]);
      watcher.on('change', handleChange);
      watcher.once('restart', () => {
        watcher.removeListener('change', handleChange);
      });
    }
    this.shimMissingExports = options.shimMissingExports;
    this.scope = new GlobalScope();
    this.context = String(options.context);
    const optionsModuleContext = options.moduleContext;
    if (typeof optionsModuleContext === 'function') {
      this.getModuleContext = id => optionsModuleContext(id) || this.context;
    }
    else if (typeof optionsModuleContext === 'object') {
      const moduleContext = new Map();
      for (const key in optionsModuleContext) {
        moduleContext.set(resolve(key), optionsModuleContext[key]);
      }
      this.getModuleContext = id => moduleContext.get(id) || this.context;
    }
    else {
      this.getModuleContext = () => this.context;
    }
    this.acornOptions = options.acorn ? Object.assign({}, options.acorn) : {};
    const acornPluginsToInject = [];
    acornPluginsToInject.push(acornImportMeta, acornExportNsFrom);
    this.acornOptions.allowAwaitOutsideFunction = true;
    const acornInjectPlugins = options.acornInjectPlugins;
    acornPluginsToInject.push(...(Array.isArray(acornInjectPlugins)
      ? acornInjectPlugins
      : acornInjectPlugins
        ? [acornInjectPlugins]
        : []));
    this.acornParser = Parser.extend(...acornPluginsToInject);
    this.moduleLoader = new ModuleLoader(this, this.moduleById, this.pluginDriver, options.external, (typeof options.manualChunks === 'function' && options.manualChunks), (this.treeshakingOptions ? this.treeshakingOptions.moduleSideEffects : null), (this.treeshakingOptions ? this.treeshakingOptions.pureExternalModules : false));
  }
  build(entryModules, manualChunks, inlineDynamicImports) {
    // Phase 1 – discovery. We load the entry module and find which
    // modules it imports, and import those, until we have all
    // of the entry module's dependencies
    timeStart('parse modules', 2);
    return Promise.all([
      this.moduleLoader.addEntryModules(normalizeEntryModules(entryModules), true),
      (manualChunks &&
        typeof manualChunks === 'object' &&
        this.moduleLoader.addManualChunks(manualChunks))
    ]).then(([{ entryModules, manualChunkModulesByAlias }]) => {
      if (entryModules.length === 0) {
        throw new Error('You must supply options.input to rollup');
      }
      for (const module of this.moduleById.values()) {
        if (module instanceof Module$1) {
          this.modules.push(module);
        }
        else {
          this.externalModules.push(module);
        }
      }
      timeEnd('parse modules', 2);
      this.phase = BuildPhase.ANALYSE;
      // Phase 2 - linking. We populate the module dependency links and
      // determine the topological execution order for the bundle
      timeStart('analyse dependency graph', 2);
      this.link(entryModules);
      timeEnd('analyse dependency graph', 2);
      // Phase 3 – marking. We include all statements that should be included
      timeStart('mark included statements', 2);
      if (inlineDynamicImports) {
        if (entryModules.length > 1) {
          throw new Error('Internal Error: can only inline dynamic imports for single-file builds.');
        }
      }
      for (const module of entryModules) {
        module.includeAllExports();
      }
      this.includeMarked(this.modules);
      // check for unused external imports
      for (const externalModule of this.externalModules)
        externalModule.warnUnusedImports();
      timeEnd('mark included statements', 2);
      // Phase 4 – we construct the chunks, working out the optimal chunking using
      // entry point graph colouring, before generating the import and export facades
      timeStart('generate chunks', 2);
      if (!this.preserveModules && !inlineDynamicImports) {
        assignChunkColouringHashes(entryModules, manualChunkModulesByAlias);
      }
      // TODO: there is one special edge case unhandled here and that is that any module
      //     exposed as an unresolvable export * (to a graph external export *,
      //     either as a namespace import reexported or top-level export *)
      //     should be made to be its own entry point module before chunking
      let chunks = [];
      if (this.preserveModules) {
        for (const module of this.modules) {
          const chunk = new Chunk$1$1(this, [module]);
          if (module.isEntryPoint || !chunk.isEmpty) {
            chunk.entryModules = [module];
          }
          chunks.push(chunk);
        }
      }
      else {
        const chunkModules = {};
        for (const module of this.modules) {
          const entryPointsHashStr = Uint8ArrayToHexString(module.entryPointsHash);
          const curChunk = chunkModules[entryPointsHashStr];
          if (curChunk) {
            curChunk.push(module);
          }
          else {
            chunkModules[entryPointsHashStr] = [module];
          }
        }
        for (const entryHashSum in chunkModules) {
          const chunkModulesOrdered = chunkModules[entryHashSum];
          sortByExecutionOrder(chunkModulesOrdered);
          const chunk = new Chunk$1$1(this, chunkModulesOrdered);
          chunks.push(chunk);
        }
      }
      for (const chunk of chunks) {
        chunk.link();
      }
      chunks = chunks.filter(isChunkRendered);
      const facades = [];
      for (const chunk of chunks) {
        facades.push(...chunk.generateFacades());
      }
      timeEnd('generate chunks', 2);
      this.phase = BuildPhase.GENERATE;
      return chunks.concat(facades);
    });
  }
  getCache() {
    // handle plugin cache eviction
    for (const name in this.pluginCache) {
      const cache = this.pluginCache[name];
      let allDeleted = true;
      for (const key of Object.keys(cache)) {
        if (cache[key][0] >= this.cacheExpiry)
          delete cache[key];
        else
          allDeleted = false;
      }
      if (allDeleted)
        delete this.pluginCache[name];
    }
    return {
      modules: this.modules.map(module => module.toJSON()),
      plugins: this.pluginCache
    };
  }
  includeMarked(modules) {
    if (this.treeshakingOptions) {
      let treeshakingPass = 1;
      do {
        timeStart(`treeshaking pass ${treeshakingPass}`, 3);
        this.needsTreeshakingPass = false;
        for (const module of modules) {
          if (module.isExecuted)
            module.include();
        }
        timeEnd(`treeshaking pass ${treeshakingPass++}`, 3);
      } while (this.needsTreeshakingPass);
    }
    else {
      // Necessary to properly replace namespace imports
      for (const module of modules)
        module.includeAllInBundle();
    }
  }
  warn(warning) {
    warning.toString = () => {
      let str = '';
      if (warning.plugin)
        str += `(${warning.plugin} plugin) `;
      if (warning.loc)
        str += `${relativeId(warning.loc.file)} (${warning.loc.line}:${warning.loc.column}) `;
      str += warning.message;
      return str;
    };
    this.onwarn(warning);
  }
  warnDeprecation(deprecation, activeDeprecation) {
    if (activeDeprecation || this.strictDeprecations) {
      const warning = errDeprecation(deprecation);
      if (this.strictDeprecations) {
        return error(warning);
      }
      this.warn(warning);
    }
  }
  link(entryModules) {
    for (const module of this.modules) {
      module.linkDependencies();
    }
    const { orderedModules, cyclePaths } = analyseModuleExecution(entryModules);
    for (const cyclePath of cyclePaths) {
      this.warn({
        code: 'CIRCULAR_DEPENDENCY',
        cycle: cyclePath,
        importer: cyclePath[0],
        message: `Circular dependency: ${cyclePath.join(' -> ')}`
      });
    }
    this.modules = orderedModules;
    for (const module of this.modules) {
      module.bindReferences();
    }
    this.warnForMissingExports();
  }
  warnForMissingExports() {
    for (const module of this.modules) {
      for (const importName of Object.keys(module.importDescriptions)) {
        const importDescription = module.importDescriptions[importName];
        if (importDescription.name !== '*' &&
          !importDescription.module.getVariableForExportName(importDescription.name)) {
          module.warn({
            code: 'NON_EXISTENT_EXPORT',
            message: `Non-existent export '${importDescription.name}' is imported from ${relativeId(importDescription.module.id)}`,
            name: importDescription.name,
            source: importDescription.module.id
          }, importDescription.start);
        }
      }
    }
  }
}

function evalIfFn(strOrFn) {
  switch (typeof strOrFn) {
    case 'function':
      return strOrFn();
    case 'string':
      return strOrFn;
    default:
      return '';
  }
}
const concatSep = (out, next) => (next ? `${out}\n${next}` : out);
const concatDblSep = (out, next) => (next ? `${out}\n\n${next}` : out);
function createAddons(options, outputPluginDriver) {
  return Promise.all([
    outputPluginDriver.hookReduceValue('banner', evalIfFn(options.banner), [], concatSep),
    outputPluginDriver.hookReduceValue('footer', evalIfFn(options.footer), [], concatSep),
    outputPluginDriver.hookReduceValue('intro', evalIfFn(options.intro), [], concatDblSep),
    outputPluginDriver.hookReduceValue('outro', evalIfFn(options.outro), [], concatDblSep)
  ])
    .then(([banner, footer, intro, outro]) => {
    if (intro)
      intro += '\n\n';
    if (outro)
      outro = `\n\n${outro}`;
    if (banner.length)
      banner += '\n';
    if (footer.length)
      footer = '\n' + footer;
    return { intro, outro, banner, footer };
  })
    .catch((err) => {
    return error({
      code: 'ADDON_ERROR',
      message: `Could not retrieve ${err.hook}. Check configuration of plugin ${err.plugin}.
\tError Message: ${err.message}`
    });
  });
}

function assignChunkIds(chunks, inputOptions, outputOptions, inputBase, addons, bundle, outputPluginDriver) {
  const entryChunks = [];
  const otherChunks = [];
  for (const chunk of chunks) {
    (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint
      ? entryChunks
      : otherChunks).push(chunk);
  }
  // make sure entry chunk names take precedence with regard to deconflicting
  const chunksForNaming = entryChunks.concat(otherChunks);
  for (const chunk of chunksForNaming) {
    if (outputOptions.file) {
      chunk.id = basename(outputOptions.file);
    }
    else if (inputOptions.preserveModules) {
      chunk.id = chunk.generateIdPreserveModules(inputBase, outputOptions, bundle);
    }
    else {
      chunk.id = chunk.generateId(addons, outputOptions, bundle, true, outputPluginDriver);
    }
    bundle[chunk.id] = FILE_PLACEHOLDER;
  }
}

// ported from https://github.com/substack/node-commondir
function commondir(files) {
  if (files.length === 0)
    return '/';
  if (files.length === 1)
    return dirname(files[0]);
  const commonSegments = files.slice(1).reduce((commonSegments, file) => {
    const pathSegements = file.split(/\/+|\\+/);
    let i;
    for (i = 0; commonSegments[i] === pathSegements[i] &&
      i < Math.min(commonSegments.length, pathSegements.length); i++)
      ;
    return commonSegments.slice(0, i);
  }, files[0].split(/\/+|\\+/));
  // Windows correctly handles paths with forward-slashes
  return commonSegments.length > 1 ? commonSegments.join('/') : '/';
}

function getExportMode(chunk, { exports: exportMode, name, format }, facadeModuleId) {
  const exportKeys = chunk.getExportNames();
  if (exportMode === 'default') {
    if (exportKeys.length !== 1 || exportKeys[0] !== 'default') {
      return error(errIncompatibleExportOptionValue('default', exportKeys, facadeModuleId));
    }
  }
  else if (exportMode === 'none' && exportKeys.length) {
    return error(errIncompatibleExportOptionValue('none', exportKeys, facadeModuleId));
  }
  if (!exportMode || exportMode === 'auto') {
    if (exportKeys.length === 0) {
      exportMode = 'none';
    }
    else if (exportKeys.length === 1 && exportKeys[0] === 'default') {
      exportMode = 'default';
    }
    else {
      if (format !== 'es' && exportKeys.indexOf('default') !== -1) {
        chunk.graph.warn(errMixedExport(facadeModuleId, name));
      }
      exportMode = 'named';
    }
  }
  return exportMode;
}

const createGetOption = (config, command) => (name, defaultValue) => command[name] !== undefined
  ? command[name]
  : config[name] !== undefined
    ? config[name]
    : defaultValue;
const normalizeObjectOptionValue = (optionValue) => {
  if (!optionValue) {
    return optionValue;
  }
  if (typeof optionValue !== 'object') {
    return {};
  }
  return optionValue;
};
const getObjectOption = (config, command, name) => {
  const commandOption = normalizeObjectOptionValue(command[name]);
  const configOption = normalizeObjectOptionValue(config[name]);
  if (commandOption !== undefined) {
    return commandOption && configOption ? Object.assign(Object.assign({}, configOption), commandOption) : commandOption;
  }
  return configOption;
};
function ensureArray$1(items) {
  if (Array.isArray(items)) {
    return items.filter(Boolean);
  }
  if (items) {
    return [items];
  }
  return [];
}
const defaultOnWarn = warning => {
  if (typeof warning === 'string') {
    console.warn(warning);
  }
  else {
    console.warn(warning.message);
  }
};
const getOnWarn = (config, defaultOnWarnHandler = defaultOnWarn) => config.onwarn
  ? warning => config.onwarn(warning, defaultOnWarnHandler)
  : defaultOnWarnHandler;
const getExternal = (config, command) => {
  const configExternal = config.external;
  return typeof configExternal === 'function'
    ? (id, ...rest) => configExternal(id, ...rest) || command.external.indexOf(id) !== -1
    : (typeof config.external === 'string'
      ? [configExternal]
      : Array.isArray(configExternal)
        ? configExternal
        : []).concat(command.external);
};
const commandAliases = {
  c: 'config',
  d: 'dir',
  e: 'external',
  f: 'format',
  g: 'globals',
  h: 'help',
  i: 'input',
  m: 'sourcemap',
  n: 'name',
  o: 'file',
  p: 'plugin',
  v: 'version',
  w: 'watch'
};
function mergeOptions({ config = {}, command: rawCommandOptions = {}, defaultOnWarnHandler }) {
  const command = getCommandOptions(rawCommandOptions);
  const inputOptions = getInputOptions(config, command, defaultOnWarnHandler);
  if (command.output) {
    Object.assign(command, command.output);
  }
  const output = config.output;
  const normalizedOutputOptions = Array.isArray(output) ? output : output ? [output] : [];
  if (normalizedOutputOptions.length === 0)
    normalizedOutputOptions.push({});
  const outputOptions = normalizedOutputOptions.map(singleOutputOptions => getOutputOptions(singleOutputOptions, command));
  const unknownOptionErrors = [];
  const validInputOptions = Object.keys(inputOptions);
  addUnknownOptionErrors(unknownOptionErrors, Object.keys(config), validInputOptions, 'input option', /^output$/);
  const validOutputOptions = Object.keys(outputOptions[0]);
  addUnknownOptionErrors(unknownOptionErrors, outputOptions.reduce((allKeys, options) => allKeys.concat(Object.keys(options)), []), validOutputOptions, 'output option');
  const validCliOutputOptions = validOutputOptions.filter(option => option !== 'sourcemapPathTransform');
  addUnknownOptionErrors(unknownOptionErrors, Object.keys(command), validInputOptions.concat(validCliOutputOptions, Object.keys(commandAliases), 'config', 'environment', 'plugin', 'silent', 'stdin'), 'CLI flag', /^_|output|(config.*)$/);
  return {
    inputOptions,
    optionError: unknownOptionErrors.length > 0 ? unknownOptionErrors.join('\n') : null,
    outputOptions
  };
}
function addUnknownOptionErrors(errors, options, validOptions, optionType, ignoredKeys = /$./) {
  const validOptionSet = new Set(validOptions);
  const unknownOptions = options.filter(key => !validOptionSet.has(key) && !ignoredKeys.test(key));
  if (unknownOptions.length > 0)
    errors.push(`Unknown ${optionType}: ${unknownOptions.join(', ')}. Allowed options: ${Array.from(validOptionSet)
      .sort()
      .join(', ')}`);
}
function getCommandOptions(rawCommandOptions) {
  const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'
    ? rawCommandOptions.external.split(',')
    : [];
  return Object.assign(Object.assign({}, rawCommandOptions), { external, globals: typeof rawCommandOptions.globals === 'string'
      ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {
        const [id, variableName] = globalDefinition.split(':');
        globals[id] = variableName;
        if (external.indexOf(id) === -1) {
          external.push(id);
        }
        return globals;
      }, Object.create(null))
      : undefined });
}
function getInputOptions(config, command = { external: [], globals: undefined }, defaultOnWarnHandler) {
  const getOption = createGetOption(config, command);
  const inputOptions = {
    acorn: config.acorn,
    acornInjectPlugins: config.acornInjectPlugins,
    cache: getOption('cache'),
    chunkGroupingSize: getOption('chunkGroupingSize', 5000),
    context: getOption('context'),
    experimentalCacheExpiry: getOption('experimentalCacheExpiry', 10),
    experimentalOptimizeChunks: getOption('experimentalOptimizeChunks'),
    external: getExternal(config, command),
    inlineDynamicImports: getOption('inlineDynamicImports', false),
    input: getOption('input', []),
    manualChunks: getOption('manualChunks'),
    moduleContext: config.moduleContext,
    onwarn: getOnWarn(config, defaultOnWarnHandler),
    perf: getOption('perf', false),
    plugins: ensureArray$1(config.plugins),
    preserveModules: getOption('preserveModules'),
    preserveSymlinks: getOption('preserveSymlinks'),
    shimMissingExports: getOption('shimMissingExports'),
    strictDeprecations: getOption('strictDeprecations', false),
    treeshake: getObjectOption(config, command, 'treeshake'),
    watch: config.watch
  };
  // support rollup({ cache: prevBuildObject })
  if (inputOptions.cache && inputOptions.cache.cache)
    inputOptions.cache = inputOptions.cache.cache;
  return inputOptions;
}
function getOutputOptions(config, command = {}) {
  const getOption = createGetOption(config, command);
  let format = getOption('format');
  // Handle format aliases
  switch (format) {
    case undefined:
    case 'esm':
    case 'module':
      format = 'es';
      break;
    case 'commonjs':
      format = 'cjs';
  }
  return {
    amd: Object.assign(Object.assign({}, config.amd), command.amd),
    assetFileNames: getOption('assetFileNames'),
    banner: getOption('banner'),
    chunkFileNames: getOption('chunkFileNames'),
    compact: getOption('compact', false),
    dir: getOption('dir'),
    dynamicImportFunction: getOption('dynamicImportFunction'),
    entryFileNames: getOption('entryFileNames'),
    esModule: getOption('esModule', true),
    exports: getOption('exports'),
    extend: getOption('extend'),
    externalLiveBindings: getOption('externalLiveBindings', true),
    file: getOption('file'),
    footer: getOption('footer'),
    format,
    freeze: getOption('freeze', true),
    globals: getOption('globals'),
    hoistTransitiveImports: getOption('hoistTransitiveImports', true),
    indent: getOption('indent', true),
    interop: getOption('interop', true),
    intro: getOption('intro'),
    name: getOption('name'),
    namespaceToStringTag: getOption('namespaceToStringTag', false),
    noConflict: getOption('noConflict'),
    outro: getOption('outro'),
    paths: getOption('paths'),
    plugins: ensureArray$1(config.plugins),
    preferConst: getOption('preferConst'),
    sourcemap: getOption('sourcemap'),
    sourcemapExcludeSources: getOption('sourcemapExcludeSources'),
    sourcemapFile: getOption('sourcemapFile'),
    sourcemapPathTransform: getOption('sourcemapPathTransform'),
    strict: getOption('strict', true)
  };
}

function checkOutputOptions(options) {
  if (options.format === 'es6') {
    return error(errDeprecation({
      message: 'The "es6" output format is deprecated – use "esm" instead',
      url: `https://rollupjs.org/guide/en/#output-format`
    }));
  }
  if (['amd', 'cjs', 'system', 'es', 'iife', 'umd'].indexOf(options.format) < 0) {
    return error({
      message: `You must specify "output.format", which can be one of "amd", "cjs", "system", "esm", "iife" or "umd".`,
      url: `https://rollupjs.org/guide/en/#output-format`
    });
  }
  if (options.exports && !['default', 'named', 'none', 'auto'].includes(options.exports)) {
    return error(errInvalidExportOptionValue(options.exports));
  }
}
function getAbsoluteEntryModulePaths(chunks) {
  const absoluteEntryModulePaths = [];
  for (const chunk of chunks) {
    for (const entryModule of chunk.entryModules) {
      if (isAbsolute$1(entryModule.id)) {
        absoluteEntryModulePaths.push(entryModule.id);
      }
    }
  }
  return absoluteEntryModulePaths;
}
const throwAsyncGenerateError = {
  get() {
    throw new Error(`bundle.generate(...) now returns a Promise instead of a { code, map } object`);
  }
};
function applyOptionHook(inputOptions, plugin) {
  if (plugin.options)
    return plugin.options.call({ meta: { rollupVersion: version$2 } }, inputOptions) || inputOptions;
  return inputOptions;
}
function normalizePlugins(rawPlugins, anonymousPrefix) {
  const plugins = ensureArray$1(rawPlugins);
  for (let pluginIndex = 0; pluginIndex < plugins.length; pluginIndex++) {
    const plugin = plugins[pluginIndex];
    if (!plugin.name) {
      plugin.name = `${anonymousPrefix}${pluginIndex + 1}`;
    }
  }
  return plugins;
}
function getInputOptions$1(rawInputOptions) {
  if (!rawInputOptions) {
    throw new Error('You must supply an options object to rollup');
  }
  let { inputOptions, optionError } = mergeOptions({
    config: rawInputOptions
  });
  if (optionError)
    inputOptions.onwarn({ message: optionError, code: 'UNKNOWN_OPTION' });
  inputOptions = inputOptions.plugins.reduce(applyOptionHook, inputOptions);
  inputOptions.plugins = normalizePlugins(inputOptions.plugins, ANONYMOUS_PLUGIN_PREFIX);
  if (inputOptions.inlineDynamicImports) {
    if (inputOptions.preserveModules)
      return error({
        code: 'INVALID_OPTION',
        message: `"preserveModules" does not support the "inlineDynamicImports" option.`
      });
    if (inputOptions.manualChunks)
      return error({
        code: 'INVALID_OPTION',
        message: '"manualChunks" option is not supported for "inlineDynamicImports".'
      });
    if (inputOptions.experimentalOptimizeChunks)
      return error({
        code: 'INVALID_OPTION',
        message: '"experimentalOptimizeChunks" option is not supported for "inlineDynamicImports".'
      });
    if ((inputOptions.input instanceof Array && inputOptions.input.length > 1) ||
      (typeof inputOptions.input === 'object' && Object.keys(inputOptions.input).length > 1))
      return error({
        code: 'INVALID_OPTION',
        message: 'Multiple inputs are not supported for "inlineDynamicImports".'
      });
  }
  else if (inputOptions.preserveModules) {
    if (inputOptions.manualChunks)
      return error({
        code: 'INVALID_OPTION',
        message: '"preserveModules" does not support the "manualChunks" option.'
      });
    if (inputOptions.experimentalOptimizeChunks)
      return error({
        code: 'INVALID_OPTION',
        message: '"preserveModules" does not support the "experimentalOptimizeChunks" option.'
      });
  }
  return inputOptions;
}
let curWatcher;
function assignChunksToBundle(chunks, outputBundle) {
  for (let i = 0; i < chunks.length; i++) {
    const chunk = chunks[i];
    const facadeModule = chunk.facadeModule;
    outputBundle[chunk.id] = {
      code: undefined,
      dynamicImports: chunk.getDynamicImportIds(),
      exports: chunk.getExportNames(),
      facadeModuleId: facadeModule && facadeModule.id,
      fileName: chunk.id,
      imports: chunk.getImportIds(),
      isDynamicEntry: facadeModule !== null && facadeModule.dynamicallyImportedBy.length > 0,
      isEntry: facadeModule !== null && facadeModule.isEntryPoint,
      map: undefined,
      modules: chunk.renderedModules,
      get name() {
        return chunk.getChunkName();
      },
      type: 'chunk'
    };
  }
  return outputBundle;
}
function rollup(rawInputOptions) {
  return __awaiter(this, void 0, void 0, function* () {
    const inputOptions = getInputOptions$1(rawInputOptions);
    initialiseTimers(inputOptions);
    const graph = new Graph(inputOptions, curWatcher);
    curWatcher = undefined;
    // remove the cache option from the memory after graph creation (cache is not used anymore)
    const useCache = rawInputOptions.cache !== false;
    delete inputOptions.cache;
    delete rawInputOptions.cache;
    timeStart('BUILD', 1);
    let chunks;
    try {
      yield graph.pluginDriver.hookParallel('buildStart', [inputOptions]);
      chunks = yield graph.build(inputOptions.input, inputOptions.manualChunks, inputOptions.inlineDynamicImports);
    }
    catch (err) {
      const watchFiles = Object.keys(graph.watchFiles);
      if (watchFiles.length > 0) {
        err.watchFiles = watchFiles;
      }
      yield graph.pluginDriver.hookParallel('buildEnd', [err]);
      throw err;
    }
    yield graph.pluginDriver.hookParallel('buildEnd', []);
    timeEnd('BUILD', 1);
    // ensure we only do one optimization pass per build
    let optimized = false;
    function getOutputOptionsAndPluginDriver(rawOutputOptions) {
      if (!rawOutputOptions) {
        throw new Error('You must supply an options object');
      }
      const outputPluginDriver = graph.pluginDriver.createOutputPluginDriver(normalizePlugins(rawOutputOptions.plugins, ANONYMOUS_OUTPUT_PLUGIN_PREFIX));
      return {
        outputOptions: normalizeOutputOptions(inputOptions, rawOutputOptions, chunks.length > 1, outputPluginDriver),
        outputPluginDriver
      };
    }
    function generate(outputOptions, isWrite, outputPluginDriver) {
      return __awaiter(this, void 0, void 0, function* () {
        timeStart('GENERATE', 1);
        const assetFileNames = outputOptions.assetFileNames || 'assets/[name]-[hash][extname]';
        const inputBase = commondir(getAbsoluteEntryModulePaths(chunks));
        const outputBundleWithPlaceholders = Object.create(null);
        outputPluginDriver.setOutputBundle(outputBundleWithPlaceholders, assetFileNames);
        let outputBundle;
        try {
          yield outputPluginDriver.hookParallel('renderStart', [outputOptions, inputOptions]);
          const addons = yield createAddons(outputOptions, outputPluginDriver);
          for (const chunk of chunks) {
            if (!inputOptions.preserveModules)
              chunk.generateInternalExports(outputOptions);
            if (inputOptions.preserveModules || (chunk.facadeModule && chunk.facadeModule.isEntryPoint))
              chunk.exportMode = getExportMode(chunk, outputOptions, chunk.facadeModule.id);
          }
          for (const chunk of chunks) {
            chunk.preRender(outputOptions, inputBase);
          }
          if (!optimized && inputOptions.experimentalOptimizeChunks) {
            optimizeChunks(chunks, outputOptions, inputOptions.chunkGroupingSize, inputBase);
            optimized = true;
          }
          assignChunkIds(chunks, inputOptions, outputOptions, inputBase, addons, outputBundleWithPlaceholders, outputPluginDriver);
          outputBundle = assignChunksToBundle(chunks, outputBundleWithPlaceholders);
          yield Promise.all(chunks.map(chunk => {
            const outputChunk = outputBundleWithPlaceholders[chunk.id];
            return chunk
              .render(outputOptions, addons, outputChunk, outputPluginDriver)
              .then(rendered => {
              outputChunk.code = rendered.code;
              outputChunk.map = rendered.map;
              return outputPluginDriver.hookParallel('ongenerate', [
                Object.assign({ bundle: outputChunk }, outputOptions),
                outputChunk
              ]);
            });
          }));
        }
        catch (error) {
          yield outputPluginDriver.hookParallel('renderError', [error]);
          throw error;
        }
        yield outputPluginDriver.hookSeq('generateBundle', [outputOptions, outputBundle, isWrite]);
        for (const key of Object.keys(outputBundle)) {
          const file = outputBundle[key];
          if (!file.type) {
            graph.warnDeprecation('A plugin is directly adding properties to the bundle object in the "generateBundle" hook. This is deprecated and will be removed in a future Rollup version, please use "this.emitFile" instead.', false);
            file.type = 'asset';
          }
        }
        outputPluginDriver.finaliseAssets();
        timeEnd('GENERATE', 1);
        return outputBundle;
      });
    }
    const cache = useCache ? graph.getCache() : undefined;
    const result = {
      cache: cache,
      generate: ((rawOutputOptions) => {
        const { outputOptions, outputPluginDriver } = getOutputOptionsAndPluginDriver(rawOutputOptions);
        const promise = generate(outputOptions, false, outputPluginDriver).then(result => createOutput(result));
        Object.defineProperty(promise, 'code', throwAsyncGenerateError);
        Object.defineProperty(promise, 'map', throwAsyncGenerateError);
        return promise;
      }),
      watchFiles: Object.keys(graph.watchFiles),
      write: ((rawOutputOptions) => {
        const { outputOptions, outputPluginDriver } = getOutputOptionsAndPluginDriver(rawOutputOptions);
        if (!outputOptions.dir && !outputOptions.file) {
          return error({
            code: 'MISSING_OPTION',
            message: 'You must specify "output.file" or "output.dir" for the build.'
          });
        }
        return generate(outputOptions, true, outputPluginDriver).then((bundle) => __awaiter(this, void 0, void 0, function* () {
          let chunkCount = 0;
          for (const fileName of Object.keys(bundle)) {
            const file = bundle[fileName];
            if (file.type === 'asset')
              continue;
            chunkCount++;
            if (chunkCount > 1)
              break;
          }
          if (chunkCount > 1) {
            if (outputOptions.sourcemapFile)
              return error({
                code: 'INVALID_OPTION',
                message: '"output.sourcemapFile" is only supported for single-file builds.'
              });
            if (typeof outputOptions.file === 'string')
              return error({
                code: 'INVALID_OPTION',
                message: 'When building multiple chunks, the "output.dir" option must be used, not "output.file".' +
                  (typeof inputOptions.input !== 'string' ||
                    inputOptions.inlineDynamicImports === true
                    ? ''
                    : ' To inline dynamic imports, set the "inlineDynamicImports" option.')
              });
          }
          yield Promise.all(Object.keys(bundle).map(chunkId => writeOutputFile(result, bundle[chunkId], outputOptions, outputPluginDriver)));
          yield outputPluginDriver.hookParallel('writeBundle', [bundle]);
          return createOutput(bundle);
        }));
      })
    };
    if (inputOptions.perf === true)
      result.getTimings = getTimings;
    return result;
  });
}
var SortingFileType;
(function (SortingFileType) {
  SortingFileType[SortingFileType["ENTRY_CHUNK"] = 0] = "ENTRY_CHUNK";
  SortingFileType[SortingFileType["SECONDARY_CHUNK"] = 1] = "SECONDARY_CHUNK";
  SortingFileType[SortingFileType["ASSET"] = 2] = "ASSET";
})(SortingFileType || (SortingFileType = {}));
function getSortingFileType(file) {
  if (file.type === 'asset') {
    return SortingFileType.ASSET;
  }
  if (file.isEntry) {
    return SortingFileType.ENTRY_CHUNK;
  }
  return SortingFileType.SECONDARY_CHUNK;
}
function createOutput(outputBundle) {
  return {
    output: Object.keys(outputBundle)
      .map(fileName => outputBundle[fileName])
      .filter(outputFile => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => {
      const fileTypeA = getSortingFileType(outputFileA);
      const fileTypeB = getSortingFileType(outputFileB);
      if (fileTypeA === fileTypeB)
        return 0;
      return fileTypeA < fileTypeB ? -1 : 1;
    })
  };
}
function writeOutputFile(build, outputFile, outputOptions, outputPluginDriver) {
  const fileName = resolve(outputOptions.dir || dirname(outputOptions.file), outputFile.fileName);
  let writeSourceMapPromise;
  let source;
  if (outputFile.type === 'asset') {
    source = outputFile.source;
  }
  else {
    source = outputFile.code;
    if (outputOptions.sourcemap && outputFile.map) {
      let url;
      if (outputOptions.sourcemap === 'inline') {
        url = outputFile.map.toUrl();
      }
      else {
        url = `${basename(outputFile.fileName)}.map`;
        writeSourceMapPromise = writeFile$1(`${fileName}.map`, outputFile.map.toString());
      }
      if (outputOptions.sourcemap !== 'hidden') {
        source += `//# ${SOURCEMAPPING_URL}=${url}\n`;
      }
    }
  }
  return writeFile$1(fileName, source)
    .then(() => writeSourceMapPromise)
    .then(() => outputFile.type === 'chunk' &&
    outputPluginDriver.hookSeq('onwrite', [
      Object.assign({ bundle: build }, outputOptions),
      outputFile
    ]))
    .then(() => { });
}
function normalizeOutputOptions(inputOptions, rawOutputOptions, hasMultipleChunks, outputPluginDriver) {
  const mergedOptions = mergeOptions({
    config: {
      output: Object.assign(Object.assign(Object.assign({}, rawOutputOptions), rawOutputOptions.output), inputOptions.output)
    }
  });
  if (mergedOptions.optionError)
    throw new Error(mergedOptions.optionError);
  // now outputOptions is an array, but rollup.rollup API doesn't support arrays
  const mergedOutputOptions = mergedOptions.outputOptions[0];
  const outputOptionsReducer = (outputOptions, result) => result || outputOptions;
  const outputOptions = outputPluginDriver.hookReduceArg0Sync('outputOptions', [mergedOutputOptions], outputOptionsReducer, pluginContext => {
    const emitError = () => pluginContext.error(errCannotEmitFromOptionsHook());
    return Object.assign(Object.assign({}, pluginContext), { emitFile: emitError, setAssetSource: emitError });
  });
  checkOutputOptions(outputOptions);
  if (typeof outputOptions.file === 'string') {
    if (typeof outputOptions.dir === 'string')
      return error({
        code: 'INVALID_OPTION',
        message: 'You must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks.'
      });
    if (inputOptions.preserveModules) {
      return error({
        code: 'INVALID_OPTION',
        message: 'You must set "output.dir" instead of "output.file" when using the "preserveModules" option.'
      });
    }
    if (typeof inputOptions.input === 'object' && !Array.isArray(inputOptions.input))
      return error({
        code: 'INVALID_OPTION',
        message: 'You must set "output.dir" instead of "output.file" when providing named inputs.'
      });
  }
  if (hasMultipleChunks) {
    if (outputOptions.format === 'umd' || outputOptions.format === 'iife')
      return error({
        code: 'INVALID_OPTION',
        message: 'UMD and IIFE output formats are not supported for code-splitting builds.'
      });
    if (typeof outputOptions.file === 'string')
      return error({
        code: 'INVALID_OPTION',
        message: 'You must set "output.dir" instead of "output.file" when generating multiple chunks.'
      });
  }
  return outputOptions;
}

var utils$1$1 = createCommonjsModule$2(function (module, exports) {
  exports.isInteger = num => {
    if (typeof num === 'number') {
      return Number.isInteger(num);
    }
    if (typeof num === 'string' && num.trim() !== '') {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  /**
   * Find a node of the given type
   */
  exports.find = (node, type) => node.nodes.find(node => node.type === type);
  /**
   * Find a node of the given type
   */
  exports.exceedsLimit = (min, max, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports.isInteger(min) || !exports.isInteger(max))
      return false;
    return ((Number(max) - Number(min)) / Number(step)) >= limit;
  };
  /**
   * Escape the given node with '\\' before node.value
   */
  exports.escapeNode = (block, n = 0, type) => {
    let node = block.nodes[n];
    if (!node)
      return;
    if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
      if (node.escaped !== true) {
        node.value = '\\' + node.value;
        node.escaped = true;
      }
    }
  };
  /**
   * Returns true if the given brace node should be enclosed in literal braces
   */
  exports.encloseBrace = node => {
    if (node.type !== 'brace')
      return false;
    if ((node.commas >> 0 + node.ranges >> 0) === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  /**
   * Returns true if a brace node is invalid.
   */
  exports.isInvalidBrace = block => {
    if (block.type !== 'brace')
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if ((block.commas >> 0 + block.ranges >> 0) === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  /**
   * Returns true if a node is an open or close node
   */
  exports.isOpenOrClose = node => {
    if (node.type === 'open' || node.type === 'close') {
      return true;
    }
    return node.open === true || node.close === true;
  };
  /**
   * Reduce an array of text nodes.
   */
  exports.reduce = nodes => nodes.reduce((acc, node) => {
    if (node.type === 'text')
      acc.push(node.value);
    if (node.type === 'range')
      node.type = 'text';
    return acc;
  }, []);
  /**
   * Flatten an array
   */
  exports.flatten = (...args) => {
    const result = [];
    const flat = arr => {
      for (let i = 0; i < arr.length; i++) {
        let ele = arr[i];
        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
      }
      return result;
    };
    flat(args);
    return result;
  };
});

const WIN_SLASH$1 = '\\\\/';
const WIN_NO_SLASH$1 = `[^${WIN_SLASH$1}]`;
/**
 * Posix glob regex
 */
const DOT_LITERAL$1 = '\\.';
const PLUS_LITERAL$1 = '\\+';
const QMARK_LITERAL$1 = '\\?';
const SLASH_LITERAL$1 = '\\/';
const ONE_CHAR$1 = '(?=.)';
const QMARK$1 = '[^/]';
const END_ANCHOR$1 = `(?:${SLASH_LITERAL$1}|$)`;
const START_ANCHOR$1 = `(?:^|${SLASH_LITERAL$1})`;
const DOTS_SLASH$1 = `${DOT_LITERAL$1}{1,2}${END_ANCHOR$1}`;
const NO_DOT$1 = `(?!${DOT_LITERAL$1})`;
const NO_DOTS$1 = `(?!${START_ANCHOR$1}${DOTS_SLASH$1})`;
const NO_DOT_SLASH$1 = `(?!${DOT_LITERAL$1}{0,1}${END_ANCHOR$1})`;
const NO_DOTS_SLASH$1 = `(?!${DOTS_SLASH$1})`;
const QMARK_NO_DOT$1 = `[^.${SLASH_LITERAL$1}]`;
const STAR$1 = `${QMARK$1}*?`;
const POSIX_CHARS$1 = {
  DOT_LITERAL: DOT_LITERAL$1,
  PLUS_LITERAL: PLUS_LITERAL$1,
  QMARK_LITERAL: QMARK_LITERAL$1,
  SLASH_LITERAL: SLASH_LITERAL$1,
  ONE_CHAR: ONE_CHAR$1,
  QMARK: QMARK$1,
  END_ANCHOR: END_ANCHOR$1,
  DOTS_SLASH: DOTS_SLASH$1,
  NO_DOT: NO_DOT$1,
  NO_DOTS: NO_DOTS$1,
  NO_DOT_SLASH: NO_DOT_SLASH$1,
  NO_DOTS_SLASH: NO_DOTS_SLASH$1,
  QMARK_NO_DOT: QMARK_NO_DOT$1,
  STAR: STAR$1,
  START_ANCHOR: START_ANCHOR$1
};
/**
 * Windows glob regex
 */
const WINDOWS_CHARS$1 = Object.assign(Object.assign({}, POSIX_CHARS$1), { SLASH_LITERAL: `[${WIN_SLASH$1}]`, QMARK: WIN_NO_SLASH$1, STAR: `${WIN_NO_SLASH$1}*?`, DOTS_SLASH: `${DOT_LITERAL$1}{1,2}(?:[${WIN_SLASH$1}]|$)`, NO_DOT: `(?!${DOT_LITERAL$1})`, NO_DOTS: `(?!(?:^|[${WIN_SLASH$1}])${DOT_LITERAL$1}{1,2}(?:[${WIN_SLASH$1}]|$))`, NO_DOT_SLASH: `(?!${DOT_LITERAL$1}{0,1}(?:[${WIN_SLASH$1}]|$))`, NO_DOTS_SLASH: `(?!${DOT_LITERAL$1}{1,2}(?:[${WIN_SLASH$1}]|$))`, QMARK_NO_DOT: `[^.${WIN_SLASH$1}]`, START_ANCHOR: `(?:^|[${WIN_SLASH$1}])`, END_ANCHOR: `(?:[${WIN_SLASH$1}]|$)` });
/**
 * POSIX Bracket Regex
 */
const POSIX_REGEX_SOURCE$2 = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};
var constants$1$2 = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$2,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHAR: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },
  // Digits
  CHAR_0: 48,
  CHAR_9: 57,
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,
  CHAR_LOWERCASE_A: 97,
  CHAR_UPPERCASE_Z: 90,
  CHAR_LOWERCASE_Z: 122,
  CHAR_LEFT_PARENTHESES: 40,
  CHAR_RIGHT_PARENTHESES: 41,
  CHAR_ASTERISK: 42,
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,
  CHAR_AT: 64,
  CHAR_BACKWARD_SLASH: 92,
  CHAR_CARRIAGE_RETURN: 13,
  CHAR_CIRCUMFLEX_ACCENT: 94,
  CHAR_COLON: 58,
  CHAR_COMMA: 44,
  CHAR_DOT: 46,
  CHAR_DOUBLE_QUOTE: 34,
  CHAR_EQUAL: 61,
  CHAR_EXCLAMATION_MARK: 33,
  CHAR_FORM_FEED: 12,
  CHAR_FORWARD_SLASH: 47,
  CHAR_GRAVE_ACCENT: 96,
  CHAR_HASH: 35,
  CHAR_HYPHEN_MINUS: 45,
  CHAR_LEFT_ANGLE_BRACKET: 60,
  CHAR_LEFT_CURLY_BRACE: 123,
  CHAR_LEFT_SQUARE_BRACKET: 91,
  CHAR_LINE_FEED: 10,
  CHAR_NO_BREAK_SPACE: 160,
  CHAR_PERCENT: 37,
  CHAR_PLUS: 43,
  CHAR_QUESTION_MARK: 63,
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  CHAR_RIGHT_CURLY_BRACE: 125,
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  CHAR_SEMICOLON: 59,
  CHAR_SINGLE_QUOTE: 39,
  CHAR_SPACE: 32,
  CHAR_TAB: 9,
  CHAR_UNDERSCORE: 95,
  CHAR_VERTICAL_LINE: 124,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  SEP: path.sep,
  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },
  /**
   * Create GLOB_CHARS
   */
  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS$1 : POSIX_CHARS$1;
  }
};

var utils$2$1 = createCommonjsModule$2(function (module, exports) {
  const win32 = process.platform === 'win32';
  const { REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL, REGEX_REMOVE_BACKSLASH } = constants$1$2;
  exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
  exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
  exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
  exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
  exports.toPosixSlashes = str => str.replace(/\\/g, '/');
  exports.removeBackslashes = str => {
    return str.replace(REGEX_REMOVE_BACKSLASH, match => {
      return match === '\\' ? '' : match;
    });
  };
  exports.supportsLookbehinds = () => {
    let segs = process.version.slice(1).split('.');
    if (segs.length === 3 && +segs[0] >= 9 || (+segs[0] === 8 && +segs[1] >= 10)) {
      return true;
    }
    return false;
  };
  exports.isWindows = options => {
    if (options && typeof options.windows === 'boolean') {
      return options.windows;
    }
    return win32 === true || path.sep === '\\';
  };
  exports.escapeLast = (input, char, lastIdx) => {
    let idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === '\\')
      return exports.escapeLast(input, char, idx - 1);
    return input.slice(0, idx) + '\\' + input.slice(idx);
  };
});

var modules = {};
var getModule$1 = function (dir) {
  var rootPath = dir ? path.resolve(dir) : process.cwd();
  var rootName = path.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new Module(rootName);
    root.filename = rootName;
    root.paths = Module._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};
var requireRelative = function (requested, relativeTo) {
  var root = getModule$1(relativeTo);
  return root.require(requested);
};
requireRelative.resolve = function (requested, relativeTo) {
  var root = getModule$1(relativeTo);
  return Module._resolveFilename(requested, root);
};
var requireRelative_1 = requireRelative;

let chokidar;
try {
  chokidar = requireRelative_1('chokidar', process.cwd());
}
catch (err) {
  chokidar = null;
}

// MODULE: compiler/bundle/dev-module.js
const devNodeModuleResolveId = async (config, inMemoryFs, resolvedId, importee) => {
  if (!shouldCheckDevModule(resolvedId, importee)) {
    return resolvedId;
  }
  const resolvedPath = resolvedId.id;
  const pkgPath = getPackageJsonPath(resolvedPath, importee);
  if (!pkgPath) {
    return resolvedId;
  }
  const pkgJsonStr = await inMemoryFs.readFile(pkgPath);
  if (!pkgJsonStr) {
    return resolvedId;
  }
  let pkgJsonData;
  try {
    pkgJsonData = JSON.parse(pkgJsonStr);
  }
  catch (e) { }
  if (!pkgJsonData || !pkgJsonData.version) {
    return resolvedId;
  }
  resolvedId.id = serializeDevNodeModuleUrl(config, pkgJsonData.name, pkgJsonData.version, resolvedPath);
  resolvedId.external = true;
  return resolvedId;
};
const getPackageJsonPath = (resolvedPath, importee) => {
  let currentPath = resolvedPath;
  for (let i = 0; i < 10; i++) {
    currentPath = dirname(currentPath);
    const aBasename = basename(currentPath);
    const upDir = dirname(currentPath);
    const bBasename = basename(upDir);
    if (aBasename === importee && bBasename === 'node_modules') {
      return join(currentPath, 'package.json');
    }
  }
  return null;
};
const compilerRequest = async (config, compilerCtx, data) => {
  const results = {
    nodeModuleId: null,
    nodeModuleVersion: null,
    nodeResolvedPath: null,
    cachePath: null,
    cacheHit: false,
    content: '',
    status: 404,
  };
  try {
    const parsedUrl = parseDevModuleUrl(config, data.path);
    Object.assign(results, parsedUrl);
    if (parsedUrl.nodeModuleId) {
      if (!parsedUrl.nodeModuleVersion) {
        results.content = `/* invalid module version */`;
        results.status = 400;
        return results;
      }
      if (!parsedUrl.nodeResolvedPath) {
        results.content = `/* invalid resolved path */`;
        results.status = 400;
        return results;
      }
      const useCache = await useDevModuleCache(config, parsedUrl.nodeResolvedPath);
      let cachePath = null;
      if (useCache) {
        cachePath = getDevModuleCachePath(config, parsedUrl);
        const cachedContent = await config.sys.readFile(cachePath);
        if (typeof cachedContent === 'string') {
          results.content = cachedContent;
          results.cachePath = cachePath;
          results.cacheHit = true;
          results.status = 200;
          return results;
        }
      }
      await bundleDevModule(config, compilerCtx, parsedUrl, results);
      if (results.status === 200 && useCache) {
        results.cachePath = cachePath;
        writeCachedFile(config, results);
      }
    }
    else {
      results.content = `/* invalid dev module */`;
      results.status = 400;
      return results;
    }
  }
  catch (e) {
    if (e) {
      if (e.stack) {
        results.content = `/*\n${e.stack}\n*/`;
      }
      else {
        results.content = `/*\n${e}\n*/`;
      }
    }
    results.status = 500;
  }
  return results;
};
const bundleDevModule = async (config, compilerCtx, parsedUrl, results) => {
  const buildCtx = new BuildContext(config, compilerCtx);
  try {
    const inputOpts = getRollupOptions(config, compilerCtx, buildCtx, {
      id: parsedUrl.nodeModuleId,
      platform: 'client',
      inputs: {
        index: parsedUrl.nodeResolvedPath,
      },
    });
    const rollupBuild = await rollup(inputOpts);
    const outputOpts = {
      format: 'es',
    };
    if (parsedUrl.nodeModuleId) {
      const commentPath = relative(config.rootDir, parsedUrl.nodeResolvedPath);
      outputOpts.intro = `/**\n * Dev Node Module: ${parsedUrl.nodeModuleId}, v${parsedUrl.nodeModuleVersion}\n * Entry: ${commentPath}\n * DEVELOPMENT PURPOSES ONLY!!\n */`;
      inputOpts.input = parsedUrl.nodeResolvedPath;
    }
    const r = await rollupBuild.generate(outputOpts);
    if (buildCtx.hasError) {
      results.status = 500;
      results.content = `console.error(${JSON.stringify(buildCtx.diagnostics)})`;
    }
    else if (r && r.output && r.output.length > 0) {
      results.content = r.output[0].code;
      results.status = 200;
    }
  }
  catch (e) {
    results.status = 500;
    results.content = `console.error(${JSON.stringify((e.stack || e) + '')})`;
  }
};
const useDevModuleCache = async (config, p) => {
  if (config.enableCache) {
    for (let i = 0; i < 10; i++) {
      const n = basename(p);
      if (n === 'node_modules') {
        return true;
      }
      const isSymbolicLink = await config.sys.isSymbolicLink(p);
      if (isSymbolicLink) {
        return false;
      }
      p = dirname(p);
    }
  }
  return false;
};
const writeCachedFile = async (config, results) => {
  try {
    await config.sys.mkdir(config.cacheDir);
    config.sys.writeFile(results.cachePath, results.content);
  }
  catch (e) {
    console.error(e);
  }
};
const serializeDevNodeModuleUrl = (config, moduleId, moduleVersion, resolvedPath) => {
  resolvedPath = relative(config.rootDir, resolvedPath);
  let id = `/${DEV_MODULE_DIR}/`;
  id += encodeURIComponent(moduleId) + '@';
  id += encodeURIComponent(moduleVersion) + '.js';
  id += '?p=' + encodeURIComponent(resolvedPath);
  return id;
};
const parseDevModuleUrl = (config, u) => {
  const parsedUrl = {
    nodeModuleId: null,
    nodeModuleVersion: null,
    nodeResolvedPath: null,
  };
  if (u && u.includes(DEV_MODULE_DIR) && u.endsWith('.js')) {
    const url = new URL(u, 'https://stenciljs.com');
    let reqPath = basename(url.pathname);
    reqPath = reqPath.substring(0, reqPath.length - 3);
    let splt = reqPath.split('@');
    if (splt.length === 2) {
      parsedUrl.nodeModuleId = decodeURIComponent(splt[0]);
      parsedUrl.nodeModuleVersion = decodeURIComponent(splt[1]);
      parsedUrl.nodeResolvedPath = url.searchParams.get('p');
      if (parsedUrl.nodeResolvedPath) {
        parsedUrl.nodeResolvedPath = decodeURIComponent(parsedUrl.nodeResolvedPath);
        parsedUrl.nodeResolvedPath = join(config.rootDir, parsedUrl.nodeResolvedPath);
      }
    }
  }
  return parsedUrl;
};
const getDevModuleCachePath = (config, parsedUrl) => {
  return join(config.cacheDir, `dev_module_${parsedUrl.nodeModuleId}_${parsedUrl.nodeModuleVersion}_${DEV_MODULE_CACHE_BUSTER}.log`);
};
const DEV_MODULE_CACHE_BUSTER = 0;
const DEV_MODULE_DIR = `~dev-module`;
const shouldCheckDevModule = (resolvedId, importee) => resolvedId &&
  importee &&
  resolvedId.id &&
  resolvedId.id.includes('node_modules') &&
  (resolvedId.id.endsWith('.js') || resolvedId.id.endsWith('.mjs')) &&
  !resolvedId.external &&
  !importee.startsWith('.') &&
  !importee.startsWith('/');

// MODULE: compiler/bundle/ext-transforms-plugin.js
const extTransformsPlugin = (config, compilerCtx, buildCtx, bundleOpts) => {
  return {
    name: 'extTransformsPlugin',
    async transform(_, id) {
      if (/\0/.test(id)) {
        return null;
      }
      const { data } = parseImportPath(id);
      if (data != null) {
        const filePath = normalizeFsPath(id);
        const code = await compilerCtx.fs.readFile(filePath);
        const cmp = buildCtx.components.find(c => c.tagName === data.tag);
        const moduleFile = cmp && compilerCtx.moduleMap.get(cmp.sourceFilePath);
        const pluginTransforms = await runPluginTransformsEsmImports(config, compilerCtx, buildCtx, code, filePath);
        const commentOriginalSelector = bundleOpts.platform === 'hydrate' && data.encapsulation === 'shadow';
        if (moduleFile) {
          const collectionDirs = config.outputTargets.filter(isOutputTargetDistCollection);
          const relPath = relative(config.srcDir, pluginTransforms.id);
          await Promise.all(collectionDirs.map(async (outputTarget) => {
            const collectionPath = join(outputTarget.collectionDir, relPath);
            await compilerCtx.fs.writeFile(collectionPath, pluginTransforms.code);
          }));
        }
        const cssTransformResults = await compilerCtx.worker.transformCssToEsm({
          file: pluginTransforms.id,
          input: pluginTransforms.code,
          tag: data.tag,
          encapsulation: data.encapsulation,
          mode: data.mode,
          commentOriginalSelector,
          sourceMap: config.sourceMap,
          minify: config.minifyCss,
          autoprefixer: config.autoprefixCss,
          docs: config.buildDocs,
        });
        // Set style docs
        if (cmp) {
          cmp.styleDocs = cssTransformResults.styleDocs;
        }
        // Track dependencies
        pluginTransforms.dependencies.forEach(dep => {
          this.addWatchFile(dep);
        });
        buildCtx.diagnostics.push(...pluginTransforms.diagnostics);
        buildCtx.diagnostics.push(...cssTransformResults.diagnostics);
        const didError = hasError(cssTransformResults.diagnostics) || hasError(pluginTransforms.diagnostics);
        if (didError) {
          this.error('Plugin CSS transform error');
        }
        const hasUpdatedStyle = buildCtx.stylesUpdated.some(s => {
          return s.styleTag === data.tag && s.styleMode === data.mode && s.styleText === cssTransformResults.styleText;
        });
        if (!hasUpdatedStyle) {
          buildCtx.stylesUpdated.push({
            styleTag: data.tag,
            styleMode: data.mode,
            styleText: cssTransformResults.styleText,
          });
        }
        return {
          code: cssTransformResults.output,
          map: cssTransformResults.map,
          moduleSideEffects: false,
        };
      }
      return null;
    },
  };
};

// MODULE: compiler/bundle/file-load-plugin.js
const fileLoadPlugin = (fs) => {
  return {
    name: 'fileLoadPlugin',
    load(id) {
      const fsFilePath = normalizeFsPath(id);
      return fs.readFile(fsFilePath);
    },
  };
};

// MODULE: compiler/bundle/image-plugin.js
const svgMimeTypes = {
  '.svg': 'image/svg+xml',
};
const imagePlugin = (config, buildCtx) => {
  return {
    name: 'image',
    async transform(code, id) {
      if (/\0/.test(id)) {
        return null;
      }
      const mime = svgMimeTypes[extname(id)];
      if (!mime) {
        return null;
      }
      try {
        const varName = createJsVarName(basename(id));
        const base64 = config.sys.encodeToBase64(code);
        if (config.devMode && base64.length > SVG_MAX_IMAGE_SIZE) {
          const warn = buildWarn(buildCtx.diagnostics);
          warn.messageText = 'Importing big images will bloat your bundle, please use assets instead.';
          warn.absFilePath = normalizePath(id);
        }
        return `const ${varName} = 'data:${mime};base64,${base64}';export default ${varName};`;
      }
      catch (e) {
        catchError(buildCtx.diagnostics, e);
      }
      return null;
    },
  };
};
const SVG_MAX_IMAGE_SIZE = 4 * 1024; // 4KiB

// MODULE: compiler/output-targets/dist-lazy/lazy-component-plugin.js
const lazyComponentPlugin = (buildCtx) => {
  const entrys = new Map();
  const plugin = {
    name: 'lazyComponentPlugin',
    resolveId(importee) {
      const entryModule = buildCtx.entryModules.find(entryModule => entryModule.entryKey === importee);
      if (entryModule) {
        entrys.set(importee, entryModule);
        return importee;
      }
      return null;
    },
    load(id) {
      const entryModule = entrys.get(id);
      if (entryModule) {
        return entryModule.cmps.map(createComponentExport).join('\n');
      }
      return null;
    },
  };
  return plugin;
};
const createComponentExport = (cmp) => {
  const originalClassName = cmp.componentClassName;
  const underscoredClassName = cmp.tagName.replace(/-/g, '_');
  const filePath = normalizePath(cmp.sourceFilePath);
  return `export { ${originalClassName} as ${underscoredClassName} } from '${filePath}';`;
};

// MODULE: compiler/bundle/loader-plugin.js
const loaderPlugin = (entries = {}) => {
  return {
    name: 'stencilLoaderPlugin',
    resolveId(id) {
      if (id in entries) {
        return {
          id,
        };
      }
      return null;
    },
    load(id) {
      if (id in entries) {
        return entries[id];
      }
      return null;
    },
  };
};

// MODULE: compiler/bundle/plugin-helper.js
const pluginHelper = (config, builtCtx) => {
  return {
    name: 'pluginHelper',
    resolveId(importee, importer) {
      if (/\0/.test(importee)) {
        // ignore IDs with null character, these belong to other plugins
        return null;
      }
      if (importee.endsWith('/')) {
        importee = importee.slice(0, -1);
      }
      if (builtIns.has(importee)) {
        let fromMsg = '';
        if (importer) {
          fromMsg = ` from ${relative(config.rootDir, importer)}`;
        }
        const diagnostic = buildError(builtCtx.diagnostics);
        diagnostic.header = `Node Polyfills Required`;
        diagnostic.messageText = `For the import "${importee}" to be bundled${fromMsg}, ensure the "rollup-plugin-node-polyfills" plugin is installed and added to the stencil config plugins. Please see the bundling docs for more information.
    Further information: https://stenciljs.com/docs/module-bundling`;
      }
      return null;
    },
  };
};
const builtIns = new Set([
  'child_process',
  'cluster',
  'dgram',
  'dns',
  'module',
  'net',
  'readline',
  'repl',
  'tls',
  'assert',
  'console',
  'constants',
  'domain',
  'events',
  'path',
  'punycode',
  'querystring',
  '_stream_duplex',
  '_stream_passthrough',
  '_stream_readable',
  '_stream_writable',
  '_stream_transform',
  'string_decoder',
  'sys',
  'tty',
  'crypto',
  'fs',
  'Buffer',
  'buffer',
  'global',
  'http',
  'https',
  'os',
  'process',
  'stream',
  'timers',
  'url',
  'util',
  'vm',
  'zlib',
]);

// MODULE: compiler/bundle/typescript-plugin.js
const typescriptPlugin = (compilerCtx, bundleOpts) => {
  const tsPrinter = ts.createPrinter();
  return {
    name: `${bundleOpts.id}TypescriptPlugin`,
    load(id) {
      if (isAbsolute(id)) {
        const fsFilePath = normalizeFsPath(id);
        const mod = getModule(compilerCtx, fsFilePath);
        if (mod) {
          return mod.staticSourceFileText;
        }
      }
      return null;
    },
    transform(_, id) {
      if (isAbsolute(id)) {
        const fsFilePath = normalizeFsPath(id);
        const mod = getModule(compilerCtx, fsFilePath);
        if (mod && mod.cmps.length > 0) {
          const transformed = ts.transform(mod.staticSourceFile, bundleOpts.customTransformers).transformed[0];
          return tsPrinter.printFile(transformed);
        }
      }
      return null;
    },
  };
};
const resolveIdWithTypeScript = (config, compilerCtx) => {
  return {
    name: `resolveIdWithTypeScript`,
    async resolveId(importee, importer) {
      if (/\0/.test(importee) || !isString(importer)) {
        return null;
      }
      const tsResolved = tsResolveModuleName(config, compilerCtx, importee, importer);
      if (tsResolved && tsResolved.resolvedModule) {
        // this is probably a .d.ts file for whatever reason in how TS resolves this
        // use this resolved file as the "importer"
        const tsResolvedPath = tsResolved.resolvedModule.resolvedFileName;
        if (isString(tsResolvedPath) && !tsResolvedPath.endsWith('.d.ts')) {
          return tsResolvedPath;
        }
      }
      return null;
    },
  };
};

// MODULE: compiler/bundle/text-plugin.js
const textPlugin = () => {
  return {
    name: 'textPlugin',
    transform(code, id) {
      if (/\0/.test(id)) {
        return null;
      }
      if (KNOWN_TXT_EXTS.has(extname(id))) {
        return `export default ${JSON.stringify(code)};`;
      }
      return null;
    },
  };
};
const KNOWN_TXT_EXTS = new Set(['.txt', '.frag', '.vert']);

// MODULE: compiler/bundle/user-index-plugin.js
const userIndexPlugin = (config, compilerCtx) => {
  return {
    name: 'userIndexPlugin',
    async resolveId(importee) {
      if (importee === USER_INDEX_ENTRY_ID) {
        const usersIndexJsPath = join(config.srcDir, 'index.ts');
        const hasUserIndex = await compilerCtx.fs.access(usersIndexJsPath);
        if (hasUserIndex) {
          return usersIndexJsPath;
        }
        return importee;
      }
      return null;
    },
    async load(id) {
      if (id === USER_INDEX_ENTRY_ID) {
        return `//! Autogenerated index`;
      }
      return null;
    },
  };
};

// MODULE: compiler/bundle/worker-plugin.js
const workerPlugin = (config, compilerCtx, buildCtx, platform, inlineWorkers) => {
  if (platform === 'worker' || platform === 'hydrate') {
    return {
      name: 'workerPlugin',
    };
  }
  const workersMap = new Map();
  return {
    name: 'workerPlugin',
    buildStart() {
      workersMap.clear();
    },
    resolveId(id) {
      if (id === WORKER_HELPER_ID) {
        return {
          id,
          moduleSideEffects: false,
        };
      }
      return null;
    },
    load(id) {
      if (id === WORKER_HELPER_ID) {
        return WORKER_HELPERS;
      }
      return null;
    },
    async transform(_, id) {
      if (/\0/.test(id)) {
        return null;
      }
      // Canonical worker path
      if (id.endsWith('?worker')) {
        const workerEntryPath = normalizeFsPath(id);
        const workerName = getWorkerName(workerEntryPath);
        const { code, dependencies, workerMsgId } = await getWorker(config, compilerCtx, buildCtx, this, workersMap, workerEntryPath);
        const referenceId = this.emitFile({
          type: 'asset',
          source: code,
          name: workerName + '.js',
        });
        dependencies.forEach(id => this.addWatchFile(id));
        return {
          code: getWorkerMain(referenceId, workerName, workerMsgId),
          moduleSideEffects: false,
        };
      }
      else if (id.endsWith('?worker-inline')) {
        const workerEntryPath = normalizeFsPath(id);
        const workerName = getWorkerName(workerEntryPath);
        const { code, dependencies, workerMsgId } = await getWorker(config, compilerCtx, buildCtx, this, workersMap, workerEntryPath);
        dependencies.forEach(id => this.addWatchFile(id));
        return {
          code: getInlineWorker(code, workerName, workerMsgId),
          moduleSideEffects: false,
        };
      }
      // Proxy worker path
      const workerEntryPath = getWorkerEntryPath(id);
      if (workerEntryPath != null) {
        const worker = await getWorker(config, compilerCtx, buildCtx, this, workersMap, workerEntryPath);
        if (worker) {
          if (inlineWorkers) {
            return {
              code: getInlineWorkerProxy(workerEntryPath, worker.workerMsgId, worker.exports),
              moduleSideEffects: false,
            };
          }
          else {
            return {
              code: getWorkerProxy(workerEntryPath, worker.exports),
              moduleSideEffects: false,
            };
          }
        }
      }
      return null;
    },
  };
};
const getWorkerEntryPath = (id) => {
  if (WORKER_SUFFIX.some(p => id.endsWith(p))) {
    return normalizeFsPath(id);
  }
  return null;
};
const getWorker = async (config, compilerCtx, buildCtx, ctx, workersMap, workerEntryPath) => {
  let worker = workersMap.get(workerEntryPath);
  if (!worker) {
    worker = await buildWorker(config, compilerCtx, buildCtx, ctx, workerEntryPath);
    workersMap.set(workerEntryPath, worker);
  }
  return worker;
};
const getWorkerName = (id) => {
  const parts = id.split('/').filter(i => !i.includes('index'));
  id = parts[parts.length - 1];
  return id.replace('.tsx', '').replace('.ts', '');
};
const buildWorker = async (config, compilerCtx, buildCtx, ctx, workerEntryPath) => {
  const workerName = getWorkerName(workerEntryPath);
  const workerMsgId = `stencil.${workerName}`;
  const build = await bundleOutput(config, compilerCtx, buildCtx, {
    platform: 'worker',
    id: workerName,
    inputs: {
      [workerName]: workerEntryPath,
    },
    inlineDynamicImports: true,
  });
  if (build) {
    // Generate commonjs output so we can intercept exports at runtme
    const output = await build.generate({
      format: 'commonjs',
      intro: getWorkerIntro(workerMsgId, config.devMode),
      esModule: false,
      preferConst: true,
      externalLiveBindings: false,
    });
    const entryPoint = output.output[0];
    if (entryPoint.imports.length > 0) {
      ctx.error('Workers should not have any external imports: ' + JSON.stringify(entryPoint.imports));
    }
    // Optimize code
    let code = entryPoint.code;
    const results = await optimizeModule(config, compilerCtx, {
      input: code,
      sourceTarget: config.buildEs5 ? 'es5' : 'es2017',
      isCore: false,
      minify: config.minifyJs,
      inlineHelpers: true,
    });
    buildCtx.diagnostics.push(...results.diagnostics);
    if (!hasError(results.diagnostics)) {
      code = results.output;
    }
    return {
      code,
      exports: entryPoint.exports,
      workerMsgId,
      dependencies: Object.keys(entryPoint.modules).filter(id => !/\0/.test(id) && id !== workerEntryPath),
    };
  }
  return null;
};
const WORKER_SUFFIX = ['.worker.ts', '.worker.tsx', '.worker/index.ts', '.worker/index.tsx'];
const WORKER_HELPER_ID = '@worker-helper';
const getWorkerIntro = (workerMsgId, isDev) => `
const exports = {};
const workerMsgId = '${workerMsgId}';
const workerMsgCallbackId = workerMsgId + '.cb';
const getTransferables = (value) => {
  if (!!value) {
  if (value instanceof ArrayBuffer) {
    return [value];
  }
  if (value.constructor === Object) {
    return [].concat(...Object.keys(value).map(k => getTransferables(value[k])))
  }
  if (typeof value === 'object') {
    return getTransferables(value.buffer);
  }
  }
  return [];
};
addEventListener('message', async ({data}) => {
  if (data && data[0] === workerMsgId) {
  let id = data[1];
  let method = data[2];
  let args = data[3];
  let i = 0;
  let argsLen = args.length;
  let value;
  let err;

  try {
    for (; i < argsLen; i++) {
    if (Array.isArray(args[i]) && args[i][0] === workerMsgCallbackId) {
      const callbackId = args[i][1];
      args[i] = (...cbArgs) => {
      postMessage(
        [workerMsgCallbackId, callbackId, cbArgs]
      );
      };
    }
    }
    ${isDev
  ? `
    value = exports[method](...args);
    if (!value || !value.then) {
    throw new Error('The exported method "' + method + '" does not return a Promise, make sure it is an "async" function');
    }
    value = await value;
    `
  : `
    value = await exports[method](...args);`}

  } catch (e) {
    value = null;
    ${isDev ? 'console.error(e);' : ''}
    err = {
    message: typeof e === 'string' ? e : e.message,
    stack: e.stack
    };
    value = undefined;
  }

  const transferables = getTransferables(value);
  ${isDev ? `if (transferables.length > 0) console.debug('Transfering', transferables);` : ''}

  postMessage(
    [workerMsgId, id, value, err],
    transferables
  );
  }
});
`;
const WORKER_HELPERS = `
let pendingIds = 0;
let callbackIds = 0;
const pending = new Map();
const callbacks = new Map();

export const createWorker = (workerPath, workerName, workerMsgId) => {
  const worker = new Worker(workerPath, {name:workerName});

  worker.addEventListener('message', ({data}) => {
  if (data) {
    const workerMsg = data[0];
    const id = data[1];
    const value = data[2];

    if (workerMsg === workerMsgId) {
    const err = data[3];
    const [resolve, reject, callbackIds] = pending.get(id);
    pending.delete(id);

    if (err) {
      reject(err);
    } else {
      if (callbackIds) {
      callbackIds.forEach(id => callbacks.delete(id));
      }
      resolve(value);
    }
    } else if (workerMsg === workerMsgId + '.cb') {
    try {
      callbacks.get(id)(...value);
    } catch (e) {
      console.error(e);
    }
    }
  }
  });

  return worker;
};

export const createWorkerProxy = (worker, workerMsgId, exportedMethod) => (
  (...args) => new Promise((resolve, reject) => {
  let pendingId = pendingIds++;
  let i = 0;
  let argLen = args.length;
  let mainData = [resolve, reject];
  pending.set(pendingId, mainData);

  for (; i < argLen; i++) {
    if (typeof args[i] === 'function') {
    const callbackId = callbackIds++;
    callbacks.set(callbackId, args[i]);
    args[i] = [workerMsgId + '.cb', callbackId];
    (mainData[2] = mainData[2] || []).push(callbackId);
    }
  }
  const postMessage = (w) => (
    w.postMessage(
    [workerMsgId, pendingId, exportedMethod, args],
    args.filter(a => a instanceof ArrayBuffer)
    )
  );
  if (worker.then) {
    worker.then(postMessage);
  } else {
    postMessage(worker);
  }
  })
);
`;
const getWorkerMain = (referenceId, workerName, workerMsgId) => {
  return `
import { createWorker } from '${WORKER_HELPER_ID}';
export const workerName = '${workerName}';
export const workerMsgId = '${workerMsgId}';
export const workerPath = /*@__PURE__*/import.meta.ROLLUP_FILE_URL_${referenceId};
export const worker = /*@__PURE__*/createWorker(workerPath, workerName, workerMsgId);
`;
};
const getInlineWorker = (code, workerName, workerMsgId) => {
  return `
import { createWorker } from '${WORKER_HELPER_ID}';
const blob = new Blob([${JSON.stringify(code)}], { type: 'text/javascript' });
const url = URL.createObjectURL(blob);
export const worker = createWorker(url, '${workerName}', '${workerMsgId}');
URL.revokeObjectURL(url);
`;
};
const getWorkerProxy = (workerEntryPath, exportedMethods) => {
  return `
import { createWorkerProxy } from '${WORKER_HELPER_ID}';
import { worker, workerName, workerMsgId } from '${workerEntryPath}?worker';
${exportedMethods
    .map(exportedMethod => {
    return `export const ${exportedMethod} = /*@__PURE__*/createWorkerProxy(worker, workerMsgId, '${exportedMethod}');`;
  })
    .join('\n')}
`;
};
const getInlineWorkerProxy = (workerEntryPath, workerMsgId, exportedMethods) => {
  return `
import { createWorkerProxy } from '${WORKER_HELPER_ID}';
const workerPromise = import('${workerEntryPath}?worker-inline').then(m => m.worker);
${exportedMethods
    .map(exportedMethod => {
    return `export const ${exportedMethod} = /*@__PURE__*/createWorkerProxy(workerPromise, '${workerMsgId}', '${exportedMethod}');`;
  })
    .join('\n')}
`;
};

// MODULE: compiler/bundle/bundle-output.js
const bundleOutput = async (config, compilerCtx, buildCtx, bundleOpts) => {
  try {
    const rollupOptions = getRollupOptions(config, compilerCtx, buildCtx, bundleOpts);
    const rollupBuild = await rollup(rollupOptions);
    compilerCtx.rollupCache.set(bundleOpts.id, rollupBuild.cache);
    return rollupBuild;
  }
  catch (e) {
    if (!buildCtx.hasError) {
      loadRollupDiagnostics(config, compilerCtx, buildCtx, e);
    }
  }
  return undefined;
};
const getRollupOptions = (config, compilerCtx, buildCtx, bundleOpts) => {
  const customResolveOptions = createCustomResolverAsync(config.sys, compilerCtx.fs, ['.tsx', '.ts', '.js', '.mjs', '.json']);
  const nodeResolvePlugin = nodeResolve(Object.assign({ mainFields: ['collection:main', 'jsnext:main', 'es2017', 'es2015', 'module', 'main'], customResolveOptions, browser: true }, config.nodeResolve));
  if (config.devServer && config.devServer.experimentalDevModules) {
    const orgNodeResolveId = nodeResolvePlugin.resolveId;
    nodeResolvePlugin.resolveId = async function (importee, importer) {
      const resolvedId = await orgNodeResolveId.call(nodeResolvePlugin, importee, importer);
      return devNodeModuleResolveId(config, compilerCtx.fs, resolvedId, importee);
    };
  }
  const beforePlugins = config.rollupPlugins.before || [];
  const afterPlugins = config.rollupPlugins.after || [];
  const rollupOptions = {
    input: bundleOpts.inputs,
    plugins: [
      coreResolvePlugin(config, compilerCtx, bundleOpts.platform),
      appDataPlugin(config, compilerCtx, buildCtx, bundleOpts.conditionals, bundleOpts.platform),
      lazyComponentPlugin(buildCtx),
      loaderPlugin(bundleOpts.loader),
      userIndexPlugin(config, compilerCtx),
      typescriptPlugin(compilerCtx, bundleOpts),
      imagePlugin(config, buildCtx),
      textPlugin(),
      extTransformsPlugin(config, compilerCtx, buildCtx, bundleOpts),
      workerPlugin(config, compilerCtx, buildCtx, bundleOpts.platform, !!bundleOpts.inlineWorkers),
      ...beforePlugins,
      nodeResolvePlugin,
      resolveIdWithTypeScript(config, compilerCtx),
      commonjs(Object.assign({ include: /node_modules/, sourceMap: config.sourceMap }, config.commonjs)),
      ...afterPlugins,
      pluginHelper(config, buildCtx),
      json({
        preferConst: true,
      }),
      replace$1({
        'process.env.NODE_ENV': config.devMode ? '"development"' : '"production"',
      }),
      fileLoadPlugin(compilerCtx.fs),
    ],
    treeshake: getTreeshakeOption(config, bundleOpts),
    inlineDynamicImports: bundleOpts.inlineDynamicImports,
    onwarn: createOnWarnFn(buildCtx.diagnostics),
    cache: compilerCtx.rollupCache.get(bundleOpts.id),
  };
  return rollupOptions;
};
const getTreeshakeOption = (config, bundleOpts) => {
  if (bundleOpts.platform === 'hydrate') {
    return {
      propertyReadSideEffects: false,
      tryCatchDeoptimization: false,
    };
  }
  const treeshake = !config.devMode && config.rollupConfig.inputOptions.treeshake !== false
    ? {
      propertyReadSideEffects: false,
      tryCatchDeoptimization: false,
    }
    : false;
  return treeshake;
};

// MODULE: compiler/app-core/app-data.js
const getBuildFeatures = (cmps) => {
  const slot = cmps.some(c => c.htmlTagNames.includes('slot'));
  const shadowDom = cmps.some(c => c.encapsulation === 'shadow');
  const slotRelocation = cmps.some(c => c.encapsulation !== 'shadow' && c.htmlTagNames.includes('slot'));
  const f = {
    allRenderFn: cmps.every(c => c.hasRenderFn),
    cmpDidLoad: cmps.some(c => c.hasComponentDidLoadFn),
    cmpShouldUpdate: cmps.some(c => c.hasComponentShouldUpdateFn),
    cmpDidUnload: cmps.some(c => c.hasComponentDidUnloadFn),
    cmpDidUpdate: cmps.some(c => c.hasComponentDidUpdateFn),
    cmpDidRender: cmps.some(c => c.hasComponentDidRenderFn),
    cmpWillLoad: cmps.some(c => c.hasComponentWillLoadFn),
    cmpWillUpdate: cmps.some(c => c.hasComponentWillUpdateFn),
    cmpWillRender: cmps.some(c => c.hasComponentWillRenderFn),
    connectedCallback: cmps.some(c => c.hasConnectedCallbackFn),
    disconnectedCallback: cmps.some(c => c.hasDisconnectedCallbackFn),
    element: cmps.some(c => c.hasElement),
    event: cmps.some(c => c.hasEvent),
    hasRenderFn: cmps.some(c => c.hasRenderFn),
    lifecycle: cmps.some(c => c.hasLifecycle),
    asyncLoading: false,
    hostListener: cmps.some(c => c.hasListener),
    hostListenerTargetWindow: cmps.some(c => c.hasListenerTargetWindow),
    hostListenerTargetDocument: cmps.some(c => c.hasListenerTargetDocument),
    hostListenerTargetBody: cmps.some(c => c.hasListenerTargetBody),
    hostListenerTargetParent: cmps.some(c => c.hasListenerTargetParent),
    hostListenerTarget: cmps.some(c => c.hasListenerTarget),
    member: cmps.some(c => c.hasMember),
    method: cmps.some(c => c.hasMethod),
    mode: cmps.some(c => c.hasMode),
    observeAttribute: cmps.some(c => c.hasAttribute),
    prop: cmps.some(c => c.hasProp),
    propBoolean: cmps.some(c => c.hasPropBoolean),
    propNumber: cmps.some(c => c.hasPropNumber),
    propString: cmps.some(c => c.hasPropString),
    propMutable: cmps.some(c => c.hasPropMutable),
    reflect: cmps.some(c => c.hasReflect),
    scoped: cmps.some(c => c.encapsulation === 'scoped'),
    shadowDom,
    shadowDelegatesFocus: shadowDom && cmps.some(c => c.shadowDelegatesFocus),
    slot,
    slotRelocation,
    state: cmps.some(c => c.hasState),
    style: cmps.some(c => c.hasStyle),
    svg: cmps.some(c => c.htmlTagNames.includes('svg')),
    updatable: cmps.some(c => c.isUpdateable),
    vdomAttribute: cmps.some(c => c.hasVdomAttribute),
    vdomXlink: cmps.some(c => c.hasVdomXlink),
    vdomClass: cmps.some(c => c.hasVdomClass),
    vdomFunctional: cmps.some(c => c.hasVdomFunctional),
    vdomKey: cmps.some(c => c.hasVdomKey),
    vdomListener: cmps.some(c => c.hasVdomListener),
    vdomPropOrAttr: cmps.some(c => c.hasVdomPropOrAttr),
    vdomRef: cmps.some(c => c.hasVdomRef),
    vdomRender: cmps.some(c => c.hasVdomRender),
    vdomStyle: cmps.some(c => c.hasVdomStyle),
    vdomText: cmps.some(c => c.hasVdomText),
    watchCallback: cmps.some(c => c.hasWatchCallback),
    taskQueue: true,
  };
  f.asyncLoading = f.cmpWillUpdate || f.cmpWillLoad || f.cmpWillRender;
  f.vdomAttribute = f.vdomAttribute || f.reflect;
  f.vdomPropOrAttr = f.vdomPropOrAttr || f.reflect;
  return f;
};
const updateComponentBuildConditionals = (moduleMap, cmps) => {
  cmps.forEach(cmp => {
    const importedModules = getModuleImports(moduleMap, cmp.sourceFilePath, []);
    importedModules.forEach(importedModule => {
      // if the component already has a boolean true value it'll keep it
      // otherwise we get the boolean value from the imported module
      cmp.hasVdomAttribute = cmp.hasVdomAttribute || importedModule.hasVdomAttribute;
      cmp.hasVdomPropOrAttr = cmp.hasVdomPropOrAttr || importedModule.hasVdomPropOrAttr;
      cmp.hasVdomXlink = cmp.hasVdomXlink || importedModule.hasVdomXlink;
      cmp.hasVdomClass = cmp.hasVdomClass || importedModule.hasVdomClass;
      cmp.hasVdomFunctional = cmp.hasVdomFunctional || importedModule.hasVdomFunctional;
      cmp.hasVdomKey = cmp.hasVdomKey || importedModule.hasVdomKey;
      cmp.hasVdomListener = cmp.hasVdomListener || importedModule.hasVdomListener;
      cmp.hasVdomRef = cmp.hasVdomRef || importedModule.hasVdomRef;
      cmp.hasVdomRender = cmp.hasVdomRender || importedModule.hasVdomRender;
      cmp.hasVdomStyle = cmp.hasVdomStyle || importedModule.hasVdomStyle;
      cmp.hasVdomText = cmp.hasVdomText || importedModule.hasVdomText;
      cmp.htmlAttrNames.push(...importedModule.htmlAttrNames);
      cmp.htmlTagNames.push(...importedModule.htmlTagNames);
      cmp.potentialCmpRefs.push(...importedModule.potentialCmpRefs);
    });
    cmp.htmlAttrNames = unique(cmp.htmlAttrNames);
    cmp.htmlTagNames = unique(cmp.htmlTagNames);
    cmp.potentialCmpRefs = unique(cmp.potentialCmpRefs);
  });
};
const getModuleImports = (moduleMap, filePath, importedModules) => {
  let moduleFile = moduleMap.get(filePath);
  if (moduleFile == null) {
    moduleFile = moduleMap.get(filePath + '.tsx');
    if (moduleFile == null) {
      moduleFile = moduleMap.get(filePath + '.ts');
      if (moduleFile == null) {
        moduleFile = moduleMap.get(filePath + '.js');
      }
    }
  }
  if (moduleFile != null && !importedModules.some(m => m.sourceFilePath === moduleFile.sourceFilePath)) {
    importedModules.push(moduleFile);
    moduleFile.localImports.forEach(localImport => {
      getModuleImports(moduleMap, localImport, importedModules);
    });
  }
  return importedModules;
};
const updateBuildConditionals = (config, b) => {
  b.isDebug = config.logLevel === 'debug';
  b.isDev = !!config.devMode;
  b.isTesting = !!config._isTesting;
  b.devTools = b.isDev && !config._isTesting;
  b.profile = !!config.profile;
  b.hotModuleReplacement = !!(config.devMode && config.devServer && config.devServer.reloadStrategy === 'hmr' && !config._isTesting);
  b.updatable = b.updatable || b.hydrateClientSide || b.hotModuleReplacement;
  b.member = b.member || b.updatable || b.mode || b.lifecycle;
  b.constructableCSS = !b.hotModuleReplacement || !!config._isTesting;
  b.asyncLoading = !!(b.asyncLoading || b.lazyLoad || b.taskQueue || b.initializeNextTick);
  b.cssAnnotations = true;
  b.appendChildSlotFix = config.extras.appendChildSlotFix;
  b.slotChildNodesFix = config.extras.slotChildNodesFix;
  b.cloneNodeFix = config.extras.cloneNodeFix;
  b.dynamicImportShim = config.extras.dynamicImportShim;
  b.lifecycleDOMEvents = !!(b.isDebug || config._isTesting || config.extras.lifecycleDOMEvents);
  b.safari10 = config.extras.safari10;
  b.scriptDataOpts = config.extras.scriptDataOpts;
  b.shadowDomShim = config.extras.shadowDomShim;
  if (b.shadowDomShim) {
    b.slotRelocation = b.slot;
  }
  if (config.hydratedFlag) {
    b.hydratedAttribute = config.hydratedFlag.selector === 'attribute';
    b.hydratedClass = config.hydratedFlag.selector === 'class';
  }
  else {
    b.hydratedAttribute = false;
    b.hydratedClass = false;
  }
};

// MODULE: compiler/output-targets/dist-custom-elements-bundle/custom-elements-build-conditionals.js
const getCustomElementsBuildConditionals = (config, cmps) => {
  const build = getBuildFeatures(cmps);
  build.lazyLoad = false;
  build.hydrateClientSide = false;
  build.hydrateServerSide = false;
  build.asyncQueue = config.taskQueue === 'congestionAsync';
  build.taskQueue = config.taskQueue !== 'immediate';
  updateBuildConditionals(config, build);
  build.devTools = false;
  return build;
};

// MODULE: compiler/output-targets/dist-custom-elements-bundle/index.js
const outputCustomElementsBundle = async (config, compilerCtx, buildCtx) => {
  if (config.devMode) {
    return;
  }
  const outputTargets = config.outputTargets.filter(isOutputTargetDistCustomElementsBundle);
  if (outputTargets.length === 0) {
    return;
  }
  const timespan = buildCtx.createTimeSpan(`generate custom elements bundle started`);
  await Promise.all(outputTargets.map(o => bundleCustomElements(config, compilerCtx, buildCtx, o)));
  timespan.finish(`generate custom elements bundle finished`);
};
const bundleCustomElements = async (config, compilerCtx, buildCtx, outputTarget) => {
  try {
    const bundleOpts = {
      id: 'customElementsBundle',
      platform: 'client',
      conditionals: getCustomElementsBuildConditionals(config, buildCtx.components),
      customTransformers: getCustomElementBundleCustomTransformer(config, compilerCtx),
      inlineWorkers: true,
      inputs: {
        index: '\0core',
      },
      loader: {
        '\0core': generateEntryPoint(buildCtx),
      },
      inlineDynamicImports: outputTarget.inlineDynamicImports,
    };
    const build = await bundleOutput(config, compilerCtx, buildCtx, bundleOpts);
    if (build) {
      const rollupOutput = await build.generate({
        format: 'esm',
        sourcemap: config.sourceMap,
        chunkFileNames: config.devMode ? '[name]-[hash].mjs' : 'p-[hash].mjs',
        entryFileNames: '[name].mjs',
      });
      const files = rollupOutput.output.map(async (bundle) => {
        if (bundle.type === 'chunk') {
          let code = bundle.code;
          const optimizeResults = await optimizeModule(config, compilerCtx, {
            input: code,
            isCore: bundle.isEntry,
            minify: config.minifyJs,
          });
          buildCtx.diagnostics.push(...optimizeResults.diagnostics);
          if (!hasError(optimizeResults.diagnostics) && typeof optimizeResults.output === 'string') {
            code = optimizeResults.output;
          }
          await compilerCtx.fs.writeFile(join(outputTarget.dir, bundle.fileName), code, { outputTargetType: outputTarget.type });
        }
      });
      await Promise.all(files);
    }
  }
  catch (e) {
    catchError(buildCtx.diagnostics, e);
  }
};
const generateEntryPoint = (buildCtx) => {
  const importStatements = [];
  const exportStatements = [];
  const exportNames = [];
  importStatements.push(`import { proxyCustomElement } from '${STENCIL_INTERNAL_CLIENT_ID}';`, `export * from '${USER_INDEX_ENTRY_ID}';`, `import { globalScripts } from '${STENCIL_APP_GLOBALS_ID}';`, 'globalScripts();');
  buildCtx.components.forEach(cmp => {
    const exportName = dashToPascalCase(cmp.tagName);
    const importName = cmp.componentClassName;
    const importAs = `$Cmp${exportName}`;
    if (cmp.isPlain) {
      exports.push(`export { ${importName} as ${exportName} } from '${cmp.sourceFilePath}';`);
    }
    else {
      const meta = stringifyRuntimeData(formatComponentRuntimeMeta(cmp, false));
      importStatements.push(`import { ${importName} as ${importAs} } from '${cmp.sourceFilePath}';`);
      exportStatements.push(`export const ${exportName} = /*@__PURE__*/proxyCustomElement(${importAs}, ${meta});`);
      exportNames.push(exportName);
    }
  });
  exportStatements.push(`
export const defineCustomElements = () => {
  [
  ${exportNames.join(',\n  ')}
  ].forEach(cmp => customElements.define(cmp.is, cmp));
};`);
  return [...importStatements, ...exportStatements, ''].join('\n');
};
const getCustomElementBundleCustomTransformer = (config, compilerCtx) => {
  const transformOpts = {
    coreImportPath: STENCIL_INTERNAL_CLIENT_ID,
    componentExport: null,
    componentMetadata: null,
    currentDirectory: config.cwd,
    proxy: null,
    style: 'static',
  };
  return [updateStencilCoreImports(transformOpts.coreImportPath), nativeComponentTransform(compilerCtx, transformOpts), removeCollectionImports(compilerCtx)];
};

// MODULE: compiler/docs/constants.js
const AUTO_GENERATE_COMMENT = `<!-- Auto Generated Below -->`;
const NOTE = `*Built with [StencilJS](https://stenciljs.com/)*`;

// MODULE: compiler/docs/generate-doc-data.js
const generateDocData = async (config, compilerCtx, buildCtx) => {
  return {
    timestamp: getBuildTimestamp(),
    compiler: {
      name: '@stencil/core',
      version,
      typescriptVersion,
    },
    components: await getDocsComponents(config, compilerCtx, buildCtx),
  };
};
const getDocsComponents = async (config, compilerCtx, buildCtx) => {
  const results = await Promise.all(buildCtx.moduleFiles.map(async (moduleFile) => {
    const filePath = moduleFile.sourceFilePath;
    const dirPath = normalizePath(dirname(filePath));
    const readmePath = normalizePath(join(dirPath, 'readme.md'));
    const usagesDir = normalizePath(join(dirPath, 'usage'));
    const readme = await getUserReadmeContent(compilerCtx, readmePath);
    const usage = await generateUsages(compilerCtx, usagesDir);
    return moduleFile.cmps
      .filter(cmp => isDocsPublic(cmp.docs) && !cmp.isCollectionDependency)
      .map(cmp => ({
      dirPath,
      filePath: relative(config.rootDir, filePath),
      fileName: basename(filePath),
      readmePath,
      usagesDir,
      tag: cmp.tagName,
      readme,
      usage,
      docs: generateDocs(readme, cmp.docs),
      docsTags: cmp.docs.tags,
      encapsulation: getDocsEncapsulation(cmp),
      dependents: cmp.directDependents,
      dependencies: cmp.directDependencies,
      dependencyGraph: buildDocsDepGraph(cmp, buildCtx.components),
      deprecation: getDocsDeprecationText(cmp.docs.tags),
      props: getDocsProperties(cmp),
      methods: getDocsMethods(cmp.methods),
      events: getDocsEvents(cmp.events),
      styles: getDocsStyles(cmp),
      slots: getDocsSlots(cmp.docs.tags),
      parts: getDocsParts(cmp.docs.tags),
      listeners: getDocsListeners(cmp.listeners),
    }));
  }));
  return sortBy(flatOne(results), cmp => cmp.tag);
};
const buildDocsDepGraph = (cmp, cmps) => {
  const dependencies = {};
  function walk(tagName) {
    if (!dependencies[tagName]) {
      const cmp = cmps.find(c => c.tagName === tagName);
      const deps = cmp.directDependencies;
      if (deps.length > 0) {
        dependencies[tagName] = deps;
        deps.forEach(walk);
      }
    }
  }
  walk(cmp.tagName);
  // load dependents
  cmp.directDependents.forEach(tagName => {
    if (dependencies[tagName] && !dependencies[tagName].includes(cmp.tagName)) {
      dependencies[tagName].push(cmp.tagName);
    }
    else {
      dependencies[tagName] = [cmp.tagName];
    }
  });
  return dependencies;
};
const getDocsEncapsulation = (cmp) => {
  if (cmp.encapsulation === 'shadow') {
    return 'shadow';
  }
  else if (cmp.encapsulation === 'scoped') {
    return 'scoped';
  }
  else {
    return 'none';
  }
};
const getDocsProperties = (cmpMeta) => {
  return sortBy([...getRealProperties(cmpMeta.properties), ...getVirtualProperties(cmpMeta.virtualProperties)], p => p.name);
};
const getRealProperties = (properties) => {
  return properties
    .filter(member => isDocsPublic(member.docs))
    .map(member => ({
    name: member.name,
    type: member.complexType.resolved,
    mutable: member.mutable,
    attr: member.attribute,
    reflectToAttr: !!member.reflect,
    docs: member.docs.text,
    docsTags: member.docs.tags,
    default: member.defaultValue,
    deprecation: getDocsDeprecationText(member.docs.tags),
    values: parseTypeIntoValues(member.complexType.resolved),
    optional: member.optional,
    required: member.required,
  }));
};
const getVirtualProperties = (virtualProps) => {
  return virtualProps.map(member => ({
    name: member.name,
    type: member.type,
    mutable: false,
    attr: member.name,
    reflectToAttr: false,
    docs: member.docs,
    docsTags: [],
    default: undefined,
    deprecation: undefined,
    values: parseTypeIntoValues(member.type),
    optional: true,
    required: false,
  }));
};
const parseTypeIntoValues = (type) => {
  if (typeof type === 'string') {
    const unions = type.split('|').map(u => u.trim());
    const parsedUnions = [];
    unions.forEach(u => {
      if (u === 'true') {
        parsedUnions.push({
          value: 'true',
          type: 'boolean',
        });
        return;
      }
      if (u === 'false') {
        parsedUnions.push({
          value: 'false',
          type: 'boolean',
        });
        return;
      }
      if (!Number.isNaN(parseFloat(u))) {
        // union is a number
        parsedUnions.push({
          value: u,
          type: 'number',
        });
        return;
      }
      if (/^("|').+("|')$/gm.test(u)) {
        // ionic is a string
        parsedUnions.push({
          value: u.slice(1, -1),
          type: 'string',
        });
        return;
      }
      parsedUnions.push({
        type: u,
      });
    });
    return parsedUnions;
  }
  return [];
};
const getDocsMethods = (methods) => {
  return sortBy(methods, member => member.name)
    .filter(member => isDocsPublic(member.docs))
    .map(member => ({
    name: member.name,
    returns: {
      type: member.complexType.return,
      docs: member.docs.tags.filter(t => t.name === 'return').join('\n'),
    },
    signature: `${member.name}${member.complexType.signature}`,
    parameters: [],
    docs: member.docs.text,
    docsTags: member.docs.tags,
    deprecation: getDocsDeprecationText(member.docs.tags),
  }));
};
const getDocsEvents = (events) => {
  return sortBy(events, eventMeta => eventMeta.name.toLowerCase())
    .filter(eventMeta => isDocsPublic(eventMeta.docs))
    .map(eventMeta => ({
    event: eventMeta.name,
    detail: eventMeta.complexType.resolved,
    bubbles: eventMeta.bubbles,
    cancelable: eventMeta.cancelable,
    composed: eventMeta.composed,
    docs: eventMeta.docs.text,
    docsTags: eventMeta.docs.tags,
    deprecation: getDocsDeprecationText(eventMeta.docs.tags),
  }));
};
const getDocsStyles = (cmpMeta) => {
  if (!cmpMeta.styleDocs) {
    return [];
  }
  return sortBy(cmpMeta.styleDocs, o => o.name.toLowerCase()).map(styleDoc => {
    return {
      name: styleDoc.name,
      annotation: styleDoc.annotation || '',
      docs: styleDoc.docs || '',
    };
  });
};
const getDocsListeners = (listeners) => {
  return listeners.map(listener => ({
    event: listener.name,
    target: listener.target,
    capture: listener.capture,
    passive: listener.passive,
  }));
};
const getDocsDeprecationText = (tags) => {
  const deprecation = tags.find(t => t.name === 'deprecated');
  if (deprecation) {
    return deprecation.text || '';
  }
  return undefined;
};
const getDocsSlots = (tags) => {
  return sortBy(getNameText('slot', tags).map(([name, docs]) => ({ name, docs })), a => a.name);
};
const getDocsParts = (tags) => {
  return sortBy(getNameText('part', tags).map(([name, docs]) => ({ name, docs })), a => a.name);
};
const getNameText = (name, tags) => {
  return tags
    .filter(tag => tag.name === name && tag.text)
    .map(({ text }) => {
    const [namePart, ...rest] = (' ' + text).split(' - ');
    return [namePart.trim(), rest.join(' - ').trim()];
  });
};
const getUserReadmeContent = async (compilerCtx, readmePath) => {
  try {
    const existingContent = await compilerCtx.fs.readFile(readmePath);
    const userContentIndex = existingContent.indexOf(AUTO_GENERATE_COMMENT) - 1;
    if (userContentIndex >= 0) {
      return existingContent.substring(0, userContentIndex);
    }
  }
  catch (e) { }
  return undefined;
};
const generateDocs = (readme, jsdoc) => {
  const docs = jsdoc.text;
  if (docs !== '' || !readme) {
    return docs;
  }
  let isContent = false;
  const lines = readme.split('\n');
  const contentLines = [];
  for (const line of lines) {
    const isHeader = line.startsWith('#');
    if (isHeader && isContent) {
      break;
    }
    if (!isHeader && !isContent) {
      isContent = true;
    }
    if (isContent) {
      contentLines.push(line);
    }
  }
  return contentLines.join('\n').trim();
};
const generateUsages = async (compilerCtx, usagesDir) => {
  const rtn = {};
  try {
    const usageFilePaths = await compilerCtx.fs.readdir(usagesDir);
    const usages = {};
    await Promise.all(usageFilePaths.map(async (f) => {
      if (!f.isFile) {
        return;
      }
      const fileName = basename(f.relPath);
      if (!fileName.toLowerCase().endsWith('.md')) {
        return;
      }
      const parts = fileName.split('.');
      parts.pop();
      const key = parts.join('.');
      usages[key] = await compilerCtx.fs.readFile(f.absPath);
    }));
    Object.keys(usages)
      .sort()
      .forEach(key => {
      rtn[key] = usages[key];
    });
  }
  catch (e) { }
  return rtn;
};

// MODULE: compiler/docs/custom/index.js
const generateCustomDocs = async (config, docsData, outputTargets) => {
  const customOutputTargets = outputTargets.filter(isOutputTargetDocsCustom);
  if (customOutputTargets.length === 0) {
    return;
  }
  await Promise.all(customOutputTargets.map(async (customOutput) => {
    try {
      await customOutput.generator(docsData);
    }
    catch (e) {
      config.logger.error(`uncaught custom docs error: ${e}`);
    }
  }));
};

// MODULE: compiler/docs/json/index.js
const generateJsonDocs = async (config, compilerCtx, docsData, outputTargets) => {
  const jsonOutputTargets = outputTargets.filter(isOutputTargetDocsJson);
  if (jsonOutputTargets.length === 0) {
    return;
  }
  const docsDtsPath = join(config.sys.getCompilerExecutingPath(), '..', '..', 'internal', 'stencil-public-docs.d.ts');
  const docsDts = await compilerCtx.fs.readFile(docsDtsPath);
  const typesContent = `
/**
 * This is an autogenerated file created by the Stencil compiler.
 * DO NOT MODIFY IT MANUALLY
 */
${docsDts}
declare const _default: JsonDocs;
export default _default;
`;
  const json = Object.assign(Object.assign({}, docsData), { components: docsData.components.map(cmp => ({
      filePath: cmp.filePath,
      encapsulation: cmp.encapsulation,
      tag: cmp.tag,
      readme: cmp.readme,
      docs: cmp.docs,
      docsTags: cmp.docsTags,
      usage: cmp.usage,
      props: cmp.props,
      methods: cmp.methods,
      events: cmp.events,
      listeners: cmp.listeners,
      styles: cmp.styles,
      slots: cmp.slots,
      dependents: cmp.dependents,
      dependencies: cmp.dependencies,
      dependencyGraph: cmp.dependencyGraph,
      deprecation: cmp.deprecation,
    })) });
  const jsonContent = JSON.stringify(json, null, 2);
  await Promise.all(jsonOutputTargets.map(jsonOutput => {
    return writeDocsOutput(compilerCtx, jsonOutput, jsonContent, typesContent);
  }));
};
const writeDocsOutput = async (compilerCtx, jsonOutput, jsonContent, typesContent) => {
  return Promise.all([
    compilerCtx.fs.writeFile(jsonOutput.file, jsonContent),
    jsonOutput.typesFile ? compilerCtx.fs.writeFile(jsonOutput.typesFile, typesContent) : Promise.resolve(),
  ]);
};

// MODULE: compiler/docs/readme/docs-util.js
class MarkdownTable {
  constructor() {
    this.rows = [];
  }
  addHeader(data) {
    this.addRow(data, true);
  }
  addRow(data, isHeader = false) {
    const colData = [];
    data.forEach(text => {
      const col = {
        text: escapeMarkdownTableColumn(text),
        width: text.length,
      };
      colData.push(col);
    });
    this.rows.push({
      columns: colData,
      isHeader: isHeader,
    });
  }
  toMarkdown() {
    return createTable(this.rows);
  }
}
const escapeMarkdownTableColumn = (text) => {
  text = text.replace(/\r?\n/g, ' ');
  text = text.replace(/\|/g, '\\|');
  return text;
};
const createTable = (rows) => {
  const content = [];
  if (rows.length === 0) {
    return content;
  }
  normalizeColumCount(rows);
  normalizeColumnWidth(rows);
  const th = rows.find(r => r.isHeader);
  if (th) {
    const headerRow = createRow(th);
    content.push(headerRow);
    content.push(createBorder(th));
  }
  const tds = rows.filter(r => !r.isHeader);
  tds.forEach(td => {
    content.push(createRow(td));
  });
  return content;
};
const createBorder = (th) => {
  const border = {
    columns: [],
    isHeader: false,
  };
  th.columns.forEach(c => {
    const borderCol = {
      text: '',
      width: c.width,
    };
    while (borderCol.text.length < borderCol.width) {
      borderCol.text += '-';
    }
    border.columns.push(borderCol);
  });
  return createRow(border);
};
const createRow = (row) => {
  const content = ['| '];
  row.columns.forEach(c => {
    content.push(c.text);
    content.push(' | ');
  });
  return content.join('').trim();
};
const normalizeColumCount = (rows) => {
  let columnCount = 0;
  rows.forEach(r => {
    if (r.columns.length > columnCount) {
      columnCount = r.columns.length;
    }
  });
  rows.forEach(r => {
    while (r.columns.length < columnCount) {
      r.columns.push({
        text: ``,
        width: 0,
      });
    }
  });
};
const normalizeColumnWidth = (rows) => {
  const columnCount = rows[0].columns.length;
  for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {
    let longestText = 0;
    rows.forEach(r => {
      const col = r.columns[columnIndex];
      if (col.text.length > longestText) {
        longestText = col.text.length;
      }
    });
    rows.forEach(r => {
      const col = r.columns[columnIndex];
      col.width = longestText;
      while (col.text.length < longestText) {
        col.text += ' ';
      }
    });
  }
};

// MODULE: compiler/docs/readme/markdown-props.js
const propsToMarkdown = (props) => {
  const content = [];
  if (props.length === 0) {
    return content;
  }
  content.push(`## Properties`);
  content.push(``);
  const table = new MarkdownTable();
  table.addHeader(['Property', 'Attribute', 'Description', 'Type', 'Default']);
  props.forEach(prop => {
    table.addRow([getPropertyField(prop), getAttributeField(prop), getDocsField(prop), `\`${prop.type}\``, `\`${prop.default}\``]);
  });
  content.push(...table.toMarkdown());
  content.push(``);
  content.push(``);
  return content;
};
const getPropertyField = (prop) => {
  return `\`${prop.name}\`${prop.required ? ' _(required)_' : ''}`;
};
const getAttributeField = (prop) => {
  return prop.attr ? `\`${prop.attr}\`` : '--';
};
const getDocsField = (prop) => {
  return `${prop.deprecation !== undefined ? `<span style="color:red">**[DEPRECATED]**</span> ${prop.deprecation}<br/><br/>` : ''}${prop.docs}`;
};

// MODULE: compiler/docs/readme/markdown-events.js
const eventsToMarkdown = (events) => {
  const content = [];
  if (events.length === 0) {
    return content;
  }
  content.push(`## Events`);
  content.push(``);
  const table = new MarkdownTable();
  table.addHeader(['Event', 'Description', 'Type']);
  events.forEach(ev => {
    table.addRow([`\`${ev.event}\``, getDocsField$1(ev), `\`CustomEvent<${ev.detail}>\``]);
  });
  content.push(...table.toMarkdown());
  content.push(``);
  content.push(``);
  return content;
};
const getDocsField$1 = (prop) => {
  return `${prop.deprecation !== undefined ? `<span style="color:red">**[DEPRECATED]**</span> ${prop.deprecation}<br/><br/>` : ''}${prop.docs}`;
};

// MODULE: compiler/docs/readme/markdown-methods.js
const methodsToMarkdown = (methods) => {
  const content = [];
  if (methods.length === 0) {
    return content;
  }
  content.push(`## Methods`);
  content.push(``);
  methods.forEach(method => {
    content.push(`### \`${method.signature}\``);
    content.push(``);
    content.push(getDocsField$2(method));
    content.push(``);
    if (method.parameters.length > 0) {
      const parmsTable = new MarkdownTable();
      parmsTable.addHeader(['Name', 'Type', 'Description']);
      method.parameters.forEach(({ name, type, docs }) => {
        parmsTable.addRow(['`' + name + '`', '`' + type + '`', docs]);
      });
      content.push(`#### Parameters`);
      content.push(``);
      content.push(...parmsTable.toMarkdown());
      content.push(``);
    }
    if (method.returns) {
      content.push(`#### Returns`);
      content.push(``);
      content.push(`Type: \`${method.returns.type}\``);
      content.push(``);
      content.push(method.returns.docs);
      content.push(``);
    }
  });
  content.push(``);
  return content;
};
const getDocsField$2 = (prop) => {
  return `${prop.deprecation !== undefined ? `<span style="color:red">**[DEPRECATED]**</span> ${prop.deprecation}<br/><br/>` : ''}${prop.docs}`;
};

// MODULE: compiler/docs/readme/markdown-usage.js
const usageToMarkdown = (usages) => {
  const content = [];
  const merged = mergeUsages(usages);
  if (merged.length === 0) {
    return content;
  }
  content.push(`## Usage`);
  merged.forEach(({ name, text }) => {
    content.push('');
    content.push(`### ${toTitleCase(name)}`);
    content.push('');
    content.push(text);
    content.push('');
  }),
    content.push('');
  content.push('');
  return content;
};
const mergeUsages = (usages) => {
  const keys = Object.keys(usages);
  const map = new Map();
  keys.forEach(key => {
    const usage = usages[key].trim();
    const array = map.get(usage) || [];
    array.push(key);
    map.set(usage, array);
  });
  const merged = [];
  map.forEach((value, key) => {
    merged.push({
      name: value.join(' / '),
      text: key,
    });
  });
  return merged;
};

// MODULE: compiler/docs/readme/markdown-css-props.js
const stylesToMarkdown = (styles) => {
  const content = [];
  if (styles.length === 0) {
    return content;
  }
  content.push(`## CSS Custom Properties`);
  content.push(``);
  const table = new MarkdownTable();
  table.addHeader(['Name', 'Description']);
  styles.forEach(style => {
    table.addRow([`\`${style.name}\``, style.docs]);
  });
  content.push(...table.toMarkdown());
  content.push(``);
  content.push(``);
  return content;
};

// MODULE: compiler/docs/readme/markdown-slots.js
const slotsToMarkdown = (slots) => {
  const content = [];
  if (slots.length === 0) {
    return content;
  }
  content.push(`## Slots`);
  content.push(``);
  const table = new MarkdownTable();
  table.addHeader(['Slot', 'Description']);
  slots.forEach(style => {
    table.addRow([style.name === '' ? '' : `\`"${style.name}"\``, style.docs]);
  });
  content.push(...table.toMarkdown());
  content.push(``);
  content.push(``);
  return content;
};

// MODULE: compiler/docs/readme/markdown-parts.js
const partsToMarkdown = (parts) => {
  const content = [];
  if (parts.length === 0) {
    return content;
  }
  content.push(`## Shadow Parts`);
  content.push(``);
  const table = new MarkdownTable();
  table.addHeader(['Part', 'Description']);
  parts.forEach(style => {
    table.addRow([style.name === '' ? '' : `\`"${style.name}"\``, style.docs]);
  });
  content.push(...table.toMarkdown());
  content.push(``);
  content.push(``);
  return content;
};

// MODULE: compiler/docs/readme/markdown-dependencies.js
const depsToMarkdown = (cmp, cmps) => {
  const content = [];
  const deps = Object.entries(cmp.dependencyGraph);
  if (deps.length === 0) {
    return content;
  }
  content.push(`## Dependencies`);
  content.push(``);
  if (cmp.dependents.length > 0) {
    const usedBy = cmp.dependents.map(tag => ' - ' + getCmpLink(cmp, tag, cmps));
    content.push(`### Used by`);
    content.push(``);
    content.push(...usedBy);
    content.push(``);
  }
  if (cmp.dependencies.length > 0) {
    const dependsOn = cmp.dependencies.map(tag => '- ' + getCmpLink(cmp, tag, cmps));
    content.push(`### Depends on`);
    content.push(``);
    content.push(...dependsOn);
    content.push(``);
  }
  content.push(`### Graph`);
  content.push('```mermaid');
  content.push('graph TD;');
  deps.forEach(([key, deps]) => {
    deps.forEach(dep => {
      content.push(`  ${key} --> ${dep}`);
    });
  });
  content.push(`  style ${cmp.tag} fill:#f9f,stroke:#333,stroke-width:4px`);
  content.push('```');
  content.push(``);
  return content;
};
const getCmpLink = (from, to, cmps) => {
  const destCmp = cmps.find(c => c.tag === to);
  if (destCmp) {
    const cmpRelPath = normalizePath(relative(from.dirPath, destCmp.dirPath));
    return `[${to}](${cmpRelPath})`;
  }
  return to;
};

// MODULE: compiler/docs/readme/output-docs.js
const generateReadme = async (config, compilerCtx, readmeOutputs, docsData, cmps) => {
  const isUpdate = !!docsData.readme;
  const userContent = isUpdate ? docsData.readme : getDefaultReadme(docsData);
  await Promise.all(readmeOutputs.map(async (readmeOutput) => {
    if (readmeOutput.dir) {
      const readmeContent = generateMarkdown(userContent, docsData, cmps, readmeOutput);
      const relPath = relative(config.srcDir, docsData.readmePath);
      const absPath = join(readmeOutput.dir, relPath);
      const results = await compilerCtx.fs.writeFile(absPath, readmeContent);
      if (results.changedContent) {
        if (isUpdate) {
          config.logger.info(`updated readme docs: ${docsData.tag}`);
        }
        else {
          config.logger.info(`created readme docs: ${docsData.tag}`);
        }
      }
    }
  }));
};
const generateMarkdown = (userContent, cmp, cmps, readmeOutput) => {
  //If the readmeOutput.dependencies is true or undefined the dependencies will be generated.
  const dependencies = readmeOutput.dependencies !== false ? depsToMarkdown(cmp, cmps) : [];
  return [
    userContent,
    AUTO_GENERATE_COMMENT,
    '',
    '',
    ...getDocsDeprecation(cmp),
    ...usageToMarkdown(cmp.usage),
    ...propsToMarkdown(cmp.props),
    ...eventsToMarkdown(cmp.events),
    ...methodsToMarkdown(cmp.methods),
    ...slotsToMarkdown(cmp.slots),
    ...partsToMarkdown(cmp.parts),
    ...stylesToMarkdown(cmp.styles),
    ...dependencies,
    `----------------------------------------------`,
    '',
    readmeOutput.footer,
    '',
  ].join('\n');
};
const getDocsDeprecation = (cmp) => {
  if (cmp.deprecation !== undefined) {
    return [`> **[DEPRECATED]** ${cmp.deprecation}`, ''];
  }
  return [];
};
const getDefaultReadme = (docsData) => {
  return [`# ${docsData.tag}`, '', '', ''].join('\n');
};

// MODULE: compiler/docs/readme/index.js
const generateReadmeDocs = async (config, compilerCtx, docsData, outputTargets) => {
  const readmeOutputTargets = outputTargets.filter(isOutputTargetDocsReadme);
  if (readmeOutputTargets.length === 0) {
    return;
  }
  const strictCheck = readmeOutputTargets.some(o => o.strict);
  if (strictCheck) {
    strickCheckDocs(config, docsData);
  }
  await Promise.all(docsData.components.map(cmpData => {
    return generateReadme(config, compilerCtx, readmeOutputTargets, cmpData, docsData.components);
  }));
};
const strickCheckDocs = (config, docsData) => {
  docsData.components.forEach(component => {
    component.props.forEach(prop => {
      if (!prop.docs && prop.deprecation === undefined) {
        config.logger.warn(`Property "${prop.name}" of "${component.tag}" is not documented. ${component.filePath}`);
      }
    });
    component.methods.forEach(method => {
      if (!method.docs && method.deprecation === undefined) {
        config.logger.warn(`Method "${method.name}" of "${component.tag}" is not documented. ${component.filePath}`);
      }
    });
    component.events.forEach(ev => {
      if (!ev.docs && ev.deprecation === undefined) {
        config.logger.warn(`Event "${ev.event}" of "${component.tag}" is not documented. ${component.filePath}`);
      }
    });
  });
};

// MODULE: compiler/docs/vscode/index.js
const generateVscodeDocs = async (compilerCtx, docsData, outputTargets) => {
  const vsCodeOutputTargets = outputTargets.filter(isOutputTargetDocsVscode);
  if (vsCodeOutputTargets.length === 0) {
    return;
  }
  await Promise.all(vsCodeOutputTargets.map(async (outputTarget) => {
    const json = {
      version: 1.1,
      tags: docsData.components.map(cmp => ({
        name: cmp.tag,
        description: {
          kind: 'markdown',
          value: cmp.docs,
        },
        attributes: cmp.props.filter(p => p.attr).map(serializeAttribute),
        references: getReferences(cmp, outputTarget.sourceCodeBaseUrl),
      })),
    };
    const jsonContent = JSON.stringify(json, null, 2);
    await compilerCtx.fs.writeFile(outputTarget.file, jsonContent);
  }));
};
const getReferences = (cmp, repoBaseUrl) => {
  const references = getNameText('reference', cmp.docsTags).map(([name, url]) => ({ name, url }));
  if (repoBaseUrl) {
    references.push({
      name: 'Source code',
      url: repoBaseUrl + cmp.filePath,
    });
  }
  if (references.length > 0) {
    return references;
  }
  return undefined;
};
const serializeAttribute = (prop) => {
  const attribute = {
    name: prop.attr,
    description: prop.docs,
  };
  const values = prop.values.filter(({ type, value }) => type === 'string' && value !== undefined).map(({ value }) => ({ name: value }));
  if (values.length > 0) {
    attribute.values = values;
  }
  return attribute;
};

// MODULE: compiler/output-targets/output-custom.js
const outputCustom = async (config, compilerCtx, buildCtx, docs, outputTargets) => {
  const customOutputTargets = outputTargets.filter(isOutputTargetCustom);
  if (customOutputTargets.length === 0) {
    return;
  }
  await Promise.all(customOutputTargets.map(async (o) => {
    const timespan = buildCtx.createTimeSpan(`generating ${o.name} started`);
    try {
      await o.generator(config, compilerCtx, buildCtx, docs);
    }
    catch (e) {
      catchError(buildCtx.diagnostics, e);
    }
    timespan.finish(`generate ${o.name} finished`);
  }));
};

// MODULE: compiler/output-targets/output-docs.js
const outputDocs = async (config, compilerCtx, buildCtx) => {
  if (!config.buildDocs) {
    return;
  }
  const docsOutputTargets = config.outputTargets.filter(o => isOutputTargetCustom(o) || isOutputTargetDocsReadme(o) || isOutputTargetDocsJson(o) || isOutputTargetDocsCustom(o) || isOutputTargetDocsVscode(o));
  if (docsOutputTargets.length === 0) {
    return;
  }
  // ensure all the styles are built first, which parses all the css docs
  await buildCtx.stylesPromise;
  const docsData = await generateDocData(config, compilerCtx, buildCtx);
  await Promise.all([
    generateReadmeDocs(config, compilerCtx, docsData, docsOutputTargets),
    generateJsonDocs(config, compilerCtx, docsData, docsOutputTargets),
    generateVscodeDocs(compilerCtx, docsData, docsOutputTargets),
    generateCustomDocs(config, docsData, docsOutputTargets),
    outputCustom(config, compilerCtx, buildCtx, docsData, docsOutputTargets),
  ]);
};

// MODULE: compiler/transformers/component-hydrate/hydrate-runtime-cmp-meta.js
const addHydrateRuntimeCmpMeta = (classMembers, cmp) => {
  const compactMeta = formatComponentRuntimeMeta(cmp, true);
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1],
    $members$: compactMeta[2],
    $listeners$: compactMeta[3],
    $lazyBundleIds$: fakeBundleIds(cmp),
    $attrsToReflect$: getHydrateAttrsToReflect(cmp),
  };
  // We always need shadow-dom shim in hydrate runtime
  if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
    cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;
  }
  const staticMember = createStaticGetter('cmpMeta', convertValueToLiteral(cmpMeta));
  addStaticStyleGetterWithinClass(classMembers, cmp);
  classMembers.push(staticMember);
};
const fakeBundleIds = (cmp) => {
  if (cmp.hasMode) {
    const modes = {};
    cmp.styles.forEach(s => {
      modes[s.modeName] = '-';
    });
    return modes;
  }
  return '-';
};
const getHydrateAttrsToReflect = (cmp) => {
  return cmp.properties.reduce((attrs, prop) => {
    if (prop.reflect) {
      attrs.push([prop.name, prop.attribute]);
    }
    return attrs;
  }, []);
};

// MODULE: compiler/transformers/component-hydrate/hydrate-component.js
const updateHydrateComponentClass = (classNode, moduleFile, cmp) => {
  return ts.updateClassDeclaration(classNode, classNode.decorators, classNode.modifiers, classNode.name, classNode.typeParameters, classNode.heritageClauses, updateHydrateHostComponentMembers(classNode, moduleFile, cmp));
};
const updateHydrateHostComponentMembers = (classNode, moduleFile, cmp) => {
  const classMembers = removeStaticMetaProperties(classNode);
  updateLazyComponentConstructor(classMembers, moduleFile, cmp);
  addLazyElementGetter(classMembers, moduleFile, cmp);
  addWatchers(classMembers, cmp);
  addHydrateRuntimeCmpMeta(classMembers, cmp);
  transformHostData(classMembers, moduleFile);
  return classMembers;
};

// MODULE: compiler/transformers/component-hydrate/tranform-to-hydrate-component.js
const hydrateComponentTransform = (compilerCtx, transformOpts) => {
  return transformCtx => {
    return tsSourceFile => {
      const moduleFile = getModuleFromSourceFile(compilerCtx, tsSourceFile);
      const visitNode = (node) => {
        if (ts.isClassDeclaration(node)) {
          const cmp = getComponentMeta(compilerCtx, tsSourceFile, node);
          if (cmp != null) {
            return updateHydrateComponentClass(node, moduleFile, cmp);
          }
        }
        return ts.visitEachChild(node, visitNode, transformCtx);
      };
      tsSourceFile = ts.visitEachChild(tsSourceFile, visitNode, transformCtx);
      if (moduleFile.cmps.length > 0) {
        tsSourceFile = updateStyleImports(transformOpts, tsSourceFile, moduleFile);
      }
      if (moduleFile.isLegacy) {
        addLegacyApis(moduleFile);
      }
      tsSourceFile = addImports(transformOpts, tsSourceFile, moduleFile.coreRuntimeApis, transformOpts.coreImportPath);
      return tsSourceFile;
    };
  };
};

// MODULE: compiler/output-targets/dist-hydrate-script/bundle-hydrate-factory.js
const bundleHydrateFactory = async (config, compilerCtx, buildCtx, _build, appFactoryEntryCode) => {
  try {
    const bundleOpts = {
      id: 'hydrate',
      platform: 'hydrate',
      conditionals: getHydrateBuildConditionals(buildCtx.components),
      customTransformers: getHydrateCustomTransformer(config, compilerCtx),
      inlineDynamicImports: true,
      inputs: {
        '@app-factory-entry': '@app-factory-entry',
      },
      loader: {
        '@app-factory-entry': appFactoryEntryCode,
      },
    };
    const rollupBuild = await bundleOutput(config, compilerCtx, buildCtx, bundleOpts);
    return rollupBuild;
  }
  catch (e) {
    if (!buildCtx.hasError) {
      loadRollupDiagnostics(config, compilerCtx, buildCtx, e);
    }
  }
  return undefined;
};
const getHydrateBuildConditionals = (cmps) => {
  const build = getBuildFeatures(cmps);
  build.lazyLoad = true;
  build.hydrateServerSide = true;
  build.cssVarShim = false;
  build.hydrateClientSide = true;
  build.isDebug = false;
  build.isDev = false;
  build.isTesting = false;
  build.devTools = false;
  build.lifecycleDOMEvents = false;
  build.profile = false;
  build.hotModuleReplacement = false;
  build.updatable = true;
  build.member = true;
  build.constructableCSS = false;
  build.asyncLoading = true;
  build.appendChildSlotFix = false;
  build.slotChildNodesFix = false;
  build.cloneNodeFix = false;
  build.cssAnnotations = true;
  build.shadowDomShim = true;
  build.safari10 = false;
  build.hydratedAttribute = false;
  build.hydratedClass = true;
  build.scriptDataOpts = false;
  build.dynamicImportShim = false;
  return build;
};
const getHydrateCustomTransformer = (config, compilerCtx) => {
  const transformOpts = {
    coreImportPath: STENCIL_INTERNAL_HYDRATE_ID,
    componentExport: null,
    componentMetadata: null,
    currentDirectory: config.cwd,
    proxy: null,
    style: 'static',
  };
  return [updateStencilCoreImports(transformOpts.coreImportPath), hydrateComponentTransform(compilerCtx, transformOpts), removeCollectionImports(compilerCtx)];
};

// MODULE: compiler/output-targets/dist-hydrate-script/hydrate-factory-closure.js
const HYDRATE_APP_CLOSURE_START = `/*hydrateAppClosure start*/`;
const HYDRATE_FACTORY_INTRO = `
export function hydrateFactory($stencilWindow, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve) {
  var globalThis = $stencilWindow;
  var self = $stencilWindow;
  var top = $stencilWindow;
  var parent = $stencilWindow;

  var addEventListener = $stencilWindow.addEventListener.bind($stencilWindow);
  var alert = $stencilWindow.alert.bind($stencilWindow);
  var blur = $stencilWindow.blur.bind($stencilWindow);
  var cancelAnimationFrame = $stencilWindow.cancelAnimationFrame.bind($stencilWindow);
  var cancelIdleCallback = $stencilWindow.cancelIdleCallback.bind($stencilWindow);
  var clearInterval = $stencilWindow.clearInterval.bind($stencilWindow);
  var clearTimeout = $stencilWindow.clearTimeout.bind($stencilWindow);
  var close = () => {};
  var confirm = $stencilWindow.confirm.bind($stencilWindow);
  var dispatchEvent = $stencilWindow.dispatchEvent.bind($stencilWindow);
  var focus = $stencilWindow.focus.bind($stencilWindow);
  var getComputedStyle = $stencilWindow.getComputedStyle.bind($stencilWindow);
  var matchMedia = $stencilWindow.matchMedia.bind($stencilWindow);
  var open = $stencilWindow.open.bind($stencilWindow);
  var prompt = $stencilWindow.prompt.bind($stencilWindow);
  var removeEventListener = $stencilWindow.removeEventListener.bind($stencilWindow);
  var requestAnimationFrame = $stencilWindow.requestAnimationFrame.bind($stencilWindow);
  var requestIdleCallback = $stencilWindow.requestIdleCallback.bind($stencilWindow);
  var setInterval = $stencilWindow.setInterval.bind($stencilWindow);
  var setTimeout = $stencilWindow.setTimeout.bind($stencilWindow);

  var CharacterData = $stencilWindow.CharacterData;
  var CSS = $stencilWindow.CSS;
  var CustomEvent = $stencilWindow.CustomEvent;
  var Document = $stencilWindow.Document;
  var DocumentFragment = $stencilWindow.DocumentFragment;
  var DocumentType = $stencilWindow.DocumentType;
  var DOMTokenList = $stencilWindow.DOMTokenList;
  var Element = $stencilWindow.Element;
  var Event = $stencilWindow.Event;
  var HTMLElement = $stencilWindow.HTMLElement;
  var IntersectionObserver = $stencilWindow.IntersectionObserver;
  var KeyboardEvent = $stencilWindow.KeyboardEvent;
  var MouseEvent = $stencilWindow.MouseEvent;
  var Node = $stencilWindow.Node;
  var NodeList = $stencilWindow.NodeList;
  var URL = $stencilWindow.URL;

  var console = $stencilWindow.console;
  var customElements = $stencilWindow.customElements;
  var history = $stencilWindow.history;
  var localStorage = $stencilWindow.localStorage;
  var location = $stencilWindow.location;
  var navigator = $stencilWindow.navigator;
  var performance = $stencilWindow.performance;
  var sessionStorage = $stencilWindow.sessionStorage;

  var devicePixelRatio = $stencilWindow.devicePixelRatio;
  var innerHeight = $stencilWindow.innerHeight;
  var innerWidth = $stencilWindow.innerWidth;
  var origin = $stencilWindow.origin;
  var pageXOffset = $stencilWindow.pageXOffset;
  var pageYOffset = $stencilWindow.pageYOffset;
  var screen = $stencilWindow.screen;
  var screenLeft = $stencilWindow.screenLeft;
  var screenTop = $stencilWindow.screenTop;
  var screenX = $stencilWindow.screenX;
  var screenY = $stencilWindow.screenY;
  var scrollX = $stencilWindow.scrollX;
  var scrollY = $stencilWindow.scrollY;
  var exports = {};

  function hydrateAppClosure($stencilWindow) {
  const window = $stencilWindow;
  const document = $stencilWindow.document;
  ${HYDRATE_APP_CLOSURE_START}
`;
const HYDRATE_FACTORY_OUTRO = `
  /*hydrateAppClosure end*/
  hydrateApp(window, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve);
  }

  hydrateAppClosure($stencilWindow);
}
`;

// MODULE: compiler/output-targets/dist-hydrate-script/update-to-hydrate-components.js
const updateToHydrateComponents = async (cmps) => {
  const hydrateCmps = await Promise.all(cmps.map(updateToHydrateComponent));
  return sortBy(hydrateCmps, c => c.cmp.componentClassName);
};
const updateToHydrateComponent = async (cmp) => {
  const cmpData = {
    filePath: cmp.sourceFilePath,
    exportLine: ``,
    cmp: cmp,
    uniqueComponentClassName: ``,
    importLine: ``,
  };
  const pascalCasedClassName = dashToPascalCase(toTitleCase(cmp.tagName));
  if (cmp.componentClassName !== pascalCasedClassName) {
    cmpData.uniqueComponentClassName = pascalCasedClassName;
    cmpData.importLine = `import { ${cmp.componentClassName} as ${cmpData.uniqueComponentClassName} } from '${cmpData.filePath}';`;
  }
  else {
    cmpData.uniqueComponentClassName = cmp.componentClassName;
    cmpData.importLine = `import { ${cmpData.uniqueComponentClassName} } from '${cmpData.filePath}';`;
  }
  return cmpData;
};

// MODULE: compiler/output-targets/dist-hydrate-script/relocate-hydrate-context.js
const relocateHydrateContextConst = (config, compilerCtx, code) => {
  // for whatever reason, const Context = {};
  // is not hoisted to the correct location when bundled,
  // so manually doing it here
  // /*hydrate context start*/export const Context = {};/*hydrate context end*/
  const globalScripts = getGlobalScriptData(config, compilerCtx);
  if (globalScripts.length > 0) {
    const startCode = code.indexOf('/*hydrate context start*/');
    if (startCode > -1) {
      const endCode = code.indexOf('/*hydrate context end*/') + '/*hydrate context end*/'.length;
      const hydrateContextCode = code.substring(startCode, endCode);
      code = code.replace(hydrateContextCode, '');
      return code.replace(HYDRATE_APP_CLOSURE_START, HYDRATE_APP_CLOSURE_START + '\n  ' + hydrateContextCode);
    }
  }
  return code;
};

// MODULE: compiler/output-targets/dist-hydrate-script/write-hydrate-outputs.js
const writeHydrateOutputs = (config, compilerCtx, buildCtx, outputTargets, rollupOutput) => {
  return Promise.all(outputTargets.map(outputTarget => {
    return writeHydrateOutput(config, compilerCtx, buildCtx, outputTarget, rollupOutput);
  }));
};
const writeHydrateOutput = async (config, compilerCtx, buildCtx, outputTarget, rollupOutput) => {
  const hydratePackageName = await getHydratePackageName(config, compilerCtx);
  const hydrateAppDirPath = outputTarget.dir;
  const hydrateCoreIndexPath = join(hydrateAppDirPath, 'index.js');
  const hydrateCoreIndexDtsFilePath = join(hydrateAppDirPath, 'index.d.ts');
  const pkgJsonPath = join(hydrateAppDirPath, 'package.json');
  const pkgJsonCode = getHydratePackageJson(config, hydrateCoreIndexPath, hydrateCoreIndexDtsFilePath, hydratePackageName);
  await Promise.all([copyHydrateRunnerDts(config, compilerCtx, hydrateAppDirPath), compilerCtx.fs.writeFile(pkgJsonPath, pkgJsonCode)]);
  // always remember a path to the hydrate app that the prerendering may need later on
  buildCtx.hydrateAppFilePath = hydrateCoreIndexPath;
  await Promise.all(rollupOutput.output.map(async (output) => {
    if (output.type === 'chunk') {
      output.code = relocateHydrateContextConst(config, compilerCtx, output.code);
      const filePath = join(hydrateAppDirPath, output.fileName);
      await compilerCtx.fs.writeFile(filePath, output.code);
    }
  }));
};
const getHydratePackageJson = (config, hydrateAppFilePath, hydrateDtsFilePath, hydratePackageName) => {
  const pkg = {
    name: hydratePackageName,
    description: `${config.namespace} component hydration app.`,
    main: basename(hydrateAppFilePath),
    types: basename(hydrateDtsFilePath),
  };
  return JSON.stringify(pkg, null, 2);
};
const getHydratePackageName = async (config, compilerCtx) => {
  try {
    const rootPkgFilePath = join(config.rootDir, 'package.json');
    const pkgStr = await compilerCtx.fs.readFile(rootPkgFilePath);
    const pkgData = JSON.parse(pkgStr);
    return `${pkgData.name}/hydrate`;
  }
  catch (e) { }
  return `${config.fsNamespace}/hydrate`;
};
const copyHydrateRunnerDts = async (config, compilerCtx, hydrateAppDirPath) => {
  const packageDir = join(config.sys.getCompilerExecutingPath(), '..', '..');
  const srcHydrateDir = join(packageDir, 'internal', 'hydrate', 'runner.d.ts');
  const runnerDtsDestPath = join(hydrateAppDirPath, 'index.d.ts');
  await compilerCtx.fs.copyFile(srcHydrateDir, runnerDtsDestPath);
};

// MODULE: compiler/output-targets/dist-hydrate-script/generate-hydrate-app.js
const generateHydrateApp = async (config, compilerCtx, buildCtx, outputTargets) => {
  try {
    const packageDir = join(config.sys.getCompilerExecutingPath(), '..', '..');
    const input = join(packageDir, 'internal', 'hydrate', 'runner.mjs');
    const mockDoc = join(packageDir, 'mock-doc', 'index.mjs');
    const rollupOptions = Object.assign(Object.assign({}, config.rollupConfig.inputOptions), { input, inlineDynamicImports: true, plugins: [
        {
          name: 'hydrateAppPlugin',
          resolveId(id) {
            if (id === STENCIL_HYDRATE_FACTORY_ID) {
              return id;
            }
            if (id === STENCIL_MOCK_DOC_ID) {
              return mockDoc;
            }
            return null;
          },
          load(id) {
            if (id === STENCIL_HYDRATE_FACTORY_ID) {
              return generateHydrateFactory(config, compilerCtx, buildCtx);
            }
            return null;
          },
        },
      ], treeshake: false, onwarn: createOnWarnFn(buildCtx.diagnostics) });
    const rollupAppBuild = await rollup(rollupOptions);
    const rollupOutput = await rollupAppBuild.generate({
      format: 'cjs',
      file: 'index.js',
    });
    await writeHydrateOutputs(config, compilerCtx, buildCtx, outputTargets, rollupOutput);
  }
  catch (e) {
    if (!buildCtx.hasError) {
      loadRollupDiagnostics(config, compilerCtx, buildCtx, e);
    }
  }
};
const generateHydrateFactory = async (config, compilerCtx, buildCtx) => {
  if (!buildCtx.hasError) {
    try {
      const cmps = buildCtx.components;
      const build = getHydrateBuildConditionals$1(config, cmps);
      const appFactoryEntryCode = await generateHydrateFactoryEntry(buildCtx);
      const rollupFactoryBuild = await bundleHydrateFactory(config, compilerCtx, buildCtx, build, appFactoryEntryCode);
      if (rollupFactoryBuild != null) {
        const rollupOutput = await rollupFactoryBuild.generate({
          format: 'cjs',
          esModule: false,
          strict: false,
          intro: HYDRATE_FACTORY_INTRO,
          outro: HYDRATE_FACTORY_OUTRO,
          preferConst: false,
        });
        if (!buildCtx.hasError && rollupOutput != null && Array.isArray(rollupOutput.output)) {
          return rollupOutput.output[0].code;
        }
      }
    }
    catch (e) {
      catchError(buildCtx.diagnostics, e);
    }
  }
  return '';
};
const generateHydrateFactoryEntry = async (buildCtx) => {
  const cmps = buildCtx.components;
  const hydrateCmps = await updateToHydrateComponents(cmps);
  const s = new MagicString$1('');
  s.append(`import { hydrateApp, registerComponents, styles } from '${STENCIL_INTERNAL_HYDRATE_ID}';\n`);
  hydrateCmps.forEach(cmpData => s.append(cmpData.importLine + '\n'));
  s.append(`registerComponents([\n`);
  hydrateCmps.forEach(cmpData => {
    s.append(`  ${cmpData.uniqueComponentClassName},\n`);
  });
  s.append(`]);\n`);
  s.append(`export { hydrateApp }\n`);
  return s.toString();
};
const getHydrateBuildConditionals$1 = (config, cmps) => {
  const build = getBuildFeatures(cmps);
  build.lazyLoad = true;
  build.hydrateClientSide = false;
  build.hydrateServerSide = true;
  updateBuildConditionals(config, build);
  build.lifecycleDOMEvents = false;
  build.devTools = false;
  build.hotModuleReplacement = false;
  build.cloneNodeFix = false;
  build.appendChildSlotFix = false;
  build.slotChildNodesFix = false;
  build.safari10 = false;
  build.shadowDomShim = false;
  return build;
};

// MODULE: compiler/output-targets/dist-hydrate-script/index.js
const outputHydrateScript = async (config, compilerCtx, buildCtx) => {
  const hydrateOutputTargets = config.outputTargets.filter(isOutputTargetHydrate);
  if (hydrateOutputTargets.length > 0) {
    if (config.devMode && config.watch) {
      buildCtx.debug(`hydrate app output skipped during dev watch builds`);
      return;
    }
    const timespan = buildCtx.createTimeSpan(`generate hydrate app started`);
    await generateHydrateApp(config, compilerCtx, buildCtx, hydrateOutputTargets);
    timespan.finish(`generate hydrate app finished`);
  }
};

// MODULE: compiler/html/used-components.js
const getUsedComponents = (doc, cmps) => {
  const tags = new Set(cmps.map(cmp => cmp.tagName.toUpperCase()));
  const found = [];
  const searchComponents = (el) => {
    if (tags.has(el.tagName)) {
      found.push(el.tagName.toLowerCase());
    }
    for (let i = 0; i < el.childElementCount; i++) {
      searchComponents(el.children[i]);
    }
  };
  searchComponents(doc.documentElement);
  return found;
};

// MODULE: compiler/entries/default-bundles.js
function getDefaultBundles(config, buildCtx, cmps) {
  const userConfigEntryPoints = getUserConfigBundles(config, buildCtx, cmps);
  if (userConfigEntryPoints.length > 0) {
    return userConfigEntryPoints;
  }
  let entryPointsHints = config.entryComponentsHint;
  if (!entryPointsHints && buildCtx.indexDoc) {
    entryPointsHints = getUsedComponents(buildCtx.indexDoc, cmps);
  }
  if (!entryPointsHints) {
    return [];
  }
  const mainBundle = unique([...entryPointsHints, ...flatOne(entryPointsHints.map(resolveTag).map(cmp => cmp.dependencies))]).map(resolveTag);
  function resolveTag(tag) {
    return cmps.find(cmp => cmp.tagName === tag);
  }
  return [mainBundle];
}
function getUserConfigBundles(config, buildCtx, cmps) {
  const definedTags = new Set();
  const entryTags = config.bundles.map(b => {
    return b.components
      .map(tag => {
      const tagError = validateComponentTag(tag);
      if (tagError) {
        const err = buildError(buildCtx.diagnostics);
        err.header = `Stencil Config`;
        err.messageText = tagError;
      }
      const component = cmps.find(cmp => cmp.tagName === tag);
      if (!component) {
        const warn = buildWarn(buildCtx.diagnostics);
        warn.header = `Stencil Config`;
        warn.messageText = `Component tag "${tag}" is defined in a bundle but no matching component was found within this app or its collections.`;
      }
      if (definedTags.has(tag)) {
        const warn = buildWarn(buildCtx.diagnostics);
        warn.header = `Stencil Config`;
        warn.messageText = `Component tag "${tag}" has been defined multiple times in the "bundles" config.`;
      }
      definedTags.add(tag);
      return component;
    })
      .sort();
  });
  return entryTags;
}

// MODULE: compiler/entries/component-bundles.js
function computeUsedComponents(config, defaultBundles, allCmps) {
  if (!config.excludeUnusedDependencies) {
    return new Set(allCmps.map(c => c.tagName));
  }
  const usedComponents = new Set();
  // All components
  defaultBundles.forEach(entry => {
    entry.forEach(cmp => usedComponents.add(cmp.tagName));
  });
  allCmps.forEach(cmp => {
    if (!cmp.isCollectionDependency) {
      usedComponents.add(cmp.tagName);
    }
  });
  allCmps.forEach(cmp => {
    if (cmp.isCollectionDependency) {
      if (cmp.dependents.some(dep => usedComponents.has(dep))) {
        usedComponents.add(cmp.tagName);
      }
    }
  });
  return usedComponents;
}
function generateComponentBundles(config, buildCtx) {
  const cmps = sortBy(buildCtx.components, cmp => cmp.dependents.length);
  const defaultBundles = getDefaultBundles(config, buildCtx, cmps);
  const usedComponents = computeUsedComponents(config, defaultBundles, cmps);
  if (config.devMode) {
    return cmps.filter(c => usedComponents.has(c.tagName)).map(cmp => [cmp]);
  }
  // Visit components that are already in one of the default bundlers
  const alreadyBundled = new Set();
  defaultBundles.forEach(entry => {
    entry.forEach(cmp => alreadyBundled.add(cmp));
  });
  const bundlers = cmps.filter(cmp => usedComponents.has(cmp.tagName) && !alreadyBundled.has(cmp)).map(c => [c]);
  return [...defaultBundles, ...optimizeBundlers(bundlers, 0.6)].filter(b => b.length > 0);
}
function optimizeBundlers(bundles, threshold) {
  const cmpIndexMap = new Map();
  bundles.forEach((entry, index) => {
    entry.forEach(cmp => {
      cmpIndexMap.set(cmp.tagName, index);
    });
  });
  const visited = new Uint8Array(bundles.length);
  const matrix = bundles.map(entry => {
    const vector = new Uint8Array(bundles.length);
    entry.forEach(cmp => {
      cmp.dependents.forEach(tag => {
        const index = cmpIndexMap.get(tag);
        if (index !== undefined) {
          vector[index] = 1;
        }
      });
    });
    entry.forEach(cmp => {
      const index = cmpIndexMap.get(cmp.tagName);
      if (index !== undefined) {
        vector[index] = 0;
      }
    });
    return vector;
  });
  // resolve similar components
  const newBundles = [];
  for (let i = 0; i < matrix.length; i++) {
    // check if bundle is visited (0 means it's not)
    if (visited[i] === 0) {
      const bundle = [...bundles[i]];
      visited[i] = 1;
      for (let j = i + 1; j < matrix.length; j++) {
        if (visited[j] === 0 && computeScore(matrix[i], matrix[j]) >= threshold) {
          bundle.push(...bundles[j]);
          visited[j] = 1;
        }
      }
      newBundles.push(bundle);
    }
  }
  return newBundles;
}
function computeScore(m0, m1) {
  let total = 0;
  let match = 0;
  for (let i = 0; i < m0.length; i++) {
    if (m0[i] === 1 || m1[i] === 1) {
      total++;
      if (m0[i] === m1[i]) {
        match++;
      }
    }
  }
  return match / total;
}

// MODULE: compiler/entries/entry-modules.js
function generateEntryModules(config, buildCtx) {
  // figure out how modules and components connect
  try {
    const bundles = generateComponentBundles(config, buildCtx);
    buildCtx.entryModules = bundles.map(createEntryModule);
  }
  catch (e) {
    catchError(buildCtx.diagnostics, e);
  }
  buildCtx.debug(`generateEntryModules, ${buildCtx.entryModules.length} entryModules`);
}
function createEntryModule(cmps) {
  // generate a unique entry key based on the components within this entry module
  cmps = sortBy(cmps, c => c.tagName);
  const entryKey = cmps.map(c => c.tagName).join('.') + '.entry';
  return {
    cmps,
    entryKey,
    modeNames: getEntryModes(cmps),
  };
}
function getEntryModes(cmps) {
  const styleModeNames = [];
  cmps.forEach(cmp => {
    const cmpStyleModes = getComponentStyleModes(cmp);
    cmpStyleModes.forEach(modeName => {
      if (!styleModeNames.includes(modeName)) {
        styleModeNames.push(modeName);
      }
    });
  });
  if (styleModeNames.length === 0) {
    styleModeNames.push(DEFAULT_STYLE_MODE);
  }
  else if (styleModeNames.length > 1) {
    const index = styleModeNames.indexOf(DEFAULT_STYLE_MODE);
    if (index > -1) {
      styleModeNames.splice(index, 1);
    }
  }
  return styleModeNames.sort();
}
function getComponentStyleModes(cmpMeta) {
  if (cmpMeta && cmpMeta.styles) {
    return cmpMeta.styles.map(style => style.modeName);
  }
  return [];
}

// MODULE: compiler/output-targets/dist-lazy/lazy-build-conditionals.js
const getLazyBuildConditionals = (config, cmps) => {
  const build = getBuildFeatures(cmps);
  build.lazyLoad = true;
  build.hydrateServerSide = false;
  build.cssVarShim = config.extras.cssVarsShim;
  build.asyncQueue = config.taskQueue === 'congestionAsync';
  build.taskQueue = config.taskQueue !== 'immediate';
  build.initializeNextTick = config.outputTargets.some(isOutputTargetAngular);
  const hasHydrateOutputTargets = config.outputTargets.some(isOutputTargetHydrate);
  build.hydrateClientSide = hasHydrateOutputTargets;
  updateBuildConditionals(config, build);
  return build;
};

// MODULE: compiler/app-core/bundle-app-core.js
const generateRollupOutput = async (build, options, config, entryModules) => {
  if (build == null) {
    return null;
  }
  const { output } = await build.generate(options);
  return output.map(chunk => {
    if (chunk.type === 'chunk') {
      const isCore = Object.keys(chunk.modules).some(m => m.includes('@stencil/core'));
      return {
        type: 'chunk',
        fileName: chunk.fileName,
        code: chunk.code,
        moduleFormat: options.format,
        entryKey: chunk.name,
        imports: chunk.imports,
        isEntry: !!chunk.isEntry,
        isComponent: !!chunk.isEntry && entryModules.some(m => m.entryKey === chunk.name),
        isBrowserLoader: chunk.isEntry && chunk.name === config.fsNamespace,
        isIndex: chunk.isEntry && chunk.name === 'index',
        isCore,
      };
    }
    else {
      return {
        type: 'asset',
        fileName: chunk.fileName,
        content: chunk.source,
      };
    }
  });
};

// MODULE: compiler/output-targets/dist-lazy/write-lazy-entry-module.js
const writeLazyModule = async (config, compilerCtx, outputTargetType, destinations, entryModule, shouldHash, code, modeName, sufix) => {
  // code = replaceStylePlaceholders(entryModule.cmps, modeName, code);
  const bundleId = await getBundleId(config, entryModule.entryKey, shouldHash, code, modeName, sufix);
  const fileName = `${bundleId}.entry.js`;
  await Promise.all(destinations.map(dst => compilerCtx.fs.writeFile(join(dst, fileName), code, { outputTargetType })));
  return {
    bundleId,
    fileName,
    code,
    modeName,
  };
};
const getBundleId = async (config, entryKey, shouldHash, code, modeName, sufix) => {
  if (shouldHash) {
    const hash = await config.sys.generateContentHash(code, config.hashedFileNameLength);
    return `p-${hash}${sufix}`;
  }
  const components = entryKey.split('.');
  let bundleId = components[0];
  if (components.length > 2) {
    bundleId = `${bundleId}_${components.length - 1}`;
  }
  if (modeName !== DEFAULT_STYLE_MODE) {
    bundleId += '-' + modeName;
  }
  return bundleId + sufix;
};

// MODULE: compiler/output-targets/dist-lazy/generate-lazy-module.js
const generateLazyModules = async (config, compilerCtx, buildCtx, outputTargetType, destinations, results, sourceTarget, isBrowserBuild, sufix) => {
  if (!Array.isArray(destinations) || destinations.length === 0) {
    return [];
  }
  const shouldMinify = config.minifyJs && isBrowserBuild;
  const rollupResults = results.filter(r => r.type === 'chunk');
  const entryComponentsResults = rollupResults.filter(rollupResult => rollupResult.isComponent);
  const chunkResults = rollupResults.filter(rollupResult => !rollupResult.isComponent && !rollupResult.isEntry);
  const [bundleModules] = await Promise.all([
    Promise.all(entryComponentsResults.map(rollupResult => {
      return generateLazyEntryModule(config, compilerCtx, buildCtx, rollupResult, outputTargetType, destinations, sourceTarget, shouldMinify, isBrowserBuild, sufix);
    })),
    Promise.all(chunkResults.map(rollupResult => {
      return writeLazyChunk(config, compilerCtx, buildCtx, rollupResult, outputTargetType, destinations, sourceTarget, shouldMinify, isBrowserBuild);
    })),
  ]);
  const lazyRuntimeData = formatLazyBundlesRuntimeMeta(bundleModules);
  config.logger.debug(`Upfront metadata is ${lazyRuntimeData.length} bytes`);
  const entryResults = rollupResults.filter(rollupResult => !rollupResult.isComponent && rollupResult.isEntry);
  await Promise.all(entryResults.map(rollupResult => {
    return writeLazyEntry(config, compilerCtx, buildCtx, rollupResult, outputTargetType, destinations, lazyRuntimeData, sourceTarget, shouldMinify, isBrowserBuild);
  }));
  await writeAssets(compilerCtx, destinations, results);
  return bundleModules;
};
const writeAssets = (compilerCtx, destinations, results) => {
  return results
    .filter(r => r.type === 'asset')
    .map((r) => {
    return Promise.all(destinations.map(dest => {
      return compilerCtx.fs.writeFile(join(dest, r.fileName), r.content);
    }));
  });
};
const generateLazyEntryModule = async (config, compilerCtx, buildCtx, rollupResult, outputTargetType, destinations, sourceTarget, shouldMinify, isBrowserBuild, sufix) => {
  const entryModule = buildCtx.entryModules.find(entryModule => entryModule.entryKey === rollupResult.entryKey);
  const shouldHash = config.hashFileNames && isBrowserBuild;
  const outputs = await Promise.all(entryModule.modeNames.map(async (modeName) => {
    const code = await convertChunk(config, compilerCtx, buildCtx, sourceTarget, shouldMinify, false, isBrowserBuild, rollupResult.code, modeName);
    return writeLazyModule(config, compilerCtx, outputTargetType, destinations, entryModule, shouldHash, code, modeName, sufix);
  }));
  return {
    rollupResult,
    entryKey: rollupResult.entryKey,
    modeNames: entryModule.modeNames.slice(),
    cmps: entryModule.cmps,
    outputs: sortBy(outputs, o => o.modeName),
  };
};
const writeLazyChunk = async (config, compilerCtx, buildCtx, rollupResult, outputTargetType, destinations, sourceTarget, shouldMinify, isBrowserBuild) => {
  const code = await convertChunk(config, compilerCtx, buildCtx, sourceTarget, shouldMinify, rollupResult.isCore, isBrowserBuild, rollupResult.code);
  await Promise.all(destinations.map(dst => {
    const filePath = join(dst, rollupResult.fileName);
    return compilerCtx.fs.writeFile(filePath, code, { outputTargetType });
  }));
};
const writeLazyEntry = async (config, compilerCtx, buildCtx, rollupResult, outputTargetType, destinations, lazyRuntimeData, sourceTarget, shouldMinify, isBrowserBuild) => {
  if (isBrowserBuild && ['loader'].includes(rollupResult.entryKey)) {
    return;
  }
  let code = rollupResult.code.replace(`[/*!__STENCIL_LAZY_DATA__*/]`, `${lazyRuntimeData}`);
  code = await convertChunk(config, compilerCtx, buildCtx, sourceTarget, shouldMinify, false, isBrowserBuild, code);
  await Promise.all(destinations.map(dst => {
    const filePath = join(dst, rollupResult.fileName);
    return compilerCtx.fs.writeFile(filePath, code, { outputTargetType });
  }));
};
const formatLazyBundlesRuntimeMeta = (bundleModules) => {
  const sortedBundles = bundleModules.slice().sort(sortBundleModules);
  const lazyBundles = sortedBundles.map(formatLazyRuntimeBundle);
  return stringifyRuntimeData(lazyBundles);
};
const formatLazyRuntimeBundle = (bundleModule) => {
  let bundleId;
  if (bundleModule.outputs.length === 0) {
    throw new Error('bundleModule.output must be at least one');
  }
  if (bundleModule.outputs[0].modeName !== DEFAULT_STYLE_MODE) {
    // more than one mode, object of bundleIds with the mode as a key
    bundleId = {};
    bundleModule.outputs.forEach(output => {
      bundleId[output.modeName] = output.bundleId;
    });
  }
  else {
    // only one default mode, bundleId is a string
    bundleId = bundleModule.outputs[0].bundleId;
  }
  const bundleCmps = bundleModule.cmps.slice().sort(sortBundleComponents);
  return [bundleId, bundleCmps.map(cmp => formatComponentRuntimeMeta(cmp, true))];
};
const sortBundleModules = (a, b) => {
  const aDependents = a.cmps.reduce((dependents, cmp) => {
    dependents.push(...cmp.dependents);
    return dependents;
  }, []);
  const bDependents = b.cmps.reduce((dependents, cmp) => {
    dependents.push(...cmp.dependents);
    return dependents;
  }, []);
  if (a.cmps.some(cmp => bDependents.includes(cmp.tagName)))
    return 1;
  if (b.cmps.some(cmp => aDependents.includes(cmp.tagName)))
    return -1;
  const aDependencies = a.cmps.reduce((dependencies, cmp) => {
    dependencies.push(...cmp.dependencies);
    return dependencies;
  }, []);
  const bDependencies = b.cmps.reduce((dependencies, cmp) => {
    dependencies.push(...cmp.dependencies);
    return dependencies;
  }, []);
  if (a.cmps.some(cmp => bDependencies.includes(cmp.tagName)))
    return -1;
  if (b.cmps.some(cmp => aDependencies.includes(cmp.tagName)))
    return 1;
  if (aDependents.length < bDependents.length)
    return -1;
  if (aDependents.length > bDependents.length)
    return 1;
  if (aDependencies.length > bDependencies.length)
    return -1;
  if (aDependencies.length < bDependencies.length)
    return 1;
  const aTags = a.cmps.map(cmp => cmp.tagName);
  const bTags = b.cmps.map(cmp => cmp.tagName);
  if (aTags.length > bTags.length)
    return -1;
  if (aTags.length < bTags.length)
    return 1;
  const aTagsStr = aTags.sort().join('.');
  const bTagsStr = bTags.sort().join('.');
  if (aTagsStr < bTagsStr)
    return -1;
  if (aTagsStr > bTagsStr)
    return 1;
  return 0;
};
const sortBundleComponents = (a, b) => {
  // <cmp-a>
  //   <cmp-b>
  //   <cmp-c></cmp-c>
  //   </cmp-b>
  // </cmp-a>
  // cmp-c is a dependency of cmp-a and cmp-b
  // cmp-c is a directDependency of cmp-b
  // cmp-a is a dependant of cmp-b and cmp-c
  // cmp-a is a directDependant of cmp-b
  if (a.directDependents.includes(b.tagName))
    return 1;
  if (b.directDependents.includes(a.tagName))
    return -1;
  if (a.directDependencies.includes(b.tagName))
    return 1;
  if (b.directDependencies.includes(a.tagName))
    return -1;
  if (a.dependents.includes(b.tagName))
    return 1;
  if (b.dependents.includes(a.tagName))
    return -1;
  if (a.dependencies.includes(b.tagName))
    return 1;
  if (b.dependencies.includes(a.tagName))
    return -1;
  if (a.dependents.length < b.dependents.length)
    return -1;
  if (a.dependents.length > b.dependents.length)
    return 1;
  if (a.dependencies.length > b.dependencies.length)
    return -1;
  if (a.dependencies.length < b.dependencies.length)
    return 1;
  if (a.tagName < b.tagName)
    return -1;
  if (a.tagName > b.tagName)
    return 1;
  return 0;
};
const convertChunk = async (config, compilerCtx, buildCtx, sourceTarget, shouldMinify, isCore, isBrowserBuild, code, modeName) => {
  const inlineHelpers = isBrowserBuild || !hasDependency(buildCtx, 'tslib');
  const optimizeResults = await optimizeModule(config, compilerCtx, {
    input: code,
    isCore,
    sourceTarget,
    inlineHelpers,
    minify: shouldMinify,
    modeName,
  });
  buildCtx.diagnostics.push(...optimizeResults.diagnostics);
  if (typeof optimizeResults.output === 'string') {
    code = optimizeResults.output;
  }
  return code;
};

// MODULE: compiler/output-targets/dist-lazy/generate-cjs.js
const generateCjs = async (config, compilerCtx, buildCtx, rollupBuild, outputTargets) => {
  const cjsOutputs = outputTargets.filter(o => !!o.cjsDir);
  if (cjsOutputs.length > 0) {
    const outputTargetType = cjsOutputs[0].type;
    const esmOpts = {
      format: 'cjs',
      entryFileNames: '[name].cjs.js',
      assetFileNames: '[name]-[hash][extname]',
      preferConst: true,
    };
    const results = await generateRollupOutput(rollupBuild, esmOpts, config, buildCtx.entryModules);
    if (results != null) {
      const destinations = cjsOutputs.map(o => o.cjsDir);
      await generateLazyModules(config, compilerCtx, buildCtx, outputTargetType, destinations, results, 'es2017', false, '.cjs');
      await generateShortcuts(compilerCtx, results, cjsOutputs);
    }
  }
};
const generateShortcuts = (compilerCtx, rollupResult, outputTargets) => {
  const indexFilename = rollupResult.find(r => r.type === 'chunk' && r.isIndex).fileName;
  return Promise.all(outputTargets.map(async (o) => {
    if (o.cjsIndexFile) {
      const entryPointPath = join(o.cjsDir, indexFilename);
      const relativePath = relativeImport(o.cjsIndexFile, entryPointPath);
      const shortcutContent = `module.exports = require('${relativePath}');\n`;
      await compilerCtx.fs.writeFile(o.cjsIndexFile, shortcutContent, { outputTargetType: o.type });
    }
  }));
};

// MODULE: compiler/output-targets/dist-lazy/generate-esm-browser.js
const generateEsmBrowser = async (config, compilerCtx, buildCtx, rollupBuild, outputTargets) => {
  const esmOutputs = outputTargets.filter(o => !!o.esmDir && !!o.isBrowserBuild);
  if (esmOutputs.length) {
    const outputTargetType = esmOutputs[0].type;
    const esmOpts = {
      format: 'es',
      entryFileNames: '[name].esm.js',
      chunkFileNames: config.hashFileNames ? 'p-[hash].js' : '[name]-[hash].js',
      assetFileNames: config.hashFileNames ? 'p-[hash][extname]' : '[name]-[hash][extname]',
      preferConst: true,
    };
    if (config.extras.dynamicImportShim) {
      // for Edge 18 and below
      esmOpts.dynamicImportFunction = getDynamicImportFunction(config.fsNamespace);
    }
    const output = await generateRollupOutput(rollupBuild, esmOpts, config, buildCtx.entryModules);
    if (output != null) {
      const es2017destinations = esmOutputs.map(o => o.esmDir);
      const componentBundle = await generateLazyModules(config, compilerCtx, buildCtx, outputTargetType, es2017destinations, output, 'es2017', true, '');
      return componentBundle;
    }
  }
  return undefined;
};

// MODULE: compiler/output-targets/dist-lazy/generate-esm.js
const generateEsm = async (config, compilerCtx, buildCtx, rollupBuild, outputTargets) => {
  const esmEs5Outputs = config.buildEs5 ? outputTargets.filter(o => !!o.esmEs5Dir && !o.isBrowserBuild) : [];
  const esmOutputs = outputTargets.filter(o => !!o.esmDir && !o.isBrowserBuild);
  if (esmOutputs.length + esmEs5Outputs.length > 0) {
    const esmOpts = {
      format: 'es',
      entryFileNames: '[name].mjs',
      assetFileNames: '[name]-[hash][extname]',
      preferConst: true,
    };
    const outputTargetType = esmOutputs[0].type;
    const output = await generateRollupOutput(rollupBuild, esmOpts, config, buildCtx.entryModules);
    if (output != null) {
      const es2017destinations = esmOutputs.map(o => o.esmDir);
      await generateLazyModules(config, compilerCtx, buildCtx, outputTargetType, es2017destinations, output, 'es2017', false, '');
      const es5destinations = esmEs5Outputs.map(o => o.esmEs5Dir);
      await generateLazyModules(config, compilerCtx, buildCtx, outputTargetType, es5destinations, output, 'es5', false, '');
      await copyPolyfills(config, compilerCtx, esmOutputs);
      await generateShortcuts$1(config, compilerCtx, outputTargets, output);
    }
  }
};
const copyPolyfills = async (config, compilerCtx, outputTargets) => {
  const destinations = outputTargets.filter(o => o.polyfills).map(o => o.esmDir);
  if (destinations.length === 0) {
    return;
  }
  const src = join(config.sys.getCompilerExecutingPath(), '..', '..', 'internal', 'client', 'polyfills');
  const files = await compilerCtx.fs.readdir(src);
  await Promise.all(destinations.map(dest => {
    return Promise.all(files.map(f => {
      return compilerCtx.fs.copyFile(f.absPath, join(dest, 'polyfills', f.relPath));
    }));
  }));
};
const generateShortcuts$1 = (config, compilerCtx, outputTargets, rollupResult) => {
  const indexFilename = rollupResult.find(r => r.type === 'chunk' && r.isIndex).fileName;
  return Promise.all(outputTargets.map(async (o) => {
    if (o.esmDir && o.esmIndexFile) {
      const entryPointPath = config.buildEs5 && o.esmEs5Dir ? join(o.esmEs5Dir, indexFilename) : join(o.esmDir, indexFilename);
      const relativePath = relativeImport(o.esmIndexFile, entryPointPath);
      const shortcutContent = `export * from '${relativePath}';`;
      await compilerCtx.fs.writeFile(o.esmIndexFile, shortcutContent, { outputTargetType: o.type });
    }
  }));
};

// MODULE: compiler/app-core/app-polyfills.js
const getClientPolyfill = async (config, compilerCtx, polyfillFile) => {
  const polyfillFilePath = join(config.sys.getCompilerExecutingPath(), '..', '..', 'internal', 'client', 'polyfills', polyfillFile);
  return compilerCtx.fs.readFile(polyfillFilePath);
};
const getAppBrowserCorePolyfills = async (config, compilerCtx) => {
  // read all the polyfill content, in this particular order
  const polyfills = INLINE_POLYFILLS.slice();
  if (config.extras.cssVarsShim) {
    polyfills.push(INLINE_CSS_SHIM);
  }
  const results = await Promise.all(polyfills.map(polyfillFile => getClientPolyfill(config, compilerCtx, polyfillFile)));
  // concat the polyfills
  return results.join('\n').trim();
};
// order of the polyfills matters!! test test test
// actual source of the polyfills are found in /src/client/polyfills/
const INLINE_POLYFILLS = ['promise.js', 'core-js.js', 'dom.js', 'es5-html-element.js', 'system.js'];
const INLINE_CSS_SHIM = 'css-shim.js';

// MODULE: compiler/output-targets/dist-lazy/generate-system.js
const generateSystem = async (config, compilerCtx, buildCtx, rollupBuild, outputTargets) => {
  const systemOutputs = outputTargets.filter(o => !!o.systemDir);
  if (systemOutputs.length > 0) {
    const esmOpts = {
      format: 'system',
      entryFileNames: config.hashFileNames ? 'p-[hash].system.js' : '[name].system.js',
      chunkFileNames: config.hashFileNames ? 'p-[hash].system.js' : '[name]-[hash].system.js',
      assetFileNames: config.hashFileNames ? 'p-[hash][extname]' : '[name]-[hash][extname]',
      preferConst: true,
    };
    const results = await generateRollupOutput(rollupBuild, esmOpts, config, buildCtx.entryModules);
    if (results != null) {
      const destinations = systemOutputs.map(o => o.esmDir);
      await generateLazyModules(config, compilerCtx, buildCtx, outputTargets[0].type, destinations, results, 'es5', true, '.system');
      await generateSystemLoaders(config, compilerCtx, results, systemOutputs);
    }
  }
};
const generateSystemLoaders = (config, compilerCtx, rollupResult, systemOutputs) => {
  const loaderFilename = rollupResult.find(r => r.type === 'chunk' && r.isBrowserLoader).fileName;
  return Promise.all(systemOutputs.map(o => writeSystemLoader(config, compilerCtx, loaderFilename, o)));
};
const writeSystemLoader = async (config, compilerCtx, loaderFilename, outputTarget) => {
  if (outputTarget.systemLoaderFile) {
    const entryPointPath = join(outputTarget.systemDir, loaderFilename);
    const relativePath = relativeImport(outputTarget.systemLoaderFile, entryPointPath);
    const loaderContent = await getSystemLoader(config, compilerCtx, relativePath, outputTarget.polyfills);
    await compilerCtx.fs.writeFile(outputTarget.systemLoaderFile, loaderContent, { outputTargetType: outputTarget.type });
  }
};
const getSystemLoader = async (config, compilerCtx, corePath, includePolyfills) => {
  const polyfills = includePolyfills ? await getAppBrowserCorePolyfills(config, compilerCtx) : '/* polyfills excluded */';
  return `
'use strict';
(function () {
  var currentScript = document.currentScript;

  // Safari 10 support type="module" but still download and executes the nomodule script
  if (!currentScript || !currentScript.hasAttribute('nomodule') || !('onbeforeload' in currentScript)) {

  ${polyfills}

  // Figure out currentScript (for IE11, since it does not support currentScript)
  var regex = /\\/${config.fsNamespace}(\\.esm)?\\.js($|\\?|#)/;
  var scriptElm = currentScript || Array.from(document.querySelectorAll('script')).find(function(s) {
    return regex.test(s.src) || s.getAttribute('data-stencil-namespace') === "${config.fsNamespace}";
  });

  var resourcesUrl = scriptElm ? scriptElm.getAttribute('data-resources-url') || scriptElm.src : '';
  var start = function() {
    var url = new URL('${corePath}', resourcesUrl);
    System.import(url.href);
  };

  if (window.__cssshim) {
    window.__cssshim.i().then(start);
  } else {
    start();
  }

  // Note: using .call(window) here because the self-executing function needs
  // to be scoped to the window object for the ES6Promise polyfill to work
  }
}).call(window);
`;
};

// MODULE: compiler/entries/component-graph.js
const generateModuleGraph = (cmps, bundleModules) => {
  const cmpMap = new Map();
  cmps.forEach(cmp => {
    const bundle = bundleModules.find(b => b.cmps.includes(cmp));
    if (bundle) {
      // add default case for no mode
      cmpMap.set(getScopeId(cmp.tagName), bundle.rollupResult.imports);
      // add modes cases
      bundle.outputs.map(o => {
        cmpMap.set(getScopeId(cmp.tagName, o.modeName), [...bundle.rollupResult.imports, o.fileName]);
      });
    }
  });
  return cmpMap;
};

// MODULE: compiler/output-targets/dist-lazy/lazy-output.js
const outputLazy = async (config, compilerCtx, buildCtx) => {
  const outputTargets = config.outputTargets.filter(isOutputTargetDistLazy);
  if (outputTargets.length === 0) {
    return;
  }
  const timespan = buildCtx.createTimeSpan(`generate lazy started`);
  try {
    // const criticalBundles = getCriticalPath(buildCtx);
    const bundleOpts = {
      id: 'lazy',
      platform: 'client',
      conditionals: getLazyBuildConditionals(config, buildCtx.components),
      customTransformers: getLazyCustomTransformer(config, compilerCtx),
      inputs: {
        [config.fsNamespace]: LAZY_BROWSER_ENTRY_ID,
        loader: LAZY_EXTERNAL_ENTRY_ID,
        index: USER_INDEX_ENTRY_ID,
      },
      loader: {
        [LAZY_EXTERNAL_ENTRY_ID]: getLazyEntry(false),
        [LAZY_BROWSER_ENTRY_ID]: getLazyEntry(true),
      },
    };
    // we've got the compiler context filled with app modules and collection dependency modules
    // figure out how all these components should be connected
    generateEntryModules(config, buildCtx);
    buildCtx.entryModules.forEach(entryModule => {
      bundleOpts.inputs[entryModule.entryKey] = entryModule.entryKey;
    });
    const rollupBuild = await bundleOutput(config, compilerCtx, buildCtx, bundleOpts);
    if (rollupBuild != null) {
      const [componentBundle] = await Promise.all([
        generateEsmBrowser(config, compilerCtx, buildCtx, rollupBuild, outputTargets),
        generateEsm(config, compilerCtx, buildCtx, rollupBuild, outputTargets),
        generateSystem(config, compilerCtx, buildCtx, rollupBuild, outputTargets),
        generateCjs(config, compilerCtx, buildCtx, rollupBuild, outputTargets),
      ]);
      await generateLegacyLoader(config, compilerCtx, outputTargets);
      if (componentBundle != null) {
        buildCtx.componentGraph = generateModuleGraph(buildCtx.components, componentBundle);
      }
    }
  }
  catch (e) {
    catchError(buildCtx.diagnostics, e);
  }
  timespan.finish(`generate lazy finished`);
};
const getLazyCustomTransformer = (config, compilerCtx) => {
  const transformOpts = {
    coreImportPath: STENCIL_INTERNAL_CLIENT_ID,
    componentExport: 'lazy',
    componentMetadata: null,
    currentDirectory: config.cwd,
    proxy: null,
    style: 'static',
  };
  return [updateStencilCoreImports(transformOpts.coreImportPath), lazyComponentTransform(compilerCtx, transformOpts), removeCollectionImports(compilerCtx)];
};
const getLazyEntry = (isBrowser) => {
  const s = new MagicString$1(``);
  s.append(`import { bootstrapLazy } from '${STENCIL_INTERNAL_CLIENT_ID}';\n`);
  if (isBrowser) {
    s.append(`import { patchBrowser } from '${STENCIL_INTERNAL_CLIENT_ID}';\n`);
    s.append(`import { globalScripts } from '${STENCIL_APP_GLOBALS_ID}';\n`);
    s.append(`patchBrowser().then(options => {\n`);
    s.append(`  globalScripts();\n`);
    s.append(`  return bootstrapLazy([/*!__STENCIL_LAZY_DATA__*/], options);\n`);
    s.append(`});\n`);
  }
  else {
    s.append(`import { patchEsm } from '${STENCIL_INTERNAL_CLIENT_ID}';\n`);
    s.append(`import { globalScripts } from '${STENCIL_APP_GLOBALS_ID}';\n`);
    s.append(`export const defineCustomElements = (win, options) => patchEsm().then(() => {\n`);
    s.append(`  globalScripts();\n`);
    s.append(`  return bootstrapLazy([/*!__STENCIL_LAZY_DATA__*/], options);\n`);
    s.append(`});\n`);
  }
  return s.toString();
};
const generateLegacyLoader = (config, compilerCtx, outputTargets) => {
  return Promise.all(outputTargets.map(async (o) => {
    if (o.legacyLoaderFile) {
      const loaderContent = getLegacyLoader(config);
      await compilerCtx.fs.writeFile(o.legacyLoaderFile, loaderContent, { outputTargetType: o.type });
    }
  }));
};
const getLegacyLoader = (config) => {
  const namespace = config.fsNamespace;
  return `
(function(doc){
  var scriptElm = doc.scripts[doc.scripts.length - 1];
  var warn = ['[${namespace}] Deprecated script, please remove: ' + scriptElm.outerHTML];

  warn.push('To improve performance it is recommended to set the differential scripts in the head as follows:')

  var parts = scriptElm.src.split('/');
  parts.pop();
  parts.push('${namespace}');
  var url = parts.join('/');

  var scriptElm = doc.createElement('script');
  scriptElm.setAttribute('type', 'module');
  scriptElm.src = url + '/${namespace}.esm.js';
  warn.push(scriptElm.outerHTML);
  scriptElm.setAttribute('data-stencil-namespace', '${namespace}');
  doc.head.appendChild(scriptElm);

  scriptElm = doc.createElement('script');
  scriptElm.setAttribute('nomodule', '');
  scriptElm.src = url + '/${namespace}.js';
  warn.push(scriptElm.outerHTML);
  scriptElm.setAttribute('data-stencil-namespace', '${namespace}');
  doc.head.appendChild(scriptElm);

  console.warn(warn.join('\\n'));

})(document);`;
};

// MODULE: compiler/output-targets/output-lazy-loader.js
const outputLazyLoader = async (config, compilerCtx) => {
  const outputTargets = config.outputTargets.filter(isOutputTargetDistLazyLoader);
  if (outputTargets.length === 0) {
    return;
  }
  await Promise.all(outputTargets.map(o => generateLoader(config, compilerCtx, o)));
};
const generateLoader = async (config, compilerCtx, outputTarget) => {
  const loaderPath = outputTarget.dir;
  const es2017Dir = outputTarget.esmDir;
  const es5Dir = outputTarget.esmEs5Dir || es2017Dir;
  const cjsDir = outputTarget.cjsDir;
  if (!loaderPath || !es2017Dir || !cjsDir) {
    return;
  }
  const es5HtmlElement = await getClientPolyfill(config, compilerCtx, 'es5-html-element.js');
  const packageJsonContent = JSON.stringify({
    'name': config.fsNamespace + '-loader',
    'typings': './index.d.ts',
    'module': './index.mjs',
    'main': './index.cjs.js',
    'node:main': './node-main.js',
    'jsnext:main': './index.es2017.mjs',
    'es2015': './index.es2017.mjs',
    'es2017': './index.es2017.mjs',
    'unpkg': './cdn.js',
  }, null, 2);
  const es5EntryPoint = join(es5Dir, 'loader.mjs');
  const es2017EntryPoint = join(es2017Dir, 'loader.mjs');
  const polyfillsEntryPoint = join(es2017Dir, 'polyfills/index.js');
  const cjsEntryPoint = join(cjsDir, 'loader.cjs.js');
  const polyfillsExport = `export * from '${normalizePath(relative(loaderPath, polyfillsEntryPoint))}';`;
  const indexContent = `
${es5HtmlElement}
${polyfillsExport}
export * from '${normalizePath(relative(loaderPath, es5EntryPoint))}';
`;
  const indexES2017Content = `
${polyfillsExport}
export * from '${normalizePath(relative(loaderPath, es2017EntryPoint))}';
`;
  const indexCjsContent = `
module.exports = require('${normalizePath(relative(loaderPath, cjsEntryPoint))}');
module.exports.applyPolyfills = function() { return Promise.resolve() };
`;
  const nodeMainContent = `
module.exports.applyPolyfills = function() { return Promise.resolve() };
module.exports.defineCustomElements = function() { return Promise.resolve() };
`;
  const indexDtsPath = join(loaderPath, 'index.d.ts');
  await Promise.all([
    compilerCtx.fs.writeFile(join(loaderPath, 'package.json'), packageJsonContent),
    compilerCtx.fs.writeFile(join(loaderPath, 'index.d.ts'), generateIndexDts(indexDtsPath, outputTarget.componentDts)),
    compilerCtx.fs.writeFile(join(loaderPath, 'index.mjs'), indexContent),
    compilerCtx.fs.writeFile(join(loaderPath, 'index.cjs.js'), indexCjsContent),
    compilerCtx.fs.writeFile(join(loaderPath, 'cdn.js'), indexCjsContent),
    compilerCtx.fs.writeFile(join(loaderPath, 'index.es2017.mjs'), indexES2017Content),
    compilerCtx.fs.writeFile(join(loaderPath, 'node-main.js'), nodeMainContent),
  ]);
};
const generateIndexDts = (indexDtsPath, componentsDtsPath) => {
  return `
export * from '${relativeImport(indexDtsPath, componentsDtsPath, '.d.ts')}';
export interface CustomElementsDefineOptions {
  exclude?: string[];
  resourcesUrl?: string;
  syncQueue?: boolean;
  jmp?: (c: Function) => any;
  raf?: (c: FrameRequestCallback) => number;
  ael?: (el: EventTarget, eventName: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions) => void;
  rel?: (el: EventTarget, eventName: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions) => void;
}
export declare function defineCustomElements(win?: Window, opts?: CustomElementsDefineOptions): Promise<void>;
export declare function applyPolyfills(): Promise<void>;
`;
};

// MODULE: compiler/app-core/app-es5-disabled.js
const generateEs5DisabledMessage = async (config, compilerCtx, outputTarget) => {
  // not doing an es5 right now
  // but it's possible during development the user
  // tests on a browser that doesn't support es2017
  const fileName = `${config.fsNamespace}.js`;
  const filePath = join(outputTarget.buildDir, fileName);
  await compilerCtx.fs.writeFile(filePath, getDisabledMessageScript(config));
  return fileName;
};
const getDisabledMessageScript = (config) => {
  const style = `
<style>
body {
  display: block !important;
  font-family: sans-serif;
  padding: 20px;
  line-height:22px;
}
h1 {
  font-size: 18px;
}
h2 {
  font-size: 14px;
  margin-top: 40px;
}
</style>
`;
  const htmlLegacy = `
  ${style}

  <h1>This Stencil app is disabled for this browser.</h1>

  <h2>Developers:</h2>
  <ul>
  <li>ES5 builds are disabled <strong>during development</strong> to take advantage of 2x faster build times.</li>
  <li>Please see the example below or our <a href="https://stenciljs.com/docs/stencil-config" target="_blank" rel="noopener noreferrer">config docs</a> if you would like to develop on a browser that does not fully support ES2017 and custom elements.</li>
  <li>Note that by default, ES5 builds and polyfills are enabled during production builds.</li>
  <li>When testing browsers it is recommended to always test in production mode, and ES5 builds should always be enabled during production builds.</li>
  <li><em>This is only an experiment and if it slows down app development then we will revert this and enable ES5 builds during dev.</em></li>
  </ul>


  <h2>Enabling ES5 builds during development:</h2>
  <pre>
  <code>npm run dev --es5</code>
  </pre>
  <p>For stencil-component-starter, use:</p>
  <pre>
  <code>npm start --es5</code>
  </pre>


  <h2>Enabling full production builds during development:</h2>
  <pre>
  <code>npm run dev --prod</code>
  </pre>
  <p>For stencil-component-starter, use:</p>
  <pre>
  <code>npm start --prod</code>
  </pre>

  <h2>Current Browser's Support:</h2>
  <ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">ES Module Imports</a>: <span id="es-modules-test"></span></li>
  <li><a href="http://2ality.com/2017/01/import-operator.html">ES Dynamic Imports</a>: <span id="es-dynamic-modules-test"></span></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements">Custom Elements</a>: <span id="custom-elements-test"></span></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">Shadow DOM</a>: <span id="shadow-dom-test"></span></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">fetch</a>: <span id="fetch-test"></span></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS Variables</a>: <span id="css-variables-test"></span></li>
  </ul>

  <h2>Current Browser:</h2>
  <pre>
  <code id="current-browser-output"></code>
  </pre>
  `;
  const htmlUpdate = `
  ${style}

  <h1>Update src/index.html</h1>

  <p>Stencil recently changed how scripts are loaded in order to improve performance.</p>

  <h2>BEFORE:</h2>
  <p>Previously, a single script was included that handled loading the correct JavaScript based on browser support.</p>
  <pre>
  <code>${escapeHtml(`<script src="/build/${config.fsNamespace}.js"></script>
`)}</code>
  </pre>

  <h2 style="margin-top:0">AFTER:</h2>
  <p>The index.html should now include two scripts using the modern ES Module script pattern.
  Note that only one file will actually be requested and loaded based on the browser's native support for ES Modules.
  For more info, please see <a href="https://developers.google.com/web/fundamentals/primers/modules#browser" target="_blank" rel="noopener noreferrer">Using JavaScript modules on the web</a>.
  </p>
  <pre>
  <code>${escapeHtml(`<script`)} <span style="background:yellow">type="module"</span> src="/build/${config.fsNamespace}<span style="background:yellow">.esm</span>.js"${escapeHtml(`></script>`)}
  ${escapeHtml(`<script`)} <span style="background:yellow">nomodule</span> ${escapeHtml(`src="/build/${config.fsNamespace}.js"></script>`)}</code>
  </pre>
  `;
  return `
(function() {
  function checkSupport() {
  if (!document.body) {
    setTimeout(checkSupport);
    return;
  }
  function supportsDynamicImports() {
    try {
    new Function('import("")');
    return true;
    } catch (e) {}
    return false;
  }
  var supportsEsModules = !!('noModule' in document.createElement('script'));

  if (!supportsEsModules) {
    document.body.innerHTML = '${inlineHTML(htmlLegacy)}';

    document.getElementById('current-browser-output').textContent = window.navigator.userAgent;
    document.getElementById('es-modules-test').textContent = supportsEsModules;
    document.getElementById('es-dynamic-modules-test').textContent = supportsDynamicImports();
    document.getElementById('shadow-dom-test').textContent = !!(document.head.attachShadow);
    document.getElementById('custom-elements-test').textContent = !!(window.customElements);
    document.getElementById('css-variables-test').textContent = !!(window.CSS && window.CSS.supports && window.CSS.supports('color', 'var(--c)'));
    document.getElementById('fetch-test').textContent = !!(window.fetch);
  } else {
    document.body.innerHTML = '${inlineHTML(htmlUpdate)}';
  }
  }

  setTimeout(checkSupport);
})();`;
};
const inlineHTML = (html) => {
  return html
    .replace(/\n/g, '\\n')
    .replace(/\'/g, `\\'`)
    .trim();
};

// MODULE: compiler/copy/hashed-copy.js
const generateHashedCopy = async (config, compilerCtx, path) => {
  try {
    const content = await compilerCtx.fs.readFile(path);
    const hash = await config.sys.generateContentHash(content, config.hashedFileNameLength);
    const hashedFileName = `p-${hash}${extname(path)}`;
    await compilerCtx.fs.writeFile(join(dirname(path), hashedFileName), content);
    return hashedFileName;
  }
  catch (e) { }
  return undefined;
};

// MODULE: compiler/html/html-utils.js
const getAbsoluteBuildDir = (outputTarget) => {
  const relativeBuildDir = relative(outputTarget.dir, outputTarget.buildDir);
  return join('/', relativeBuildDir) + '/';
};

// MODULE: compiler/service-worker/generate-sw.js
const generateServiceWorker = async (config, buildCtx, workbox, outputTarget) => {
  const serviceWorker = await getServiceWorker(outputTarget);
  if (serviceWorker.unregister) {
    await config.sys.writeFile(serviceWorker.swDest, SELF_UNREGISTER_SW);
  }
  else if (serviceWorker.swSrc) {
    return Promise.all([copyLib(buildCtx, outputTarget, workbox), injectManifest(buildCtx, serviceWorker, workbox)]);
  }
  else {
    return generateSW(buildCtx, serviceWorker, workbox);
  }
};
const copyLib = async (buildCtx, outputTarget, workbox) => {
  const timeSpan = buildCtx.createTimeSpan(`copy service worker library started`, true);
  try {
    await workbox.copyWorkboxLibraries(outputTarget.appDir);
  }
  catch (e) {
    const d = buildWarn(buildCtx.diagnostics);
    d.messageText = 'Service worker library already exists';
  }
  timeSpan.finish(`copy service worker library finished`);
};
const generateSW = async (buildCtx, serviceWorker, workbox) => {
  const timeSpan = buildCtx.createTimeSpan(`generate service worker started`);
  try {
    await workbox.generateSW(serviceWorker);
    timeSpan.finish(`generate service worker finished`);
  }
  catch (e) {
    catchError(buildCtx.diagnostics, e);
  }
};
const injectManifest = async (buildCtx, serviceWorker, workbox) => {
  const timeSpan = buildCtx.createTimeSpan(`inject manifest into service worker started`);
  try {
    await workbox.injectManifest(serviceWorker);
    timeSpan.finish('inject manifest into service worker finished');
  }
  catch (e) {
    catchError(buildCtx.diagnostics, e);
  }
};
const hasServiceWorkerChanges = (config, buildCtx) => {
  if (config.devMode && !config.flags.serviceWorker) {
    return false;
  }
  const wwwServiceOutputs = config.outputTargets.filter(isOutputTargetWww).filter(o => o.serviceWorker && o.serviceWorker.swSrc);
  return wwwServiceOutputs.some(outputTarget => {
    return buildCtx.filesChanged.some(fileChanged => {
      if (outputTarget.serviceWorker) {
        return basename(fileChanged).toLowerCase() === basename(outputTarget.serviceWorker.swSrc).toLowerCase();
      }
      return false;
    });
  });
};
const getServiceWorker = async (outputTarget) => {
  if (!outputTarget.serviceWorker) {
    return undefined;
  }
  const serviceWorker = Object.assign({}, outputTarget.serviceWorker);
  if (serviceWorker.unregister !== true) {
    delete serviceWorker.unregister;
  }
  return serviceWorker;
};
const INDEX_ORG = 'index-org.html';
const getRegisterSW = (swUrl) => {
  return `
if ('serviceWorker' in navigator && location.protocol !== 'file:') {
  window.addEventListener('load', function() {
  navigator.serviceWorker.register('${swUrl}')
    .then(function(reg) {
    reg.onupdatefound = function() {
      var installingWorker = reg.installing;
      installingWorker.onstatechange = function() {
      if (installingWorker.state === 'installed') {
        window.dispatchEvent(new Event('swUpdate'))
      }
      }
    }
    })
    .catch(function(err) { console.error('service worker error', err) });
  });
}`;
};
const UNREGISTER_SW = `
if ('serviceWorker' in navigator && location.protocol !== 'file:') {
  // auto-unregister service worker during dev mode
  navigator.serviceWorker.getRegistration().then(function(registration) {
  if (registration) {
    registration.unregister().then(function() { location.reload(true) });
  }
  });
}
`;
const SELF_UNREGISTER_SW = `
self.addEventListener('install', function(e) {
  self.skipWaiting();
});

self.addEventListener('activate', function(e) {
  self.registration.unregister()
  .then(function() {
    return self.clients.matchAll();
  })
  .then(function(clients) {
    clients.forEach(client => client.navigate(client.url))
  });
});
`;

// MODULE: compiler/html/inline-style-sheets.js
const inlineStyleSheets = (compilerCtx, doc, maxSize, outputTarget) => {
  const globalLinks = Array.from(doc.querySelectorAll('link[rel=stylesheet]'));
  return Promise.all(globalLinks.map(async (link) => {
    const href = link.getAttribute('href');
    if (typeof href !== 'string' || !href.startsWith('/') || link.getAttribute('media') !== null) {
      return;
    }
    try {
      const fsPath = join(outputTarget.dir, href);
      const styles = await compilerCtx.fs.readFile(fsPath);
      if (styles.length > maxSize) {
        return;
      }
      // insert inline <style>
      const inlinedStyles = doc.createElement('style');
      inlinedStyles.innerHTML = styles;
      link.parentNode.insertBefore(inlinedStyles, link);
      link.remove();
    }
    catch (e) { }
  }));
};

// MODULE: compiler/html/inject-module-preloads.js
const optimizeCriticalPath = (doc, criticalBundlers, outputTarget) => {
  const buildDir = getAbsoluteBuildDir(outputTarget);
  const paths = criticalBundlers.map(path => join(buildDir, path));
  injectModulePreloads(doc, paths);
};
const injectModulePreloads = (doc, paths) => {
  const existingLinks = Array.from(doc.querySelectorAll('link[rel=modulepreload]')).map(link => link.getAttribute('href'));
  const addLinks = paths.filter(path => !existingLinks.includes(path)).map(path => createModulePreload(doc, path));
  const firstScript = doc.head.querySelector('script');
  if (firstScript) {
    addLinks.forEach(link => {
      doc.head.insertBefore(link, firstScript);
    });
  }
  else {
    addLinks.forEach(link => {
      doc.head.appendChild(link);
    });
  }
};
const createModulePreload = (doc, href) => {
  const link = doc.createElement('link');
  link.setAttribute('rel', 'modulepreload');
  link.setAttribute('href', href);
  return link;
};

// MODULE: compiler/html/inline-esm-import.js
const optimizeEsmImport = async (config, compilerCtx, doc, outputTarget) => {
  const resourcesUrl = getAbsoluteBuildDir(outputTarget);
  const entryFilename = `${config.fsNamespace}.esm.js`;
  const expectedSrc = join(resourcesUrl, entryFilename);
  const script = Array.from(doc.querySelectorAll('script')).find(s => s.getAttribute('type') === 'module' && !s.hasAttribute('crossorigin') && s.getAttribute('src') === expectedSrc);
  if (!script) {
    return false;
  }
  script.setAttribute('data-resources-url', resourcesUrl);
  script.setAttribute('data-stencil-namespace', config.fsNamespace);
  const entryPath = join(outputTarget.buildDir, entryFilename);
  const content = await compilerCtx.fs.readFile(entryPath);
  if (isString(content)) {
    // If the script is too big, instead of inlining, we hash the file and change
    // the <script> to the new location
    if (config.allowInlineScripts && content.length < MAX_JS_INLINE_SIZE) {
      // Let's try to inline, we have to fix all the relative paths of the imports
      const results = updateImportPaths(content, resourcesUrl);
      if (results.orgImportPaths.length > 0) {
        // insert inline script
        script.removeAttribute('src');
        script.innerHTML = results.code;
      }
    }
    else {
      const hashedFile = await generateHashedCopy(config, compilerCtx, entryPath);
      if (hashedFile) {
        const hashedPath = join(resourcesUrl, hashedFile);
        script.setAttribute('src', hashedPath);
        injectModulePreloads(doc, [hashedPath]);
      }
    }
    return true;
  }
  return false;
};
const updateImportPaths = (code, newDir) => {
  const orgImportPaths = [];
  const tsSourceFile = ts.createSourceFile('module.ts', code, ts.ScriptTarget.Latest);
  ts.transform(tsSourceFile, [readImportPaths(orgImportPaths)]);
  orgImportPaths.forEach(orgImportPath => {
    const newPath = replacePathDir(orgImportPath, newDir);
    if (newPath) {
      code = code.replace(`"${orgImportPath}"`, `"${newPath}"`);
      code = code.replace(`'${orgImportPath}'`, `'${newPath}'`);
    }
  });
  return {
    code,
    orgImportPaths,
  };
};
const replacePathDir = (orgImportPath, newDir) => {
  if (orgImportPath.startsWith('./') && (orgImportPath.endsWith('.js') || orgImportPath.endsWith('.mjs'))) {
    return newDir + orgImportPath.substring(2);
  }
  return null;
};
const readImportPaths = (orgImportPaths) => {
  return () => {
    return tsSourceFile => {
      const importStatements = tsSourceFile.statements
        .filter(ts.isImportDeclaration)
        .filter(s => s.moduleSpecifier != null)
        .filter(s => ts.isStringLiteral(s.moduleSpecifier) && s.moduleSpecifier.text);
      importStatements.forEach(s => {
        if (ts.isStringLiteral(s.moduleSpecifier)) {
          orgImportPaths.push(s.moduleSpecifier.text);
        }
      });
      return tsSourceFile;
    };
  };
};
// https://twitter.com/addyosmani/status/1143938175926095872
const MAX_JS_INLINE_SIZE = 1 * 1024;

// MODULE: compiler/html/update-global-styles-link.js
const updateGlobalStylesLink = (config, doc, globalScriptFilename, outputTarget) => {
  if (!globalScriptFilename) {
    return;
  }
  const buildDir = getAbsoluteBuildDir(outputTarget);
  const originalPath = join(buildDir, config.fsNamespace + '.css');
  const newPath = join(buildDir, globalScriptFilename);
  if (originalPath === newPath) {
    return;
  }
  const replacer = new RegExp(escapeRegExp(originalPath) + '$');
  Array.from(doc.querySelectorAll('link')).forEach(link => {
    const href = link.getAttribute('href');
    if (href) {
      const newHref = href.replace(replacer, newPath);
      if (newHref !== href) {
        link.setAttribute('href', newHref);
      }
    }
  });
};
const escapeRegExp = (text) => text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');

// MODULE: compiler/service-worker/service-worker-util.js
const generateServiceWorkerUrl = (outputTarget, serviceWorker) => {
  let swUrl = normalizePath(relative(outputTarget.appDir, serviceWorker.swDest));
  if (swUrl.charAt(0) !== '/') {
    swUrl = '/' + swUrl;
  }
  const baseUrl = new URL(outputTarget.baseUrl, 'http://config.stenciljs.com');
  let basePath = baseUrl.pathname;
  if (!basePath.endsWith('/')) {
    basePath += '/';
  }
  swUrl = basePath + swUrl.substring(1);
  return swUrl;
};

// MODULE: compiler/html/inject-sw-script.js
const updateIndexHtmlServiceWorker = async (config, buildCtx, doc, outputTarget) => {
  const serviceWorker = outputTarget.serviceWorker;
  if (serviceWorker !== false) {
    if ((serviceWorker && serviceWorker.unregister) || (!serviceWorker && config.devMode)) {
      injectUnregisterServiceWorker(doc);
    }
    else if (serviceWorker) {
      await injectRegisterServiceWorker(buildCtx, outputTarget, doc);
    }
  }
};
const injectRegisterServiceWorker = async (buildCtx, outputTarget, doc) => {
  const swUrl = generateServiceWorkerUrl(outputTarget, outputTarget.serviceWorker);
  const serviceWorker = getRegisterSwScript(doc, buildCtx, swUrl);
  doc.body.appendChild(serviceWorker);
};
const injectUnregisterServiceWorker = (doc) => {
  const script = doc.createElement('script');
  script.innerHTML = UNREGISTER_SW;
  doc.body.appendChild(script);
};
const getRegisterSwScript = (doc, buildCtx, swUrl) => {
  const script = doc.createElement('script');
  script.setAttribute('data-build', `${buildCtx.timestamp}`);
  script.innerHTML = getRegisterSW(swUrl);
  return script;
};

// MODULE: compiler/output-targets/output-www.js
const outputWww = async (config, compilerCtx, buildCtx) => {
  const outputTargets = config.outputTargets.filter(isOutputTargetWww);
  if (outputTargets.length === 0) {
    return;
  }
  const timespan = buildCtx.createTimeSpan(`generate www started`, true);
  const criticalBundles = getCriticalPath(buildCtx);
  await Promise.all(outputTargets.map(outputTarget => generateWww(config, compilerCtx, buildCtx, criticalBundles, outputTarget)));
  timespan.finish(`generate www finished`);
};
const getCriticalPath = (buildCtx) => {
  const componentGraph = buildCtx.componentGraph;
  if (!buildCtx.indexDoc || !componentGraph) {
    return [];
  }
  return unique(flatOne(getUsedComponents(buildCtx.indexDoc, buildCtx.components)
    .map(tagName => getScopeId(tagName))
    .map(scopeId => buildCtx.componentGraph.get(scopeId) || []))).sort();
};
const generateWww = async (config, compilerCtx, buildCtx, criticalPath, outputTarget) => {
  if (!config.buildEs5) {
    await generateEs5DisabledMessage(config, compilerCtx, outputTarget);
  }
  // Copy global styles into the build directory
  // Process
  if (buildCtx.indexDoc && outputTarget.indexHtml) {
    await generateIndexHtml(config, compilerCtx, buildCtx, criticalPath, outputTarget);
  }
  await generateHostConfig(compilerCtx, outputTarget);
};
const generateHostConfig = (compilerCtx, outputTarget) => {
  const buildDir = getAbsoluteBuildDir(outputTarget);
  const hostConfigPath = join(outputTarget.appDir, 'host.config.json');
  const hostConfigContent = JSON.stringify({
    hosting: {
      headers: [
        {
          source: join(buildDir, '/p-*'),
          headers: [
            {
              key: 'Cache-Control',
              value: 'max-age=31556952, s-maxage=31556952, immutable',
            },
          ],
        },
      ],
    },
  }, null, '  ');
  return compilerCtx.fs.writeFile(hostConfigPath, hostConfigContent, { outputTargetType: outputTarget.type });
};
const generateIndexHtml = async (config, compilerCtx, buildCtx, criticalPath, outputTarget) => {
  if (compilerCtx.hasSuccessfulBuild && !buildCtx.hasHtmlChanges) {
    // no need to rebuild index.html if there were no app file changes
    return;
  }
  // get the source index html content
  try {
    const doc = cloneDocument(buildCtx.indexDoc);
    // validateHtml(config, buildCtx, doc);
    await updateIndexHtmlServiceWorker(config, buildCtx, doc, outputTarget);
    if (!config.watch && !config.devMode) {
      const globalStylesFilename = await generateHashedCopy(config, compilerCtx, join(outputTarget.buildDir, `${config.fsNamespace}.css`));
      const scriptFound = await optimizeEsmImport(config, compilerCtx, doc, outputTarget);
      await inlineStyleSheets(compilerCtx, doc, MAX_CSS_INLINE_SIZE, outputTarget);
      updateGlobalStylesLink(config, doc, globalStylesFilename, outputTarget);
      if (scriptFound) {
        optimizeCriticalPath(doc, criticalPath, outputTarget);
      }
    }
    const indexContent = serializeNodeToHtml(doc);
    await compilerCtx.fs.writeFile(outputTarget.indexHtml, indexContent, { outputTargetType: outputTarget.type });
    if (outputTarget.serviceWorker && config.flags.prerender) {
      await compilerCtx.fs.writeFile(join(outputTarget.appDir, INDEX_ORG), indexContent, { outputTargetType: outputTarget.type });
    }
    buildCtx.debug(`generateIndexHtml, write: ${relative(config.rootDir, outputTarget.indexHtml)}`);
  }
  catch (e) {
    catchError(buildCtx.diagnostics, e);
  }
};
const MAX_CSS_INLINE_SIZE = 3 * 1024;

// MODULE: compiler/output-targets/output-collection.js
const writeCollectionManifests = async (config, compilerCtx, buildCtx, outputTargets) => {
  const collectionData = JSON.stringify(serializeCollectionManifest(config, compilerCtx, buildCtx), null, 2);
  return Promise.all(outputTargets.map(o => writeCollectionManifest(compilerCtx, collectionData, o)));
};
// this maps the json data to our internal data structure
// apping is so that the internal data structure "could"
// change, but the external user data will always use the same api
// over the top lame mapping functions is basically so we can loosly
// couple core component meta data between specific versions of the compiler
const writeCollectionManifest = async (compilerCtx, collectionData, outputTarget) => {
  // get the absolute path to the directory where the collection will be saved
  const collectionDir = normalizePath(outputTarget.collectionDir);
  // create an absolute file path to the actual collection json file
  const collectionFilePath = normalizePath(join(collectionDir, COLLECTION_MANIFEST_FILE_NAME));
  // don't bother serializing/writing the collection if we're not creating a distribution
  await compilerCtx.fs.writeFile(collectionFilePath, collectionData);
};
const serializeCollectionManifest = (config, compilerCtx, buildCtx) => {
  // create the single collection we're going to fill up with data
  const collectionManifest = {
    entries: buildCtx.moduleFiles.filter(mod => !mod.isCollectionDependency && mod.cmps.length > 0).map(mod => relative(config.srcDir, mod.jsFilePath)),
    compiler: {
      name: '@stencil/core',
      version,
      typescriptVersion,
    },
    collections: serializeCollectionDependencies(compilerCtx),
    bundles: config.bundles.map(b => ({
      components: b.components.slice().sort(),
    })),
  };
  if (config.globalScript) {
    const mod = compilerCtx.moduleMap.get(normalizePath(config.globalScript));
    if (mod) {
      collectionManifest.global = relative(config.srcDir, mod.jsFilePath);
    }
  }
  return collectionManifest;
};
const serializeCollectionDependencies = (compilerCtx) => {
  const collectionDeps = compilerCtx.collections.map(c => ({
    name: c.collectionName,
    tags: flatOne(c.moduleFiles.map(m => m.cmps))
      .map(cmp => cmp.tagName)
      .sort(),
  }));
  return sortBy(collectionDeps, item => item.name);
};

// MODULE: compiler/output-targets/dist-collection/index.js
const outputCollection = async (config, compilerCtx, buildCtx, changedModuleFiles) => {
  const outputTargets = config.outputTargets.filter(isOutputTargetDistCollection);
  if (outputTargets.length === 0) {
    return;
  }
  const timespan = buildCtx.createTimeSpan(`generate collections started`, true);
  try {
    await Promise.all(changedModuleFiles.map(async (mod) => {
      const code = mod.staticSourceFileText;
      await Promise.all(outputTargets.map(async (o) => {
        const relPath = relative(config.srcDir, mod.jsFilePath);
        const filePath = join(o.collectionDir, relPath);
        await compilerCtx.fs.writeFile(filePath, code, { outputTargetType: o.type });
      }));
    }));
    await writeCollectionManifests(config, compilerCtx, buildCtx, outputTargets);
  }
  catch (e) {
    catchError(buildCtx.diagnostics, e);
  }
  timespan.finish(`generate collections finished`);
};

// MODULE: compiler/types/stencil-types.js
const updateStencilTypesImports = (typesDir, dtsFilePath, dtsContent) => {
  const dir = dirname(dtsFilePath);
  const relPath = relative(dir, typesDir);
  let coreDtsPath = join(relPath, CORE_FILENAME);
  if (!coreDtsPath.startsWith('.')) {
    coreDtsPath = `./${coreDtsPath}`;
  }
  coreDtsPath = normalizePath(coreDtsPath);
  if (dtsContent.includes('@stencil/core')) {
    dtsContent = dtsContent.replace(/(from\s*(:?'|"))@stencil\/core\/internal('|")/g, `$1${coreDtsPath}$2`);
    dtsContent = dtsContent.replace(/(from\s*(:?'|"))@stencil\/core('|")/g, `$1${coreDtsPath}$2`);
  }
  return dtsContent;
};
const copyStencilCoreDts = async (config, compilerCtx) => {
  const typesOutputTargets = config.outputTargets.filter(isOutputTargetDistTypes).filter(o => o.typesDir);
  const srcStencilDtsPath = join(config.sys.getCompilerExecutingPath(), '..', '..', 'internal', CORE_DTS);
  const srcStencilCoreDts = await compilerCtx.fs.readFile(srcStencilDtsPath);
  return Promise.all(typesOutputTargets.map(o => {
    const coreDtsFilePath = join(o.typesDir, CORE_DTS);
    return compilerCtx.fs.writeFile(coreDtsFilePath, srcStencilCoreDts, { outputTargetType: o.type });
  }));
};
const CORE_FILENAME = `stencil-public-runtime`;
const CORE_DTS = `${CORE_FILENAME}.d.ts`;

// MODULE: compiler/types/types-utils.js
const COMPONENTS_DTS_HEADER = `
  /* eslint-disable */
  /* tslint:disable */
  /**
   * This is an autogenerated file created by the Stencil compiler.
   * It contains typing information for all components that exist in this project.
   */
`;
const sortImportNames = (a, b) => {
  const aName = a.localName.toLowerCase();
  const bName = b.localName.toLowerCase();
  if (aName < bName)
    return -1;
  if (aName > bName)
    return 1;
  if (a.localName < b.localName)
    return -1;
  if (a.localName > b.localName)
    return 1;
  return 0;
};

// MODULE: compiler/types/generate-event-types.js
const generateEventTypes = (cmpEvents) => {
  return cmpEvents.map(cmpEvent => {
    const name = `on${toTitleCase(cmpEvent.name)}`;
    const type = cmpEvent.complexType.original ? `(event: CustomEvent<${cmpEvent.complexType.original}>) => void` : `CustomEvent`;
    return {
      name,
      type,
      optional: false,
      required: false,
      public: isDocsPublic(cmpEvent.docs),
      jsdoc: getTextDocs(cmpEvent.docs),
    };
  });
};

// MODULE: compiler/types/generate-method-types.js
const generateMethodTypes = (cmpMethods) => {
  return cmpMethods.map(cmpMethod => ({
    name: cmpMethod.name,
    type: cmpMethod.complexType.signature,
    optional: false,
    required: false,
    public: isDocsPublic(cmpMethod.docs),
    jsdoc: getTextDocs(cmpMethod.docs),
  }));
};

// MODULE: compiler/types/generate-prop-types.js
const generatePropTypes = (cmpMeta) => {
  return [
    ...cmpMeta.properties.map(cmpProp => ({
      name: cmpProp.name,
      type: cmpProp.complexType.original,
      optional: cmpProp.optional,
      required: cmpProp.required,
      public: isDocsPublic(cmpProp.docs),
      jsdoc: getTextDocs(cmpProp.docs),
    })),
    ...cmpMeta.virtualProperties.map(cmpProp => ({
      name: cmpProp.name,
      type: cmpProp.type,
      optional: true,
      required: false,
      jsdoc: cmpProp.docs,
      public: true,
    })),
  ];
};

// MODULE: compiler/types/generate-component-types.js
/**
 * Generate a string based on the types that are defined within a component.
 *
 * @param cmp the metadata for the component that a type definition string is generated for
 * @param importPath the path of the component file
 */
const generateComponentTypes = (cmp) => {
  const tagName = cmp.tagName.toLowerCase();
  const tagNameAsPascal = dashToPascalCase(tagName);
  const htmlElementName = `HTML${tagNameAsPascal}Element`;
  const propAttributes = generatePropTypes(cmp);
  const methodAttributes = generateMethodTypes(cmp.methods);
  const eventAttributes = generateEventTypes(cmp.events);
  const stencilComponentAttributes = attributesToMultiLineString([...propAttributes, ...methodAttributes], false);
  const isDep = cmp.isCollectionDependency;
  const stencilComponentJSXAttributes = attributesToMultiLineString([...propAttributes, ...eventAttributes], true);
  return {
    isDep,
    tagName,
    tagNameAsPascal,
    htmlElementName,
    component: `interface ${tagNameAsPascal} {${stencilComponentAttributes}}`,
    jsx: `interface ${tagNameAsPascal} {${stencilComponentJSXAttributes}}`,
    element: `
interface ${htmlElementName} extends Components.${tagNameAsPascal}, HTMLStencilElement {}
var ${htmlElementName}: {
  prototype: ${htmlElementName};
  new (): ${htmlElementName};
};`,
  };
};
const attributesToMultiLineString = (attributes, jsxAttributes, paddingString = '') => {
  const attributesStr = sortBy(attributes, a => a.name)
    .filter(type => type.public || !jsxAttributes)
    .reduce((fullList, type) => {
    if (type.jsdoc) {
      fullList.push(`/**`);
      fullList.push(...type.jsdoc.split('\n').map(line => '  * ' + line));
      fullList.push(` */`);
    }
    const optional = jsxAttributes ? !type.required : type.optional;
    fullList.push(`'${type.name}'${optional ? '?' : ''}: ${type.type};`);
    return fullList;
  }, [])
    .map(item => `${paddingString}${item}`)
    .join(`\n`);
  return attributesStr !== '' ? `\n${attributesStr}\n` : '';
};

// MODULE: compiler/types/update-import-refs.js
/**
 * Find all referenced types by a component and add them to the importDataObj and return the newly
 * updated importDataObj
 *
 * @param importDataObj key/value of type import file, each value is an array of imported types
 * @param cmpMeta the metadata for the component that is referencing the types
 * @param filePath the path of the component file
 * @param config general config that all of stencil uses
 */
const updateReferenceTypeImports = (importDataObj, allTypes, cmp, filePath) => {
  const updateImportReferences = updateImportReferenceFactory(allTypes, filePath);
  return [...cmp.properties, ...cmp.events, ...cmp.methods]
    .filter(cmpProp => cmpProp.complexType && cmpProp.complexType.references)
    .reduce((obj, cmpProp) => {
    return updateImportReferences(obj, cmpProp.complexType.references);
  }, importDataObj);
};
const updateImportReferenceFactory = (allTypes, filePath) => {
  function getIncrementTypeName(name) {
    const counter = allTypes.get(name);
    if (counter === undefined) {
      allTypes.set(name, 1);
      return name;
    }
    allTypes.set(name, counter + 1);
    return `${name}${counter}`;
  }
  return (obj, typeReferences) => {
    Object.keys(typeReferences)
      .map(typeName => {
      return [typeName, typeReferences[typeName]];
    })
      .forEach(([typeName, type]) => {
      let importFileLocation;
      // If global then there is no import statement needed
      if (type.location === 'global') {
        return;
        // If local then import location is the current file
      }
      else if (type.location === 'local') {
        importFileLocation = filePath;
      }
      else if (type.location === 'import') {
        importFileLocation = type.path;
      }
      // If this is a relative path make it absolute
      if (importFileLocation.startsWith('.')) {
        importFileLocation = resolve(dirname(filePath), importFileLocation);
      }
      obj[importFileLocation] = obj[importFileLocation] || [];
      // If this file already has a reference to this type move on
      if (obj[importFileLocation].find(df => df.localName === typeName)) {
        return;
      }
      const newTypeName = getIncrementTypeName(typeName);
      obj[importFileLocation].push({
        localName: typeName,
        importName: newTypeName,
      });
    });
    return obj;
  };
};

// MODULE: compiler/types/generate-app-types.js
const generateAppTypes = async (config, compilerCtx, buildCtx, destination) => {
  // only gather components that are still root ts files we've found and have component metadata
  // the compilerCtx cache may still have files that may have been deleted/renamed
  const timespan = buildCtx.createTimeSpan(`generated app types started`, true);
  // Generate d.ts files for component types
  let componentTypesFileContent = await generateComponentTypesFile(config, buildCtx);
  // immediately write the components.d.ts file to disk and put it into fs memory
  let componentsDtsFilePath = getComponentsDtsSrcFilePath(config);
  if (destination !== 'src') {
    componentsDtsFilePath = resolve(destination, GENERATED_DTS);
    componentTypesFileContent = updateStencilTypesImports(destination, componentsDtsFilePath, componentTypesFileContent);
  }
  const writeResults = await compilerCtx.fs.writeFile(componentsDtsFilePath, componentTypesFileContent, { immediateWrite: true });
  const hasComponentsDtsChanged = writeResults.changedContent;
  const componentsDtsRelFileName = relative(config.rootDir, componentsDtsFilePath);
  if (hasComponentsDtsChanged) {
    config.logger.debug(`generateAppTypes: ${componentsDtsRelFileName} has changed`);
  }
  timespan.finish(`generated app types finished: ${componentsDtsRelFileName}`);
  return hasComponentsDtsChanged;
};
/**
 * Generate the component.d.ts file that contains types for all components
 * @param config the project build configuration
 * @param options compiler options from tsconfig
 */
const generateComponentTypesFile = async (config, buildCtx, _destination) => {
  let typeImportData = {};
  const allTypes = new Map();
  const needsJSXElementHack = buildCtx.components.some(cmp => cmp.isLegacy);
  const components = buildCtx.components.filter(m => !m.isCollectionDependency);
  const modules = components.map(cmp => {
    typeImportData = updateReferenceTypeImports(typeImportData, allTypes, cmp, cmp.sourceFilePath);
    return generateComponentTypes(cmp);
  });
  const jsxAugmentation = `
  declare module "@stencil/core" {
    export namespace JSX {
    interface IntrinsicElements {
      ${modules.map(m => `'${m.tagName}': LocalJSX.${m.tagNameAsPascal} & JSXBase.HTMLAttributes<${m.htmlElementName}>;`).join('\n')}
    }
    }
  }
  `;
  const jsxElementGlobal = !needsJSXElementHack
    ? ''
    : `
  // Adding a global JSX for backcompatibility with legacy dependencies
  export namespace JSX {
    export interface Element {}
  }
  `;
  const componentsFileString = `
  export namespace Components {
    ${modules
    .map(m => `${m.component}`)
    .join('\n')
    .trim()}
  }

  declare global {
    ${jsxElementGlobal}
    ${modules.map(m => m.element).join('\n')}
    interface HTMLElementTagNameMap {
    ${modules.map(m => `'${m.tagName}': ${m.htmlElementName};`).join('\n')}
    }
  }

  declare namespace LocalJSX {
    ${modules
    .map(m => `${m.jsx}`)
    .join('\n')
    .trim()}

    interface IntrinsicElements {
    ${modules.map(m => `'${m.tagName}': ${m.tagNameAsPascal};`).join('\n')}
    }
  }

  export { LocalJSX as JSX };

  ${jsxAugmentation}
  `;
  const typeImportString = Object.keys(typeImportData)
    .map(filePath => {
    const typeData = typeImportData[filePath];
    let importFilePath;
    if (isAbsolute(filePath)) {
      importFilePath = normalizePath('./' + relative(config.srcDir, filePath)).replace(/\.(tsx|ts)$/, '');
    }
    else {
      importFilePath = filePath;
    }
    return `import {
    ${typeData
      .sort(sortImportNames)
      .map(td => {
      if (td.localName === td.importName) {
        return `${td.importName},`;
      }
      else {
        return `${td.localName} as ${td.importName},`;
      }
    })
      .join('\n')}
    } from '${importFilePath}';`;
  })
    .join('\n');
  const code = `
  ${COMPONENTS_DTS_HEADER}
  import { HTMLStencilElement, JSXBase } from '@stencil/core/internal';
  ${typeImportString}
  ${componentsFileString}
  `;
  const tsSourceFile = ts.createSourceFile(GENERATED_DTS, code, ts.ScriptTarget.Latest, false);
  const tsPrinter = ts.createPrinter({
    newLine: ts.NewLineKind.LineFeed,
  });
  return tsPrinter.printFile(tsSourceFile);
};

// MODULE: compiler/types/generate-types.js
const generateTypes = async (config, compilerCtx, buildCtx, pkgData, outputTarget) => {
  if (!buildCtx.hasError && isString(pkgData.types)) {
    await generateTypesOutput(config, compilerCtx, buildCtx, pkgData, outputTarget);
    await copyStencilCoreDts(config, compilerCtx);
  }
};
const generateTypesOutput = async (config, compilerCtx, buildCtx, pkgData, outputTarget) => {
  const srcDirItems = await compilerCtx.fs.readdir(config.srcDir, { recursive: false });
  const srcDtsFiles = srcDirItems.filter(srcItem => srcItem.isFile && isDtsFile(srcItem.absPath));
  const distTypesDir = dirname(pkgData.types);
  // Copy .d.ts files from src to dist
  // In addition, all references to @stencil/core are replaced
  await Promise.all(srcDtsFiles.map(async (srcDtsFile) => {
    const relPath = relative(config.srcDir, srcDtsFile.absPath);
    const distPath = join(config.rootDir, distTypesDir, relPath);
    const originalDtsContent = await compilerCtx.fs.readFile(srcDtsFile.absPath);
    const distDtsContent = updateStencilTypesImports(outputTarget.typesDir, distPath, originalDtsContent);
    await compilerCtx.fs.writeFile(distPath, distDtsContent);
  }));
  const distPath = join(config.rootDir, distTypesDir);
  await generateAppTypes(config, compilerCtx, buildCtx, distPath);
};

// MODULE: compiler/output-targets/output-types.js
const outputTypes = async (config, compilerCtx, buildCtx) => {
  const outputTargets = config.outputTargets.filter(isOutputTargetDistTypes);
  if (outputTargets.length === 0) {
    return;
  }
  const pkgData = buildCtx.packageJson;
  if (pkgData == null) {
    return;
  }
  const timespan = buildCtx.createTimeSpan(`generate types started`, true);
  await Promise.all(outputTargets.map(outputsTarget => generateTypes(config, compilerCtx, buildCtx, pkgData, outputsTarget)));
  timespan.finish(`generate types finished`);
};

// MODULE: compiler/output-targets/index.js
const generateOutputTargets = async (config, compilerCtx, buildCtx) => {
  const timeSpan = buildCtx.createTimeSpan('generate outputs started', true);
  const changedModuleFiles = Array.from(compilerCtx.changedModules)
    .map(filename => compilerCtx.moduleMap.get(filename))
    .filter(mod => mod && !mod.isCollectionDependency);
  compilerCtx.changedModules.clear();
  invalidateRollupCaches(compilerCtx);
  await Promise.all([
    outputAngular(config, compilerCtx, buildCtx),
    outputCopy(config, compilerCtx, buildCtx),
    outputCollection(config, compilerCtx, buildCtx, changedModuleFiles),
    outputCustomElements(config, compilerCtx, buildCtx, changedModuleFiles),
    outputCustomElementsBundle(config, compilerCtx, buildCtx),
    outputHydrateScript(config, compilerCtx, buildCtx),
    outputLazyLoader(config, compilerCtx),
    outputApp(config, compilerCtx, buildCtx),
  ]);
  // must run after all the other outputs
  // since it validates files were created
  await outputDocs(config, compilerCtx, buildCtx);
  await outputTypes(config, compilerCtx, buildCtx);
  timeSpan.finish('generate outputs finished');
};
const outputApp = async (config, compilerCtx, buildCtx) => {
  await outputLazy(config, compilerCtx, buildCtx);
  await outputWww(config, compilerCtx, buildCtx);
};
const invalidateRollupCaches = (compilerCtx) => {
  const invalidatedIds = compilerCtx.changedFiles;
  compilerCtx.rollupCache.forEach((cache) => {
    cache.modules.forEach(mod => {
      if (mod.transformDependencies.some(id => invalidatedIds.has(id))) {
        mod.originalCode = null;
      }
    });
  });
};

// MODULE: compiler/entries/resolve-component-dependencies.js
function resolveComponentDependencies(cmps) {
  computeDependencies(cmps);
  computeDependents(cmps);
}
function computeDependencies(cmps) {
  const visited = new Set();
  cmps.forEach(cmp => {
    resolveTransitiveDependencies(cmp, cmps, visited);
    cmp.dependencies = unique(cmp.dependencies).sort();
  });
}
function computeDependents(cmps) {
  cmps.forEach(cmp => {
    resolveTransitiveDependents(cmp, cmps);
  });
}
function resolveTransitiveDependencies(cmp, cmps, visited) {
  if (visited.has(cmp)) {
    return cmp.dependencies;
  }
  visited.add(cmp);
  const dependencies = unique(cmp.potentialCmpRefs.filter(tagName => cmps.some(c => c.tagName === tagName)));
  cmp.dependencies = cmp.directDependencies = dependencies;
  const transitiveDeps = flatOne(dependencies.map(tagName => cmps.find(c => c.tagName === tagName)).map(c => resolveTransitiveDependencies(c, cmps, visited)));
  return (cmp.dependencies = [...dependencies, ...transitiveDeps]);
}
function resolveTransitiveDependents(cmp, cmps) {
  cmp.dependents = cmps
    .filter(c => c.dependencies.includes(cmp.tagName))
    .map(c => c.tagName)
    .sort();
  cmp.directDependents = cmps
    .filter(c => c.directDependencies.includes(cmp.tagName))
    .map(c => c.tagName)
    .sort();
}

// MODULE: compiler/transpile/run-program.js
const runTsProgram = async (config, compilerCtx, buildCtx, tsBuilder) => {
  const tsSyntactic = loadTypeScriptDiagnostics(tsBuilder.getSyntacticDiagnostics());
  const tsGlobal = loadTypeScriptDiagnostics(tsBuilder.getGlobalDiagnostics());
  const tsOptions = loadTypeScriptDiagnostics(tsBuilder.getOptionsDiagnostics());
  buildCtx.diagnostics.push(...tsSyntactic);
  buildCtx.diagnostics.push(...tsGlobal);
  buildCtx.diagnostics.push(...tsOptions);
  if (buildCtx.hasError) {
    return false;
  }
  const tsProgram = tsBuilder.getProgram();
  const tsTypeChecker = tsProgram.getTypeChecker();
  const typesOutputTarget = config.outputTargets.filter(isOutputTargetDistTypes);
  const emitCallback = (emitFilePath, data, _w, _e, tsSourceFiles) => {
    if (emitFilePath.endsWith('.js')) {
      updateModule(config, compilerCtx, buildCtx, tsSourceFiles[0], data, emitFilePath, tsTypeChecker, null);
    }
    else if (emitFilePath.endsWith('.d.ts')) {
      const relativeEmitFilepath = getRelativeDts(config, tsSourceFiles[0].fileName, emitFilePath);
      typesOutputTarget.forEach(o => {
        const distPath = join(o.typesDir, relativeEmitFilepath);
        data = updateStencilTypesImports(o.typesDir, distPath, data);
        compilerCtx.fs.writeFile(distPath, data);
      });
    }
  };
  // Emit files that changed
  tsBuilder.emit(undefined, emitCallback, undefined, false, {
    before: [convertDecoratorsToStatic(config, buildCtx.diagnostics, tsTypeChecker)],
  });
  // Finalize components metadata
  buildCtx.moduleFiles = Array.from(compilerCtx.moduleMap.values());
  buildCtx.components = getComponentsFromModules(buildCtx.moduleFiles);
  updateComponentBuildConditionals(compilerCtx.moduleMap, buildCtx.components);
  resolveComponentDependencies(buildCtx.components);
  validateUniqueTagNames(config, buildCtx);
  if (buildCtx.hasError) {
    return false;
  }
  // create the components.d.ts file and write to disk
  const hasTypesChanged = await generateAppTypes(config, compilerCtx, buildCtx, 'src');
  if (hasTypesChanged) {
    return true;
  }
  if (config.validateTypes) {
    const tsSemantic = loadTypeScriptDiagnostics(tsBuilder.getSemanticDiagnostics());
    if (config.devMode) {
      tsSemantic.forEach(semanticDiagnostic => {
        // Unused variable errors become warnings in dev mode
        if (semanticDiagnostic.code === '6133' || semanticDiagnostic.code === '6192') {
          semanticDiagnostic.level = 'warn';
        }
      });
    }
    buildCtx.diagnostics.push(...tsSemantic);
  }
  return false;
};
const validateUniqueTagNames = (config, buildCtx) => {
  buildCtx.components.forEach(cmp => {
    const tagName = cmp.tagName;
    const cmpsWithTagName = buildCtx.components.filter(c => c.tagName === tagName);
    if (cmpsWithTagName.length > 1) {
      const err = buildError(buildCtx.diagnostics);
      err.header = `Component Tag Name "${tagName}" Must Be Unique`;
      err.messageText = `Please update the components so "${tagName}" is only used once: ${cmpsWithTagName.map(c => relative(config.rootDir, c.sourceFilePath)).join(' ')}`;
    }
  });
};
const getRelativeDts = (config, srcPath, emitDtsPath) => {
  const parts = [];
  srcPath = normalizePath(srcPath);
  for (let i = 0; i < 30; i++) {
    if (config.srcDir === srcPath) {
      break;
    }
    const b = basename(emitDtsPath);
    parts.push(b);
    emitDtsPath = join(emitDtsPath, '..');
    srcPath = normalizePath(join(srcPath, '..'));
  }
  return join.apply(null, parts.reverse());
};

// MODULE: compiler/output-targets/output-service-workers.js
const outputServiceWorkers = async (config, buildCtx) => {
  const wwwServiceOutputs = config.outputTargets.filter(isOutputTargetWww).filter(o => typeof o.indexHtml === 'string' && !!o.serviceWorker);
  if (wwwServiceOutputs.length === 0) {
    return;
  }
  if (config.sys.lazyRequire == null) {
    return;
  }
  // let's make sure they have what we need from workbox installed
  await config.sys.lazyRequire.ensure(config.logger, config.rootDir, [WORKBOX_BUILD_MODULE_ID]);
  // we've ensure workbox is installed, so let's require it now
  const workbox = config.sys.lazyRequire.require(WORKBOX_BUILD_MODULE_ID);
  await Promise.all(wwwServiceOutputs.map(outputTarget => generateServiceWorker(config, buildCtx, workbox, outputTarget)));
};
const WORKBOX_BUILD_MODULE_ID = 'workbox-build';

// MODULE: compiler/types/validate-build-package-json.js
const validateBuildPackageJson = async (config, compilerCtx, buildCtx) => {
  if (config.watch) {
    return;
  }
  if (buildCtx.packageJson == null) {
    return;
  }
  const outputTargets = config.outputTargets.filter(isOutputTargetDistCollection);
  const typesOutputTargets = config.outputTargets.filter(isOutputTargetDistTypes);
  await Promise.all([
    ...outputTargets.map(outputsTarget => {
      return validatePackageJsonOutput(config, compilerCtx, buildCtx, outputsTarget);
    }),
    ...typesOutputTargets.map(outputTarget => {
      return validateTypes(config, compilerCtx, buildCtx, outputTarget);
    }),
  ]);
};
const validatePackageJsonOutput = async (config, compilerCtx, buildCtx, outputTarget) => {
  await Promise.all([
    validatePackageFiles(config, compilerCtx, buildCtx, outputTarget),
    validateMain(config, compilerCtx, buildCtx, outputTarget),
    validateModule(config, compilerCtx, buildCtx, outputTarget),
    validateCollection(config, compilerCtx, buildCtx, outputTarget),
    validateBrowser(config, compilerCtx, buildCtx),
  ]);
};
const validatePackageFiles = async (config, compilerCtx, buildCtx, outputTarget) => {
  if (!config.devMode && Array.isArray(buildCtx.packageJson.files)) {
    const actualDistDir = normalizePath(relative(config.rootDir, outputTarget.dir));
    const validPaths = [`${actualDistDir}`, `${actualDistDir}/`, `./${actualDistDir}`, `./${actualDistDir}/`];
    const containsDistDir = buildCtx.packageJson.files.some(userPath => validPaths.some(validPath => normalizePath(userPath) === validPath));
    if (!containsDistDir) {
      const msg = `package.json "files" array must contain the distribution directory "${actualDistDir}/" when generating a distribution.`;
      packageJsonWarn(config, compilerCtx, buildCtx, msg, `"files"`);
      return;
    }
    await Promise.all(buildCtx.packageJson.files.map(async (pkgFile) => {
      if (!isGlob(pkgFile)) {
        const packageJsonDir = dirname(config.packageJsonFilePath);
        const absPath = join(packageJsonDir, pkgFile);
        const hasAccess = await compilerCtx.fs.access(absPath);
        if (!hasAccess) {
          const msg = `Unable to find "${pkgFile}" within the package.json "files" array.`;
          packageJsonError(config, compilerCtx, buildCtx, msg, `"${pkgFile}"`);
        }
      }
    }));
  }
};
const validateMain = (config, compilerCtx, buildCtx, outputTarget) => {
  const mainAbs = join(outputTarget.dir, 'index.js');
  const mainRel = relative(config.rootDir, mainAbs);
  if (typeof buildCtx.packageJson.main !== 'string' || buildCtx.packageJson.main === '') {
    const msg = `package.json "main" property is required when generating a distribution. It's recommended to set the "main" property to: ${mainRel}`;
    packageJsonWarn(config, compilerCtx, buildCtx, msg, `"main"`);
  }
  else if (normalizePath(buildCtx.packageJson.main) !== normalizePath(mainRel)) {
    const msg = `package.json "main" property is set to "${buildCtx.packageJson.main}". It's recommended to set the "main" property to: ${mainRel}`;
    packageJsonWarn(config, compilerCtx, buildCtx, msg, `"main"`);
  }
};
const validateModule = (config, compilerCtx, buildCtx, outputTarget) => {
  const moduleAbs = join(outputTarget.dir, 'index.mjs');
  const moduleRel = relative(config.rootDir, moduleAbs);
  if (typeof buildCtx.packageJson.module !== 'string') {
    const msg = `package.json "module" property is required when generating a distribution. It's recommended to set the "module" property to: ${moduleRel}`;
    packageJsonWarn(config, compilerCtx, buildCtx, msg, `"module"`);
  }
  else if (normalizePath(buildCtx.packageJson.module) !== normalizePath(moduleRel)) {
    const msg = `package.json "module" property is set to "${buildCtx.packageJson.module}". It's recommended to set the "module" property to: ${moduleRel}`;
    packageJsonWarn(config, compilerCtx, buildCtx, msg, `"module"`);
  }
};
const validateTypes = async (config, compilerCtx, buildCtx, outputTarget) => {
  const typesAbs = getComponentsDtsTypesFilePath(outputTarget);
  const recommendedPath = relative(config.rootDir, typesAbs);
  if (typeof buildCtx.packageJson.types !== 'string' || buildCtx.packageJson.types === '') {
    const msg = `package.json "types" property is required when generating a distribution. It's recommended to set the "types" property to: ${recommendedPath}`;
    packageJsonWarn(config, compilerCtx, buildCtx, msg, `"types"`);
  }
  else if (!buildCtx.packageJson.types.endsWith('.d.ts')) {
    const msg = `package.json "types" file must have a ".d.ts" extension: ${buildCtx.packageJson.types}`;
    packageJsonWarn(config, compilerCtx, buildCtx, msg, `"types"`);
  }
  else {
    const typesFile = join(config.rootDir, buildCtx.packageJson.types);
    const typesFileExists = await compilerCtx.fs.access(typesFile);
    if (!typesFileExists) {
      let msg = `package.json "types" property is set to "${buildCtx.packageJson.types}" but cannot be found.`;
      if (normalizePath(buildCtx.packageJson.types) !== normalizePath(recommendedPath)) {
        msg += ` It's recommended to set the "types" property to: ${recommendedPath}`;
      }
      packageJsonError(config, compilerCtx, buildCtx, msg, `"types"`);
    }
  }
};
const validateCollection = (config, compilerCtx, buildCtx, outputTarget) => {
  if (outputTarget.collectionDir) {
    const collectionRel = join(relative(config.rootDir, outputTarget.collectionDir), COLLECTION_MANIFEST_FILE_NAME);
    if (!buildCtx.packageJson.collection || normalizePath(buildCtx.packageJson.collection) !== collectionRel) {
      const msg = `package.json "collection" property is required when generating a distribution and must be set to: ${collectionRel}`;
      packageJsonWarn(config, compilerCtx, buildCtx, msg, `"collection"`);
    }
  }
};
const validateBrowser = (config, compilerCtx, buildCtx) => {
  if (typeof buildCtx.packageJson.browser === 'string') {
    const msg = `package.json "browser" property is set to "${buildCtx.packageJson.browser}". However, for maximum compatibility with all bundlers it's recommended to not set the "browser" property and instead ensure both "module" and "main" properties are set.`;
    packageJsonWarn(config, compilerCtx, buildCtx, msg, `"browser"`);
  }
};
const packageJsonError = (config, compilerCtx, buildCtx, msg, warnKey) => {
  const err = buildJsonFileError(compilerCtx, buildCtx.diagnostics, config.packageJsonFilePath, msg, warnKey);
  err.header = `Package Json`;
  return err;
};
const packageJsonWarn = (config, compilerCtx, buildCtx, msg, warnKey) => {
  const warn = buildJsonFileError(compilerCtx, buildCtx.diagnostics, config.packageJsonFilePath, msg, warnKey);
  warn.header = `Package Json`;
  warn.level = 'warn';
  return warn;
};

// MODULE: compiler/html/validate-manifest-json.js
const validateManifestJson = (config, compilerCtx, buildCtx) => {
  if (config.devMode) {
    return null;
  }
  const outputTargets = config.outputTargets.filter(isOutputTargetWww);
  return Promise.all(outputTargets.map(async (outputsTarget) => {
    const manifestFilePath = join(outputsTarget.dir, 'manifest.json');
    try {
      const manifestContent = await compilerCtx.fs.readFile(manifestFilePath);
      if (manifestContent) {
        try {
          const manifestData = JSON.parse(manifestContent);
          await validateManifestJsonData(compilerCtx, buildCtx, manifestFilePath, manifestData);
        }
        catch (e) {
          const err = buildError(buildCtx.diagnostics);
          err.header = `Invalid manifest.json: ${e}`;
          err.absFilePath = manifestFilePath;
        }
      }
    }
    catch (e) { }
  }));
};
const validateManifestJsonData = async (compilerCtx, buildCtx, manifestFilePath, manifestData) => {
  if (Array.isArray(manifestData.icons)) {
    await Promise.all(manifestData.icons.map((manifestIcon) => {
      return validateManifestJsonIcon(compilerCtx, buildCtx, manifestFilePath, manifestIcon);
    }));
  }
};
const validateManifestJsonIcon = async (compilerCtx, buildCtx, manifestFilePath, manifestIcon) => {
  let iconSrc = manifestIcon.src;
  if (typeof iconSrc !== 'string') {
    const msg = `Manifest icon missing "src"`;
    buildJsonFileError(compilerCtx, buildCtx.diagnostics, manifestFilePath, msg, `"icons"`);
    return;
  }
  if (iconSrc.startsWith('/')) {
    iconSrc = iconSrc.substr(1);
  }
  const manifestDir = dirname(manifestFilePath);
  const iconPath = join(manifestDir, iconSrc);
  const hasAccess = await compilerCtx.fs.access(iconPath);
  if (!hasAccess) {
    const msg = `Unable to find manifest icon "${manifestIcon.src}"`;
    buildJsonFileError(compilerCtx, buildCtx.diagnostics, manifestFilePath, msg, `"${manifestIcon.src}"`);
  }
};

// MODULE: compiler/build/validate-files.js
const validateBuildFiles = (config, compilerCtx, buildCtx) => {
  if (buildCtx.hasError) {
    return null;
  }
  return Promise.all([validateBuildPackageJson(config, compilerCtx, buildCtx), validateManifestJson(config, compilerCtx, buildCtx)]);
};

// MODULE: compiler/build/write-build.js
const writeBuild = async (config, compilerCtx, buildCtx) => {
  const timeSpan = buildCtx.createTimeSpan(`writeBuildFiles started`, true);
  let totalFilesWrote = 0;
  try {
    // commit all the writeFiles, mkdirs, rmdirs and unlinks to disk
    const commitResults = await compilerCtx.fs.commit();
    // get the results from the write to disk commit
    buildCtx.filesWritten = commitResults.filesWritten;
    buildCtx.filesDeleted = commitResults.filesDeleted;
    buildCtx.dirsDeleted = commitResults.dirsDeleted;
    buildCtx.dirsAdded = commitResults.dirsAdded;
    totalFilesWrote = commitResults.filesWritten.length;
    // successful write
    // kick off writing the cached file stuff
    // await compilerCtx.cache.commit();
    buildCtx.debug(`in-memory-fs: ${compilerCtx.fs.getMemoryStats()}`);
    // buildCtx.debug(`cache: ${compilerCtx.cache.getMemoryStats()}`);
    await outputServiceWorkers(config, buildCtx), await validateBuildFiles(config, compilerCtx, buildCtx);
  }
  catch (e) {
    catchError(buildCtx.diagnostics, e);
  }
  timeSpan.finish(`writeBuildFiles finished, files wrote: ${totalFilesWrote}`);
};

// MODULE: compiler/build/build.js
const build = async (config, compilerCtx, buildCtx, tsBuilder) => {
  try {
    // reset process.cwd() for 3rd-party plugins
    process.chdir(config.rootDir);
    // empty the directories on the first build
    await emptyOutputTargets(config, compilerCtx, buildCtx);
    if (buildCtx.hasError)
      return buildAbort(buildCtx);
    if (config.srcIndexHtml) {
      const indexSrcHtml = await compilerCtx.fs.readFile(config.srcIndexHtml);
      if (isString(indexSrcHtml)) {
        buildCtx.indexDoc = createDocument(indexSrcHtml);
      }
    }
    await readPackageJson(config, compilerCtx, buildCtx);
    if (buildCtx.hasError)
      return buildAbort(buildCtx);
    // run typescript program
    const tsTimeSpan = buildCtx.createTimeSpan('transpile started');
    const componentDtsChanged = await runTsProgram(config, compilerCtx, buildCtx, tsBuilder);
    tsTimeSpan.finish('transpile finished');
    if (buildCtx.hasError)
      return buildAbort(buildCtx);
    if (config.watch && componentDtsChanged) {
      // silent abort for watch mode only
      return null;
    }
    // preprocess and generate styles before any outputTarget starts
    buildCtx.stylesPromise = generateGlobalStyles(config, compilerCtx, buildCtx);
    if (buildCtx.hasError)
      return buildAbort(buildCtx);
    // create outputs
    await generateOutputTargets(config, compilerCtx, buildCtx);
    if (buildCtx.hasError)
      return buildAbort(buildCtx);
    /// write outputs
    await buildCtx.stylesPromise;
    await writeBuild(config, compilerCtx, buildCtx);
    // await copyPromise;
  }
  catch (e) {
    // ¯\_(ツ)_/¯
    catchError(buildCtx.diagnostics, e);
  }
  // TODO
  // clear changed files
  compilerCtx.changedFiles.clear();
  // return what we've learned today
  return buildFinish(buildCtx);
};

// MODULE: compiler/transpile/ts-config.js
const getTsOptionsToExtend = (config) => {
  const tsOptions = {
    experimentalDecorators: true,
    declaration: config.outputTargets.some(isOutputTargetDistTypes),
    module: ts.ModuleKind.ESNext,
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    noEmitOnError: false,
    outDir: config.cacheDir,
    sourceMap: config.sourceMap,
  };
  return tsOptions;
};

// MODULE: compiler/transpile/create-build-program.js
const createTsBuildProgram = async (config, buildCallback) => {
  let isRunning = false;
  let timeoutId;
  const optionsToExtend = getTsOptionsToExtend(config);
  const tsWatchSys = Object.assign(Object.assign({}, ts.sys), { watchFile(path, callback) {
      if (path.endsWith(`/${GENERATED_DTS}`)) {
        return ts.sys.watchFile(path, callback);
      }
      return {
        close() { },
      };
    },
    watchDirectory() {
      return {
        close() { },
      };
    },
    setTimeout(callback, time) {
      timeoutId = setInterval(() => {
        if (!isRunning) {
          callback();
          clearInterval(timeoutId);
        }
      }, config.sys.watchTimeout || time);
      return timeoutId;
    },
    clearTimeout(id) {
      return clearInterval(id);
    } });
  config.sys.addDestory(() => tsWatchSys.clearTimeout(timeoutId));
  const tsWatchHost = ts.createWatchCompilerHost(config.tsconfig, optionsToExtend, tsWatchSys, ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic => {
    config.logger.debug('watch reportDiagnostic:' + reportDiagnostic.messageText);
  }, reportWatchStatus => {
    config.logger.debug(reportWatchStatus.messageText);
  });
  tsWatchHost.afterProgramCreate = async (tsBuilder) => {
    isRunning = true;
    await buildCallback(tsBuilder);
    isRunning = false;
  };
  return ts.createWatchProgram(tsWatchHost);
};

// MODULE: compiler/build/full-build.js
const createFullBuild = async (config, compilerCtx) => {
  return new Promise(resolve => {
    let tsWatchProgram = null;
    compilerCtx.events.on('fileUpdate', p => {
      config.logger.debug(`fileUpdate: ${p}`);
      compilerCtx.fs.clearFileCache(p);
    });
    const onBuild = async (tsBuilder) => {
      const buildCtx = new BuildContext(config, compilerCtx);
      buildCtx.isRebuild = false;
      buildCtx.requiresFullBuild = true;
      buildCtx.start();
      const result = await build(config, compilerCtx, buildCtx, tsBuilder);
      if (result !== null) {
        if (tsWatchProgram) {
          tsWatchProgram.close();
          tsWatchProgram = null;
        }
        resolve(result);
      }
    };
    createTsBuildProgram(config, onBuild).then(program => {
      tsWatchProgram = program;
    });
  });
};

// MODULE: compiler/sys/in-memory-fs.js
const createInMemoryFs = (sys) => {
  const items = new Map();
  const outputTargetTypes = new Map();
  const accessData = async (filePath) => {
    const item = getItem(filePath);
    if (typeof item.exists === 'boolean') {
      return {
        exists: item.exists,
        isDirectory: item.isDirectory,
        isFile: item.isFile,
      };
    }
    const data = {
      exists: false,
      isDirectory: false,
      isFile: false,
    };
    const s = await stat(filePath);
    if (s) {
      item.exists = s.exists;
      item.isDirectory = s.isDirectory;
      item.isFile = s.isFile;
      data.exists = item.exists;
      data.isDirectory = item.isDirectory;
      data.isFile = item.isFile;
    }
    else {
      item.exists = false;
    }
    return data;
  };
  const access = async (filePath) => {
    const data = await accessData(filePath);
    return data.exists;
  };
  /**
   * Synchronous!!! Do not use!!!
   * (Only typescript transpiling is allowed to use)
   * @param filePath
   */
  const accessSync = (filePath) => {
    const item = getItem(filePath);
    if (typeof item.exists !== 'boolean') {
      const s = statSync(filePath);
      item.exists = s.exists;
      item.isDirectory = s.isDirectory;
      item.isFile = s.isFile;
    }
    return item.exists;
  };
  const copyFile = async (src, dest) => {
    const item = getItem(src);
    item.queueCopyFileToDest = dest;
  };
  const emptyDir = async (dirPath) => {
    const item = getItem(dirPath);
    await removeDir(dirPath);
    item.isFile = false;
    item.isDirectory = true;
    item.queueWriteToDisk = true;
    item.queueDeleteFromDisk = false;
  };
  const readdir = async (dirPath, opts = {}) => {
    dirPath = normalizePath(dirPath);
    const collectedPaths = [];
    if (opts.inMemoryOnly === true) {
      let inMemoryDir = dirPath;
      if (!inMemoryDir.endsWith('/')) {
        inMemoryDir += '/';
      }
      const inMemoryDirs = dirPath.split('/');
      items.forEach((d, filePath) => {
        if (!filePath.startsWith(dirPath)) {
          return;
        }
        const parts = filePath.split('/');
        if (parts.length === inMemoryDirs.length + 1 || (opts.recursive && parts.length > inMemoryDirs.length)) {
          if (d.exists) {
            const item = {
              absPath: filePath,
              relPath: parts[inMemoryDirs.length],
              isDirectory: d.isDirectory,
              isFile: d.isFile,
            };
            if (!shouldExcludeFromReaddir(opts, item)) {
              collectedPaths.push(item);
            }
          }
        }
      });
    }
    else {
      // always a disk read
      await readDirectory(dirPath, dirPath, opts, collectedPaths);
    }
    return collectedPaths.sort((a, b) => {
      if (a.absPath < b.absPath)
        return -1;
      if (a.absPath > b.absPath)
        return 1;
      return 0;
    });
  };
  const readDirectory = async (initPath, dirPath, opts, collectedPaths) => {
    // used internally only so we could easily recursively drill down
    // loop through this directory and sub directories
    // always a disk read!!
    const dirItems = await sys.readdir(dirPath);
    if (dirItems.length > 0) {
      // cache some facts about this path
      const item = getItem(dirPath);
      item.exists = true;
      item.isFile = false;
      item.isDirectory = true;
      await Promise.all(dirItems.map(async (dirItem) => {
        // let's loop through each of the files we've found so far
        // create an absolute path of the item inside of this directory
        const absPath = normalizePath(dirItem);
        const relPath = normalizePath(relative(initPath, absPath));
        // get the fs stats for the item, could be either a file or directory
        const stats = await stat(absPath);
        const childItem = {
          absPath: absPath,
          relPath: relPath,
          isDirectory: stats.isDirectory,
          isFile: stats.isFile,
        };
        if (shouldExcludeFromReaddir(opts, childItem)) {
          return;
        }
        collectedPaths.push(childItem);
        if (opts.recursive === true && stats.isDirectory === true) {
          // looks like it's yet another directory
          // let's keep drilling down
          await readDirectory(initPath, absPath, opts, collectedPaths);
        }
      }));
    }
  };
  const shouldExcludeFromReaddir = (opts, item) => {
    if (item.isDirectory) {
      if (Array.isArray(opts.excludeDirNames)) {
        const base = basename(item.absPath);
        if (opts.excludeDirNames.some(dir => base === dir)) {
          return true;
        }
      }
    }
    else {
      if (Array.isArray(opts.excludeExtensions)) {
        const p = item.relPath.toLowerCase();
        if (opts.excludeExtensions.some(ext => p.endsWith(ext))) {
          return true;
        }
      }
    }
    return false;
  };
  const readFile = async (filePath, opts) => {
    if (opts == null || opts.useCache === true || opts.useCache === undefined) {
      const item = getItem(filePath);
      if (item.exists && typeof item.fileText === 'string') {
        return item.fileText;
      }
    }
    const fileText = await sys.readFile(filePath);
    const item = getItem(filePath);
    if (typeof fileText === 'string') {
      if (fileText.length < MAX_TEXT_CACHE) {
        item.exists = true;
        item.isFile = true;
        item.isDirectory = false;
        item.fileText = fileText;
      }
    }
    else {
      item.exists = false;
    }
    return fileText;
  };
  /**
   * Synchronous!!! Do not use!!!
   * (Only typescript transpiling is allowed to use)
   * @param filePath
   */
  const readFileSync = (filePath, opts) => {
    if (opts == null || opts.useCache === true || opts.useCache === undefined) {
      const item = getItem(filePath);
      if (item.exists && typeof item.fileText === 'string') {
        return item.fileText;
      }
    }
    const fileText = sys.readFileSync(filePath);
    const item = getItem(filePath);
    if (typeof fileText === 'string') {
      if (fileText.length < MAX_TEXT_CACHE) {
        item.exists = true;
        item.isFile = true;
        item.isDirectory = false;
        item.fileText = fileText;
      }
    }
    else {
      item.exists = false;
    }
    return fileText;
  };
  const remove = async (itemPath) => {
    const stats = await stat(itemPath);
    if (stats.isDirectory === true) {
      await removeDir(itemPath);
    }
    else if (stats.isFile === true) {
      await removeItem(itemPath);
    }
  };
  const removeDir = async (dirPath) => {
    const item = getItem(dirPath);
    item.isFile = false;
    item.isDirectory = true;
    if (!item.queueWriteToDisk) {
      item.queueDeleteFromDisk = true;
    }
    try {
      const dirItems = await readdir(dirPath, { recursive: true });
      await Promise.all(dirItems.map(item => removeItem(item.absPath)));
    }
    catch (e) {
      // do not throw error if the directory never existed
    }
  };
  const removeItem = async (filePath) => {
    const item = getItem(filePath);
    if (!item.queueWriteToDisk) {
      item.queueDeleteFromDisk = true;
    }
  };
  const stat = async (itemPath) => {
    const item = getItem(itemPath);
    if (typeof item.isDirectory !== 'boolean' || typeof item.isFile !== 'boolean') {
      const s = await sys.stat(itemPath);
      if (s) {
        item.exists = true;
        if (s.isFile()) {
          item.isFile = true;
          item.isDirectory = false;
          item.size = s.size;
        }
        else if (s.isDirectory()) {
          item.isFile = false;
          item.isDirectory = true;
          item.size = s.size;
        }
        else {
          item.isFile = false;
          item.isDirectory = false;
          item.size = null;
        }
      }
      else {
        item.exists = false;
      }
    }
    return {
      exists: !!item.exists,
      isFile: !!item.isFile,
      isDirectory: !!item.isDirectory,
      size: typeof item.size === 'number' ? item.size : 0,
    };
  };
  /**
   * Synchronous!!! Do not use!!!
   * Always returns an object, does not throw errors.
   * (Only typescript transpiling is allowed to use)
   * @param itemPath
   */
  const statSync = (itemPath) => {
    const item = getItem(itemPath);
    if (typeof item.isDirectory !== 'boolean' || typeof item.isFile !== 'boolean') {
      const s = sys.statSync(itemPath);
      if (s) {
        item.exists = true;
        if (s.isFile()) {
          item.isFile = true;
          item.isDirectory = false;
          item.size = s.size;
        }
        else if (s.isDirectory()) {
          item.isFile = false;
          item.isDirectory = true;
          item.size = s.size;
        }
        else {
          item.isFile = false;
          item.isDirectory = false;
          item.size = null;
        }
      }
      else {
        item.exists = false;
      }
    }
    return {
      exists: !!item.exists,
      isFile: !!item.isFile,
      isDirectory: !!item.isDirectory,
    };
  };
  const writeFile = async (filePath, content, opts) => {
    if (typeof filePath !== 'string') {
      throw new Error(`writeFile, invalid filePath: ${filePath}`);
    }
    if (typeof content !== 'string') {
      throw new Error(`writeFile, invalid content: ${filePath}`);
    }
    const results = {
      ignored: false,
      changedContent: false,
      queuedWrite: false,
    };
    if (shouldIgnore(filePath) === true) {
      results.ignored = true;
      return results;
    }
    const item = getItem(filePath);
    item.exists = true;
    item.isFile = true;
    item.isDirectory = false;
    item.queueDeleteFromDisk = false;
    if (typeof item.fileText === 'string') {
      // compare strings but replace Windows CR to rule out any
      // insignificant new line differences
      results.changedContent = item.fileText.replace(/\r/g, '') !== content.replace(/\r/g, '');
    }
    else {
      results.changedContent = true;
    }
    item.fileText = content;
    results.queuedWrite = false;
    if (opts != null) {
      if (typeof opts.outputTargetType === 'string') {
        outputTargetTypes.set(filePath, opts.outputTargetType);
      }
      if (opts.useCache === false) {
        item.useCache = false;
      }
    }
    if (opts != null && opts.inMemoryOnly === true) {
      // we don't want to actually write this to disk
      // just keep it in memory
      if (item.queueWriteToDisk) {
        // we already queued this file to write to disk
        // in that case we still need to do it
        results.queuedWrite = true;
      }
      else {
        // we only want this in memory and
        // it wasn't already queued to be written
        item.queueWriteToDisk = false;
      }
      // ensure in-memory directories are created
      await ensureDir(filePath, true);
    }
    else if (opts != null && opts.immediateWrite === true) {
      // if this is an immediate write then write the file
      // now and do not add it to the queue
      if (results.changedContent || opts.useCache !== true) {
        // writing the file to disk is a big deal and kicks off fs watchers
        // so let's just double check that the file is actually different first
        const existingFile = await sys.readFile(filePath);
        if (typeof existingFile === 'string') {
          results.changedContent = item.fileText.replace(/\r/g, '') !== existingFile.replace(/\r/g, '');
        }
        if (results.changedContent) {
          await ensureDir(filePath, false);
          await sys.writeFile(filePath, item.fileText);
        }
      }
    }
    else {
      // we want to write this to disk (eventually)
      // but only if the content is different
      // from our existing cached content
      if (!item.queueWriteToDisk && results.changedContent === true) {
        // not already queued to be written
        // and the content is different
        item.queueWriteToDisk = true;
        results.queuedWrite = true;
      }
    }
    return results;
  };
  const writeFiles = (files, opts) => {
    const writes = [];
    if (isIterable(files)) {
      files.forEach((content, filePath) => {
        writes.push(writeFile(filePath, content, opts));
      });
    }
    else {
      Object.keys(files).map(filePath => {
        writes.push(writeFile(filePath, files[filePath], opts));
      });
    }
    return Promise.all(writes);
  };
  const commit = async () => {
    const instructions = getCommitInstructions(items);
    // ensure directories we need exist
    const dirsAdded = await commitEnsureDirs(instructions.dirsToEnsure, false);
    // write all queued the files
    const filesWritten = await commitWriteFiles(instructions.filesToWrite);
    // write all queued the files to copy
    const filesCopied = await commitCopyFiles(instructions.filesToCopy);
    // remove all the queued files to be deleted
    const filesDeleted = await commitDeleteFiles(instructions.filesToDelete);
    // remove all the queued dirs to be deleted
    const dirsDeleted = await commitDeleteDirs(instructions.dirsToDelete);
    instructions.filesToDelete.forEach(fileToDelete => {
      clearFileCache(fileToDelete);
    });
    instructions.dirsToDelete.forEach(dirToDelete => {
      clearDirCache(dirToDelete);
    });
    // return only the files that were
    return {
      filesCopied,
      filesWritten,
      filesDeleted,
      dirsDeleted,
      dirsAdded,
    };
  };
  const ensureDir = async (p, inMemoryOnly) => {
    const allDirs = [];
    while (true) {
      p = dirname(p);
      if (typeof p === 'string' && p.length > 0 && p !== '/' && p.endsWith(':/') === false && p.endsWith(':\\') === false) {
        allDirs.push(p);
      }
      else {
        break;
      }
    }
    allDirs.reverse();
    await commitEnsureDirs(allDirs, inMemoryOnly);
  };
  const commitEnsureDirs = async (dirsToEnsure, inMemoryOnly) => {
    const dirsAdded = [];
    for (const dirPath of dirsToEnsure) {
      const item = getItem(dirPath);
      if (item.exists === true && item.isDirectory === true) {
        // already cached that this path is indeed an existing directory
        continue;
      }
      try {
        // cache that we know this is a directory on disk
        item.exists = true;
        item.isDirectory = true;
        item.isFile = false;
        if (!inMemoryOnly) {
          await sys.mkdir(dirPath);
        }
        dirsAdded.push(dirPath);
      }
      catch (e) { }
    }
    return dirsAdded;
  };
  const commitCopyFiles = (filesToCopy) => {
    const copiedFiles = Promise.all(filesToCopy.map(async (data) => {
      const src = data[0];
      const dest = data[1];
      await sys.copyFile(src, dest);
      return [src, dest];
    }));
    return copiedFiles;
  };
  const commitWriteFiles = (filesToWrite) => {
    const writtenFiles = Promise.all(filesToWrite.map(async (filePath) => {
      if (typeof filePath !== 'string') {
        throw new Error(`unable to writeFile without filePath`);
      }
      return commitWriteFile(filePath);
    }));
    return writtenFiles;
  };
  const commitWriteFile = async (filePath) => {
    const item = getItem(filePath);
    if (item.fileText == null) {
      throw new Error(`unable to find item fileText to write: ${filePath}`);
    }
    await sys.writeFile(filePath, item.fileText);
    if (item.useCache === false) {
      clearFileCache(filePath);
    }
    return filePath;
  };
  const commitDeleteFiles = async (filesToDelete) => {
    const deletedFiles = await Promise.all(filesToDelete.map(async (filePath) => {
      if (typeof filePath !== 'string') {
        throw new Error(`unable to unlink without filePath`);
      }
      await sys.unlink(filePath);
      return filePath;
    }));
    return deletedFiles;
  };
  const commitDeleteDirs = async (dirsToDelete) => {
    const dirsDeleted = [];
    for (const dirPath of dirsToDelete) {
      try {
        await sys.rmdir(dirPath);
      }
      catch (e) { }
      dirsDeleted.push(dirPath);
    }
    return dirsDeleted;
  };
  const clearDirCache = (dirPath) => {
    dirPath = normalizePath(dirPath);
    items.forEach((_, f) => {
      const filePath = relative(dirPath, f).split('/')[0];
      if (!filePath.startsWith('.') && !filePath.startsWith('/')) {
        clearFileCache(f);
      }
    });
  };
  const clearFileCache = (filePath) => {
    filePath = normalizePath(filePath);
    const item = items.get(filePath);
    if (item != null && !item.queueWriteToDisk) {
      items.delete(filePath);
    }
  };
  const cancelDeleteFilesFromDisk = (filePaths) => {
    filePaths.forEach(filePath => {
      const item = getItem(filePath);
      if (item.isFile === true && item.queueDeleteFromDisk === true) {
        item.queueDeleteFromDisk = false;
      }
    });
  };
  const cancelDeleteDirectoriesFromDisk = (dirPaths) => {
    dirPaths.forEach(dirPath => {
      const item = getItem(dirPath);
      if (item.queueDeleteFromDisk === true) {
        item.queueDeleteFromDisk = false;
      }
    });
  };
  const getItem = (itemPath) => {
    itemPath = normalizePath(itemPath);
    let item = items.get(itemPath);
    if (item != null) {
      return item;
    }
    items.set(itemPath, (item = {
      exists: null,
      fileText: null,
      size: null,
      mtimeMs: null,
      isDirectory: null,
      isFile: null,
      queueCopyFileToDest: null,
      queueDeleteFromDisk: null,
      queueWriteToDisk: null,
      useCache: null,
    }));
    return item;
  };
  const clearCache = () => items.clear();
  const keys = () => Array.from(items.keys()).sort();
  const getMemoryStats = () => `data length: ${items.size}`;
  const getBuildOutputs = () => {
    const outputs = [];
    outputTargetTypes.forEach((outputTargetType, filePath) => {
      const output = outputs.find(o => o.type === outputTargetType);
      if (output) {
        output.files.push(filePath);
      }
      else {
        outputs.push({
          type: outputTargetType,
          files: [filePath],
        });
      }
    });
    outputs.forEach(o => o.files.sort());
    return outputs.sort((a, b) => {
      if (a.type < b.type)
        return -1;
      if (a.type > b.type)
        return 1;
      return 0;
    });
  };
  // only cache if it's less than 5MB-ish (using .length as a rough guess)
  // why 5MB? idk, seems like a good number for source text
  // it's pretty darn large to cover almost ALL legitimate source files
  // and anything larger is probably a REALLY large file and a rare case
  // which we don't need to eat up memory for
  const MAX_TEXT_CACHE = 5242880;
  const fs = {
    access,
    accessSync,
    accessData,
    cancelDeleteDirectoriesFromDisk,
    cancelDeleteFilesFromDisk,
    clearCache,
    clearDirCache,
    clearFileCache,
    commit,
    copyFile,
    emptyDir,
    getBuildOutputs,
    getItem,
    getMemoryStats,
    keys,
    readFile,
    readFileSync,
    readdir,
    remove,
    stat,
    statSync,
    sys,
    writeFile,
    writeFiles,
  };
  return fs;
};
const getCommitInstructions = (items) => {
  const instructions = {
    filesToDelete: [],
    filesToWrite: [],
    filesToCopy: [],
    dirsToDelete: [],
    dirsToEnsure: [],
  };
  items.forEach((item, itemPath) => {
    if (item.queueWriteToDisk === true) {
      if (item.isFile === true) {
        instructions.filesToWrite.push(itemPath);
        const dir = normalizePath(dirname(itemPath));
        if (!instructions.dirsToEnsure.includes(dir)) {
          instructions.dirsToEnsure.push(dir);
        }
        const dirDeleteIndex = instructions.dirsToDelete.indexOf(dir);
        if (dirDeleteIndex > -1) {
          instructions.dirsToDelete.splice(dirDeleteIndex, 1);
        }
        const fileDeleteIndex = instructions.filesToDelete.indexOf(itemPath);
        if (fileDeleteIndex > -1) {
          instructions.filesToDelete.splice(fileDeleteIndex, 1);
        }
      }
      else if (item.isDirectory === true) {
        if (!instructions.dirsToEnsure.includes(itemPath)) {
          instructions.dirsToEnsure.push(itemPath);
        }
        const dirDeleteIndex = instructions.dirsToDelete.indexOf(itemPath);
        if (dirDeleteIndex > -1) {
          instructions.dirsToDelete.splice(dirDeleteIndex, 1);
        }
      }
    }
    else if (item.queueDeleteFromDisk === true) {
      if (item.isDirectory && !instructions.dirsToEnsure.includes(itemPath)) {
        instructions.dirsToDelete.push(itemPath);
      }
      else if (item.isFile && !instructions.filesToWrite.includes(itemPath)) {
        instructions.filesToDelete.push(itemPath);
      }
    }
    else if (typeof item.queueCopyFileToDest === 'string') {
      const src = itemPath;
      const dest = item.queueCopyFileToDest;
      instructions.filesToCopy.push([src, dest]);
      const dir = normalizePath(dirname(dest));
      if (!instructions.dirsToEnsure.includes(dir)) {
        instructions.dirsToEnsure.push(dir);
      }
      const dirDeleteIndex = instructions.dirsToDelete.indexOf(dir);
      if (dirDeleteIndex > -1) {
        instructions.dirsToDelete.splice(dirDeleteIndex, 1);
      }
      const fileDeleteIndex = instructions.filesToDelete.indexOf(dest);
      if (fileDeleteIndex > -1) {
        instructions.filesToDelete.splice(fileDeleteIndex, 1);
      }
    }
    item.queueDeleteFromDisk = false;
    item.queueWriteToDisk = false;
  });
  // add all the ancestor directories for each directory too
  for (let i = 0, ilen = instructions.dirsToEnsure.length; i < ilen; i++) {
    const segments = instructions.dirsToEnsure[i].split('/');
    for (let j = 2; j < segments.length; j++) {
      const dir = segments.slice(0, j).join('/');
      if (instructions.dirsToEnsure.includes(dir) === false) {
        instructions.dirsToEnsure.push(dir);
      }
    }
  }
  // sort directories so shortest paths are ensured first
  instructions.dirsToEnsure.sort((a, b) => {
    const segmentsA = a.split('/').length;
    const segmentsB = b.split('/').length;
    if (segmentsA < segmentsB)
      return -1;
    if (segmentsA > segmentsB)
      return 1;
    if (a.length < b.length)
      return -1;
    if (a.length > b.length)
      return 1;
    return 0;
  });
  // sort directories so longest paths are removed first
  instructions.dirsToDelete.sort((a, b) => {
    const segmentsA = a.split('/').length;
    const segmentsB = b.split('/').length;
    if (segmentsA < segmentsB)
      return 1;
    if (segmentsA > segmentsB)
      return -1;
    if (a.length < b.length)
      return 1;
    if (a.length > b.length)
      return -1;
    return 0;
  });
  instructions.dirsToEnsure.forEach(dirToEnsure => {
    const i = instructions.dirsToDelete.indexOf(dirToEnsure);
    if (i > -1) {
      instructions.dirsToDelete.splice(i, 1);
    }
  });
  instructions.dirsToDelete = instructions.dirsToDelete.filter(dir => {
    if (dir === '/' || dir.endsWith(':/') === true) {
      return false;
    }
    return true;
  });
  instructions.dirsToEnsure = instructions.dirsToEnsure.filter(dir => {
    const item = items.get(dir);
    if (item != null && item.exists === true && item.isDirectory === true) {
      return false;
    }
    if (dir === '/' || dir.endsWith(':/')) {
      return false;
    }
    return true;
  });
  return instructions;
};
const shouldIgnore = (filePath) => {
  filePath = filePath.trim().toLowerCase();
  return IGNORE.some(ignoreFile => filePath.endsWith(ignoreFile));
};
const IGNORE = ['.ds_store', '.gitignore', 'desktop.ini', 'thumbs.db'];

// MODULE: compiler/worker/main-thread.js
const createWorkerMainContext = (workerCtrl) => {
  return {
    compileModule: workerCtrl.handler('compileModule'),
    optimizeCss: workerCtrl.handler('optimizeCss'),
    transformCssToEsm: workerCtrl.handler('transformCssToEsm'),
    transpileToEs5: workerCtrl.handler('transpileToEs5'),
    prepareModule: workerCtrl.handler('prepareModule'),
  };
};

// MODULE: compiler/sys/worker/sys-worker.js
const createSysWorker = (sys, maxConcurrentWorkers) => {
  if (sys.createWorkerController == null || maxConcurrentWorkers < 1) {
    return createWorkerContext();
  }
  const workerCtrl = sys.createWorkerController(sys.getCompilerExecutingPath(), maxConcurrentWorkers);
  sys.addDestory(() => workerCtrl.destroy());
  return createWorkerMainContext(workerCtrl);
};

// MODULE: compiler/transpile/create-watch-program.js
const createTsWatchProgram = async (config, buildCallback) => {
  let isRunning = false;
  let lastTsBuilder;
  let timeoutId;
  let rebuildTimer;
  const optionsToExtend = getTsOptionsToExtend(config);
  const tsWatchSys = Object.assign(Object.assign({}, ts.sys), { setTimeout(callback, time) {
      clearInterval(rebuildTimer);
      const t = (timeoutId = setInterval(() => {
        if (!isRunning) {
          callback();
          clearInterval(t);
          timeoutId = rebuildTimer = null;
        }
      }, config.sys.watchTimeout || time));
      return t;
    },
    clearTimeout(id) {
      return clearInterval(id);
    } });
  config.sys.addDestory(() => tsWatchSys.clearTimeout(timeoutId));
  const tsWatchHost = ts.createWatchCompilerHost(config.tsconfig, optionsToExtend, tsWatchSys, ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic => {
    config.logger.debug('watch reportDiagnostic:' + reportDiagnostic.messageText);
  }, reportWatchStatus => {
    config.logger.debug(reportWatchStatus.messageText);
  });
  tsWatchHost.afterProgramCreate = async (tsBuilder) => {
    lastTsBuilder = tsBuilder;
    isRunning = true;
    await buildCallback(tsBuilder);
    isRunning = false;
  };
  return {
    program: ts.createWatchProgram(tsWatchHost),
    rebuild: () => {
      if (lastTsBuilder && !timeoutId) {
        rebuildTimer = tsWatchSys.setTimeout(() => tsWatchHost.afterProgramCreate(lastTsBuilder), 300);
      }
    },
  };
};

// MODULE: compiler/fs-watch/fs-watch-rebuild.js
const filesChanged = (buildCtx) => {
  // files changed include updated, added and deleted
  return unique([...buildCtx.filesUpdated, ...buildCtx.filesAdded, ...buildCtx.filesDeleted]).sort();
};
const scriptsAdded = (buildCtx) => {
  // collect all the scripts that were added
  return buildCtx.filesAdded
    .filter(f => {
    return SCRIPT_EXT.some(ext => f.endsWith(ext.toLowerCase()));
  })
    .map(f => basename(f));
};
const scriptsDeleted = (buildCtx) => {
  // collect all the scripts that were deleted
  return buildCtx.filesDeleted
    .filter(f => {
    return SCRIPT_EXT.some(ext => f.endsWith(ext.toLowerCase()));
  })
    .map(f => basename(f));
};
const hasScriptChanges = (buildCtx) => {
  return buildCtx.filesChanged.some(f => {
    const ext = getExt(f);
    return SCRIPT_EXT.includes(ext);
  });
};
const hasStyleChanges = (buildCtx) => {
  return buildCtx.filesChanged.some(f => {
    const ext = getExt(f);
    return STYLE_EXT.includes(ext);
  });
};
const getExt = (filePath) => filePath
  .split('.')
  .pop()
  .toLowerCase();
const SCRIPT_EXT = ['ts', 'tsx', 'js', 'jsx'];
const STYLE_EXT = ['css', 'scss', 'sass', 'pcss', 'styl', 'stylus', 'less'];
const hasHtmlChanges = (config, buildCtx) => {
  const anyHtmlChanged = buildCtx.filesChanged.some(f => f.toLowerCase().endsWith('.html'));
  if (anyHtmlChanged) {
    // any *.html in any directory that changes counts and rebuilds
    return true;
  }
  const srcIndexHtmlChanged = buildCtx.filesChanged.some(fileChanged => {
    // the src index index.html file has changed
    // this file name could be something other than index.html
    return fileChanged === config.srcIndexHtml;
  });
  return srcIndexHtmlChanged;
};

// MODULE: compiler/build/watch-build.js
const createWatchBuild = async (config, compilerCtx) => {
  let isRebuild = false;
  let tsWatchProgram;
  let fileWatcher;
  let closeResolver;
  const watchWaiter = new Promise(resolve => (closeResolver = resolve));
  const dirsAdded = new Set();
  const dirsDeleted = new Set();
  const filesAdded = new Set();
  const filesUpdated = new Set();
  const filesDeleted = new Set();
  const onFileChange = (file, kind) => {
    updateCompilerCtxCache(config, compilerCtx, file, kind);
    switch (kind) {
      case 'dirAdd':
        dirsAdded.add(file);
        break;
      case 'dirDelete':
        dirsDeleted.add(file);
        break;
      case 'fileAdd':
        filesAdded.add(file);
        break;
      case 'fileUpdate':
        filesUpdated.add(file);
        break;
      case 'fileDelete':
        filesDeleted.add(file);
        break;
    }
    config.logger.debug(`${kind}: ${file}`);
    tsWatchProgram.rebuild();
  };
  const onBuild = async (tsBuilder) => {
    const buildCtx = new BuildContext(config, compilerCtx);
    buildCtx.isRebuild = isRebuild;
    buildCtx.requiresFullBuild = !isRebuild;
    buildCtx.dirsAdded = Array.from(dirsAdded.keys()).sort();
    buildCtx.dirsDeleted = Array.from(dirsDeleted.keys()).sort();
    buildCtx.filesAdded = Array.from(filesAdded.keys()).sort();
    buildCtx.filesUpdated = Array.from(filesUpdated.keys()).sort();
    buildCtx.filesDeleted = Array.from(filesDeleted.keys()).sort();
    buildCtx.filesChanged = filesChanged(buildCtx);
    buildCtx.scriptsAdded = scriptsAdded(buildCtx);
    buildCtx.scriptsDeleted = scriptsDeleted(buildCtx);
    buildCtx.hasScriptChanges = hasScriptChanges(buildCtx);
    buildCtx.hasStyleChanges = hasStyleChanges(buildCtx);
    buildCtx.hasHtmlChanges = hasHtmlChanges(config, buildCtx);
    buildCtx.hasServiceWorkerChanges = hasServiceWorkerChanges(config, buildCtx);
    dirsAdded.clear();
    dirsDeleted.clear();
    filesAdded.clear();
    filesUpdated.clear();
    filesDeleted.clear();
    emitFsChange(compilerCtx, buildCtx);
    buildCtx.start();
    const result = await build(config, compilerCtx, buildCtx, tsBuilder);
    if (result && !result.hasError) {
      isRebuild = true;
    }
  };
  const start = async () => {
    fileWatcher = await watchSrcDirectory(config, compilerCtx, onFileChange);
    tsWatchProgram = await createTsWatchProgram(config, onBuild);
    return watchWaiter;
  };
  const close = async () => {
    if (tsWatchProgram) {
      fileWatcher.close();
      tsWatchProgram.program.close();
      tsWatchProgram = null;
    }
    const watcherCloseResults = {
      exitCode: 0,
    };
    closeResolver(watcherCloseResults);
    return watcherCloseResults;
  };
  const request = async (data) => compilerRequest(config, compilerCtx, data);
  config.sys.addDestory(close);
  return {
    start,
    close,
    on: compilerCtx.events.on,
    request,
  };
};
const watchSrcDirectory = async (config, compilerCtx, callback) => {
  const watching = new Map();
  const watchFile = (path) => {
    if (!watching.has(path)) {
      watching.set(path, config.sys.watchFile(path, callback));
    }
  };
  const files = await compilerCtx.fs.readdir(config.srcDir, {
    recursive: true,
    excludeDirNames: ['.cache', '.github', '.stencil', '.vscode', 'node_modules'],
    excludeExtensions: ['.md', '.markdown', '.txt', '.spec.ts', '.spec.tsx', '.e2e.ts', '.e2e.tsx', '.gitignore', '.editorconfig'],
  });
  files.filter(({ isFile }) => isFile).forEach(({ absPath }) => watchFile(absPath));
  watching.set(config.srcDir, config.sys.watchDirectory(config.srcDir, (filename, kind) => {
    watchFile(filename);
    callback(filename, kind);
  }));
  return {
    close() {
      watching.forEach(w => w.close());
    },
  };
};
const emitFsChange = (compilerCtx, buildCtx) => {
  if (buildCtx.dirsAdded.length > 0 || buildCtx.dirsDeleted.length > 0 || buildCtx.filesUpdated.length > 0 || buildCtx.filesAdded.length > 0 || buildCtx.filesDeleted.length > 0) {
    compilerCtx.events.emit('fsChange', {
      dirsAdded: buildCtx.dirsAdded.slice(),
      dirsDeleted: buildCtx.dirsDeleted.slice(),
      filesUpdated: buildCtx.filesUpdated.slice(),
      filesAdded: buildCtx.filesAdded.slice(),
      filesDeleted: buildCtx.filesDeleted.slice(),
    });
  }
};
const updateCompilerCtxCache = (config, compilerCtx, path, kind) => {
  compilerCtx.fs.clearFileCache(path);
  compilerCtx.changedFiles.add(path);
  if (kind === 'fileDelete') {
    compilerCtx.moduleMap.delete(path);
  }
  else if (kind === 'dirDelete') {
    const fsRootDir = resolve('/');
    compilerCtx.moduleMap.forEach((_, moduleFilePath) => {
      let moduleAncestorDir = dirname(moduleFilePath);
      for (let i = 0; i < 50; i++) {
        if (moduleAncestorDir === config.rootDir || moduleAncestorDir === fsRootDir) {
          break;
        }
        if (moduleAncestorDir === path) {
          compilerCtx.fs.clearFileCache(moduleFilePath);
          compilerCtx.moduleMap.delete(moduleFilePath);
          compilerCtx.changedFiles.add(moduleFilePath);
          break;
        }
        moduleAncestorDir = dirname(moduleAncestorDir);
      }
    });
  }
};

// MODULE: compiler/sys/fetch/fetch-preload.js
const fetchPreloadFs = async (config, inMemoryFs) => {
  if (IS_WEB_WORKER_ENV && IS_FETCH_ENV) {
    const preloadUrls = getCoreFetchPreloadUrls(config, config.sys.getCompilerExecutingPath());
    await Promise.all(preloadUrls.map(async (preload) => {
      try {
        const fileExists = await inMemoryFs.access(preload.filePath);
        if (!fileExists) {
          const rsp = await httpFetch(config.sys, preload.url);
          if (rsp && rsp.ok) {
            const content = await rsp.clone().text();
            await inMemoryFs.writeFile(preload.filePath, content);
          }
        }
      }
      catch (e) {
        config.logger.error(e);
      }
    }));
    await inMemoryFs.commit();
  }
};
const getCoreFetchPreloadUrls = (config, compilerUrl) => {
  const stencilCoreBase = new URL('..', compilerUrl);
  const stencilResourcePaths = dependencies.find(dep => dep.name === '@stencil/core').resources;
  const tsLibBase = new URL('..', getRemoteTypeScriptUrl(config.sys));
  const tsResourcePaths = dependencies.find(dep => dep.name === 'typescript').resources;
  return [
    ...stencilResourcePaths.map(p => {
      return {
        url: new URL(p, stencilCoreBase).href,
        filePath: getNodeModulePath(config.rootDir, '@stencil', 'core', p),
      };
    }),
    ...tsResourcePaths.map(p => {
      return {
        url: new URL(p, tsLibBase).href,
        filePath: getNodeModulePath(config.rootDir, 'typescript', p),
      };
    }),
  ];
};

// MODULE: compiler/sys/logger.js
const createLogger = () => {
  const logger = {
    colors: true,
    level: '',
    info: console.log.bind(console),
    warn: console.warn.bind(console),
    error: console.error.bind(console),
    debug: console.debug.bind(console),
    red(msg) {
      return msg;
    },
    green(msg) {
      return msg;
    },
    yellow(msg) {
      return msg;
    },
    blue(msg) {
      return msg;
    },
    magenta(msg) {
      return msg;
    },
    cyan(msg) {
      return msg;
    },
    gray(msg) {
      return msg;
    },
    bold(msg) {
      return msg;
    },
    dim(msg) {
      return msg;
    },
    bgRed(msg) {
      return msg;
    },
    createTimeSpan(_startMsg, _debug = false) {
      return {
        duration() {
          return 0;
        },
        finish() {
          return 0;
        },
      };
    },
    printDiagnostics(diagnostics) {
      diagnostics.forEach(diagnostic => {
        logDiagnostic(diagnostic, logger.colors);
      });
    },
    buildLogFilePath: null,
    writeLogs(_) {
      /**/
    },
  };
  return logger;
};
const logDiagnostic = (diagnostic, colors) => {
  let color = BLUE;
  let prefix = 'Build';
  if (diagnostic.level === 'error') {
    color = RED;
    prefix = 'Error';
  }
  else if (diagnostic.level === 'warn') {
    color = YELLOW;
    prefix = 'Warning';
  }
  if (diagnostic.header) {
    prefix = diagnostic.header;
  }
  let msg = '';
  const filePath = diagnostic.relFilePath || diagnostic.absFilePath;
  if (filePath) {
    msg += filePath;
    if (typeof diagnostic.lineNumber === 'number' && diagnostic.lineNumber > 0) {
      msg += ', line ' + diagnostic.lineNumber;
      if (typeof diagnostic.columnNumber === 'number' && diagnostic.columnNumber > 0) {
        msg += ', column ' + diagnostic.columnNumber;
      }
    }
    msg += '\n';
  }
  msg += diagnostic.messageText;
  if (diagnostic.lines && diagnostic.lines.length > 0) {
    diagnostic.lines.forEach(l => {
      msg += '\n' + l.lineNumber + ':  ' + l.text;
    });
    msg += '\n';
  }
  if (colors) {
    const styledPrefix = ['%c' + prefix, `background: ${color}; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;`];
    console.log(...styledPrefix, msg);
  }
  else if (diagnostic.level === 'error') {
    console.error(msg);
  }
  else if (diagnostic.level === 'warn') {
    console.warn(msg);
  }
  else {
    console.log(msg);
  }
};
const YELLOW = `#f39c12`;
const RED = `#c0392b`;
const BLUE = `#3498db`;

// MODULE: compiler/sys/worker/web-worker-main.js
const createWebWorkerMainController = (workerUrl, maxConcurrentWorkers) => {
  let msgIds = 0;
  let isDestroyed = false;
  let isQueued = false;
  let workerIds = 0;
  let workerBlob;
  const tasks = new Map();
  const queuedSendMsgs = [];
  const workers = [];
  const hardwareConcurrency = navigator.hardwareConcurrency || 1;
  const totalWorkers = Math.max(Math.min(maxConcurrentWorkers, hardwareConcurrency), 2) - 1;
  const tick = Promise.resolve();
  const onMsgsFromWorker = (worker, ev) => {
    if (!isDestroyed) {
      const msgsFromWorker = ev.data;
      if (Array.isArray(msgsFromWorker)) {
        for (const msgFromWorker of msgsFromWorker) {
          if (msgFromWorker) {
            const task = tasks.get(msgFromWorker.stencilId);
            if (task) {
              tasks.delete(msgFromWorker.stencilId);
              if (msgFromWorker.stencilRtnError) {
                task.reject(msgFromWorker.stencilRtnError);
              }
              else {
                task.resolve(msgFromWorker.stencilRtnValue);
              }
              worker.activeTasks--;
              if (worker.activeTasks < 0 || worker.activeTasks > 50) {
                worker.activeTasks = 0;
              }
            }
            else if (msgFromWorker.stencilRtnError) {
              console.error(msgFromWorker.stencilRtnError);
            }
          }
        }
      }
    }
  };
  const onError = (e) => console.error(e);
  const createWebWorkerMain = () => {
    let worker = null;
    const workerOpts = {
      name: `stencil.worker.${workerIds++}`,
    };
    try {
      // first try directly starting the worker with the URL
      worker = new Worker(workerUrl, workerOpts);
    }
    catch (e) {
      // probably a cross-origin issue, try using a Blob instead
      if (workerBlob == null) {
        workerBlob = new Blob([`importScripts('${workerUrl}');`], { type: 'application/javascript' });
      }
      worker = new Worker(URL.createObjectURL(workerBlob), workerOpts);
    }
    const workerChild = {
      worker,
      activeTasks: 0,
      sendQueue: [],
    };
    worker.onerror = onError;
    worker.onmessage = ev => onMsgsFromWorker(workerChild, ev);
    return workerChild;
  };
  const sendMsgsToWorkers = (w) => {
    if (w.sendQueue.length > 0) {
      w.worker.postMessage(w.sendQueue);
      w.sendQueue.length = 0;
    }
  };
  const queueMsgToWorker = (msg) => {
    let theChoseOne;
    if (workers.length > 0) {
      theChoseOne = workers[0];
      if (totalWorkers > 1) {
        for (const worker of workers) {
          if (worker.activeTasks < theChoseOne.activeTasks) {
            theChoseOne = worker;
          }
        }
        if (theChoseOne.activeTasks > 0 && workers.length < totalWorkers) {
          theChoseOne = createWebWorkerMain();
          workers.push(theChoseOne);
        }
      }
    }
    else {
      theChoseOne = createWebWorkerMain();
      workers.push(theChoseOne);
    }
    theChoseOne.activeTasks++;
    theChoseOne.sendQueue.push(msg);
  };
  const flushSendQueue = () => {
    isQueued = false;
    queuedSendMsgs.forEach(queueMsgToWorker);
    queuedSendMsgs.length = 0;
    workers.forEach(sendMsgsToWorkers);
  };
  const send = (...args) => new Promise((resolve, reject) => {
    if (isDestroyed) {
      reject(TASK_CANCELED_MSG);
    }
    else {
      const msg = {
        stencilId: msgIds++,
        args,
      };
      queuedSendMsgs.push(msg);
      tasks.set(msg.stencilId, {
        resolve,
        reject,
      });
      if (!isQueued) {
        isQueued = true;
        tick.then(flushSendQueue);
      }
    }
  });
  const destroy = () => {
    isDestroyed = true;
    tasks.forEach(t => t.reject(TASK_CANCELED_MSG));
    tasks.clear();
    workers.forEach(w => w.worker.terminate());
    workers.length = 0;
  };
  const handler = (name) => {
    return function (...args) {
      return send(name, ...args);
    };
  };
  return {
    send,
    destroy,
    handler,
  };
};

// MODULE: compiler/sys/stencil-sys.js
const createSystem = () => {
  const items = new Map();
  const destroys = new Set();
  const addDestory = (cb) => destroys.add(cb);
  const removeDestory = (cb) => destroys.delete(cb);
  const events = buildEvents();
  const destroy = async () => {
    const waits = [];
    destroys.forEach(cb => {
      try {
        const rtn = cb();
        if (rtn && rtn.then) {
          waits.push(rtn);
        }
      }
      catch (e) {
        console.error(`stencil sys destroy: ${e}`);
      }
    });
    await Promise.all(waits);
    destroys.clear();
  };
  const normalize = (p) => {
    if (p === '/' || p === '') {
      return '/';
    }
    const dir = dirname(p);
    const base = basename(p);
    if (dir.endsWith('/')) {
      return normalizePath(`${dir}${base}`);
    }
    return normalizePath(`${dir}/${base}`);
  };
  const accessSync = (p) => {
    const item = items.get(normalize(p));
    return !!(item && (item.isDirectory || item.isFile));
  };
  const access = async (p) => accessSync(p);
  const copyFile = async (src, dest) => {
    writeFileSync(dest, readFileSync(src));
    return true;
  };
  const encodeToBase64 = (str) => btoa(unescape(encodeURIComponent(str)));
  const getCurrentDirectory = () => {
    if (IS_NODE_ENV) {
      return global['process'].cwd();
    }
    return '/';
  };
  const getCompilerExecutingPath = () => {
    if (IS_NODE_ENV) {
      return __filename;
    }
    if (IS_WEB_WORKER_ENV) {
      return location.href;
    }
    throw new Error('unable to find executing path');
  };
  const isSymbolicLink = (_p) => new Promise(resolve => {
    resolve(false);
  });
  const mkdirSync = (p, _opts) => {
    p = normalize(p);
    const item = items.get(p);
    if (!item) {
      items.set(p, {
        basename: basename(p),
        dirname: dirname(p),
        isDirectory: true,
        isFile: false,
        watcherCallbacks: null,
        data: undefined,
      });
      emitDirectoryWatch(p, new Set());
    }
    else {
      item.isDirectory = true;
      item.isFile = false;
    }
    return true;
  };
  const mkdir = async (p, opts) => mkdirSync(p);
  const readdirSync = (p) => {
    p = normalize(p);
    const dirItems = [];
    const dir = items.get(p);
    if (dir && dir.isDirectory) {
      items.forEach((item, itemPath) => {
        if (itemPath !== '/') {
          if (p.endsWith('/') && `${p}${item.basename}` === itemPath) {
            dirItems.push(itemPath);
          }
          else if (`${p}/${item.basename}` === itemPath) {
            dirItems.push(itemPath);
          }
        }
      });
    }
    return dirItems.sort();
  };
  const readdir = async (p) => readdirSync(p);
  const readFileSync = (p) => {
    p = normalize(p);
    const item = items.get(p);
    if (item && item.isFile) {
      return item.data;
    }
    return undefined;
  };
  const readFile = async (p) => readFileSync(p);
  const realpathSync = (p) => normalize(p);
  const realpath = async (p) => realpathSync(p);
  const resolvePath = (p) => normalize(p);
  const rmdirSync = (p) => {
    p = normalize(p);
    items.delete(p);
    emitDirectoryWatch(p, new Set());
    return true;
  };
  const rmdir = async (p) => rmdirSync(p);
  const statSync = (p) => {
    p = normalize(p);
    const item = items.get(p);
    if (item && (item.isDirectory || item.isFile)) {
      const s = {
        isDirectory: () => item.isDirectory,
        isFile: () => item.isFile,
        isSymbolicLink: () => false,
        size: item.isFile ? item.data.length : 0,
      };
      return s;
    }
    return undefined;
  };
  const stat = async (p) => statSync(p);
  const unlinkSync = (p) => {
    p = normalize(p);
    const item = items.get(p);
    if (item) {
      if (item.watcherCallbacks) {
        item.watcherCallbacks.forEach(watcherCallback => {
          watcherCallback(p, 'fileDelete');
        });
      }
      items.delete(p);
      emitDirectoryWatch(p, new Set());
    }
    return true;
  };
  const unlink = async (p) => unlinkSync(p);
  const watchDirectory = (p, dirWatcherCallback) => {
    p = normalize(p);
    const item = items.get(p);
    const close = () => {
      const closeItem = items.get(p);
      if (closeItem && closeItem.watcherCallbacks) {
        const index = closeItem.watcherCallbacks.indexOf(dirWatcherCallback);
        if (index > -1) {
          closeItem.watcherCallbacks.splice(index, 1);
        }
      }
    };
    addDestory(close);
    if (item) {
      item.isDirectory = true;
      item.isFile = false;
      item.watcherCallbacks = item.watcherCallbacks || [];
      item.watcherCallbacks.push(dirWatcherCallback);
    }
    else {
      items.set(p, {
        basename: basename(p),
        dirname: dirname(p),
        isDirectory: true,
        isFile: false,
        watcherCallbacks: [dirWatcherCallback],
        data: undefined,
      });
    }
    return {
      close() {
        removeDestory(close);
        close();
      },
    };
  };
  const watchFile = (p, fileWatcherCallback) => {
    p = normalize(p);
    const item = items.get(p);
    const close = () => {
      const closeItem = items.get(p);
      if (closeItem && closeItem.watcherCallbacks) {
        const index = closeItem.watcherCallbacks.indexOf(fileWatcherCallback);
        if (index > -1) {
          closeItem.watcherCallbacks.splice(index, 1);
        }
      }
    };
    addDestory(close);
    if (item) {
      item.isDirectory = false;
      item.isFile = true;
      item.watcherCallbacks = item.watcherCallbacks || [];
      item.watcherCallbacks.push(fileWatcherCallback);
    }
    else {
      items.set(p, {
        basename: basename(p),
        dirname: dirname(p),
        isDirectory: true,
        isFile: false,
        watcherCallbacks: [fileWatcherCallback],
        data: undefined,
      });
    }
    return {
      close() {
        removeDestory(close);
        close();
      },
    };
  };
  const emitDirectoryWatch = (p, emitted) => {
    const parentDir = normalize(dirname(p));
    const dirItem = items.get(parentDir);
    if (dirItem && dirItem.isDirectory && dirItem.watcherCallbacks) {
      dirItem.watcherCallbacks.forEach(watcherCallback => {
        watcherCallback(p, null);
      });
    }
    if (!emitted.has(parentDir)) {
      emitted.add(parentDir);
      emitDirectoryWatch(parentDir, emitted);
    }
  };
  const writeFileSync = (p, data) => {
    p = normalize(p);
    const item = items.get(p);
    if (item) {
      const hasChanged = item.data !== data;
      item.data = data;
      if (hasChanged && item.watcherCallbacks) {
        item.watcherCallbacks.forEach(watcherCallback => {
          watcherCallback(p, 'fileUpdate');
        });
      }
    }
    else {
      items.set(p, {
        basename: basename(p),
        dirname: dirname(p),
        isDirectory: false,
        isFile: true,
        watcherCallbacks: null,
        data,
      });
      emitDirectoryWatch(p, new Set());
    }
    return true;
  };
  const generateContentHash = async (content) => {
    const arrayBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(content));
    const hashArray = Array.from(new Uint8Array(arrayBuffer)); // convert buffer to byte array
    let hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string
    if (typeof length === 'number') {
      hashHex = hashHex.substr(0, length);
    }
    return hashHex;
  };
  const writeFile = async (p, data) => writeFileSync(p, data);
  const copy = async (copyTasks, srcDir) => {
    const results = {
      diagnostics: [],
      dirPaths: [],
      filePaths: [],
    };
    console.log('todo, copy task', copyTasks.length, srcDir);
    return results;
  };
  const fileWatchTimeout = 32;
  mkdirSync('/');
  const sys = {
    events,
    access,
    accessSync,
    addDestory,
    copyFile,
    destroy,
    encodeToBase64,
    watchTimeout: fileWatchTimeout,
    getCurrentDirectory,
    getCompilerExecutingPath,
    isSymbolicLink,
    mkdir,
    mkdirSync,
    normalizePath: normalize,
    readdir,
    readdirSync,
    readFile,
    readFileSync,
    realpath,
    realpathSync,
    removeDestory,
    resolvePath,
    rmdir,
    rmdirSync,
    stat,
    statSync,
    unlink,
    unlinkSync,
    watchDirectory,
    watchFile,
    writeFile,
    writeFileSync,
    generateContentHash,
    createWorkerController: HAS_WEB_WORKER ? createWebWorkerMainController : null,
    details: getDetails(),
    copy,
  };
  sys.resolveModuleId = opts => resolveModuleIdAsync(sys, null, opts);
  return sys;
};
const getDetails = () => {
  const details = {
    cpuModel: '',
    cpus: -1,
    freemem() {
      return 0;
    },
    platform: '',
    release: '',
    runtime: 'node',
    runtimeVersion: '',
    tmpDir: '/.tmp',
    totalmem: -1,
  };
  return details;
};

// MODULE: compiler/sys/config.js
const getConfig = (userConfig) => {
  const config = Object.assign({}, userConfig);
  if (!config.logger) {
    config.logger = createLogger();
  }
  if (!config.sys) {
    config.sys = createSystem();
  }
  config.flags = config.flags || {};
  if (config.flags.debug || config.flags.verbose) {
    config.logLevel = 'debug';
  }
  else if (config.flags.logLevel) {
    config.logLevel = config.flags.logLevel;
  }
  else if (typeof config.logLevel !== 'string') {
    config.logLevel = 'info';
  }
  config.logger.level = config.logLevel;
  return config;
};

// MODULE: compiler/sys/fs-patch.js
const patchFs = (userSys) => {
  const fsObj = fs;
  Object.assign(fsObj.__sys, userSys);
};

// MODULE: compiler/compiler.js
const createCompiler = async (config) => {
  // actual compiler code
  // could be in a web worker on the browser
  // or the main thread in node
  config = getConfig(config);
  const diagnostics = [];
  const sys = config.sys;
  const compilerCtx = new CompilerContext();
  patchFs(sys);
  compilerCtx.fs = createInMemoryFs(sys);
  compilerCtx.cache = new Cache(config, createInMemoryFs(sys));
  await compilerCtx.cache.initCacheDir();
  sys.resolveModuleId = opts => resolveModuleIdAsync(sys, compilerCtx.fs, opts);
  compilerCtx.worker = createSysWorker(sys, config.maxConcurrentWorkers);
  await fetchPreloadFs(config, compilerCtx.fs);
  if (sys.events) {
    // Pipe events from sys.events to compilerCtx
    sys.events.on(compilerCtx.events.emit);
  }
  await patchTypescript(config, diagnostics, compilerCtx.fs);
  const build = () => createFullBuild(config, compilerCtx);
  const createWatcher = () => createWatchBuild(config, compilerCtx);
  const destroy = async () => {
    compilerCtx.reset();
    compilerCtx.events.unsubscribeAll();
    await sys.destroy();
  };
  const compiler = {
    build,
    createWatcher,
    destroy,
    sys,
  };
  config.logger.printDiagnostics(diagnostics);
  return compiler;
};

// MODULE: compiler/config/config-utils.js
const getAbsolutePath = (config, dir) => {
  if (!isAbsolute(dir)) {
    dir = join(config.rootDir, dir);
  }
  return dir;
};
const setBooleanConfig = (config, configName, flagName, defaultValue) => {
  if (flagName) {
    if (typeof config.flags[flagName] === 'boolean') {
      config[configName] = config.flags[flagName];
    }
  }
  const userConfigName = getUserConfigName(config, configName);
  if (typeof config[userConfigName] === 'function') {
    config[userConfigName] = !!config[userConfigName]();
  }
  if (typeof config[userConfigName] === 'boolean') {
    config[configName] = config[userConfigName];
  }
  else {
    config[configName] = defaultValue;
  }
};
const getUserConfigName = (config, correctConfigName) => {
  const userConfigNames = Object.keys(config);
  for (const userConfigName of userConfigNames) {
    if (userConfigName.toLowerCase() === correctConfigName.toLowerCase()) {
      if (userConfigName !== correctConfigName) {
        config.logger.warn(`config "${userConfigName}" should be "${correctConfigName}"`);
        return userConfigName;
      }
      break;
    }
  }
  return correctConfigName;
};

// MODULE: compiler/config/validate-dev-server.js
const validateDevServer = (config, diagnostics) => {
  if (config.devServer === false || config.devServer === null) {
    return null;
  }
  const flags = config.flags;
  const devServer = Object.assign({}, config.devServer);
  if (isString(flags.address)) {
    devServer.address = flags.address;
  }
  else if (!isString(devServer.address)) {
    devServer.address = '0.0.0.0';
  }
  let addressProtocol;
  if (devServer.address.toLowerCase().startsWith('http://')) {
    devServer.address = devServer.address.substring(7);
    addressProtocol = 'http';
  }
  else if (devServer.address.toLowerCase().startsWith('https://')) {
    devServer.address = devServer.address.substring(8);
    addressProtocol = 'https';
  }
  devServer.address = devServer.address.split('/')[0];
  let addressPort;
  const addressSplit = devServer.address.split(':');
  if (addressSplit.length > 1) {
    if (!isNaN(addressSplit[1])) {
      devServer.address = addressSplit[0];
      addressPort = parseInt(addressSplit[1], 10);
    }
  }
  if (isNumber(flags.port)) {
    devServer.port = flags.port;
  }
  else if (devServer.port !== null && !isNumber(devServer.port)) {
    if (isNumber(addressPort)) {
      devServer.port = addressPort;
    }
    else if (devServer.address === 'localhost' || !isNaN(devServer.address.split('.')[0])) {
      devServer.port = 3333;
    }
    else {
      devServer.port = null;
    }
  }
  if (devServer.hotReplacement === true) {
    // DEPRECATED: 2019-05-20
    devServer.reloadStrategy = 'hmr';
  }
  else if (devServer.hotReplacement === false || devServer.hotReplacement === null) {
    // DEPRECATED: 2019-05-20
    devServer.reloadStrategy = null;
  }
  else {
    if (devServer.reloadStrategy === undefined) {
      devServer.reloadStrategy = 'hmr';
    }
    else if (devServer.reloadStrategy !== 'hmr' && devServer.reloadStrategy !== 'pageReload' && devServer.reloadStrategy !== null) {
      throw new Error(`Invalid devServer reloadStrategy "${devServer.reloadStrategy}". Valid configs include "hmr", "pageReload" and null.`);
    }
  }
  if (!isBoolean(devServer.gzip)) {
    devServer.gzip = true;
  }
  if (!isBoolean(devServer.openBrowser)) {
    devServer.openBrowser = true;
  }
  if (!isBoolean(devServer.websocket)) {
    devServer.websocket = true;
  }
  if (devServer.protocol !== 'http' && devServer.protocol !== 'https') {
    devServer.protocol = devServer.https ? 'https' : addressProtocol ? addressProtocol : 'http';
  }
  if (devServer.historyApiFallback !== null && devServer.historyApiFallback !== false) {
    devServer.historyApiFallback = devServer.historyApiFallback || {};
    if (!isString(devServer.historyApiFallback.index)) {
      devServer.historyApiFallback.index = 'index.html';
    }
    if (!isBoolean(devServer.historyApiFallback.disableDotRule)) {
      devServer.historyApiFallback.disableDotRule = false;
    }
  }
  if (flags.open === false) {
    devServer.openBrowser = false;
  }
  else if (flags.prerender && !config.watch) {
    devServer.openBrowser = false;
  }
  let serveDir = null;
  let basePath = null;
  const wwwOutputTarget = config.outputTargets.find(isOutputTargetWww);
  if (wwwOutputTarget) {
    const baseUrl = new URL(wwwOutputTarget.baseUrl, 'http://config.stenciljs.com');
    basePath = baseUrl.pathname;
    serveDir = wwwOutputTarget.appDir;
  }
  else {
    serveDir = config.rootDir;
  }
  if (!isString(basePath) || basePath.trim() === '') {
    basePath = `/`;
  }
  basePath = normalizePath(basePath);
  if (!basePath.startsWith('/')) {
    basePath = '/' + basePath;
  }
  if (!basePath.endsWith('/')) {
    basePath += '/';
  }
  if (!isBoolean(devServer.logRequests)) {
    devServer.logRequests = config.logLevel === 'debug';
  }
  if (!isString(devServer.root)) {
    devServer.root = serveDir;
  }
  if (!isString(devServer.basePath)) {
    devServer.basePath = basePath;
  }
  if (isString(devServer.baseUrl)) {
    const err = buildError(diagnostics);
    err.messageText = `devServer config "baseUrl" has been renamed to "basePath", and should not include a domain or protocol.`;
  }
  if (!isAbsolute(devServer.root)) {
    devServer.root = join(config.rootDir, devServer.root);
  }
  devServer.root = normalizePath(devServer.root);
  if (devServer.excludeHmr) {
    if (!Array.isArray(devServer.excludeHmr)) {
      const err = buildError(diagnostics);
      err.messageText = `dev server excludeHmr must be an array of glob strings`;
    }
  }
  else {
    devServer.excludeHmr = [];
  }
  if (!config.devMode || config.buildEs5) {
    devServer.experimentalDevModules = false;
  }
  else {
    devServer.experimentalDevModules = !!devServer.experimentalDevModules;
  }
  return devServer;
};

// MODULE: compiler/config/validate-namespace.js
const validateNamespace = (c, diagnostics) => {
  c.namespace = isString(c.namespace) ? c.namespace : DEFAULT_NAMESPACE;
  c.namespace = c.namespace.trim();
  const invalidNamespaceChars = c.namespace.replace(/(\w)|(\-)|(\$)/g, '');
  if (invalidNamespaceChars !== '') {
    const err = buildError(diagnostics);
    err.messageText = `Namespace "${c.namespace}" contains invalid characters: ${invalidNamespaceChars}`;
  }
  if (c.namespace.length < 3) {
    const err = buildError(diagnostics);
    err.messageText = `Namespace "${c.namespace}" must be at least 3 characters`;
  }
  if (/^\d+$/.test(c.namespace.charAt(0))) {
    const err = buildError(diagnostics);
    err.messageText = `Namespace "${c.namespace}" cannot have a number for the first character`;
  }
  if (c.namespace.charAt(0) === '-') {
    const err = buildError(diagnostics);
    err.messageText = `Namespace "${c.namespace}" cannot have a dash for the first character`;
  }
  if (c.namespace.charAt(c.namespace.length - 1) === '-') {
    const err = buildError(diagnostics);
    err.messageText = `Namespace "${c.namespace}" cannot have a dash for the last character`;
  }
  // the file system namespace is the one
  // used in filenames and seen in the url
  if (!isString(c.fsNamespace)) {
    c.fsNamespace = c.namespace.toLowerCase().trim();
  }
  if (c.namespace.includes('-')) {
    // convert to PascalCase
    c.namespace = dashToPascalCase(c.namespace);
  }
};
const validateDistNamespace = (config, diagnostics) => {
  const hasDist = config.outputTargets.some(isOutputTargetDist);
  if (hasDist) {
    if (!isString(config.namespace) || config.namespace.toLowerCase() === 'app') {
      const err = buildError(diagnostics);
      err.messageText = `When generating a distribution it is recommended to choose a unique namespace rather than the default setting "App". Please updated the "namespace" config property within the stencil config.`;
    }
  }
};
const DEFAULT_NAMESPACE = 'App';

// MODULE: compiler/config/validate-hydrated.js
const validateHydrated = (config) => {
  if (config.hydratedFlag === null || config.hydratedFlag === false) {
    return null;
  }
  const hydratedFlag = Object.assign({}, config.hydratedFlag);
  if (!isString(hydratedFlag.name) || hydratedFlag.property === '') {
    hydratedFlag.name = `hydrated`;
  }
  if (hydratedFlag.selector === 'attribute') {
    hydratedFlag.selector = `attribute`;
  }
  else {
    hydratedFlag.selector = `class`;
  }
  if (!isString(hydratedFlag.property) || hydratedFlag.property === '') {
    hydratedFlag.property = `visibility`;
  }
  if (!isString(hydratedFlag.initialValue) && hydratedFlag.initialValue !== null) {
    hydratedFlag.initialValue = `hidden`;
  }
  if (!isString(hydratedFlag.hydratedValue) && hydratedFlag.initialValue !== null) {
    hydratedFlag.hydratedValue = `inherit`;
  }
  return hydratedFlag;
};

// MODULE: compiler/config/outputs/validate-collection.js
const validateCollection$1 = (config, userOutputs) => {
  return userOutputs.filter(isOutputTargetDistCollection).map(o => {
    return Object.assign(Object.assign({}, o), { dir: getAbsolutePath(config, o.dir || 'dist/collection') });
  });
};

// MODULE: compiler/config/outputs/validate-custom-element.js
const validateCustomElement = (config, userOutputs) => {
  return userOutputs.filter(isOutputTargetDistCustomElements).map(o => {
    const outputTarget = Object.assign(Object.assign({}, o), { dir: getAbsolutePath(config, o.dir || 'dist/components') });
    if (!isBoolean(outputTarget.empty)) {
      outputTarget.empty = true;
    }
    return outputTarget;
  });
};

// MODULE: compiler/config/outputs/validate-custom-output.js
const validateCustomOutput = (config, diagnostics, userOutputs) => {
  return userOutputs.filter(isOutputTargetCustom).map(o => {
    if (o.validate) {
      const localDiagnostics = [];
      try {
        o.validate(config, diagnostics);
      }
      catch (e) {
        catchError(localDiagnostics, e);
      }
      if (o.copy && o.copy.length > 0) {
        config.outputTargets.push({
          type: COPY,
          dir: config.rootDir,
          copy: [...o.copy],
        });
      }
      diagnostics.push(...localDiagnostics);
    }
    return o;
  });
};

// MODULE: compiler/config/validate-copy.js
const validateCopy = (copy, defaultCopy = []) => {
  if (copy === null || copy === false) {
    return [];
  }
  if (!Array.isArray(copy)) {
    copy = [];
  }
  copy = copy.slice();
  for (const task of defaultCopy) {
    if (copy.every(t => t.src !== task.src)) {
      copy.push(task);
    }
  }
  return unique(copy, task => `${task.src}:${task.dest}:${task.keepDirStructure}`);
};

// MODULE: compiler/config/outputs/validate-dist.js
const validateDist = (config, userOutputs) => {
  const distOutputTargets = userOutputs.filter(isOutputTargetDist);
  return distOutputTargets.reduce((outputs, o) => {
    const distOutputTarget = validateOutputTargetDist(config, o);
    outputs.push(distOutputTarget);
    const namespace = config.fsNamespace || 'app';
    const lazyDir = join(distOutputTarget.buildDir, namespace);
    // Lazy build for CDN in dist
    outputs.push({
      type: DIST_LAZY,
      esmDir: lazyDir,
      systemDir: config.buildEs5 ? lazyDir : undefined,
      systemLoaderFile: config.buildEs5 ? join(lazyDir, namespace + '.js') : undefined,
      legacyLoaderFile: join(distOutputTarget.buildDir, namespace + '.js'),
      polyfills: distOutputTarget.polyfills !== undefined ? !!distOutputTarget.polyfills : true,
      isBrowserBuild: true,
      empty: distOutputTarget.empty,
    });
    outputs.push({
      type: COPY,
      dir: lazyDir,
      copyAssets: 'dist',
    });
    outputs.push({
      type: DIST_GLOBAL_STYLES,
      file: join(lazyDir, `${config.fsNamespace}.css`),
    });
    if (config.buildDist) {
      if (distOutputTarget.collectionDir) {
        outputs.push({
          type: DIST_COLLECTION,
          dir: distOutputTarget.dir,
          collectionDir: distOutputTarget.collectionDir,
          empty: distOutputTarget.empty,
        });
        outputs.push({
          type: COPY,
          dir: distOutputTarget.collectionDir,
          copyAssets: 'collection',
          copy: [...distOutputTarget.copy, { src: '**/*.svg' }, { src: '**/*.js' }],
        });
      }
      outputs.push({
        type: DIST_TYPES,
        dir: distOutputTarget.dir,
        typesDir: distOutputTarget.typesDir,
        empty: distOutputTarget.empty,
      });
      const esmDir = join(distOutputTarget.dir, 'esm');
      const esmEs5Dir = config.buildEs5 ? join(distOutputTarget.dir, 'esm-es5') : undefined;
      const cjsDir = join(distOutputTarget.dir, 'cjs');
      // Create lazy output-target
      outputs.push({
        type: DIST_LAZY,
        esmDir,
        esmEs5Dir,
        cjsDir,
        cjsIndexFile: join(distOutputTarget.dir, 'index.js'),
        esmIndexFile: join(distOutputTarget.dir, 'index.mjs'),
        polyfills: true,
        empty: distOutputTarget.empty,
      });
      // Create output target that will generate the /loader entry-point
      outputs.push({
        type: DIST_LAZY_LOADER,
        dir: distOutputTarget.esmLoaderPath,
        esmDir,
        esmEs5Dir,
        cjsDir,
        componentDts: getComponentsDtsTypesFilePath(distOutputTarget),
        empty: distOutputTarget.empty,
      });
    }
    return outputs;
  }, []);
};
const validateOutputTargetDist = (config, o) => {
  const outputTarget = Object.assign(Object.assign({}, o), { dir: getAbsolutePath(config, o.dir || DEFAULT_DIR) });
  if (!isString(outputTarget.buildDir)) {
    outputTarget.buildDir = DEFAULT_BUILD_DIR;
  }
  if (!isAbsolute(outputTarget.buildDir)) {
    outputTarget.buildDir = join(outputTarget.dir, outputTarget.buildDir);
  }
  if (outputTarget.collectionDir === undefined) {
    outputTarget.collectionDir = DEFAULT_COLLECTION_DIR;
  }
  if (outputTarget.collectionDir && !isAbsolute(outputTarget.collectionDir)) {
    outputTarget.collectionDir = join(outputTarget.dir, outputTarget.collectionDir);
  }
  if (!outputTarget.esmLoaderPath) {
    outputTarget.esmLoaderPath = DEFAULT_ESM_LOADER_DIR;
  }
  if (!isAbsolute(outputTarget.esmLoaderPath)) {
    outputTarget.esmLoaderPath = resolve(outputTarget.dir, outputTarget.esmLoaderPath);
  }
  if (!outputTarget.typesDir) {
    outputTarget.typesDir = DEFAULT_TYPES_DIR;
  }
  if (!isAbsolute(outputTarget.typesDir)) {
    outputTarget.typesDir = join(outputTarget.dir, outputTarget.typesDir);
  }
  if (!isBoolean(outputTarget.empty)) {
    outputTarget.empty = true;
  }
  outputTarget.copy = validateCopy(outputTarget.copy, config.copy);
  return outputTarget;
};
const DEFAULT_DIR = 'dist';
const DEFAULT_BUILD_DIR = '';
const DEFAULT_COLLECTION_DIR = 'collection';
const DEFAULT_TYPES_DIR = 'types';
const DEFAULT_ESM_LOADER_DIR = 'loader';

// MODULE: compiler/config/outputs/validate-docs.js
const validateDocs = (config, diagnostics, userOutputs) => {
  const docsOutputs = [];
  // json docs flag
  if (typeof config.flags.docsJson === 'string') {
    docsOutputs.push(validateJsonDocsOutputTarget(config, diagnostics, {
      type: 'docs-json',
      file: config.flags.docsJson,
    }));
  }
  // json docs
  const jsonDocsOutputs = userOutputs.filter(isOutputTargetDocsJson);
  jsonDocsOutputs.forEach(jsonDocsOutput => {
    docsOutputs.push(validateJsonDocsOutputTarget(config, diagnostics, jsonDocsOutput));
  });
  // readme docs flag
  if (config.flags.docs || config.flags.task === 'docs') {
    if (!userOutputs.some(isOutputTargetDocsReadme)) {
      // didn't provide a docs config, so let's add one
      docsOutputs.push(validateReadmeOutputTarget(config, diagnostics, { type: 'docs-readme' }));
    }
  }
  // readme docs
  const readmeDocsOutputs = userOutputs.filter(isOutputTargetDocsReadme);
  readmeDocsOutputs.forEach(readmeDocsOutput => {
    docsOutputs.push(validateReadmeOutputTarget(config, diagnostics, readmeDocsOutput));
  });
  // custom docs
  const customDocsOutputs = userOutputs.filter(isOutputTargetDocsCustom);
  customDocsOutputs.forEach(jsonDocsOutput => {
    docsOutputs.push(validateCustomDocsOutputTarget(diagnostics, jsonDocsOutput));
  });
  // vscode docs
  const vscodeDocsOutputs = userOutputs.filter(isOutputTargetDocsVscode);
  vscodeDocsOutputs.forEach(vscodeDocsOutput => {
    docsOutputs.push(validateVScodeDocsOutputTarget(diagnostics, vscodeDocsOutput));
  });
  return docsOutputs;
};
const validateReadmeOutputTarget = (config, diagnostics, outputTarget) => {
  if (outputTarget.type === 'docs') {
    diagnostics.push({
      type: 'config',
      level: 'warn',
      header: 'Deprecated "docs"',
      messageText: `The output target { type: "docs" } has been deprecated, please use "docs-readme" instead.`,
      absFilePath: config.configPath,
    });
    outputTarget.type = 'docs-readme';
  }
  if (typeof outputTarget.dir !== 'string') {
    outputTarget.dir = config.srcDir;
  }
  if (!isAbsolute(outputTarget.dir)) {
    outputTarget.dir = join(config.rootDir, outputTarget.dir);
  }
  if (outputTarget.footer == null) {
    outputTarget.footer = NOTE;
  }
  outputTarget.strict = !!outputTarget.strict;
  return outputTarget;
};
const validateJsonDocsOutputTarget = (config, diagnostics, outputTarget) => {
  if (typeof outputTarget.file !== 'string') {
    const err = buildError(diagnostics);
    err.messageText = `docs-json outputTarget missing the "file" option`;
  }
  outputTarget.file = join(config.rootDir, outputTarget.file);
  if (typeof outputTarget.typesFile === 'string') {
    outputTarget.typesFile = join(config.rootDir, outputTarget.typesFile);
  }
  else if (outputTarget.typesFile !== null && outputTarget.file.endsWith('.json')) {
    outputTarget.typesFile = outputTarget.file.replace(/\.json$/, '.d.ts');
  }
  outputTarget.strict = !!outputTarget.strict;
  return outputTarget;
};
const validateCustomDocsOutputTarget = (diagnostics, outputTarget) => {
  if (typeof outputTarget.generator !== 'function') {
    const err = buildError(diagnostics);
    err.messageText = `docs-custom outputTarget missing the "generator" function`;
  }
  outputTarget.strict = !!outputTarget.strict;
  return outputTarget;
};
const validateVScodeDocsOutputTarget = (diagnostics, outputTarget) => {
  if (typeof outputTarget.file !== 'string') {
    const err = buildError(diagnostics);
    err.messageText = `docs-vscode outputTarget missing the "file" paht`;
  }
  return outputTarget;
};

// MODULE: compiler/config/outputs/validate-angular.js
const validateAngular = (userConfig, userOutputs) => {
  const angularOutputTargets = userOutputs.filter(isOutputTargetAngular);
  return angularOutputTargets.map(outputTarget => {
    let directivesProxyFile = outputTarget.directivesProxyFile;
    if (directivesProxyFile && !isAbsolute(directivesProxyFile)) {
      directivesProxyFile = join(userConfig.rootDir, directivesProxyFile);
    }
    let directivesArrayFile = outputTarget.directivesArrayFile;
    if (directivesArrayFile && !isAbsolute(directivesArrayFile)) {
      directivesArrayFile = join(userConfig.rootDir, directivesArrayFile);
    }
    let directivesUtilsFile = outputTarget.directivesUtilsFile;
    if (directivesUtilsFile && !isAbsolute(directivesUtilsFile)) {
      directivesUtilsFile = join(userConfig.rootDir, directivesUtilsFile);
    }
    return {
      type: 'angular',
      componentCorePackage: outputTarget.componentCorePackage,
      directivesProxyFile,
      directivesArrayFile,
      directivesUtilsFile,
      excludeComponents: outputTarget.excludeComponents || []
    };
  });
};

// MODULE: compiler/config/outputs/validate-hydrate-script.js
const validateHydrateScript = (config, userOutputs) => {
  const output = [];
  const hasHydrateOutputTarget = userOutputs.some(isOutputTargetHydrate);
  if (!hasHydrateOutputTarget) {
    // we don't already have a hydrate output target
    // let's still see if we require one because of other output targets
    const hasWwwOutput = userOutputs.filter(isOutputTargetWww).some(o => isString(o.indexHtml));
    if (hasWwwOutput && config.flags && config.flags.prerender) {
      // we're prerendering a www output target, so we'll need a hydrate app
      let hydrateDir;
      const distOutput = userOutputs.find(isOutputTargetDist);
      if (distOutput != null && isString(distOutput.dir)) {
        hydrateDir = join(distOutput.dir, 'hydrate');
      }
      else {
        hydrateDir = 'dist/hydrate';
      }
      const hydrateForWwwOutputTarget = {
        type: DIST_HYDRATE_SCRIPT,
        dir: hydrateDir,
      };
      userOutputs.push(hydrateForWwwOutputTarget);
    }
  }
  const hydrateOutputTargets = userOutputs.filter(isOutputTargetHydrate);
  hydrateOutputTargets.forEach(outputTarget => {
    if (!isString(outputTarget.dir)) {
      // no directory given, see if we've got a dist to go off of
      outputTarget.dir = 'hydrate';
    }
    if (!isAbsolute(outputTarget.dir)) {
      outputTarget.dir = join(config.rootDir, outputTarget.dir);
    }
    if (!isBoolean(outputTarget.empty)) {
      outputTarget.empty = true;
    }
    output.push(outputTarget);
  });
  return output;
};

// MODULE: compiler/config/outputs/validate-lazy.js
const validateLazy = (config, userOutputs) => {
  return userOutputs.filter(isOutputTargetDistLazy).map(o => {
    const dir = getAbsolutePath(config, o.dir || join('dist', config.fsNamespace));
    const lazyOutput = {
      type: DIST_LAZY,
      esmDir: dir,
      systemDir: config.buildEs5 ? dir : undefined,
      systemLoaderFile: config.buildEs5 ? join(dir, `${config.fsNamespace}.js`) : undefined,
      polyfills: !!o.polyfills,
      isBrowserBuild: true,
      empty: isBoolean(o.empty) ? o.empty : true,
    };
    return lazyOutput;
  });
};

// MODULE: compiler/config/outputs/validate-stats.js
const validateStats = (userConfig, userOutputs) => {
  const outputTargets = [];
  if (userConfig.flags.stats) {
    const hasOutputTarget = userOutputs.some(isOutputTargetStats);
    if (!hasOutputTarget) {
      outputTargets.push({
        type: STATS,
      });
    }
  }
  outputTargets.push(...userOutputs.filter(isOutputTargetStats));
  outputTargets.forEach(outputTarget => {
    if (!outputTarget.file) {
      outputTarget.file = 'stencil-stats.json';
    }
    if (!isAbsolute(outputTarget.file)) {
      outputTarget.file = join(userConfig.rootDir, outputTarget.file);
    }
  });
  return outputTargets;
};

// MODULE: compiler/config/validate-prerender.js
const validatePrerender = (config, diagnostics, outputTarget) => {
  if (!config.flags || (!config.flags.prerender && config.flags.task !== 'prerender')) {
    return;
  }
  outputTarget.baseUrl = normalizePath(outputTarget.baseUrl);
  if (!outputTarget.baseUrl.startsWith('http://') && !outputTarget.baseUrl.startsWith('https://')) {
    const err = buildError(diagnostics);
    err.messageText = `When prerendering, the "baseUrl" output target config must be a full URL and start with either "http://" or "https://". The config can be updated in the "www" output target within the stencil config.`;
  }
  try {
    new URL(outputTarget.baseUrl);
  }
  catch (e) {
    const err = buildError(diagnostics);
    err.messageText = `invalid "baseUrl": ${e}`;
  }
  if (!outputTarget.baseUrl.endsWith('/')) {
    outputTarget.baseUrl += '/';
  }
  if (typeof outputTarget.prerenderConfig === 'string') {
    if (!isAbsolute(outputTarget.prerenderConfig)) {
      outputTarget.prerenderConfig = join(config.rootDir, outputTarget.prerenderConfig);
    }
  }
};

// MODULE: prerender/host-config.js
const HOST_CONFIG_FILENAME = 'host.config.json';

// MODULE: compiler/config/validate-service-worker.js
const validateServiceWorker = (config, outputTarget) => {
  if (outputTarget.serviceWorker === false) {
    return;
  }
  if (config.devMode && !config.flags.serviceWorker) {
    outputTarget.serviceWorker = null;
    return;
  }
  if (outputTarget.serviceWorker === null) {
    outputTarget.serviceWorker = null;
    return;
  }
  if (outputTarget.serviceWorker === true) {
    outputTarget.serviceWorker = {};
  }
  else if (!outputTarget.serviceWorker && config.devMode) {
    outputTarget.serviceWorker = null;
    return;
  }
  if (typeof outputTarget.serviceWorker !== 'object') {
    // what was passed in could have been a boolean
    // in that case let's just turn it into an empty obj so Object.assign doesn't crash
    outputTarget.serviceWorker = {};
  }
  if (!Array.isArray(outputTarget.serviceWorker.globPatterns)) {
    if (typeof outputTarget.serviceWorker.globPatterns === 'string') {
      outputTarget.serviceWorker.globPatterns = [outputTarget.serviceWorker.globPatterns];
    }
    else if (typeof outputTarget.serviceWorker.globPatterns !== 'string') {
      outputTarget.serviceWorker.globPatterns = DEFAULT_GLOB_PATTERNS.slice();
    }
  }
  if (typeof outputTarget.serviceWorker.globDirectory !== 'string') {
    outputTarget.serviceWorker.globDirectory = outputTarget.appDir;
  }
  if (typeof outputTarget.serviceWorker.globIgnores === 'string') {
    outputTarget.serviceWorker.globIgnores = [outputTarget.serviceWorker.globIgnores];
  }
  outputTarget.serviceWorker.globIgnores = outputTarget.serviceWorker.globIgnores || [];
  addGlobIgnores(config, outputTarget.serviceWorker.globIgnores);
  outputTarget.serviceWorker.dontCacheBustURLsMatching = /p-\w{8}/;
  if (isString(outputTarget.serviceWorker.swSrc) && !isAbsolute(outputTarget.serviceWorker.swSrc)) {
    outputTarget.serviceWorker.swSrc = join(config.rootDir, outputTarget.serviceWorker.swSrc);
  }
  if (!isString(outputTarget.serviceWorker.swDest)) {
    outputTarget.serviceWorker.swDest = join(outputTarget.appDir, DEFAULT_FILENAME);
  }
  if (!isAbsolute(outputTarget.serviceWorker.swDest)) {
    outputTarget.serviceWorker.swDest = join(outputTarget.appDir, outputTarget.serviceWorker.swDest);
  }
};
const addGlobIgnores = (config, globIgnores) => {
  globIgnores.push(`**/${HOST_CONFIG_FILENAME}`, `**/*.system.entry.js`, `**/*.system.js`, `**/${config.fsNamespace}.js`, `**/${config.fsNamespace}.esm.js`, `**/${config.fsNamespace}.css`);
};
const DEFAULT_GLOB_PATTERNS = ['*.html', '**/*.{js,css,json}'];
const DEFAULT_FILENAME = 'sw.js';

// MODULE: compiler/config/outputs/validate-www.js
const validateWww = (config, diagnostics, userOutputs) => {
  const hasOutputTargets = userOutputs.length > 0;
  const hasE2eTests = !!(config.flags && config.flags.e2e);
  const userWwwOutputs = userOutputs.filter(isOutputTargetWww);
  if (!hasOutputTargets || (hasE2eTests && !userOutputs.some(isOutputTargetWww) && !userOutputs.some(isOutputTargetDist))) {
    userWwwOutputs.push({ type: WWW });
  }
  if (config.flags.prerender && userWwwOutputs.length === 0) {
    const err = buildError(diagnostics);
    err.messageText = `You need at least one "www" output target configured in your stencil.config.ts, when the "--prerender" flag is used`;
  }
  return userWwwOutputs.reduce((outputs, o) => {
    const outputTarget = validateWwwOutputTarget(config, o, diagnostics);
    outputs.push(outputTarget);
    // Add dist-lazy output target
    const buildDir = outputTarget.buildDir;
    outputs.push({
      type: DIST_LAZY,
      dir: buildDir,
      esmDir: buildDir,
      systemDir: config.buildEs5 ? buildDir : undefined,
      systemLoaderFile: config.buildEs5 ? join(buildDir, `${config.fsNamespace}.js`) : undefined,
      polyfills: outputTarget.polyfills,
      isBrowserBuild: true,
    });
    // Copy for dist
    outputs.push({
      type: COPY,
      dir: buildDir,
      copyAssets: 'dist',
    });
    // Copy for www
    outputs.push({
      type: COPY,
      dir: outputTarget.appDir,
      copy: validateCopy(outputTarget.copy, [...(config.copy || []), { src: 'assets', warn: false }, { src: 'manifest.json', warn: false }]),
    });
    // Generate global style with original name
    outputs.push({
      type: DIST_GLOBAL_STYLES,
      file: join(buildDir, `${config.fsNamespace}.css`),
    });
    return outputs;
  }, []);
};
const validateWwwOutputTarget = (config, outputTarget, diagnostics) => {
  if (!isString(outputTarget.baseUrl)) {
    outputTarget.baseUrl = '/';
  }
  if (!outputTarget.baseUrl.endsWith('/')) {
    // Make sure the baseUrl always finish with "/"
    outputTarget.baseUrl += '/';
  }
  outputTarget.dir = getAbsolutePath(config, outputTarget.dir || 'www');
  // Fix "dir" to account
  const pathname = new URL(outputTarget.baseUrl, 'http://localhost/').pathname;
  outputTarget.appDir = join(outputTarget.dir, pathname);
  if (outputTarget.appDir.endsWith('/') || outputTarget.appDir.endsWith('\\')) {
    outputTarget.appDir = outputTarget.appDir.substring(0, outputTarget.appDir.length - 1);
  }
  if (!isString(outputTarget.buildDir)) {
    outputTarget.buildDir = 'build';
  }
  if (!isAbsolute(outputTarget.buildDir)) {
    outputTarget.buildDir = join(outputTarget.appDir, outputTarget.buildDir);
  }
  if (!isString(outputTarget.indexHtml)) {
    outputTarget.indexHtml = 'index.html';
  }
  if (!isAbsolute(outputTarget.indexHtml)) {
    outputTarget.indexHtml = join(outputTarget.appDir, outputTarget.indexHtml);
  }
  if (!isBoolean(outputTarget.empty)) {
    outputTarget.empty = true;
  }
  validatePrerender(config, diagnostics, outputTarget);
  validateServiceWorker(config, outputTarget);
  if (outputTarget.polyfills === undefined) {
    outputTarget.polyfills = true;
  }
  outputTarget.polyfills = !!outputTarget.polyfills;
  return outputTarget;
};

// MODULE: compiler/config/outputs/validate-custom-element-bundle.js
const validateCustomElementBundle = (config, userOutputs) => {
  return userOutputs.filter(isOutputTargetDistCustomElementsBundle).map(o => {
    const outputTarget = Object.assign(Object.assign({}, o), { dir: getAbsolutePath(config, o.dir || 'dist/custom-elements-bundle') });
    if (!isBoolean(outputTarget.empty)) {
      outputTarget.empty = true;
    }
    return outputTarget;
  });
};

// MODULE: compiler/config/outputs/index.js
const validateOutputTargets = (config, diagnostics) => {
  const userOutputs = (config.outputTargets || []).slice();
  userOutputs.forEach(outputTarget => {
    if (!VALID_TYPES_NEXT.includes(outputTarget.type)) {
      const err = buildError(diagnostics);
      err.messageText = `Invalid outputTarget type "${outputTarget.type}". Valid outputTarget types include: ${VALID_TYPES_NEXT.map(t => `"${t}"`).join(', ')}`;
    }
  });
  config.outputTargets = [
    ...validateCollection$1(config, userOutputs),
    ...validateCustomElement(config, userOutputs),
    ...validateCustomElementBundle(config, userOutputs),
    ...validateCustomOutput(config, diagnostics, userOutputs),
    ...validateLazy(config, userOutputs),
    ...validateWww(config, diagnostics, userOutputs),
    ...validateDist(config, userOutputs),
    ...validateHydrateScript(config, userOutputs),
    ...validateDocs(config, diagnostics, userOutputs),
    ...validateAngular(config, userOutputs),
    ...validateStats(config, userOutputs),
  ];
};

// MODULE: compiler/config/validate-paths.js
const validatePaths = (config) => {
  if (typeof config.rootDir !== 'string') {
    config.rootDir = '/';
  }
  if (typeof config.srcDir !== 'string') {
    config.srcDir = DEFAULT_SRC_DIR;
  }
  if (!isAbsolute(config.srcDir)) {
    config.srcDir = join(config.rootDir, config.srcDir);
  }
  if (typeof config.cacheDir !== 'string') {
    config.cacheDir = DEFAULT_CACHE_DIR;
  }
  if (!isAbsolute(config.cacheDir)) {
    config.cacheDir = join(config.rootDir, config.cacheDir);
  }
  if (typeof config.srcIndexHtml !== 'string') {
    config.srcIndexHtml = join(config.srcDir, DEFAULT_INDEX_HTML);
  }
  if (!isAbsolute(config.srcIndexHtml)) {
    config.srcIndexHtml = join(config.rootDir, config.srcIndexHtml);
  }
  if (typeof config.globalScript === 'string' && !isAbsolute(config.globalScript)) {
    if (!isAbsolute(config.globalScript)) {
      config.globalScript = join(config.rootDir, config.globalScript);
    }
  }
  if (typeof config.globalStyle === 'string') {
    if (!isAbsolute(config.globalStyle)) {
      config.globalStyle = join(config.rootDir, config.globalStyle);
    }
  }
  if (config.writeLog) {
    if (typeof config.buildLogFilePath !== 'string') {
      config.buildLogFilePath = DEFAULT_BUILD_LOG_FILE_NAME;
    }
    if (!isAbsolute(config.buildLogFilePath)) {
      config.buildLogFilePath = join(config.rootDir, config.buildLogFilePath);
    }
  }
  config.packageJsonFilePath = join(config.rootDir, 'package.json');
};
const DEFAULT_BUILD_LOG_FILE_NAME = 'stencil-build.log';
const DEFAULT_CACHE_DIR = '.stencil';
const DEFAULT_INDEX_HTML = 'index.html';
const DEFAULT_SRC_DIR = 'src';

// MODULE: compiler/config/validate-plugins.js
const validatePlugins = (config, diagnostics) => {
  const userPlugins = config.plugins;
  if (!config.rollupPlugins) {
    config.rollupPlugins = {};
  }
  if (!Array.isArray(userPlugins)) {
    config.plugins = [];
    return;
  }
  const rollupPlugins = userPlugins.filter(plugin => {
    return !!(plugin && typeof plugin === 'object' && !plugin.pluginType);
  });
  const hasResolveNode = rollupPlugins.some(p => p.name === 'node-resolve');
  const hasCommonjs = rollupPlugins.some(p => p.name === 'commonjs');
  if (hasCommonjs) {
    const warn = buildWarn(diagnostics);
    warn.messageText = `Stencil already uses "@rollup/plugin-commonjs", please remove it from your "stencil.config.ts" plugins.
  You can configure the commonjs settings using the "commonjs" property in "stencil.config.ts`;
  }
  if (hasResolveNode) {
    const warn = buildWarn(diagnostics);
    warn.messageText = `Stencil already uses "@rollup/plugin-commonjs", please remove it from your "stencil.config.ts" plugins.
  You can configure the commonjs settings using the "commonjs" property in "stencil.config.ts`;
  }
  config.rollupPlugins.before = [
    ...config.rollupPlugins.before || [],
    ...rollupPlugins.filter(({ name }) => name !== 'node-resolve' && name !== 'commonjs')
  ];
  config.plugins = userPlugins.filter(plugin => {
    return !!(plugin && typeof plugin === 'object' && plugin.pluginType);
  });
};

// MODULE: compiler/config/validate-rollup-config.js
const validateRollupConfig = (config) => {
  const cleanRollupConfig = getCleanRollupConfig(config.rollupConfig);
  config.rollupConfig = cleanRollupConfig;
};
const getCleanRollupConfig = (rollupConfig) => {
  let cleanRollupConfig = DEFAULT_ROLLUP_CONFIG;
  if (!rollupConfig || !isObject(rollupConfig)) {
    return cleanRollupConfig;
  }
  if (rollupConfig.inputOptions && isObject(rollupConfig.inputOptions)) {
    cleanRollupConfig = Object.assign(Object.assign({}, cleanRollupConfig), { inputOptions: pluck(rollupConfig.inputOptions, ['context', 'moduleContext', 'treeshake']) });
  }
  if (rollupConfig.outputOptions && isObject(rollupConfig.outputOptions)) {
    cleanRollupConfig = Object.assign(Object.assign({}, cleanRollupConfig), { outputOptions: pluck(rollupConfig.outputOptions, ['globals']) });
  }
  return cleanRollupConfig;
};
const DEFAULT_ROLLUP_CONFIG = {
  inputOptions: {},
  outputOptions: {},
};

// MODULE: compiler/config/validate-testing.js
const validateTesting = (config, diagnostics) => {
  const testing = (config.testing = Object.assign({}, config.testing || {}));
  if (!config.flags || (!config.flags.e2e && !config.flags.spec)) {
    return;
  }
  if (typeof config.flags.headless === 'boolean') {
    testing.browserHeadless = config.flags.headless;
  }
  else if (typeof testing.browserHeadless !== 'boolean') {
    testing.browserHeadless = true;
  }
  if (!testing.browserWaitUntil) {
    testing.browserWaitUntil = 'load';
  }
  testing.browserArgs = testing.browserArgs || [];
  addTestingConfigOption(testing.browserArgs, '--font-render-hinting=medium');
  addTestingConfigOption(testing.browserArgs, '--incognito');
  if (config.flags.ci) {
    addTestingConfigOption(testing.browserArgs, '--no-sandbox');
    addTestingConfigOption(testing.browserArgs, '--disable-setuid-sandbox');
    addTestingConfigOption(testing.browserArgs, '--disable-dev-shm-usage');
    testing.browserHeadless = true;
  }
  if (typeof testing.rootDir === 'string') {
    if (!isAbsolute(testing.rootDir)) {
      testing.rootDir = join(config.rootDir, testing.rootDir);
    }
  }
  else {
    testing.rootDir = config.rootDir;
  }
  if (config.flags && typeof config.flags.screenshotConnector === 'string') {
    testing.screenshotConnector = config.flags.screenshotConnector;
  }
  if (typeof testing.screenshotConnector === 'string') {
    if (!isAbsolute(testing.screenshotConnector)) {
      testing.screenshotConnector = join(config.rootDir, testing.screenshotConnector);
    }
  }
  else {
    testing.screenshotConnector = join(config.sys.getCompilerExecutingPath(), '..', '..', 'screenshot', 'local-connector.js');
  }
  if (!Array.isArray(testing.testPathIgnorePatterns)) {
    testing.testPathIgnorePatterns = DEFAULT_IGNORE_PATTERNS.map(ignorePattern => {
      return join(testing.rootDir, ignorePattern);
    });
    config.outputTargets
      .filter(o => (isOutputTargetDist(o) || isOutputTargetWww(o)) && o.dir)
      .forEach((outputTarget) => {
      testing.testPathIgnorePatterns.push(outputTarget.dir);
    });
  }
  if (typeof testing.preset !== 'string') {
    testing.preset = join(config.sys.getCompilerExecutingPath(), '..', '..', 'testing');
  }
  else if (!isAbsolute(testing.preset)) {
    testing.preset = join(config.configPath, testing.preset);
  }
  if (!Array.isArray(testing.setupFilesAfterEnv)) {
    testing.setupFilesAfterEnv = [];
  }
  testing.setupFilesAfterEnv.unshift(join(config.sys.getCompilerExecutingPath(), '..', '..', 'testing', 'jest-setuptestframework.js'));
  if (testing.setupTestFrameworkScriptFile) {
    const err = buildWarn(diagnostics);
    err.messageText = `setupTestFrameworkScriptFile has been deprecated.`;
  }
  if (typeof testing.testEnvironment === 'string') {
    if (!isAbsolute(testing.testEnvironment)) {
      testing.testEnvironment = join(config.configPath, testing.testEnvironment);
    }
  }
  if (typeof testing.allowableMismatchedPixels === 'number') {
    if (testing.allowableMismatchedPixels < 0) {
      const err = buildError(diagnostics);
      err.messageText = `allowableMismatchedPixels must be a value that is 0 or greater`;
    }
  }
  else {
    testing.allowableMismatchedPixels = DEFAULT_ALLOWABLE_MISMATCHED_PIXELS;
  }
  if (typeof testing.allowableMismatchedRatio === 'number') {
    if (testing.allowableMismatchedRatio < 0 || testing.allowableMismatchedRatio > 1) {
      const err = buildError(diagnostics);
      err.messageText = `allowableMismatchedRatio must be a value ranging from 0 to 1`;
    }
  }
  if (typeof testing.pixelmatchThreshold === 'number') {
    if (testing.pixelmatchThreshold < 0 || testing.pixelmatchThreshold > 1) {
      const err = buildError(diagnostics);
      err.messageText = `pixelmatchThreshold must be a value ranging from 0 to 1`;
    }
  }
  else {
    testing.pixelmatchThreshold = DEFAULT_PIXEL_MATCH_THRESHOLD;
  }
  if (testing.testRegex === undefined) {
    testing.testRegex = '(/__tests__/.*|\\.?(test|spec|e2e))\\.(tsx?|ts?|jsx?|js?)$';
  }
  if (Array.isArray(testing.testMatch)) {
    delete testing.testRegex;
  }
  else if (typeof testing.testRegex === 'string') {
    delete testing.testMatch;
  }
  if (typeof testing.runner !== 'string') {
    testing.runner = join(config.sys.getCompilerExecutingPath(), '..', '..', 'testing', 'jest-runner.js');
  }
  if (typeof testing.waitBeforeScreenshot === 'number') {
    if (testing.waitBeforeScreenshot < 0) {
      const err = buildError(diagnostics);
      err.messageText = `waitBeforeScreenshot must be a value that is 0 or greater`;
    }
  }
  else {
    testing.waitBeforeScreenshot = 10;
  }
  if (!Array.isArray(testing.emulate) || testing.emulate.length === 0) {
    testing.emulate = [
      {
        userAgent: 'default',
        viewport: {
          width: 600,
          height: 600,
          deviceScaleFactor: 1,
          isMobile: false,
          hasTouch: false,
          isLandscape: false,
        },
      },
    ];
  }
};
const addTestingConfigOption = (setArray, option) => {
  if (!setArray.includes(option)) {
    setArray.push(option);
  }
};
const DEFAULT_ALLOWABLE_MISMATCHED_PIXELS = 100;
const DEFAULT_PIXEL_MATCH_THRESHOLD = 0.1;
const DEFAULT_IGNORE_PATTERNS = ['.vscode', '.stencil', 'node_modules'];

// MODULE: compiler/config/validate-workers.js
const validateWorkers = (config) => {
  if (typeof config.maxConcurrentWorkers !== 'number') {
    config.maxConcurrentWorkers = 8;
  }
  if (config.flags) {
    if (typeof config.flags.maxWorkers === 'number') {
      config.maxConcurrentWorkers = config.flags.maxWorkers;
    }
    else if (config.flags.ci) {
      config.maxConcurrentWorkers = 4;
    }
  }
  config.maxConcurrentWorkers = Math.max(Math.min(config.maxConcurrentWorkers, 16), 0);
};

// MODULE: compiler/config/validate-config.js
const validateConfig = (userConfig) => {
  const config = Object.assign({}, userConfig || {}); // not positive it's json safe
  const diagnostics = [];
  // copy flags (we know it'll be json safe)
  config.flags = JSON.parse(JSON.stringify(config.flags || {}));
  // default devMode false
  if (config.flags.prod) {
    config.devMode = false;
  }
  else if (config.flags.dev) {
    config.devMode = true;
  }
  else if (!isBoolean(config.devMode)) {
    config.devMode = DEFAULT_DEV_MODE;
  }
  config.extras = config.extras || {};
  config.extras.appendChildSlotFix = !!config.extras.appendChildSlotFix;
  config.extras.cloneNodeFix = !!config.extras.cloneNodeFix;
  config.extras.cssVarsShim = config.extras.cssVarsShim !== false;
  config.extras.dynamicImportShim = config.extras.dynamicImportShim !== false;
  config.extras.lifecycleDOMEvents = !!config.extras.lifecycleDOMEvents;
  config.extras.safari10 = config.extras.safari10 !== false;
  config.extras.scriptDataOpts = config.extras.scriptDataOpts !== false;
  config.extras.shadowDomShim = config.extras.shadowDomShim !== false;
  config.extras.slotChildNodesFix = !!config.extras.slotChildNodesFix;
  setBooleanConfig(config, 'minifyCss', null, !config.devMode);
  setBooleanConfig(config, 'minifyJs', null, !config.devMode);
  setBooleanConfig(config, 'sourceMap', null, false);
  setBooleanConfig(config, 'watch', 'watch', false);
  setBooleanConfig(config, 'minifyCss', null, !config.devMode);
  setBooleanConfig(config, 'minifyJs', null, !config.devMode);
  setBooleanConfig(config, 'buildEs5', 'es5', !config.devMode);
  setBooleanConfig(config, 'buildDocs', 'docs', !config.devMode);
  setBooleanConfig(config, 'buildDist', 'esm', !config.devMode || config.buildEs5);
  setBooleanConfig(config, 'profile', 'profile', config.devMode);
  setBooleanConfig(config, 'writeLog', 'log', false);
  setBooleanConfig(config, 'buildAppCore', null, true);
  setBooleanConfig(config, 'autoprefixCss', null, config.buildEs5);
  setBooleanConfig(config, 'validateTypes', null, !config._isTesting);
  setBooleanConfig(config, 'allowInlineScripts', null, true);
  if (typeof config.taskQueue !== 'string') {
    config.taskQueue = 'congestionAsync';
  }
  else if (config.taskQueue === 'sync') {
    // deprecated 1.12.1
    config.taskQueue = 'immediate';
  }
  // hash file names
  if (!isBoolean(config.hashFileNames)) {
    config.hashFileNames = !config.devMode;
  }
  if (!isNumber(config.hashedFileNameLength)) {
    config.hashedFileNameLength = DEFAULT_HASHED_FILENAME_LENTH;
  }
  if (config.hashedFileNameLength < MIN_HASHED_FILENAME_LENTH) {
    const err = buildError(diagnostics);
    err.messageText = `config.hashedFileNameLength must be at least ${MIN_HASHED_FILENAME_LENTH} characters`;
  }
  if (config.hashedFileNameLength > MAX_HASHED_FILENAME_LENTH) {
    const err = buildError(diagnostics);
    err.messageText = `config.hashedFileNameLength cannot be more than ${MAX_HASHED_FILENAME_LENTH} characters`;
  }
  // get a good namespace
  validateNamespace(config, diagnostics);
  // figure out all of the config paths and absolute paths
  validatePaths(config);
  // outputTargets
  validateOutputTargets(config, diagnostics);
  // plugins
  validatePlugins(config, diagnostics);
  // rollup config
  validateRollupConfig(config);
  // dev server
  config.devServer = validateDevServer(config, diagnostics);
  // testing
  validateTesting(config, diagnostics);
  // hydrate flag
  config.hydratedFlag = validateHydrated(config);
  // bundles
  if (Array.isArray(config.bundles)) {
    config.bundles = sortBy(config.bundles, (a) => a.components.length);
  }
  else {
    config.bundles = [];
  }
  // Default copy
  config.copy = config.copy || [];
  // validate how many workers we can use
  validateWorkers(config);
  // default devInspector to whatever devMode is
  setBooleanConfig(config, 'devInspector', null, config.devMode);
  if (!config._isTesting) {
    validateDistNamespace(config, diagnostics);
  }
  setBooleanConfig(config, 'enableCache', 'cache', true);
  if (config.excludeSrc) {
    const warn = buildWarn(diagnostics);
    warn.messageText = `"excludeSrc" is deprecated, use the "exclude" option in tsconfig.json`;
  }
  if (config.includeSrc) {
    const warn = buildWarn(diagnostics);
    warn.messageText = `"includeSrc" is deprecated, use the "include" option in tsconfig.json`;
  }
  return {
    config,
    diagnostics,
  };
};
const DEFAULT_DEV_MODE = false;
const DEFAULT_HASHED_FILENAME_LENTH = 8;
const MIN_HASHED_FILENAME_LENTH = 4;
const MAX_HASHED_FILENAME_LENTH = 32;

// MODULE: compiler/sys/typescript/typescript-config.js
const validateTsConfig = async (ts, config, sys, init) => {
  var _a;
  const tsconfig = {
    path: null,
    compilerOptions: null,
    diagnostics: [],
  };
  try {
    const readTsConfig = await getTsConfigPath(config, sys, init);
    if (!readTsConfig) {
      const diagnostic = buildError(tsconfig.diagnostics);
      diagnostic.header = `Missing tsconfig.json`;
      diagnostic.messageText = `Unable to load TypeScript config file. Please create a "tsconfig.json" file within the "${config.rootDir}" directory.`;
    }
    else {
      tsconfig.path = readTsConfig.path;
      const host = Object.assign(Object.assign({}, ts.sys), { readFile: (p) => {
          if (p === tsconfig.path) {
            return readTsConfig.content;
          }
          return sys.readFileSync(p);
        }, readDirectory: (p) => sys.readdirSync(p), onUnRecoverableConfigFileDiagnostic: (e) => console.error(e) });
      const results = ts.getParsedCommandLineOfConfigFile(tsconfig.path, {}, host);
      if (results.errors && results.errors.length > 0) {
        results.errors.forEach(configErr => {
          const tsDiagnostic = loadTypeScriptDiagnostic(configErr);
          if (tsDiagnostic.code === '18003') {
            // "No inputs were found in config file"
            // fine to just "warn" rather than "error" even before starting
            tsDiagnostic.level = 'warn';
          }
          tsDiagnostic.absFilePath = tsconfig.path;
          tsconfig.diagnostics.push(tsDiagnostic);
        });
      }
      else {
        if (results.raw) {
          if (!hasSrcDirectoryInclude(results.raw.include)) {
            const warn = buildWarn(tsconfig.diagnostics);
            warn.header = `tsconfig.json "include" required`;
            warn.messageText = `In order for TypeScript to improve watch performance, it's recommended the "tsconfig.json" file should have the "include" property, with at least the app's "src" directory listed. For example: "include": ["src"]`;
          }
          if (hasStencilConfigInclude(results.raw.include)) {
            const warn = buildWarn(tsconfig.diagnostics);
            warn.header = `tsconfig.json should not reference stencil.config.ts`;
            warn.messageText = `stencil.config.ts is not part of the output build, it should not be included.`;
          }
        }
        if (results.options) {
          tsconfig.compilerOptions = results.options;
          const target = (_a = tsconfig.compilerOptions.target) !== null && _a !== void 0 ? _a : ts.ScriptTarget.ES5;
          if ([ts.ScriptTarget.ES3, ts.ScriptTarget.ES5, ts.ScriptTarget.ES2015, ts.ScriptTarget.ES2016].includes(target)) {
            const warn = buildWarn(tsconfig.diagnostics);
            warn.messageText = `To improve bundling, it is always recommended to set the tsconfig.json “target” setting to "es2017". Note that the compiler will automatically handle transpilation for ES5-only browsers.`;
          }
          if (tsconfig.compilerOptions.module !== ts.ModuleKind.ESNext && !config._isTesting) {
            const warn = buildWarn(tsconfig.diagnostics);
            warn.messageText = `To improve bundling, it is always recommended to set the tsconfig.json “module” setting to “esnext”. Note that the compiler will automatically handle bundling both modern and legacy builds.`;
          }
        }
      }
    }
  }
  catch (e) {
    catchError(tsconfig.diagnostics, e);
  }
  return tsconfig;
};
const getTsConfigPath = async (config, sys, init) => {
  const tsconfig = {
    path: null,
    content: null,
  };
  if (isString(config.tsconfig)) {
    if (!isAbsolute(config.tsconfig)) {
      tsconfig.path = join(config.rootDir, config.tsconfig);
    }
    else {
      tsconfig.path = config.tsconfig;
    }
  }
  else {
    tsconfig.path = join(config.rootDir, 'tsconfig.json');
  }
  tsconfig.content = await sys.readFile(tsconfig.path);
  if (!isString(tsconfig.content)) {
    if (!init.initTsConfig) {
      // not set to automatically generate a default tsconfig
      return null;
    }
    // create a default tsconfig
    tsconfig.path = join(config.rootDir, 'tsconfig.json');
    tsconfig.content = createDefaultTsConfig(config);
    await sys.writeFile(tsconfig.path, tsconfig.content);
  }
  tsconfig.path = normalizePath(tsconfig.path);
  return tsconfig;
};
const createDefaultTsConfig = (config) => JSON.stringify({
  compilerOptions: {
    allowSyntheticDefaultImports: true,
    experimentalDecorators: true,
    lib: ['dom', 'es2015'],
    moduleResolution: 'node',
    module: 'esnext',
    target: 'es2017',
    jsx: 'react',
    jsxFactory: 'h',
  },
  include: [relative(config.rootDir, config.srcDir)],
}, null, 2);
const hasSrcDirectoryInclude = (includeProp) => Array.isArray(includeProp) && includeProp.length > 0;
const hasStencilConfigInclude = (includeProp) => Array.isArray(includeProp) && includeProp.includes('stencil.config.ts');

// MODULE: compiler/config/load-config.js
const loadConfig = async (init = {}) => {
  const results = {
    config: null,
    diagnostics: [],
    tsconfig: {
      compilerOptions: null,
    },
  };
  try {
    const sys = init.sys || createSystem();
    const config = init.config || {};
    const cwd = sys.getCurrentDirectory();
    const tsPromise = loadTypescript(sys, results.diagnostics, init.typescriptPath);
    let configPath = init.configPath || config.configPath;
    let isDefaultConfigPath = true;
    if (isString(configPath)) {
      if (!isAbsolute(configPath)) {
        // passed in a custom stencil config location
        // but it's relative, so prefix the cwd
        configPath = normalizePath(join(cwd, configPath));
      }
      else {
        // config path already an absolute path, we're good here
        configPath = normalizePath(configPath);
      }
      isDefaultConfigPath = false;
    }
    else {
      // nothing was passed in, use the current working directory
      configPath = normalizePath(cwd);
    }
    const loadedConfigFile = await loadConfigFile(sys, results.diagnostics, configPath, isDefaultConfigPath, init.typescriptPath);
    if (hasError(results.diagnostics)) {
      return results;
    }
    if (loadedConfigFile != null) {
      // merge the user's config object into their loaded config file
      configPath = loadedConfigFile.configPath;
      results.config = Object.assign(loadedConfigFile, config);
      results.config.configPath = configPath;
      results.config.rootDir = normalizePath(dirname(configPath));
    }
    else {
      // no stencil.config.ts or .js file, which is fine
      // #0CJS ¯\_(ツ)_/¯
      results.config = Object.assign({}, config);
      results.config.configPath = null;
      results.config.rootDir = normalizePath(cwd);
    }
    results.config.sys = sys;
    results.config.cwd = normalizePath(cwd);
    const validated = validateConfig(results.config);
    results.diagnostics.push(...validated.diagnostics);
    if (hasError(results.diagnostics)) {
      return results;
    }
    results.config = validated.config;
    if (results.config.flags.debug || results.config.flags.verbose) {
      results.config.logLevel = 'debug';
    }
    else if (results.config.flags.logLevel) {
      results.config.logLevel = results.config.flags.logLevel;
    }
    else if (typeof results.config.logLevel !== 'string') {
      results.config.logLevel = 'info';
    }
    results.config.logger = init.logger || results.config.logger || createLogger();
    results.config.logger.level = results.config.logLevel;
    const loadedTs = await tsPromise;
    if (!hasError(results.diagnostics)) {
      const tsConfigResults = await validateTsConfig(loadedTs, results.config, sys, init);
      results.diagnostics.push(...tsConfigResults.diagnostics);
      results.config.tsconfig = tsConfigResults.path;
      results.config.tsCompilerOptions = tsConfigResults.compilerOptions;
      results.tsconfig.compilerOptions = tsConfigResults.compilerOptions;
    }
    if (isString(init.typescriptPath)) {
      results.config.typescriptPath = init.typescriptPath;
    }
  }
  catch (e) {
    catchError(results.diagnostics, e);
  }
  return results;
};
const loadConfigFile = async (sys, diagnostics, configPath, isDefaultConfigPath, typescriptPath) => {
  let config = null;
  let hasConfigFile = false;
  if (isString(configPath)) {
    const stat = await sys.stat(configPath);
    if (!stat && !isDefaultConfigPath) {
      const diagnostic = buildError(diagnostics);
      diagnostic.absFilePath = configPath;
      diagnostic.header = `Invalid config path`;
      diagnostic.messageText = `Config path "${configPath}" not found`;
      return null;
    }
    if (stat) {
      if (stat.isFile()) {
        hasConfigFile = true;
      }
      else if (stat.isDirectory()) {
        // this is only a directory, so let's make some assumptions
        for (const configName of CONFIG_FILENAMES) {
          const testConfigFilePath = join(configPath, configName);
          const stat = await sys.stat(testConfigFilePath);
          if (stat && stat.isFile()) {
            configPath = testConfigFilePath;
            hasConfigFile = true;
            break;
          }
        }
      }
    }
  }
  if (hasConfigFile) {
    // the passed in config was a string, so it's probably a path to the config we need to load
    // first clear the require cache so we don't get the same file
    const configFileData = await evaluateConfigFile(sys, diagnostics, configPath, typescriptPath);
    if (hasError(diagnostics)) {
      return config;
    }
    if (!configFileData.config) {
      const err = buildError(diagnostics);
      err.messageText = `Invalid Stencil configuration file "${configPath}". Missing "config" property.`;
      err.absFilePath = configPath;
      return config;
    }
    config = configFileData.config;
    config.configPath = normalizePath(configPath);
  }
  return config;
};
const CONFIG_FILENAMES = ['stencil.config.ts', 'stencil.config.js'];
const evaluateConfigFile = async (sys, diagnostics, configFilePath, typescriptPath) => {
  let configFileData = null;
  try {
    // TODO: this should use sys for resolving
    const ts = await loadTypescript(sys, diagnostics, typescriptPath);
    if (IS_NODE_ENV) {
      // ensure we cleared out node's internal require() cache for this file
      delete require.cache[resolve(configFilePath)];
      // let's override node's require for a second
      // don't worry, we'll revert this when we're done
      require.extensions['.ts'] = (module, filename) => {
        let sourceText = sys.readFileSync(filename, 'utf8');
        if (configFilePath.endsWith('.ts')) {
          // looks like we've got a typed config file
          // let's transpile it to .js quick
          sourceText = transpileTypedConfig(ts, diagnostics, sourceText, configFilePath);
        }
        else {
          // quick hack to turn a modern es module
          // into and old school commonjs module
          sourceText = sourceText.replace(/export\s+\w+\s+(\w+)/gm, 'exports.$1');
        }
        module._compile(sourceText, filename);
      };
      // let's do this!
      configFileData = require(configFilePath);
      // all set, let's go ahead and reset the require back to the default
      require.extensions['.ts'] = undefined;
    }
    else {
      // browser environment, can't use node's require() to evaluate
      let sourceText = sys.readFileSync(configFilePath, 'utf8');
      sourceText = transpileTypedConfig(ts, diagnostics, sourceText, configFilePath);
      if (hasError(diagnostics)) {
        return configFileData;
      }
      const evalConfig = new Function(`const exports = {}; ${sourceText}; return exports;`);
      configFileData = evalConfig();
    }
  }
  catch (e) {
    catchError(diagnostics, e);
  }
  return configFileData;
};
const transpileTypedConfig = (ts, diagnostics, sourceText, filePath) => {
  // let's transpile an awesome stencil.config.ts file into
  // a boring stencil.config.js file
  if (hasError(diagnostics)) {
    return sourceText;
  }
  const opts = {
    fileName: filePath,
    compilerOptions: {
      module: ts.ModuleKind.CommonJS,
      moduleResolution: ts.ModuleResolutionKind.NodeJs,
      esModuleInterop: true,
      target: ts.ScriptTarget.ES5,
      allowJs: true,
    },
    reportDiagnostics: false,
  };
  const output = ts.transpileModule(sourceText, opts);
  return output.outputText;
};

// MODULE: compiler/optimize/optimize-js.js
const optimizeJs = async (inputOpts) => {
  const result = {
    output: inputOpts.input,
    diagnostics: [],
    sourceMap: null,
  };
  try {
    const prettyOutput = !!inputOpts.pretty;
    const config = {
      extras: {
        safari10: true,
      },
    };
    const sourceTarget = inputOpts.target === 'es5' ? 'es5' : 'latest';
    const minifyOpts = getTerserOptions(config, sourceTarget, prettyOutput);
    const minifyResults = await minifyJs(inputOpts.input, minifyOpts);
    if (minifyResults.diagnostics.length > 0) {
      result.diagnostics.push(...minifyResults.diagnostics);
    }
    else {
      result.output = minifyResults.output;
      result.sourceMap = minifyResults.sourceMap;
    }
  }
  catch (e) {
    catchError(result.diagnostics, e);
  }
  return result;
};

// MODULE: compiler/index.js
initWorkerThread(globalThis);

exports.compile = compile$1;
exports.compileSync = compileSync;
exports.createCompiler = createCompiler;
exports.createSystem = createSystem;
exports.createWorkerContext = createWorkerContext;
exports.dependencies = dependencies;
exports.loadConfig = loadConfig;
exports.optimizeCss = optimizeCss;
exports.optimizeJs = optimizeJs;
exports.path = path;
exports.version = version;

if (typeof module !== "undefined" && module.exports) {
  module.exports = exports;
}
return exports;
})({});
